from flask import Flask, render_template, request, jsonify, session, redirect, url_for, abort, has_app_context as flask_has_app_context, g
from flask_sqlalchemy import SQLAlchemy
from sqlalchemy.orm import joinedload
from datetime import datetime, timedelta, timezone
from dotenv import load_dotenv
from flask import Response
import gzip
import requests
import json
import os
import random
from functools import wraps
import logging
from logging.handlers import RotatingFileHandler, TimedRotatingFileHandler
import hashlib

# åº”ç”¨ç‰ˆæœ¬å·
APP_VERSION = '2.1.1'
import time
import threading
from threading import Lock, Thread, Event
from typing import Optional, Union
from urllib.parse import quote_plus, quote
import xml.etree.ElementTree as ET
import re
from PIL import Image, ImageDraw, ImageFont
from io import BytesIO
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.utils import formataddr

# ==================== æˆæƒéªŒè¯ ====================
from license import require_license, check_license, is_license_valid
require_license()  # éªŒè¯å¤±è´¥ä¼šé€€å‡ºç¨‹åº

# ==================== è¾…åŠ©å‡½æ•°ï¼ˆéœ€è¦åœ¨é…ç½®å‡½æ•°ä¹‹å‰å®šä¹‰ï¼‰====================
def has_app_context():
    """æ£€æŸ¥æ˜¯å¦åœ¨ Flask åº”ç”¨ä¸Šä¸‹æ–‡ä¸­"""
    try:
        return flask_has_app_context()
    except:
        return False


# ==================== æ•°æ®åº“é…ç½®ç¼“å­˜ï¼ˆåœ¨ db åˆå§‹åŒ–å‰å®šä¹‰ï¼‰====================
_db_config_cache = {}  # å†…å­˜ç¼“å­˜ï¼Œå‡å°‘æ•°æ®åº“æŸ¥è¯¢
_db_config_cache_time = {}  # ç¼“å­˜æ—¶é—´
DB_CONFIG_CACHE_TTL = 60  # ç¼“å­˜æœ‰æ•ˆæœŸï¼ˆç§’ï¼‰


def get_db_config(key: str, default=None, use_cache=True):
    """ä»æ•°æ®åº“è·å–é…ç½®ï¼ˆå¸¦ç¼“å­˜ï¼‰- å»¶è¿ŸåŠ è½½"""
    global _db_config_cache, _db_config_cache_time
    
    # æ£€æŸ¥ç¼“å­˜
    if use_cache and key in _db_config_cache:
        if time.time() - _db_config_cache_time.get(key, 0) < DB_CONFIG_CACHE_TTL:
            return _db_config_cache[key]
    
    try:
        # ç¡®ä¿åœ¨åº”ç”¨ä¸Šä¸‹æ–‡ä¸­
        if not has_app_context():
            return default
        
        # å»¶è¿Ÿå¯¼å…¥ï¼Œé¿å…å¾ªç¯ä¾èµ–
        from flask import current_app
        
        # ç›´æ¥æŸ¥è¯¢æ•°æ®åº“ï¼ˆä¸ä¾èµ– SystemConfig ç±»ï¼‰
        result = db.session.execute(
            db.text("SELECT config_value FROM system_config WHERE config_key = :key"),
            {'key': key}
        ).fetchone()
        
        if result and result[0]:
            value = json.loads(result[0])
            # æ›´æ–°ç¼“å­˜
            _db_config_cache[key] = value
            _db_config_cache_time[key] = time.time()
            return value
        
        return default
    except Exception as e:
        # è¡¨å¯èƒ½ä¸å­˜åœ¨ï¼Œé™é»˜è¿”å›é»˜è®¤å€¼
        return default


def set_db_config(key: str, value: dict, description: str = None):
    """ä¿å­˜é…ç½®åˆ°æ•°æ®åº“ - å»¶è¿ŸåŠ è½½"""
    global _db_config_cache, _db_config_cache_time
    
    try:
        if not has_app_context():
            return False
        
        config_value = json.dumps(value, ensure_ascii=False)
        now = datetime.now()
        
        # ä½¿ç”¨ UPSERT æ“ä½œï¼ˆå…¼å®¹ MySQL å’Œ SQLiteï¼‰
        existing = db.session.execute(
            db.text("SELECT id FROM system_config WHERE config_key = :key"),
            {'key': key}
        ).fetchone()
        
        if existing:
            db.session.execute(
                db.text("""UPDATE system_config 
                          SET config_value = :value, description = :desc, updated_at = :now 
                          WHERE config_key = :key"""),
                {'key': key, 'value': config_value, 'desc': description, 'now': now}
            )
        else:
            db.session.execute(
                db.text("""INSERT INTO system_config (config_key, config_value, description, updated_at) 
                          VALUES (:key, :value, :desc, :now)"""),
                {'key': key, 'value': config_value, 'desc': description, 'now': now}
            )
        
        db.session.commit()
        
        # æ›´æ–°ç¼“å­˜
        _db_config_cache[key] = value
        _db_config_cache_time[key] = time.time()
        
        return True
    except Exception as e:
        print(f"[WARNING] ä¿å­˜é…ç½®åˆ°æ•°æ®åº“ {key} å¤±è´¥: {e}")
        db.session.rollback()
        return False


def clear_db_config_cache(key: str = None):
    """æ¸…é™¤é…ç½®ç¼“å­˜"""
    global _db_config_cache, _db_config_cache_time
    
    if key:
        _db_config_cache.pop(key, None)
        _db_config_cache_time.pop(key, None)
    else:
        _db_config_cache.clear()
        _db_config_cache_time.clear()


def get_all_db_configs():
    """è·å–æ‰€æœ‰æ•°æ®åº“é…ç½®"""
    try:
        if not has_app_context():
            return {}
        
        results = db.session.execute(
            db.text("SELECT config_key, config_value FROM system_config")
        ).fetchall()
        
        configs = {}
        for row in results:
            try:
                configs[row[0]] = json.loads(row[1]) if row[1] else None
            except:
                configs[row[0]] = row[1]
        
        return configs
    except Exception as e:
        print(f"[WARNING] è·å–æ‰€æœ‰é…ç½®å¤±è´¥: {e}")
        return {}


def delete_db_config(key: str):
    """åˆ é™¤æŒ‡å®šé…ç½®"""
    try:
        if not has_app_context():
            return False
        
        db.session.execute(
            db.text("DELETE FROM system_config WHERE config_key = :key"),
            {'key': key}
        )
        db.session.commit()
        clear_db_config_cache(key)
        return True
    except Exception as e:
        print(f"[WARNING] åˆ é™¤é…ç½® {key} å¤±è´¥: {e}")
        db.session.rollback()
        return False


def get_all_db_configs(prefix: str = None):
    """è·å–æ‰€æœ‰é…ç½®ï¼ˆå¯é€‰å‰ç¼€è¿‡æ»¤ï¼‰"""
    try:
        if not has_app_context():
            return {}
        
        if prefix:
            result = db.session.execute(
                db.text("SELECT config_key, config_value FROM system_config WHERE config_key LIKE :prefix"),
                {'prefix': f'{prefix}%'}
            )
        else:
            result = db.session.execute(
                db.text("SELECT config_key, config_value FROM system_config")
            )
        
        configs = {}
        for row in result:
            key = row[0]
            try:
                value = json.loads(row[1]) if row[1] else {}
            except:
                value = row[1]
            configs[key] = value
        
        return configs
    except Exception as e:
        print(f"[WARNING] è·å–é…ç½®åˆ—è¡¨å¤±è´¥: {e}")
        return {}


# åˆ›å»ºæŒä¹…åŒ–çš„ requests Sessionï¼ˆè¿æ¥æ± å¤ç”¨ï¼‰
http_session = requests.Session()
http_session.headers.update({'User-Agent': 'Emby-Request-System/1.0'})

# ==================== TMDB API ç¼“å­˜ ====================
class TMDBCache:
    """TMDB API å“åº”ç¼“å­˜ï¼ˆå†…å­˜ç¼“å­˜ï¼‰"""
    def __init__(self, default_ttl=300):  # é»˜è®¤ç¼“å­˜5åˆ†é’Ÿ
        self._cache = {}
        self._lock = Lock()
        self.default_ttl = default_ttl
    
    def _make_key(self, prefix, *args):
        """ç”Ÿæˆç¼“å­˜é”®"""
        return f"{prefix}:{':'.join(str(a) for a in args)}"
    
    def get(self, key):
        """è·å–ç¼“å­˜"""
        with self._lock:
            if key in self._cache:
                data, expire_time = self._cache[key]
                if time.time() < expire_time:
                    return data
                else:
                    del self._cache[key]
        return None
    
    def set(self, key, value, ttl=None):
        """è®¾ç½®ç¼“å­˜"""
        if ttl is None:
            ttl = self.default_ttl
        with self._lock:
            self._cache[key] = (value, time.time() + ttl)
    
    def clear_expired(self):
        """æ¸…ç†è¿‡æœŸç¼“å­˜"""
        with self._lock:
            now = time.time()
            expired_keys = [k for k, (_, exp) in self._cache.items() if now >= exp]
            for key in expired_keys:
                del self._cache[key]
    
    def stats(self):
        """è¿”å›ç¼“å­˜ç»Ÿè®¡"""
        with self._lock:
            return {
                'size': len(self._cache),
                'keys': list(self._cache.keys())[:10]  # åªè¿”å›å‰10ä¸ªé”®
            }

# åˆ›å»ºå…¨å±€ç¼“å­˜å®ä¾‹
tmdb_cache = TMDBCache(default_ttl=86400)  # 1å¤©ç¼“å­˜ï¼ˆ86400ç§’ï¼‰

# åŠ è½½ç¯å¢ƒå˜é‡
load_dotenv()

app = Flask(__name__)

# æ³¨å†Œæ”¯æŒè´Ÿæ•°çš„ int è½¬æ¢å™¨ï¼ˆTelegram ç”¨æˆ· ID ä¸ºè´Ÿæ•°ï¼‰
from werkzeug.routing import IntegerConverter
class SignedIntConverter(IntegerConverter):
    regex = r'-?\d+'
app.url_map.converters['int'] = SignedIntConverter

# ä»ç¯å¢ƒå˜é‡è¯»å–é…ç½®
app.config['SECRET_KEY'] = os.getenv('SECRET_KEY', 'your-secret-key-change-this')

# æ•°æ®åº“é…ç½® - æ”¯æŒä¸¤ç§æ–¹å¼
# æ–¹å¼1: ç›´æ¥ä½¿ç”¨ DATABASE_URIï¼ˆå…¼å®¹æ—§é…ç½®ï¼‰
# æ–¹å¼2: ä½¿ç”¨åˆ†ç¦»çš„é…ç½®é¡¹ï¼ˆæ¨èï¼‰
if os.getenv('DATABASE_URI'):
    app.config['SQLALCHEMY_DATABASE_URI'] = os.getenv('DATABASE_URI')
else:
    # ä»åˆ†ç¦»çš„é…ç½®é¡¹æ„å»ºæ•°æ®åº“URI
    db_host = os.getenv('DB_HOST', 'localhost')
    db_port = os.getenv('DB_PORT', '3306')
    db_user = os.getenv('DB_USER', 'root')
    db_password = os.getenv('DB_PASSWORD', '')
    db_name = os.getenv('DB_NAME', 'emby_database')
    
    if db_password:
        app.config['SQLALCHEMY_DATABASE_URI'] = f'mysql+pymysql://{db_user}:{db_password}@{db_host}:{db_port}/{db_name}'
    else:
        # å¦‚æœæ²¡æœ‰è®¾ç½®å¯†ç ï¼Œé»˜è®¤ä½¿ç”¨SQLite
        app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///movie_requests.db'

app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False

# Session å®‰å…¨é…ç½®
app.config['SESSION_COOKIE_NAME'] = 'emby_session'  # ä½¿ç”¨å”¯ä¸€cookieåç§°ï¼Œé¿å…ä¸å…¶ä»–ç³»ç»Ÿå†²çª
app.config['SESSION_COOKIE_HTTPONLY'] = True      # ç¦æ­¢ JS è¯»å– Cookieï¼Œé˜²æ­¢ XSS çªƒå–
app.config['SESSION_COOKIE_SAMESITE'] = 'Lax'     # é˜²æ­¢ CSRF è·¨ç«™è¯·æ±‚ä¼ªé€ 
app.config['SESSION_COOKIE_SECURE'] = os.getenv('SESSION_COOKIE_SECURE', 'auto').lower() == 'true'  # auto=ä¸è®¾ç½®(ç”±Flaskæ ¹æ®è¯·æ±‚è‡ªåŠ¨åˆ¤æ–­), true=å¼ºåˆ¶HTTPS, false=å…³é—­
app.config['PERMANENT_SESSION_LIFETIME'] = timedelta(days=7)  # Session æœ‰æ•ˆæœŸ 7 å¤©

# å‡å°‘ werkzeug æ—¥å¿—å™ªéŸ³ï¼ˆè¿‡æ»¤æ‰é™æ€èµ„æºå’Œå›¾ç‰‡ä»£ç†è¯·æ±‚ï¼‰
import logging
import re

class RequestFilter(logging.Filter):
    """è¿‡æ»¤æ‰å›¾ç‰‡ä»£ç†ç­‰é«˜é¢‘è¯·æ±‚çš„æ—¥å¿—"""
    def filter(self, record):
        msg = record.getMessage()
        # è¿‡æ»¤æ‰å›¾ç‰‡ä»£ç†è¯·æ±‚æ—¥å¿—
        if '/api/tmdb-image/' in msg:
            return False
        # è¿‡æ»¤æ‰é™æ€èµ„æºè¯·æ±‚
        if '/static/' in msg:
            return False
        return True


class SensitiveDataFilter(logging.Filter):
    """è„±æ•æ•æ„Ÿä¿¡æ¯ï¼ˆIPåœ°å€ã€Telegram IDã€chat_idç­‰ï¼‰"""
    
    # éœ€è¦è„±æ•çš„æ¨¡å¼
    PATTERNS = [
        # IP åœ°å€
        (re.compile(r'\b(\d{1,3}\.\d{1,3}\.\d{1,3})\.\d{1,3}\b'), r'\1.***'),
        # chat_id, user_id, telegram_id ç­‰æ•°å­—IDï¼ˆä¿ç•™å‰3ä½å2ä½ï¼‰
        (re.compile(r'(chat_id|user_id|telegram_id|tg_id|from_id)\s*[=:]\s*(\d{3})\d+(\d{2})\b', re.IGNORECASE), r'\1=\2***\3'),
        # Telegram ID æ ¼å¼ï¼ˆçº¯æ•°å­—ï¼Œ8ä½ä»¥ä¸Šï¼‰
        (re.compile(r'(Telegram\s*[=:]\s*)(\d{3})\d{3,}(\d{2})\b'), r'\1\2***\3'),
        # embyid
        (re.compile(r'(embyid\s*[=:]\s*)([a-f0-9]{8})[a-f0-9-]+([a-f0-9]{4})\b', re.IGNORECASE), r'\1\2***\3'),
    ]
    
    def filter(self, record):
        # å¯¹æ—¥å¿—æ¶ˆæ¯è¿›è¡Œè„±æ•å¤„ç†
        msg = record.getMessage()
        for pattern, replacement in self.PATTERNS:
            msg = pattern.sub(replacement, msg)
        # æ›´æ–° record çš„æ¶ˆæ¯
        record.msg = msg
        record.args = ()
        return True


# åº”ç”¨è¿‡æ»¤å™¨åˆ° werkzeug logger
werkzeug_logger = logging.getLogger('werkzeug')
werkzeug_logger.addFilter(RequestFilter())

# åº”ç”¨è„±æ•è¿‡æ»¤å™¨åˆ° app logger
app.logger.addFilter(SensitiveDataFilter())

# æ•°æ®åº“è¿æ¥æ± ä¼˜åŒ–
app.config['SQLALCHEMY_ENGINE_OPTIONS'] = {
    'pool_size': 10,              # è¿æ¥æ± å¤§å°
    'pool_recycle': 3600,         # è¿æ¥å›æ”¶æ—¶é—´ï¼ˆç§’ï¼‰
    'pool_pre_ping': True,        # è¿æ¥å‰æµ‹è¯•
    'max_overflow': 20,           # è¶…å‡º pool_size åæœ€å¤šåˆ›å»ºçš„è¿æ¥æ•°
    'pool_timeout': 30,           # è·å–è¿æ¥çš„è¶…æ—¶æ—¶é—´
}

db = SQLAlchemy(app)
db_initialized = False

# ==================== ç™»å½•æš´åŠ›ç ´è§£é˜²æŠ¤ ====================
class LoginRateLimiter:
    """åŸºäºå†…å­˜çš„ç™»å½•é¢‘ç‡é™åˆ¶å™¨ï¼Œé˜²æ­¢æš´åŠ›ç ´è§£"""
    
    def __init__(self, max_attempts=5, lockout_seconds=900, cleanup_interval=300):
        self._attempts = {}   # {key: [timestamp1, timestamp2, ...]}
        self._lockouts = {}   # {key: lockout_expire_time}
        self._lock = Lock()
        self.max_attempts = max_attempts        # æœ€å¤§å°è¯•æ¬¡æ•°
        self.lockout_seconds = lockout_seconds  # é”å®šæ—¶é•¿ï¼ˆç§’ï¼‰ï¼Œé»˜è®¤15åˆ†é’Ÿ
        self.cleanup_interval = cleanup_interval
        self._last_cleanup = time.time()
    
    def _get_client_ip(self):
        """è·å–å®¢æˆ·ç«¯çœŸå®IP"""
        forwarded = request.headers.get('X-Forwarded-For', '')
        if forwarded:
            return forwarded.split(',')[0].strip()
        return request.remote_addr or '0.0.0.0'
    
    def _cleanup(self):
        """å®šæœŸæ¸…ç†è¿‡æœŸè®°å½•"""
        now = time.time()
        if now - self._last_cleanup < self.cleanup_interval:
            return
        self._last_cleanup = now
        window = now - self.lockout_seconds
        expired_keys = [k for k, v in self._lockouts.items() if v < now]
        for k in expired_keys:
            self._lockouts.pop(k, None)
            self._attempts.pop(k, None)
        # æ¸…ç†è¿‡æœŸçš„å°è¯•è®°å½•
        for k in list(self._attempts.keys()):
            self._attempts[k] = [t for t in self._attempts[k] if t > window]
            if not self._attempts[k]:
                self._attempts.pop(k, None)
    
    def is_locked(self, extra_key=''):
        """æ£€æŸ¥IPæ˜¯å¦è¢«é”å®šï¼Œè¿”å› (is_locked, remaining_seconds)"""
        ip = self._get_client_ip()
        key = f"{ip}:{extra_key}" if extra_key else ip
        with self._lock:
            self._cleanup()
            if key in self._lockouts:
                remaining = self._lockouts[key] - time.time()
                if remaining > 0:
                    return True, int(remaining)
                else:
                    self._lockouts.pop(key, None)
                    self._attempts.pop(key, None)
        return False, 0
    
    def record_failure(self, extra_key=''):
        """è®°å½•ä¸€æ¬¡å¤±è´¥å°è¯•ï¼Œå¦‚æœè¶…è¿‡é˜ˆå€¼åˆ™é”å®š"""
        ip = self._get_client_ip()
        key = f"{ip}:{extra_key}" if extra_key else ip
        now = time.time()
        with self._lock:
            if key not in self._attempts:
                self._attempts[key] = []
            # åªä¿ç•™çª—å£æœŸå†…çš„è®°å½•ï¼ˆ5åˆ†é’Ÿçª—å£ï¼‰
            window = now - 300
            self._attempts[key] = [t for t in self._attempts[key] if t > window]
            self._attempts[key].append(now)
            
            if len(self._attempts[key]) >= self.max_attempts:
                self._lockouts[key] = now + self.lockout_seconds
                app.logger.warning(f'ç™»å½•é¢‘ç‡é™åˆ¶: IP {ip} (key={extra_key}) åœ¨5åˆ†é’Ÿå†…å¤±è´¥ {len(self._attempts[key])} æ¬¡ï¼Œé”å®š {self.lockout_seconds}ç§’')
                return True  # å·²è§¦å‘é”å®š
        return False
    
    def record_success(self, extra_key=''):
        """ç™»å½•æˆåŠŸåæ¸…é™¤è¯¥IPçš„å¤±è´¥è®°å½•"""
        ip = self._get_client_ip()
        key = f"{ip}:{extra_key}" if extra_key else ip
        with self._lock:
            self._attempts.pop(key, None)
            self._lockouts.pop(key, None)

# ç”¨æˆ·ç™»å½•é™æµå™¨ï¼ˆ10æ¬¡å¤±è´¥/5åˆ†é’Ÿ â†’ é”å®š10åˆ†é’Ÿï¼‰
login_limiter = LoginRateLimiter(max_attempts=10, lockout_seconds=600)
# ç®¡ç†å‘˜ç™»å½•é™æµå™¨ï¼ˆ10æ¬¡å¤±è´¥/5åˆ†é’Ÿ â†’ é”å®š10åˆ†é’Ÿï¼‰
admin_login_limiter = LoginRateLimiter(max_attempts=10, lockout_seconds=600)

# æ±‚ç‰‡é™åˆ¶é…ç½®
# Açº§(ç™½åå•ç”¨æˆ·): 3æ¬¡/å¤©
# Bçº§(æ³¨å†Œç”¨æˆ·): 1æ¬¡/å¤©
# æ¯æ—¥æ±‚ç‰‡é™åˆ¶è¯´æ˜ï¼š
# ç®¡ç†å‘˜: æ— é™åˆ¶
# Açº§ç”¨æˆ· (lv='a', ç™½åå•): ä»é…ç½®è¯»å– request_limit.level_a (é»˜è®¤3æ¬¡/å¤©)
# Bçº§ç”¨æˆ· (æœ‰æœ‰æ•ˆè®¢é˜…): ä»é…ç½®è¯»å– request_limit.level_b (é»˜è®¤1æ¬¡/å¤©)
# Cçº§ç”¨æˆ· (lv='c', å·²ç¦ç”¨): ä»é…ç½®è¯»å– request_limit.level_c (é»˜è®¤0æ¬¡/å¤©)
# Dçº§ç”¨æˆ· (æœªè®¢é˜…): ä»é…ç½®è¯»å– request_limit.level_d (é»˜è®¤0æ¬¡/å¤©)
# æ³¨æ„: MAX_DAILY_REQUESTS å·²å¼ƒç”¨ï¼Œè¯·åœ¨ç®¡ç†åå°çš„"ç³»ç»Ÿè®¾ç½® â†’ æ±‚ç‰‡é™åˆ¶"ä¸­é…ç½®
MAX_DAILY_REQUESTS = int(os.getenv('MAX_DAILY_REQUESTS', 3))  # å·²å¼ƒç”¨: è¯·ä½¿ç”¨åå°é…ç½®

TMDB_API_KEY = os.getenv('TMDB_API_KEY', '')  # ä»ç¯å¢ƒå˜é‡è·å–TMDB APIå¯†é’¥
TMDB_BASE_URL = 'https://api.themoviedb.org/3'
TMDB_IMAGE_BASE_URL = 'https://image.tmdb.org/t/p/w500'

# ä»£ç†é…ç½®ï¼ˆå¦‚æœéœ€è¦ï¼‰
PROXY_URL = os.getenv('PROXY_URL', '')  # ä¾‹å¦‚: http://127.0.0.1:7890
if PROXY_URL:
    http_session.proxies = {
        'http': PROXY_URL,
        'https': PROXY_URL
    }
    app.logger.info(f'ä½¿ç”¨ä»£ç†: {PROXY_URL}')

# ç®¡ç†å‘˜é…ç½® - ç°åœ¨ä»é…ç½®æ–‡ä»¶è¯»å–ï¼Œç¯å¢ƒå˜é‡ä»…ä½œä¸ºå¤‡ç”¨
# è¿™äº›å˜é‡ä¼šåœ¨åº”ç”¨å¯åŠ¨æ—¶è¢« init_admin_config() æ›´æ–°
ADMIN_SECRET_PATH = None  # åŠ¨æ€ä»é…ç½®æ–‡ä»¶è¯»å–
ADMIN_USERNAME = None     # åŠ¨æ€ä»é…ç½®æ–‡ä»¶è¯»å–
ADMIN_PASSWORD = None     # åŠ¨æ€ä»é…ç½®æ–‡ä»¶è¯»å–ï¼ˆå“ˆå¸Œå€¼ï¼‰

# æ—§çš„ç®¡ç†å‘˜ç”¨æˆ·ååˆ—è¡¨ï¼ˆå…¼å®¹æ—§ä»£ç ï¼Œä½†ä¸å†ä½¿ç”¨ï¼‰
ADMIN_USERNAMES = []

# Telegram BOTé…ç½®
TELEGRAM_BOT_TOKEN = os.getenv('TELEGRAM_BOT_TOKEN', '')
TELEGRAM_CHAT_ID = os.getenv('TELEGRAM_CHAT_ID', '')
# ä¸Šç‰‡ç®¡ç†å‘˜é…ç½®ï¼ˆå¤šä¸ªç®¡ç†å‘˜ç”¨é€—å·åˆ†éš”ï¼Œæ ¼å¼: @username1,@username2ï¼‰
UPLOAD_ADMINS = os.getenv('UPLOAD_ADMINS', '')
# å…¥åº“é€šçŸ¥ç¾¤ç»„ï¼ˆå‘é€å…¥åº“å®Œæˆé€šçŸ¥å¹¶@ç”¨æˆ·ï¼‰
TELEGRAM_GROUP_ID = os.getenv('TELEGRAM_GROUP_ID', '')

# Telegram Webhook é…ç½®
TELEGRAM_CONFIGURED_URL = ''  # ç”¨æˆ·é…ç½®çš„æœåŠ¡å™¨åœ°å€
_TELEGRAM_WEBHOOK_SECRET = ''  # Webhook secret_tokenï¼Œç”¨äºéªŒè¯è¯·æ±‚æ¥è‡ªå½“å‰é…ç½®çš„ Bot

# å…¬å‘Šå¼¹çª—é…ç½®ï¼ˆä»ç¯å¢ƒå˜é‡è¯»å–ï¼Œé»˜è®¤ç¦ç”¨ï¼‰
ANNOUNCEMENT_ENABLED = os.getenv('ANNOUNCEMENT_ENABLED', 'false').lower() == 'true'
ANNOUNCEMENT_CONTENT = os.getenv('ANNOUNCEMENT_CONTENT', '')

# ==================== PT ç«™é…ç½® ====================
# MoviePilot API é…ç½®
MOVIEPILOT_URL = os.getenv('MOVIEPILOT_URL', '').rstrip('/')
MOVIEPILOT_USERNAME = os.getenv('MOVIEPILOT_USERNAME', '')
MOVIEPILOT_PASSWORD = os.getenv('MOVIEPILOT_PASSWORD', '')
MOVIEPILOT_TOKEN = os.getenv('MOVIEPILOT_TOKEN', '')  # å¯é€‰ï¼šç›´æ¥æä¾› JWT Token

# qBittorrent é…ç½®
QBITTORRENT_BASE_URL = os.getenv('QBITTORRENT_BASE_URL', '').rstrip('/')
QBITTORRENT_USERNAME = os.getenv('QBITTORRENT_USERNAME', '')
QBITTORRENT_PASSWORD = os.getenv('QBITTORRENT_PASSWORD', '')
QBITTORRENT_CATEGORY = os.getenv('QBITTORRENT_CATEGORY', 'emby-request')
QBITTORRENT_SAVE_PATH = os.getenv('QBITTORRENT_SAVE_PATH', '')
DOWNLOAD_POLL_INTERVAL = int(os.getenv('DOWNLOAD_POLL_INTERVAL', '12'))
ENABLE_DOWNLOAD_MONITOR = os.getenv('ENABLE_DOWNLOAD_MONITOR', 'true').lower() == 'true'

# Emby æœåŠ¡å™¨é…ç½®
EMBY_URL = os.getenv('EMBY_URL', '').rstrip('/')
EMBY_API_KEY = os.getenv('EMBY_API_KEY', '')
EMBY_WEBHOOK_SECRET = os.getenv('EMBY_WEBHOOK_SECRET', '')  # å¯é€‰çš„ Webhook å¯†é’¥éªŒè¯

# ==================== å‰§é›†å…¥åº“é€šçŸ¥èšåˆ ====================
# åŒä¸€éƒ¨å‰§çš„å¤šé›†å…¥åº“ä¼šèšåˆä¸ºä¸€æ¡é€šçŸ¥ï¼Œç­‰å¾… AGGREGATE_DELAY ç§’æ— æ–°é›†åç»Ÿä¸€å‘é€
AGGREGATE_DELAY = int(os.getenv('LIBRARY_NOTIFY_DELAY', '300'))  # é»˜è®¤5åˆ†é’Ÿ(300ç§’)
_library_notify_pending = {}   # key: series_key â†’ {timer, data}
_library_notify_lock = threading.Lock()


def _flush_aggregated_notification(series_key):
    """å®šæ—¶å™¨è§¦å‘ï¼šå‘é€èšåˆåçš„å‰§é›†å…¥åº“é€šçŸ¥"""
    with _library_notify_lock:
        pending = _library_notify_pending.pop(series_key, None)
    if not pending:
        return
    try:
        info = pending['data']
        episodes = sorted(info['episodes'])  # [(season, episode), ...]
        episode_names = info.get('episode_names', {})

        # æŒ‰å­£åˆ†ç»„
        from collections import defaultdict
        seasons = defaultdict(list)
        for s, e in episodes:
            seasons[s].append(e)

        # æ„å»ºå­£é›†æè¿°
        parts = []
        single_episode_name = None  # å•é›†æ—¶çš„é›†å
        for s_num in sorted(seasons.keys()):
            eps = seasons[s_num]
            if len(eps) == 1:
                ep_tag = f"S{s_num:02d}E{eps[0]:02d}"
                # å•é›†ï¼šå°è¯•é™„å¸¦é›†åï¼ˆå¦‚ "ç¬¬åä¸‰é›†"ï¼‰
                ep_name = episode_names.get((s_num, eps[0]))
                if ep_name:
                    single_episode_name = ep_name
                parts.append(ep_tag)
            else:
                eps_sorted = sorted(eps)
                # æ£€æŸ¥æ˜¯å¦è¿ç»­
                if eps_sorted[-1] - eps_sorted[0] == len(eps_sorted) - 1:
                    parts.append(f"S{s_num:02d} E{eps_sorted[0]:02d}-E{eps_sorted[-1]:02d}")
                else:
                    ep_str = 'ã€'.join(str(e) for e in eps_sorted)
                    parts.append(f"S{s_num:02d} ç¬¬{ep_str}é›†")

        season_episode = ' '.join(parts)
        # å¦‚æœåªæœ‰ä¸€é›†ä¸”æœ‰é›†åï¼Œåœ¨å­£é›†æè¿°åé™„åŠ é›†å
        if len(episodes) == 1 and single_episode_name:
            season_episode = f"{season_episode} {single_episode_name}"
        file_count = len(episodes)

        with app.app_context():
            app.logger.info(f'å‘é€èšåˆå…¥åº“é€šçŸ¥: {info["title"]} {season_episode} ({file_count}é›†)')
            send_general_library_notification(
                title=info['title'],
                year=info.get('year'),
                season_episode=season_episode,
                vote_average=info.get('vote_average'),
                category=info.get('category'),
                resource_quality=info.get('resource_quality'),
                file_count=file_count,
                total_size=info.get('total_size'),
                tmdb_id=info.get('tmdb_id'),
                release_group=None,
                time_usage=None,
                overview=info.get('overview'),
                poster_path=info.get('poster_path')
            )
    except Exception as e:
        try:
            with app.app_context():
                app.logger.error(f'èšåˆå…¥åº“é€šçŸ¥å‘é€å¤±è´¥: {e}')
        except:
            pass


def _queue_episode_notification(series_key, title, year, season_num, episode_num,
                                 vote_average, category, resource_quality,
                                 total_size, tmdb_id, overview, poster_path,
                                 episode_name=None):
    """å°†å•é›†å…¥åº“äº‹ä»¶åŠ å…¥èšåˆé˜Ÿåˆ—ï¼Œé‡ç½®å®šæ—¶å™¨"""
    with _library_notify_lock:
        if series_key in _library_notify_pending:
            entry = _library_notify_pending[series_key]
            # å–æ¶ˆæ—§å®šæ—¶å™¨
            entry['timer'].cancel()
            # è¿½åŠ é›†æ•°
            entry['data']['episodes'].append((season_num or 0, episode_num or 0))
            # è®°å½•æ¯é›†çš„é›†åï¼ˆç”¨äºå•é›†é€šçŸ¥æ—¶æ˜¾ç¤ºï¼‰
            if episode_name:
                entry['data'].setdefault('episode_names', {})[(season_num or 0, episode_num or 0)] = episode_name
            # ç´¯åŠ æ–‡ä»¶å¤§å°
            if total_size and entry['data'].get('total_size'):
                try:
                    # å°è¯•æŠŠå­—ç¬¦ä¸²å¤§å°è½¬ä¸ºæ•°å€¼ç´¯åŠ 
                    pass  # å¤§å°æ ¼å¼å¤æ‚ï¼Œä¿ç•™æœ€æ–°å€¼å³å¯
                except:
                    pass
            if total_size:
                entry['data']['total_size'] = total_size
            # æ›´æ–°ç”»è´¨ï¼ˆå–æœ€é«˜ï¼‰
            if resource_quality:
                entry['data']['resource_quality'] = resource_quality
        else:
            episode_names = {}
            if episode_name:
                episode_names[(season_num or 0, episode_num or 0)] = episode_name
            entry = {
                'data': {
                    'title': title,
                    'year': year,
                    'episodes': [(season_num or 0, episode_num or 0)],
                    'episode_names': episode_names,
                    'vote_average': vote_average,
                    'category': category,
                    'resource_quality': resource_quality,
                    'total_size': total_size,
                    'tmdb_id': tmdb_id,
                    'overview': overview,
                    'poster_path': poster_path,
                }
            }
            _library_notify_pending[series_key] = entry

        # åˆ›å»ºæ–°å®šæ—¶å™¨
        timer = threading.Timer(AGGREGATE_DELAY, _flush_aggregated_notification, args=[series_key])
        timer.daemon = True
        entry['timer'] = timer
        timer.start()

    app.logger.info(f'å‰§é›†å…¥åº“å·²åŠ å…¥èšåˆé˜Ÿåˆ—: {title} S{season_num or 0:02d}E{episode_num or 0:02d}, '
                    f'å½“å‰ç´¯è®¡ {len(entry["data"]["episodes"])} é›†, {AGGREGATE_DELAY}ç§’åå‘é€')


# ==================== ä»£ç†é…ç½® ====================
# æ”¯æŒ HTTP/HTTPS å’Œ SOCKS5 ä»£ç†ï¼Œç”¨äºä¸­å›½å¤§é™†æœåŠ¡å™¨è®¿é—®å¤–ç½‘
HTTP_PROXY = os.getenv('HTTP_PROXY', '') or os.getenv('http_proxy', '')
HTTPS_PROXY = os.getenv('HTTPS_PROXY', '') or os.getenv('https_proxy', '')
SOCKS5_PROXY = os.getenv('SOCKS5_PROXY', '') or os.getenv('socks5_proxy', '')
ALL_PROXY = os.getenv('ALL_PROXY', '') or os.getenv('all_proxy', '')
NO_PROXY = os.getenv('NO_PROXY', 'localhost,127.0.0.1') or os.getenv('no_proxy', 'localhost,127.0.0.1')


def get_proxy_config():
    """è·å–ä»£ç†é…ç½®"""
    proxies = {}
    
    # ä¼˜å…ˆä½¿ç”¨ SOCKS5 ä»£ç†
    if SOCKS5_PROXY:
        proxies = {
            'http': SOCKS5_PROXY,
            'https': SOCKS5_PROXY
        }
    # å…¶æ¬¡ä½¿ç”¨ ALL_PROXY
    elif ALL_PROXY:
        proxies = {
            'http': ALL_PROXY,
            'https': ALL_PROXY
        }
    # æœ€åä½¿ç”¨ HTTP/HTTPS ä»£ç†
    elif HTTP_PROXY or HTTPS_PROXY:
        if HTTP_PROXY:
            proxies['http'] = HTTP_PROXY
        if HTTPS_PROXY:
            proxies['https'] = HTTPS_PROXY
    
    return proxies if proxies else None


def get_proxied_session():
    """è·å–é…ç½®äº†ä»£ç†çš„ requests Session"""
    session = requests.Session()
    proxy_config = get_proxy_config()
    if proxy_config:
        session.proxies.update(proxy_config)
    return session


# åˆ›å»ºå…¨å±€ä»£ç† Sessionï¼ˆç”¨äºè®¿é—®å¤–ç½‘æœåŠ¡å¦‚ Telegramã€TMDBï¼‰
PROXY_SESSION = get_proxied_session()

# æ›´æ–° http_session ä»¥ä½¿ç”¨ä»£ç†é…ç½®ï¼ˆç”¨äº TMDB API ç­‰å¤–ç½‘è¯·æ±‚ï¼‰
_proxy_config = get_proxy_config()
if _proxy_config:
    http_session.proxies.update(_proxy_config)
    print("[CONFIG] ä»£ç†å·²é…ç½®")
else:
    print("[CONFIG] æœªé…ç½®ä»£ç†ï¼Œç›´è¿å¤–ç½‘")

# ==================== æ•°æ®åº“é…ç½®é”®å¸¸é‡ ====================
# è¿™äº›å¸¸é‡åœ¨ SystemConfig ç±»å®šä¹‰å‰ä½¿ç”¨ï¼Œéœ€è¦å•ç‹¬å®šä¹‰
CONFIG_KEY_ADMIN = 'admin'
CONFIG_KEY_EMBY = 'emby'
CONFIG_KEY_TELEGRAM = 'telegram'
CONFIG_KEY_TMDB = 'tmdb'
CONFIG_KEY_MOVIEPILOT = 'moviepilot'
CONFIG_KEY_QBITTORRENT = 'qbittorrent'
CONFIG_KEY_SEARCH = 'search'
CONFIG_KEY_REQUEST_LIMIT = 'request_limit'
CONFIG_KEY_CATEGORY = 'category'
CONFIG_KEY_EPAY = 'epay'
CONFIG_KEY_SITE = 'site'
CONFIG_KEY_PLANS = 'plans'
CONFIG_KEY_PROXY = 'proxy'
CONFIG_KEY_CHECKIN = 'checkin'
CONFIG_KEY_SUBSCRIPTION_EXPIRE = 'subscription_expire'
CONFIG_KEY_INVITE_REWARD = 'invite_reward'
CONFIG_KEY_EMAIL = 'email'
CONFIG_KEY_LOGIN_NOTIFY = 'login_notify'
CONFIG_KEY_EXPIRE_REMIND = 'expire_remind'
CONFIG_KEY_RANKING = 'ranking'

# æ˜“æ”¯ä»˜é…ç½®ï¼ˆæ”¯æŒç¯å¢ƒå˜é‡æˆ–é…ç½®æ–‡ä»¶ï¼‰
EPAY_CONFIG_FILE = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'instance', 'epay_config.json')

# å¥—é¤é…ç½®æ–‡ä»¶
PLANS_CONFIG_FILE = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'instance', 'plans_config.json')

# å‰ç«¯é…ç½®æ–‡ä»¶
SITE_CONFIG_FILE = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'instance', 'site_config.json')

# é»˜è®¤å‰ç«¯é…ç½®
DEFAULT_SITE_CONFIG = {
    'site_name': 'Emby',
    'site_subtitle': 'ç®¡ç†ç³»ç»Ÿ',
    'site_title': 'Embyç®¡ç†ç³»ç»Ÿ',
    'site_logo': '',
    'shop_url': '',
    'panel_url': '',
    'telegram_group': '',
    'telegram_bot_username': '',
    'support_email': 'support@example.com',
    'footer_text': '',
    'welcome_message': 'æ¬¢è¿ä½¿ç”¨ Emby ç®¡ç†ç³»ç»Ÿï¼',
    'docs_intro': 'ä»¥ä¸‹æ˜¯å¿«é€Ÿå…¥é—¨æŒ‡å—ï¼š',
    'custom_css': '',
    'custom_js': '',
    'custom_links': [
        {'name': 'å¸®åŠ©æ–‡æ¡£', 'url': '#', 'icon': 'ğŸ“–', 'enabled': True},
        {'name': 'Telegramç¾¤ç»„', 'url': '', 'icon': 'ğŸ’¬', 'enabled': True},
        {'name': 'å®˜æ–¹ç½‘ç«™', 'url': '', 'icon': 'ğŸŒ', 'enabled': False}
    ],
    'register_mode': 'open',  # æ³¨å†Œæ¨¡å¼: open(å¼€æ”¾æ³¨å†Œ), invite(ä»…é‚€è¯·æ³¨å†Œ), closed(å…³é—­æ³¨å†Œ)
    'use_image_proxy': True  # æ˜¯å¦ä½¿ç”¨å›¾ç‰‡ä»£ç†ï¼ˆå¤§é™†ç”¨æˆ·å»ºè®®å¼€å¯ï¼Œæµ·å¤–ç”¨æˆ·å¯å…³é—­ä»¥åŠ é€Ÿï¼‰
}

# é»˜è®¤å¥—é¤é…ç½®
DEFAULT_PLANS = [
    {
        'id': 'basic_1m',
        'type': 'basic',
        'name': 'å…¥é—¨ç‰ˆ',
        'icon': 'ğŸŒ±',
        'description': 'é€‚åˆè½»åº¦è§‚å½±ç”¨æˆ·ï¼Œæ»¡è¶³åŸºæœ¬è§‚å½±éœ€æ±‚',
        'duration': 1,
        'duration_days': 30,
        'price': 15,
        'price_1m': 15,
        'original_price': None,
        'features': ['1080P ç”»è´¨', '1 ä¸ªè®¾å¤‡', 'æ¯æ—¥ 1 æ¬¡æ±‚ç‰‡', 'æ ‡å‡†æ”¯æŒ'],
        'popular': False
    },
    {
        'id': 'standard_1m',
        'type': 'standard',
        'name': 'æ ‡å‡†ç‰ˆ',
        'icon': 'â­',
        'description': 'é€‚åˆæ—¥å¸¸è§‚å½±ç”¨æˆ·ï¼Œäº«å—æ›´å¤šèµ„æº',
        'duration': 1,
        'duration_days': 30,
        'price': 25,
        'price_1m': 25,
        'original_price': None,
        'features': ['4K ç”»è´¨', '2 ä¸ªè®¾å¤‡', 'æ¯æ—¥ 3 æ¬¡æ±‚ç‰‡', 'ä¼˜å…ˆæ”¯æŒ'],
        'popular': True
    },
    {
        'id': 'standard_3m',
        'type': 'standard',
        'name': 'æ ‡å‡†ç‰ˆ',
        'icon': 'â­',
        'description': 'é€‚åˆæ—¥å¸¸è§‚å½±ç”¨æˆ·ï¼Œäº«å—æ›´å¤šèµ„æº',
        'duration': 3,
        'duration_days': 90,
        'price': 68,
        'price_3m': 68,
        'original_price': 75,
        'features': ['4K ç”»è´¨', '2 ä¸ªè®¾å¤‡', 'æ¯æ—¥ 3 æ¬¡æ±‚ç‰‡', 'ä¼˜å…ˆæ”¯æŒ'],
        'popular': False
    },
    {
        'id': 'premium_1m',
        'type': 'premium',
        'name': 'é«˜çº§ç‰ˆ',
        'icon': 'ğŸ’',
        'description': 'é€‚åˆå½±è§†çˆ±å¥½è€…ï¼Œä¼˜å…ˆè·å–çƒ­é—¨èµ„æº',
        'duration': 1,
        'duration_days': 30,
        'price': 45,
        'price_1m': 45,
        'original_price': None,
        'features': ['4K ç”»è´¨', '4 ä¸ªè®¾å¤‡', 'æ¯æ—¥ 5 æ¬¡æ±‚ç‰‡', 'ä¸“å±æ”¯æŒ', 'VIP æ ‡è¯†'],
        'popular': False
    },
    {
        'id': 'premium_12m',
        'type': 'premium',
        'name': 'é«˜çº§ç‰ˆ',
        'icon': 'ğŸ’',
        'description': 'é€‚åˆå½±è§†çˆ±å¥½è€…ï¼Œä¼˜å…ˆè·å–çƒ­é—¨èµ„æº',
        'duration': 12,
        'duration_days': 360,
        'price': 480,
        'price_12m': 480,
        'original_price': 540,
        'features': ['4K ç”»è´¨', '4 ä¸ªè®¾å¤‡', 'æ¯æ—¥ 5 æ¬¡æ±‚ç‰‡', 'ä¸“å±æ”¯æŒ', 'VIP æ ‡è¯†'],
        'popular': False
    },
    {
        'id': 'ultimate_1m',
        'type': 'ultimate',
        'name': 'å°Šäº«ç‰ˆ',
        'icon': 'ğŸ‘‘',
        'description': 'æè‡´ä½“éªŒï¼Œå°Šäº«å…¨éƒ¨ç‰¹æƒæœåŠ¡',
        'duration': 1,
        'duration_days': 30,
        'price': 88,
        'price_1m': 88,
        'original_price': None,
        'features': ['8K ç”»è´¨', 'æ— é™è®¾å¤‡', 'æ— é™æ±‚ç‰‡', '24/7 ä¸“å±æ”¯æŒ', 'VIP+ æ ‡è¯†', 'ç‹¬å®¶å†…å®¹'],
        'popular': False
    }
]

def load_plans_config():
    """åŠ è½½å¥—é¤é…ç½® - ä¼˜å…ˆä»æ•°æ®åº“è¯»å–"""
    try:
        if has_app_context():
            db_plans = get_db_config(CONFIG_KEY_PLANS)
            if db_plans and isinstance(db_plans, list):
                return db_plans
    except Exception as e:
        print(f"[WARNING] ä»æ•°æ®åº“åŠ è½½å¥—é¤é…ç½®å¤±è´¥: {e}")
    
    # å›é€€åˆ°æ–‡ä»¶
    if os.path.exists(PLANS_CONFIG_FILE):
        try:
            with open(PLANS_CONFIG_FILE, 'r', encoding='utf-8') as f:
                plans = json.load(f)
                if plans and isinstance(plans, list):
                    return plans
        except Exception as e:
            print(f"[WARNING] è¯»å–å¥—é¤é…ç½®æ–‡ä»¶å¤±è´¥: {e}")
    return DEFAULT_PLANS


def save_plans_config(plans):
    """ä¿å­˜å¥—é¤é…ç½® - åŒæ—¶ä¿å­˜åˆ°æ•°æ®åº“å’Œæ–‡ä»¶"""
    success = True
    
    # ä¿å­˜åˆ°æ•°æ®åº“
    try:
        if has_app_context():
            set_db_config(CONFIG_KEY_PLANS, plans, 'å¥—é¤é…ç½®')
    except Exception as e:
        print(f"[WARNING] ä¿å­˜å¥—é¤åˆ°æ•°æ®åº“å¤±è´¥: {e}")
        success = False
    
    # åŒæ—¶ä¿å­˜åˆ°æ–‡ä»¶
    try:
        os.makedirs(os.path.dirname(PLANS_CONFIG_FILE), exist_ok=True)
        with open(PLANS_CONFIG_FILE, 'w', encoding='utf-8') as f:
            json.dump(plans, f, ensure_ascii=False, indent=2)
    except Exception as e:
        print(f"[WARNING] ä¿å­˜å¥—é¤é…ç½®æ–‡ä»¶å¤±è´¥: {e}")
    
    return success


def load_site_config():
    """åŠ è½½å‰ç«¯é…ç½® - ä¼˜å…ˆä»æ•°æ®åº“è¯»å–"""
    config = DEFAULT_SITE_CONFIG.copy()
    
    try:
        if has_app_context():
            db_config = get_db_config(CONFIG_KEY_SITE)
            if db_config:
                for key in db_config:
                    if key in config:
                        config[key] = db_config[key]
                return config
    except Exception as e:
        print(f"[WARNING] ä»æ•°æ®åº“åŠ è½½å‰ç«¯é…ç½®å¤±è´¥: {e}")
    
    # å›é€€åˆ°æ–‡ä»¶
    if os.path.exists(SITE_CONFIG_FILE):
        try:
            with open(SITE_CONFIG_FILE, 'r', encoding='utf-8') as f:
                file_config = json.load(f)
                for key in file_config:
                    if key in config:
                        config[key] = file_config[key]
        except Exception as e:
            print(f"[WARNING] è¯»å–å‰ç«¯é…ç½®æ–‡ä»¶å¤±è´¥: {e}")
    return config


def save_site_config(config):
    """ä¿å­˜å‰ç«¯é…ç½® - åŒæ—¶ä¿å­˜åˆ°æ•°æ®åº“å’Œæ–‡ä»¶"""
    success = True
    
    # ä¿å­˜åˆ°æ•°æ®åº“
    try:
        if has_app_context():
            set_db_config(CONFIG_KEY_SITE, config, 'å‰ç«¯ç«™ç‚¹é…ç½®')
    except Exception as e:
        print(f"[WARNING] ä¿å­˜å‰ç«¯é…ç½®åˆ°æ•°æ®åº“å¤±è´¥: {e}")
        success = False
    
    # åŒæ—¶ä¿å­˜åˆ°æ–‡ä»¶
    try:
        os.makedirs(os.path.dirname(SITE_CONFIG_FILE), exist_ok=True)
        with open(SITE_CONFIG_FILE, 'w', encoding='utf-8') as f:
            json.dump(config, f, ensure_ascii=False, indent=2)
    except Exception as e:
        print(f"[WARNING] ä¿å­˜å‰ç«¯é…ç½®æ–‡ä»¶å¤±è´¥: {e}")
    
    return success


def get_site_config():
    """è·å–å½“å‰å‰ç«¯é…ç½®"""
    return load_site_config()


def load_epay_config():
    """åŠ è½½æ˜“æ”¯ä»˜é…ç½® - ä¼˜å…ˆä»æ•°æ®åº“è¯»å–"""
    config = {
        'epay_url': os.getenv('EPAY_URL', ''),
        'epay_pid': os.getenv('EPAY_PID', ''),
        'epay_key': os.getenv('EPAY_KEY', ''),
        'epay_notify_url': os.getenv('EPAY_NOTIFY_URL', ''),
        'epay_return_url': os.getenv('EPAY_RETURN_URL', '')
    }
    
    # å°è¯•ä»æ•°æ®åº“è¯»å–
    try:
        if has_app_context():
            db_config = get_db_config(CONFIG_KEY_EPAY)
            if db_config:
                for key in config:
                    if db_config.get(key):
                        config[key] = db_config[key]
                return config
    except Exception as e:
        print(f"[WARNING] ä»æ•°æ®åº“åŠ è½½æ˜“æ”¯ä»˜é…ç½®å¤±è´¥: {e}")
    
    # å›é€€åˆ°æ–‡ä»¶
    if os.path.exists(EPAY_CONFIG_FILE):
        try:
            with open(EPAY_CONFIG_FILE, 'r', encoding='utf-8') as f:
                file_config = json.load(f)
                # åªè¦†ç›–éç©ºå€¼
                for key in config:
                    if file_config.get(key):
                        config[key] = file_config[key]
        except Exception as e:
            print(f"[WARNING] è¯»å–æ˜“æ”¯ä»˜é…ç½®æ–‡ä»¶å¤±è´¥: {e}")
    return config


def save_epay_config(config):
    """ä¿å­˜æ˜“æ”¯ä»˜é…ç½® - åŒæ—¶ä¿å­˜åˆ°æ•°æ®åº“å’Œæ–‡ä»¶"""
    success = True
    
    # ä¿å­˜åˆ°æ•°æ®åº“
    try:
        if has_app_context():
            set_db_config(CONFIG_KEY_EPAY, config, 'æ˜“æ”¯ä»˜é…ç½®')
    except Exception as e:
        print(f"[WARNING] ä¿å­˜æ˜“æ”¯ä»˜é…ç½®åˆ°æ•°æ®åº“å¤±è´¥: {e}")
        success = False
    
    # åŒæ—¶ä¿å­˜åˆ°æ–‡ä»¶
    try:
        os.makedirs(os.path.dirname(EPAY_CONFIG_FILE), exist_ok=True)
        with open(EPAY_CONFIG_FILE, 'w', encoding='utf-8') as f:
            json.dump(config, f, ensure_ascii=False, indent=2)
    except Exception as e:
        print(f"[WARNING] ä¿å­˜æ˜“æ”¯ä»˜é…ç½®æ–‡ä»¶å¤±è´¥: {e}")
    
    return success


def get_epay_config():
    """è·å–å½“å‰æ˜“æ”¯ä»˜é…ç½®"""
    return load_epay_config()

# åˆå§‹åŒ–åŠ è½½é…ç½®
_epay_config = load_epay_config()
EPAY_URL = _epay_config['epay_url'].rstrip('/') if _epay_config['epay_url'] else ''
EPAY_PID = _epay_config['epay_pid']
EPAY_KEY = _epay_config['epay_key']
EPAY_NOTIFY_URL = _epay_config['epay_notify_url']
EPAY_RETURN_URL = _epay_config['epay_return_url']

# ==================== MoviePilot & qBittorrent é…ç½®æ–‡ä»¶ ====================
DOWNLOAD_CONFIG_FILE = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'instance', 'download_config.json')

# é»˜è®¤ä¸‹è½½é…ç½®
DEFAULT_DOWNLOAD_CONFIG = {
    'moviepilot': {
        'url': '',
        'username': '',
        'password': '',
        'token': '',
        'enabled': False
    },
    'qbittorrent': {
        'url': '',
        'username': '',
        'password': '',
        'category': 'emby-request',
        'save_path': '',
        'enabled': False
    }
}


def load_download_config():
    """åŠ è½½ä¸‹è½½å·¥å…·é…ç½® - ä¼˜å…ˆä»æ•°æ®åº“è¯»å–"""
    config = {
        'moviepilot': DEFAULT_DOWNLOAD_CONFIG['moviepilot'].copy(),
        'qbittorrent': DEFAULT_DOWNLOAD_CONFIG['qbittorrent'].copy()
    }
    
    # é¦–å…ˆä»ç¯å¢ƒå˜é‡è¯»å–ï¼ˆä½œä¸ºé»˜è®¤å€¼ï¼‰
    config['moviepilot']['url'] = os.getenv('MOVIEPILOT_URL', '')
    config['moviepilot']['username'] = os.getenv('MOVIEPILOT_USERNAME', '')
    config['moviepilot']['password'] = os.getenv('MOVIEPILOT_PASSWORD', '')
    config['moviepilot']['token'] = os.getenv('MOVIEPILOT_TOKEN', '')
    
    config['qbittorrent']['url'] = os.getenv('QBITTORRENT_BASE_URL', '')
    config['qbittorrent']['username'] = os.getenv('QBITTORRENT_USERNAME', '')
    config['qbittorrent']['password'] = os.getenv('QBITTORRENT_PASSWORD', '')
    config['qbittorrent']['category'] = os.getenv('QBITTORRENT_CATEGORY', 'emby-request')
    config['qbittorrent']['save_path'] = os.getenv('QBITTORRENT_SAVE_PATH', '')
    
    # å°è¯•ä»æ•°æ®åº“è¯»å–
    db_loaded = False
    try:
        if has_app_context():
            db_mp = get_db_config(CONFIG_KEY_MOVIEPILOT)
            if db_mp:
                for key in config['moviepilot']:
                    if key in db_mp and db_mp[key] != '':
                        config['moviepilot'][key] = db_mp[key]
                db_loaded = True
            
            db_qb = get_db_config(CONFIG_KEY_QBITTORRENT)
            if db_qb:
                for key in config['qbittorrent']:
                    if key in db_qb and db_qb[key] != '':
                        config['qbittorrent'][key] = db_qb[key]
                db_loaded = True
    except Exception as e:
        print(f"[WARNING] ä»æ•°æ®åº“åŠ è½½ä¸‹è½½é…ç½®å¤±è´¥: {e}")
    
    # å¦‚æœæ•°æ®åº“æ²¡æœ‰ï¼Œå›é€€åˆ°é…ç½®æ–‡ä»¶
    if not db_loaded and os.path.exists(DOWNLOAD_CONFIG_FILE):
        try:
            with open(DOWNLOAD_CONFIG_FILE, 'r', encoding='utf-8') as f:
                file_config = json.load(f)
                if 'moviepilot' in file_config:
                    for key in config['moviepilot']:
                        if key in file_config['moviepilot'] and file_config['moviepilot'][key] != '':
                            config['moviepilot'][key] = file_config['moviepilot'][key]
                if 'qbittorrent' in file_config:
                    for key in config['qbittorrent']:
                        if key in file_config['qbittorrent'] and file_config['qbittorrent'][key] != '':
                            config['qbittorrent'][key] = file_config['qbittorrent'][key]
        except Exception as e:
            print(f"[WARNING] è¯»å–ä¸‹è½½é…ç½®æ–‡ä»¶å¤±è´¥: {e}")
    
    # åˆ¤æ–­æ˜¯å¦å·²é…ç½®ï¼ˆå¯ç”¨çŠ¶æ€ï¼‰
    config['moviepilot']['enabled'] = bool(config['moviepilot']['url'] and (
        (config['moviepilot']['username'] and config['moviepilot']['password']) or config['moviepilot']['token']
    ))
    config['qbittorrent']['enabled'] = bool(
        config['qbittorrent']['url'] and config['qbittorrent']['username'] and config['qbittorrent']['password']
    )
    
    return config


def save_download_config(config):
    """ä¿å­˜ä¸‹è½½å·¥å…·é…ç½® - åŒæ—¶ä¿å­˜åˆ°æ•°æ®åº“å’Œæ–‡ä»¶"""
    success = True
    
    # ä¿å­˜åˆ°æ•°æ®åº“
    try:
        if has_app_context():
            if 'moviepilot' in config:
                set_db_config(CONFIG_KEY_MOVIEPILOT, config['moviepilot'], 'MoviePilot é…ç½®')
            if 'qbittorrent' in config:
                set_db_config(CONFIG_KEY_QBITTORRENT, config['qbittorrent'], 'qBittorrent é…ç½®')
    except Exception as e:
        print(f"[WARNING] ä¿å­˜ä¸‹è½½é…ç½®åˆ°æ•°æ®åº“å¤±è´¥: {e}")
        success = False
    
    # åŒæ—¶ä¿å­˜åˆ°æ–‡ä»¶
    try:
        os.makedirs(os.path.dirname(DOWNLOAD_CONFIG_FILE), exist_ok=True)
        with open(DOWNLOAD_CONFIG_FILE, 'w', encoding='utf-8') as f:
            json.dump(config, f, ensure_ascii=False, indent=2)
    except Exception as e:
        print(f"[WARNING] ä¿å­˜ä¸‹è½½é…ç½®æ–‡ä»¶å¤±è´¥: {e}")
    
    return success


def get_download_config():
    """è·å–å½“å‰ä¸‹è½½é…ç½®"""
    return load_download_config()


def update_global_download_config():
    """æ›´æ–°å…¨å±€å˜é‡ä¸ºé…ç½®æ–‡ä»¶ä¸­çš„å€¼ï¼Œå¹¶é‡æ–°åˆå§‹åŒ– PT å®¢æˆ·ç«¯"""
    global MOVIEPILOT_URL, MOVIEPILOT_USERNAME, MOVIEPILOT_PASSWORD, MOVIEPILOT_TOKEN
    global QBITTORRENT_BASE_URL, QBITTORRENT_USERNAME, QBITTORRENT_PASSWORD, QBITTORRENT_CATEGORY, QBITTORRENT_SAVE_PATH
    global qbit_client
    
    config = load_download_config()
    
    MOVIEPILOT_URL = config['moviepilot']['url'].rstrip('/') if config['moviepilot']['url'] else ''
    MOVIEPILOT_USERNAME = config['moviepilot']['username']
    MOVIEPILOT_PASSWORD = config['moviepilot']['password']
    MOVIEPILOT_TOKEN = config['moviepilot']['token']
    
    QBITTORRENT_BASE_URL = config['qbittorrent']['url'].rstrip('/') if config['qbittorrent']['url'] else ''
    QBITTORRENT_USERNAME = config['qbittorrent']['username']
    QBITTORRENT_PASSWORD = config['qbittorrent']['password']
    QBITTORRENT_CATEGORY = config['qbittorrent']['category'] or 'emby-request'
    QBITTORRENT_SAVE_PATH = config['qbittorrent']['save_path']
    
    # é‡æ–°åˆå§‹åŒ– PT Manager çš„å®¢æˆ·ç«¯
    try:
        # æ¸…ç©ºç°æœ‰å®¢æˆ·ç«¯
        pt_manager.clients.clear()
        
        # å¦‚æœ MoviePilot å·²é…ç½®ï¼Œé‡æ–°æ³¨å†Œ
        if MOVIEPILOT_URL and (MOVIEPILOT_TOKEN or (MOVIEPILOT_USERNAME and MOVIEPILOT_PASSWORD)):
            moviepilot_client = MoviePilotClient(
                base_url=MOVIEPILOT_URL,
                username=MOVIEPILOT_USERNAME,
                password=MOVIEPILOT_PASSWORD,
                token=MOVIEPILOT_TOKEN,
                priority=20
            )
            pt_manager.register(moviepilot_client)
            print("[CONFIG] MoviePilot å®¢æˆ·ç«¯å·²é‡æ–°åˆå§‹åŒ–")
        
        # é‡æ–°åˆå§‹åŒ– qBittorrent å®¢æˆ·ç«¯
        qbit_client = QbitClient(QBITTORRENT_BASE_URL, QBITTORRENT_USERNAME, QBITTORRENT_PASSWORD)
    except NameError:
        # é¦–æ¬¡è°ƒç”¨æ—¶ pt_manager è¿˜æœªåˆ›å»ºï¼Œå¿½ç•¥
        pass
    
    print(f"[CONFIG] ä¸‹è½½é…ç½®å·²æ›´æ–°: MP={'å·²é…ç½®' if MOVIEPILOT_URL else 'æœªé…ç½®'}, QB={'å·²é…ç½®' if QBITTORRENT_BASE_URL else 'æœªé…ç½®'}")

# åˆå§‹åŒ–åŠ è½½ä¸‹è½½é…ç½®
update_global_download_config()


# ==================== ç³»ç»Ÿé…ç½®æ–‡ä»¶ï¼ˆEmbyã€Telegramã€ç®¡ç†å‘˜ç­‰ï¼‰====================
SYSTEM_CONFIG_FILE = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'instance', 'system_config.json')

# é»˜è®¤äºŒçº§åˆ†ç±»ç­–ç•¥é…ç½®ï¼ˆå‚è€ƒMoviePilotï¼‰
DEFAULT_CATEGORY_CONFIG = {
    'movie': {
        # ç”µå½±åˆ†ç±»è§„åˆ™ï¼ŒæŒ‰é¡ºåºåŒ¹é…
        'åŠ¨ç”»ç”µå½±': {
            'genre_ids': [16]  # 16æ˜¯åŠ¨ç”»
        },
        'åè¯­ç”µå½±': {
            'original_language': ['zh', 'cn', 'bo', 'za']
        },
        'å¤–è¯­ç”µå½±': {}  # é»˜è®¤åˆ†ç±»ï¼Œæ— æ¡ä»¶
    },
    'tv': {
        # ç”µè§†å‰§åˆ†ç±»è§„åˆ™ï¼ŒæŒ‰é¡ºåºåŒ¹é…
        'å›½æ¼«': {
            'genre_ids': [16],
            'origin_country': ['CN', 'TW', 'HK']
        },
        'æ—¥ç•ª': {
            'genre_ids': [16],
            'origin_country': ['JP']
        },
        'çºªå½•ç‰‡': {
            'genre_ids': [99]
        },
        'å„¿ç«¥': {
            'genre_ids': [10762]
        },
        'ç»¼è‰º': {
            'genre_ids': [10764, 10767]
        },
        'å›½äº§å‰§': {
            'origin_country': ['CN', 'TW', 'HK']
        },
        'æ¬§ç¾å‰§': {
            'origin_country': ['US', 'FR', 'GB', 'DE', 'ES', 'IT', 'NL', 'PT', 'RU', 'UK', 'CA', 'AU', 'NZ']
        },
        'æ—¥éŸ©å‰§': {
            'origin_country': ['JP', 'KP', 'KR', 'TH', 'IN', 'SG', 'VN', 'PH', 'MY']
        },
        'æµ·å¤–å‰§': {}  # é»˜è®¤åˆ†ç±»ï¼Œæ— æ¡ä»¶
    }
}

# é»˜è®¤ç³»ç»Ÿé…ç½®
DEFAULT_SYSTEM_CONFIG = {
    'admin': {
        'username': '',        # ç®¡ç†å‘˜ç”¨æˆ·å
        'password': '',        # ç®¡ç†å‘˜å¯†ç ï¼ˆå“ˆå¸Œå­˜å‚¨ï¼‰
        'secret_path': '',     # åå°å…¥å£è·¯å¾„
        'initialized': False   # æ˜¯å¦å·²å®Œæˆé¦–æ¬¡é…ç½®
    },
    'emby': {
        'url': '',
        'api_key': '',
        'webhook_secret': ''
    },
    'subscription_expire': {
        'auto_disable': True,           # è¿‡æœŸåè‡ªåŠ¨ç¦ç”¨ Emby è´¦å·
        'delete_days': 0,               # è¿‡æœŸåå¤šå°‘å¤©åˆ é™¤ Emby è´¦å·ï¼ˆ0è¡¨ç¤ºä¸åˆ é™¤ï¼‰
        'delete_web_account': False,    # åˆ é™¤ Emby è´¦å·æ—¶æ˜¯å¦åŒæ—¶åˆ é™¤ç½‘ç«™è´¦å·
        'retention_mode': 'off',        # ä¿å·æ¨¡å¼: off=å…³é—­, checkin=ç§¯åˆ†ä¿å·, watch=è§‚çœ‹ä¿å·, both=åŒä¿ï¼ˆç§¯åˆ†+è§‚çœ‹ï¼‰
        'retention_checkin_days': 20,   # ï¼ˆå·²å¼ƒç”¨ï¼Œä¿ç•™å…¼å®¹ï¼‰
        'retention_checkin_cost': 10,   # ç§¯åˆ†ä¿å·ï¼šç§¯åˆ†è¶³å¤Ÿæ—¶è‡ªåŠ¨æ‰£é™¤çš„ç§¯åˆ†æ•°
        'retention_watch_days': 30,     # è§‚çœ‹ä¿å·ï¼šNå¤©å†…éœ€æœ‰è§‚çœ‹è®°å½•
        'retention_watch_minutes': 30,  # è§‚çœ‹ä¿å·ï¼šç´¯è®¡è§‚çœ‹æ—¶é•¿ï¼ˆåˆ†é’Ÿï¼‰
        'retention_renew_days': 30,     # ä¿å·ç»­æœŸå¤©æ•°
    },
    'telegram': {
        'bot_token': '',
        'chat_id': '',
        'group_id': '',
        'bot_admins': '',  # BOTç®¡ç†å‘˜ Telegram IDï¼Œå¤šä¸ªç”¨é€—å·åˆ†éš”
        'gift_days': 30,   # /kk å‘½ä»¤èµ é€å¤©æ•°
        'max_streams': 0,  # æœ€å¤§åŒæ—¶æ’­æ”¾æµæ•°ï¼ˆ0è¡¨ç¤ºä¸é™åˆ¶ï¼‰
        'bot_photo': '',   # Bot æ¬¢è¿å›¾ç‰‡ URLï¼ˆç•™ç©ºä½¿ç”¨é»˜è®¤å›¾ç‰‡ï¼‰
        'configured_url': '',  # ç”¨æˆ·é…ç½®çš„ Webhook æœåŠ¡å™¨åœ°å€
        'require_bindtg': False,  # æ˜¯å¦å¼ºåˆ¶ç”¨æˆ·ç»‘å®š Telegram åæ‰èƒ½ä½¿ç”¨ç³»ç»Ÿ
        'templates': {
            'request': '',   # æ±‚ç‰‡é€šçŸ¥æ¨¡æ¿ï¼ˆç©ºåˆ™ä½¿ç”¨é»˜è®¤ï¼‰
            'completion': '' # å…¥åº“é€šçŸ¥æ¨¡æ¿ï¼ˆç©ºåˆ™ä½¿ç”¨é»˜è®¤ï¼‰
        },
        'request_notification': {
            'enabled': True,  # æ˜¯å¦å¯ç”¨æ±‚ç‰‡é€šçŸ¥
            'send_to': 'group',  # æ¨é€ç›®æ ‡: group(ç¾¤ç»„) æˆ– personal(ä¸ªäºº)
            'mention_admin': True,  # æ˜¯å¦@ç®¡ç†å‘˜
            'show_overview': True,  # æ˜¯å¦æ˜¾ç¤ºç®€ä»‹
            'show_poster': True,  # æ˜¯å¦æ˜¾ç¤ºæµ·æŠ¥
            'custom_message': ''  # è‡ªå®šä¹‰é€šçŸ¥æ–‡æ¡ˆï¼ˆæ”¯æŒå˜é‡æ›¿æ¢ï¼‰
        }
    },
    'search': {
        'strategy': 'all',  # all æˆ– first
        'poll_interval': 10
    },
    'tmdb': {
        'api_key': ''
    },
    'request_limit': {
        'max_daily': 3,  # æ¯æ—¥æœ€å¤§æ±‚ç‰‡æ¬¡æ•°
        'level_a': 3,    # Açº§(ç™½åå•)
        'level_b': 1,    # Bçº§(æ³¨å†Œç”¨æˆ·)
        'level_c': 0,    # Cçº§(å·²ç¦ç”¨)
        'level_d': 0     # Dçº§(æ— è´¦å·)
    },
    'category': DEFAULT_CATEGORY_CONFIG,  # äºŒçº§åˆ†ç±»ç­–ç•¥
    'invite_reward': {
        'enabled': True,             # æ˜¯å¦å¯ç”¨é‚€è¯·è¿”åˆ©
        'reward_percent': 10,        # è¿”åˆ©ç™¾åˆ†æ¯”ï¼ˆå¦‚10è¡¨ç¤º10%ï¼‰
        'min_reward_days': 1,        # æœ€ä½è¿”åˆ©å¤©æ•°
        'reward_mode': 'recurring'   # é»˜è®¤è¿”åˆ©æ¨¡å¼: once=ä¸€æ¬¡æ€§, recurring=å¾ªç¯(æ¯æ¬¡è´­ä¹°éƒ½è¿”åˆ©)
    },
    'email': {
        'enabled': False,            # æ˜¯å¦å¯ç”¨é‚®ä»¶åŠŸèƒ½
        'smtp_host': '',             # SMTP æœåŠ¡å™¨åœ°å€
        'smtp_port': 465,            # SMTP ç«¯å£
        'smtp_ssl': True,            # æ˜¯å¦ä½¿ç”¨ SSL
        'smtp_user': '',             # SMTP ç”¨æˆ·åï¼ˆå‘ä»¶é‚®ç®±ï¼‰
        'smtp_password': '',         # SMTP å¯†ç /æˆæƒç 
        'sender_name': 'Embyç®¡ç†ç³»ç»Ÿ', # å‘ä»¶äººåç§°
        'require_email_register': False  # æ³¨å†Œæ—¶æ˜¯å¦å¼ºåˆ¶ç»‘å®šé‚®ç®±
    },
    'ranking': {
        'enabled': False,              # æ˜¯å¦å¯ç”¨æ’­æ”¾æ’è¡ŒåŠŸèƒ½
        'movie_limit': 10,             # ç”µå½±æ’è¡Œæ˜¾ç¤ºæ•°é‡
        'episode_limit': 10,           # å‰§é›†æ’è¡Œæ˜¾ç¤ºæ•°é‡
        'user_limit': 10,              # ç”¨æˆ·æ’è¡Œæ˜¾ç¤ºæ•°é‡
        'exclude_users': '',           # æ’é™¤ç”¨æˆ·ï¼ˆEmbyç”¨æˆ·åï¼Œé€—å·åˆ†éš”ï¼‰
        'push_enabled': False,         # æ˜¯å¦å¯ç”¨å®šæ—¶æ¨é€åˆ°ç¾¤ç»„
        'push_chat_id': '',            # æ¨é€ç›®æ ‡ç¾¤ç»„ Chat IDï¼ˆç•™ç©ºä½¿ç”¨é»˜è®¤ç¾¤ç»„ï¼‰
        'push_daily_time': '21:00',    # æ—¥æ¦œæ¨é€æ—¶é—´ (HH:MM)
        'push_weekly_day': 0,          # å‘¨æ¦œæ¨é€æ˜ŸæœŸå‡  (0=å‘¨ä¸€, 6=å‘¨æ—¥)
        'push_weekly_time': '21:00',   # å‘¨æ¦œæ¨é€æ—¶é—´ (HH:MM)
        'push_daily': True,            # æ¨é€æ—¥æ¦œ
        'push_weekly': True,           # æ¨é€å‘¨æ¦œ
    }
}


def generate_random_string(length=12):
    """ç”Ÿæˆéšæœºå­—ç¬¦ä¸²"""
    import string
    import secrets
    chars = string.ascii_letters + string.digits
    return ''.join(secrets.choice(chars) for _ in range(length))


def hash_admin_password(password):
    """å“ˆå¸Œç®¡ç†å‘˜å¯†ç """
    import hashlib
    return hashlib.sha256(password.encode()).hexdigest()


# é»˜è®¤ç®¡ç†å‘˜é…ç½®ï¼ˆå›ºå®šå€¼ï¼‰
DEFAULT_ADMIN_USERNAME = 'admin'
DEFAULT_ADMIN_PASSWORD = 'admin123'
DEFAULT_ADMIN_PATH = 'embypanel'


def init_admin_config():
    """åˆå§‹åŒ–ç®¡ç†å‘˜é…ç½®ï¼ˆé¦–æ¬¡å¯åŠ¨æ—¶ï¼‰"""
    config = load_system_config()
    
    # å¦‚æœå·²ç»æœ‰ç”¨æˆ·åé…ç½®ï¼Œç›´æ¥è¿”å›
    if config.get('admin', {}).get('username'):
        return config
    
    # ä½¿ç”¨å›ºå®šçš„é»˜è®¤ç®¡ç†å‘˜é…ç½®
    config['admin'] = {
        'username': DEFAULT_ADMIN_USERNAME,
        'password': hash_admin_password(DEFAULT_ADMIN_PASSWORD),
        'secret_path': DEFAULT_ADMIN_PATH,
        'initialized': False  # æ ‡è®°æœªå®Œæˆé¦–æ¬¡é…ç½®ï¼Œç™»å½•åå¼ºåˆ¶ä¿®æ”¹
    }
    
    save_system_config(config)
    
    # æ‰“å°é»˜è®¤é…ç½®ä¿¡æ¯ï¼ˆä»…é¦–æ¬¡å¯åŠ¨ï¼‰
    print("=" * 60)
    print("  âš ï¸  é¦–æ¬¡å¯åŠ¨ - é»˜è®¤ç®¡ç†å‘˜é…ç½®")
    print("=" * 60)
    print(f"  åå°å…¥å£: /{DEFAULT_ADMIN_PATH}")
    print(f"  ç”¨æˆ·å: {DEFAULT_ADMIN_USERNAME}")
    print(f"  å¯†ç : {DEFAULT_ADMIN_PASSWORD}")
    print("=" * 60)
    print("  âš ï¸  ç™»å½•åå°†å¼ºåˆ¶ä¿®æ”¹è´¦å·å¯†ç å’Œå…¥å£è·¯å¾„ï¼")
    print("=" * 60)
    
    return config


def get_admin_config():
    """è·å–ç®¡ç†å‘˜é…ç½® - ä¼˜å…ˆä»æ•°æ®åº“è¯»å–"""
    try:
        # å°è¯•ä»æ•°æ®åº“è¯»å–
        if has_app_context():
            db_config = get_db_config(CONFIG_KEY_ADMIN)
            if db_config:
                return db_config
    except Exception as e:
        print(f"[WARNING] ä»æ•°æ®åº“è·å–ç®¡ç†å‘˜é…ç½®å¤±è´¥: {e}")
    
    # å›é€€åˆ°æ–‡ä»¶é…ç½®
    config = load_system_config_from_file()
    return config.get('admin', {})


def load_system_config(use_cache=True):
    """åŠ è½½ç³»ç»Ÿé…ç½® - ä¼˜å…ˆä»æ•°æ®åº“è¯»å–ï¼Œå›é€€åˆ°æ–‡ä»¶
    
    Args:
        use_cache: æ˜¯å¦ä½¿ç”¨å†…å­˜ç¼“å­˜ï¼Œé»˜è®¤Trueã€‚ç®¡ç†å‘˜ä¿å­˜åé‡æ–°åŠ è½½æ—¶ä¼ Falseä»¥ç¡®ä¿è¯»å–æœ€æ–°å€¼ã€‚
    """
    config = get_default_system_config()
    
    # å°è¯•ä»æ•°æ®åº“è¯»å–å„é…ç½®é¡¹
    try:
        if has_app_context():
            # ä»æ•°æ®åº“è¯»å–å„é…ç½®é¡¹
            db_admin = get_db_config(CONFIG_KEY_ADMIN, use_cache=use_cache)
            if db_admin:
                config['admin'] = db_admin
            
            db_emby = get_db_config(CONFIG_KEY_EMBY, use_cache=use_cache)
            if db_emby:
                config['emby'].update(db_emby)
            
            db_telegram = get_db_config(CONFIG_KEY_TELEGRAM, use_cache=use_cache)
            if db_telegram:
                if 'templates' not in db_telegram:
                    db_telegram['templates'] = {'request': '', 'completion': ''}
                config['telegram'].update(db_telegram)
            
            db_search = get_db_config(CONFIG_KEY_SEARCH, use_cache=use_cache)
            if db_search:
                config['search'].update(db_search)
            
            db_tmdb = get_db_config(CONFIG_KEY_TMDB, use_cache=use_cache)
            if db_tmdb:
                config['tmdb'].update(db_tmdb)
            
            db_request_limit = get_db_config(CONFIG_KEY_REQUEST_LIMIT, use_cache=use_cache)
            if db_request_limit:
                config['request_limit'].update(db_request_limit)
            
            db_category = get_db_config(CONFIG_KEY_CATEGORY, use_cache=use_cache)
            if db_category:
                config['category'] = db_category
            
            db_checkin = get_db_config(CONFIG_KEY_CHECKIN, use_cache=use_cache)
            if db_checkin:
                config['checkin'] = db_checkin
            
            db_subscription_expire = get_db_config(CONFIG_KEY_SUBSCRIPTION_EXPIRE, use_cache=use_cache)
            if db_subscription_expire:
                config['subscription_expire'] = db_subscription_expire
            
            db_invite_reward = get_db_config(CONFIG_KEY_INVITE_REWARD, use_cache=use_cache)
            if db_invite_reward:
                config['invite_reward'] = db_invite_reward
            
            db_email = get_db_config(CONFIG_KEY_EMAIL, use_cache=use_cache)
            if db_email:
                config['email'] = db_email
            
            db_login_notify = get_db_config(CONFIG_KEY_LOGIN_NOTIFY, use_cache=use_cache)
            if db_login_notify:
                config['login_notify'] = db_login_notify
            
            db_expire_remind = get_db_config(CONFIG_KEY_EXPIRE_REMIND, use_cache=use_cache)
            if db_expire_remind:
                config['expire_remind'] = db_expire_remind
            
            db_ranking = get_db_config(CONFIG_KEY_RANKING, use_cache=use_cache)
            if db_ranking:
                config['ranking'] = db_ranking
            
            # å¦‚æœæ•°æ®åº“æœ‰é…ç½®ï¼Œç›´æ¥è¿”å›
            if db_admin or db_emby or db_telegram:
                return config
    except Exception as e:
        print(f"[WARNING] ä»æ•°æ®åº“åŠ è½½é…ç½®å¤±è´¥: {e}")
    
    # å›é€€åˆ°æ–‡ä»¶é…ç½®
    return load_system_config_from_file()


def get_default_system_config():
    """è·å–é»˜è®¤ç³»ç»Ÿé…ç½®"""
    config = {
        'admin': DEFAULT_SYSTEM_CONFIG['admin'].copy(),
        'emby': DEFAULT_SYSTEM_CONFIG['emby'].copy(),
        'telegram': DEFAULT_SYSTEM_CONFIG['telegram'].copy(),
        'search': DEFAULT_SYSTEM_CONFIG['search'].copy(),
        'tmdb': DEFAULT_SYSTEM_CONFIG['tmdb'].copy(),
        'request_limit': DEFAULT_SYSTEM_CONFIG['request_limit'].copy(),
        'category': {
            'movie': DEFAULT_CATEGORY_CONFIG['movie'].copy(),
            'tv': DEFAULT_CATEGORY_CONFIG['tv'].copy()
        },
        'checkin': {
            'enabled': False,
            'bot_enabled': False,
            'checkin_permission': 'all',
            'coin_name': 'ç§¯åˆ†',
            'coin_min': 1,
            'coin_max': 10,
            'exchange_plans': []
        },
        'subscription_expire': {
            'auto_disable': True,
            'delete_days': 0,
            'delete_web_account': False,
            'retention_mode': 'off',
            'retention_checkin_days': 20,
            'retention_checkin_cost': 10,
            'retention_watch_days': 30,
            'retention_watch_minutes': 30,
            'retention_renew_days': 30,
        },
        'invite_reward': {
            'enabled': True,
            'reward_percent': 10,
            'min_reward_days': 1,
            'reward_mode': 'recurring'
        },
        'email': {
            'enabled': False,
            'smtp_host': '',
            'smtp_port': 465,
            'smtp_ssl': True,
            'smtp_user': '',
            'smtp_password': '',
            'sender_name': 'Embyç®¡ç†ç³»ç»Ÿ',
            'require_email_register': False
        },
        'login_notify': {
            'enabled': False,
            'email': True,
            'telegram': True
        },
        'expire_remind': {
            'enabled': False,
            'days': [3, 7],
            'email': True,
            'telegram': True
        },
        'ranking': DEFAULT_SYSTEM_CONFIG['ranking'].copy()
    }
    config['telegram']['templates'] = DEFAULT_SYSTEM_CONFIG['telegram']['templates'].copy()
    return config


def load_system_config_from_file():
    """ä»æ–‡ä»¶åŠ è½½ç³»ç»Ÿé…ç½®ï¼ˆåŸå§‹æ–¹æ³•ï¼Œä½œä¸ºå›é€€ï¼‰"""
    config = get_default_system_config()
    
    # ä»ç¯å¢ƒå˜é‡è¯»å–ï¼ˆä½œä¸ºé»˜è®¤å€¼ï¼‰
    config['emby']['url'] = os.getenv('EMBY_URL', '')
    config['emby']['api_key'] = os.getenv('EMBY_API_KEY', '')
    config['emby']['webhook_secret'] = os.getenv('EMBY_WEBHOOK_SECRET', '')
    
    config['telegram']['bot_token'] = os.getenv('TELEGRAM_BOT_TOKEN', '')
    config['telegram']['chat_id'] = os.getenv('TELEGRAM_CHAT_ID', '')
    config['telegram']['group_id'] = os.getenv('TELEGRAM_GROUP_ID', '')
    
    config['search']['strategy'] = os.getenv('PT_SEARCH_STRATEGY', 'all')
    config['search']['poll_interval'] = int(os.getenv('DOWNLOAD_POLL_INTERVAL', '10'))
    
    config['tmdb']['api_key'] = os.getenv('TMDB_API_KEY', '')
    
    config['request_limit']['max_daily'] = int(os.getenv('MAX_DAILY_REQUESTS', '3'))
    
    # ä»é…ç½®æ–‡ä»¶è¯»å–ï¼ˆä¼˜å…ˆçº§é«˜äºç¯å¢ƒå˜é‡ï¼‰
    if os.path.exists(SYSTEM_CONFIG_FILE):
        try:
            with open(SYSTEM_CONFIG_FILE, 'r', encoding='utf-8') as f:
                file_config = json.load(f)
                for section in config:
                    if section in file_config:
                        for key in config[section]:
                            if key in file_config[section]:
                                if isinstance(config[section][key], dict) and isinstance(file_config[section][key], dict):
                                    config[section][key].update(file_config[section][key])
                                elif file_config[section][key] not in ('', None):
                                    config[section][key] = file_config[section][key]
        except Exception as e:
            print(f"[WARNING] è¯»å–ç³»ç»Ÿé…ç½®æ–‡ä»¶å¤±è´¥: {e}")
    
    return config


def save_system_config(config):
    """ä¿å­˜ç³»ç»Ÿé…ç½® - åŒæ—¶ä¿å­˜åˆ°æ•°æ®åº“å’Œæ–‡ä»¶"""
    db_success = True
    file_success = True
    _save_failures = []
    
    # ä¿å­˜åˆ°æ•°æ®åº“
    try:
        if has_app_context():
            if 'admin' in config:
                if not set_db_config(CONFIG_KEY_ADMIN, config['admin'], 'ç®¡ç†å‘˜é…ç½®'):
                    _save_failures.append('admin')
            if 'emby' in config:
                if not set_db_config(CONFIG_KEY_EMBY, config['emby'], 'Emby æœåŠ¡å™¨é…ç½®'):
                    _save_failures.append('emby')
            if 'telegram' in config:
                if not set_db_config(CONFIG_KEY_TELEGRAM, config['telegram'], 'Telegram BOTé…ç½®'):
                    _save_failures.append('telegram')
            if 'search' in config:
                if not set_db_config(CONFIG_KEY_SEARCH, config['search'], 'æœç´¢ç­–ç•¥é…ç½®'):
                    _save_failures.append('search')
            if 'tmdb' in config:
                if not set_db_config(CONFIG_KEY_TMDB, config['tmdb'], 'TMDB API é…ç½®'):
                    _save_failures.append('tmdb')
            if 'request_limit' in config:
                if not set_db_config(CONFIG_KEY_REQUEST_LIMIT, config['request_limit'], 'æ±‚ç‰‡é™åˆ¶é…ç½®'):
                    _save_failures.append('request_limit')
            if 'category' in config:
                if not set_db_config(CONFIG_KEY_CATEGORY, config['category'], 'äºŒçº§åˆ†ç±»ç­–ç•¥'):
                    _save_failures.append('category')
            if 'checkin' in config:
                if not set_db_config(CONFIG_KEY_CHECKIN, config['checkin'], 'ç­¾åˆ°ç³»ç»Ÿé…ç½®'):
                    _save_failures.append('checkin')
            if 'subscription_expire' in config:
                if not set_db_config(CONFIG_KEY_SUBSCRIPTION_EXPIRE, config['subscription_expire'], 'è®¢é˜…è¿‡æœŸç®¡ç†é…ç½®'):
                    _save_failures.append('subscription_expire')
            if 'invite_reward' in config:
                if not set_db_config(CONFIG_KEY_INVITE_REWARD, config['invite_reward'], 'é‚€è¯·è¿”åˆ©é…ç½®'):
                    _save_failures.append('invite_reward')
            if 'email' in config:
                if not set_db_config(CONFIG_KEY_EMAIL, config['email'], 'é‚®ä»¶SMTPé…ç½®'):
                    _save_failures.append('email')
            if 'login_notify' in config:
                if not set_db_config(CONFIG_KEY_LOGIN_NOTIFY, config['login_notify'], 'ç™»å½•é€šçŸ¥é…ç½®'):
                    _save_failures.append('login_notify')
            if 'expire_remind' in config:
                if not set_db_config(CONFIG_KEY_EXPIRE_REMIND, config['expire_remind'], 'åˆ°æœŸæé†’é…ç½®'):
                    _save_failures.append('expire_remind')
            if 'ranking' in config:
                if not set_db_config(CONFIG_KEY_RANKING, config['ranking'], 'æ’­æ”¾æ’è¡Œé…ç½®'):
                    _save_failures.append('ranking')
            
            if _save_failures:
                db_success = False
                print(f"[WARNING] ä»¥ä¸‹é…ç½®ä¿å­˜åˆ°æ•°æ®åº“å¤±è´¥: {', '.join(_save_failures)}")
            else:
                print("[CONFIG] é…ç½®å·²ä¿å­˜åˆ°æ•°æ®åº“")
        else:
            print("[WARNING] æ— åº”ç”¨ä¸Šä¸‹æ–‡ï¼Œè·³è¿‡æ•°æ®åº“ä¿å­˜")
            db_success = False
    except Exception as e:
        print(f"[ERROR] ä¿å­˜é…ç½®åˆ°æ•°æ®åº“å¤±è´¥: {e}")
        import traceback
        traceback.print_exc()
        db_success = False
    
    # åŒæ—¶ä¿å­˜åˆ°æ–‡ä»¶ï¼ˆä½œä¸ºå¤‡ä»½ï¼‰
    try:
        os.makedirs(os.path.dirname(SYSTEM_CONFIG_FILE), exist_ok=True)
        with open(SYSTEM_CONFIG_FILE, 'w', encoding='utf-8') as f:
            json.dump(config, f, ensure_ascii=False, indent=2)
        print(f"[CONFIG] é…ç½®å·²ä¿å­˜åˆ°æ–‡ä»¶: {SYSTEM_CONFIG_FILE}")
        file_success = True
    except Exception as e:
        print(f"[WARNING] ä¿å­˜é…ç½®æ–‡ä»¶å¤±è´¥: {e}")
        file_success = False
    
    # åªè¦æ•°æ®åº“æˆ–æ–‡ä»¶æœ‰ä¸€ä¸ªæˆåŠŸå°±è¿”å› True
    return db_success or file_success

def get_system_config():
    """è·å–å½“å‰ç³»ç»Ÿé…ç½®"""
    return load_system_config()

def update_global_system_config():
    """æ›´æ–°å…¨å±€å˜é‡ä¸ºé…ç½®æ–‡ä»¶ä¸­çš„å€¼"""
    global EMBY_URL, EMBY_API_KEY, EMBY_WEBHOOK_SECRET
    global TELEGRAM_BOT_TOKEN, TELEGRAM_CHAT_ID, TELEGRAM_GROUP_ID
    global TELEGRAM_CONFIGURED_URL, _TELEGRAM_WEBHOOK_SECRET
    global PT_SEARCH_STRATEGY, DOWNLOAD_POLL_INTERVAL
    global TMDB_API_KEY, MAX_DAILY_REQUESTS
    global emby_client
    global _bot_username_cache, _bot_username_cache_time
    
    config = load_system_config()
    
    EMBY_URL = config['emby']['url'].rstrip('/') if config['emby']['url'] else ''
    EMBY_API_KEY = config['emby']['api_key']
    EMBY_WEBHOOK_SECRET = config['emby']['webhook_secret']
    
    _old_tg_token = globals().get('TELEGRAM_BOT_TOKEN', '')
    TELEGRAM_BOT_TOKEN = config['telegram']['bot_token']
    TELEGRAM_CHAT_ID = config['telegram']['chat_id']
    TELEGRAM_GROUP_ID = config['telegram']['group_id'] or config['telegram']['chat_id']
    
    # Bot Token å˜æ›´æ—¶æ¸…é™¤æœºå™¨äººç”¨æˆ·åç¼“å­˜ï¼Œå¼ºåˆ¶é‡æ–°è·å–
    if _old_tg_token and _old_tg_token != TELEGRAM_BOT_TOKEN:
        _bot_username_cache = None
        _bot_username_cache_time = 0
    
    # åŠ è½½ Telegram Webhook é…ç½®
    if 'configured_url' in config['telegram']:
        TELEGRAM_CONFIGURED_URL = config['telegram']['configured_url']
    # åŠ è½½ Webhook secret_token
    if 'webhook_secret_token' in config['telegram']:
        _TELEGRAM_WEBHOOK_SECRET = config['telegram']['webhook_secret_token']
    
    PT_SEARCH_STRATEGY = config['search']['strategy']
    DOWNLOAD_POLL_INTERVAL = int(config['search']['poll_interval']) if config['search']['poll_interval'] else 10
    
    TMDB_API_KEY = config['tmdb']['api_key']
    MAX_DAILY_REQUESTS = int(config['request_limit']['max_daily']) if config['request_limit']['max_daily'] else 3
    
    # æ›´æ–° emby_clientï¼ˆå¦‚æœå·²åˆå§‹åŒ–ï¼‰
    if 'emby_client' in globals() and emby_client is not None:
        emby_client.base_url = EMBY_URL
        emby_client.api_key = EMBY_API_KEY
        emby_client.session.headers.update({'X-Emby-Token': EMBY_API_KEY})
    
    print(f"[CONFIG] ç³»ç»Ÿé…ç½®å·²æ›´æ–°: EMBY={'å·²é…ç½®' if EMBY_URL else 'æœªé…ç½®'}, TG={'å·²é…ç½®' if TELEGRAM_BOT_TOKEN else 'æœªé…ç½®'}, TMDB={'å·²é…ç½®' if TMDB_API_KEY else 'æœªé…ç½®'}")

# åˆå§‹åŒ–åŠ è½½ç³»ç»Ÿé…ç½®
update_global_system_config()


# ==================== MoviePilot å®¢æˆ·ç«¯ ====================
class MoviePilotClient:
    """MoviePilot API å®¢æˆ·ç«¯ - é€šè¿‡ MoviePilot æœç´¢å’Œä¸‹è½½ç§å­"""
    
    def __init__(self, base_url: str, username: str = '', password: str = '', token: str = '', priority: int = 10):
        self.name = 'MoviePilot'
        self.priority = priority
        self.base_url = base_url.rstrip('/')
        self.username = username
        self.password = password
        self.access_token = token
        self.token_expires = 0
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Emby-Request-System/1.0',
            'Content-Type': 'application/json',
            'Accept': 'application/json',
        })
        if PROXY_URL:
            self.session.proxies = http_session.proxies
    
    def is_enabled(self) -> bool:
        return bool(self.base_url and (self.access_token or (self.username and self.password)))
    
    def _format_size(self, size_bytes: int) -> str:
        """æ ¼å¼åŒ–æ–‡ä»¶å¤§å°"""
        if not size_bytes:
            return 'æœªçŸ¥'
        for unit in ['B', 'KB', 'MB', 'GB', 'TB']:
            if size_bytes < 1024:
                return f"{size_bytes:.2f} {unit}"
            size_bytes /= 1024
        return f"{size_bytes:.2f} PB"
    
    def _add_source_to_results(self, results: list) -> list:
        """ç¡®ä¿æ¯ä¸ªç»“æœéƒ½æœ‰ source å­—æ®µ"""
        for item in results:
            if 'source' not in item or not item['source']:
                item['source'] = self.name
        return results
    
    def _login(self) -> bool:
        """ç™»å½• MoviePilot è·å– access token"""
        if not self.username or not self.password:
            return False
        
        try:
            url = f"{self.base_url}/api/v1/login/access-token"
            # ç™»å½•æ¥å£éœ€è¦è¡¨å•æ ¼å¼ï¼Œä¸èƒ½ç”¨ JSON
            data = {
                'username': self.username,
                'password': self.password,
            }
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
            }
            response = self.session.post(url, data=data, headers=headers, timeout=10)
            if response.status_code == 200:
                result = response.json()
                self.access_token = result.get('access_token', '')
                if self.access_token:
                    # Token æœ‰æ•ˆæœŸçº¦30åˆ†é’Ÿï¼Œæå‰5åˆ†é’Ÿåˆ·æ–°
                    self.token_expires = time.time() + 25 * 60
                    app.logger.info(f"[{self.name}] ç™»å½•æˆåŠŸï¼Œè·å–åˆ° access token")
                    return True
            app.logger.error(f"[{self.name}] ç™»å½•å¤±è´¥: {response.status_code}")
            return False
        except Exception as e:
            app.logger.error(f"[{self.name}] ç™»å½•å¼‚å¸¸: {e}")
            return False
    
    def _ensure_token(self) -> bool:
        """ç¡®ä¿æœ‰æœ‰æ•ˆçš„ access token"""
        # å¦‚æœå·²æœ‰ token ä¸”æœªè¿‡æœŸï¼Œç›´æ¥ä½¿ç”¨
        if self.access_token and (self.token_expires == 0 or time.time() < self.token_expires):
            return True
        # å°è¯•ç™»å½•è·å–æ–° token
        return self._login()
    
    def search(self, keyword: str, media_type: str = 'movie') -> list:
        if not keyword or not self.is_enabled():
            return []
        
        # ç¡®ä¿æœ‰æœ‰æ•ˆçš„ token
        if not self._ensure_token():
            app.logger.error(f"[{self.name}] æ— æ³•è·å–æœ‰æ•ˆçš„ access token")
            return []
        
        results = []
        app.logger.info(f"[{self.name}] æœç´¢: keyword={keyword}, media_type={media_type}")
        
        try:
            # MoviePilot æœç´¢ API
            url = f"{self.base_url}/api/v1/search/title"
            params = {
                'keyword': keyword,
                'page': 0,
            }
            headers = {
                'Authorization': f'Bearer {self.access_token}',
            }
            
            response = self.session.get(url, params=params, headers=headers, timeout=60)
            app.logger.info(f"[{self.name}] å“åº”çŠ¶æ€: {response.status_code}")
            
            if response.status_code == 401 or response.status_code == 403:
                # Token å¯èƒ½è¿‡æœŸï¼Œå°è¯•é‡æ–°ç™»å½•
                app.logger.warning(f"[{self.name}] Token å¯èƒ½è¿‡æœŸï¼Œå°è¯•é‡æ–°ç™»å½•")
                self.access_token = ''
                if self._login():
                    headers['Authorization'] = f'Bearer {self.access_token}'
                    response = self.session.get(url, params=params, headers=headers, timeout=60)
                    app.logger.info(f"[{self.name}] é‡è¯•å“åº”çŠ¶æ€: {response.status_code}")
                else:
                    app.logger.error(f"[{self.name}] é‡æ–°ç™»å½•å¤±è´¥")
                    return []
            
            response.raise_for_status()
            
            # è§£æ JSON å“åº”
            try:
                data = response.json()
            except ValueError as json_error:
                app.logger.error(f"[{self.name}] JSON è§£æå¤±è´¥: {json_error}, å“åº”å†…å®¹: {response.text[:200]}")
                return []
            
            # MoviePilot è¿”å›æ ¼å¼: {"success": true, "data": [...]}
            if isinstance(data, dict):
                if not data.get('success', True):
                    error_msg = data.get('message', 'æœªçŸ¥é”™è¯¯')
                    app.logger.warning(f"[{self.name}] æœç´¢å¤±è´¥: {error_msg}")
                    return []
                torrents = data.get('data', [])
            else:
                torrents = data
            
            app.logger.info(f"[{self.name}] APIè¿”å›: {len(torrents) if torrents else 0} æ¡ç§å­")
            
            if not torrents:
                return []
            
            for item in torrents:
                # MoviePilot è¿”å›çš„æ•°æ®ç»“æ„: {"torrent_info": {...}, "meta_info": {...}}
                torrent_info = item.get('torrent_info', {}) if isinstance(item, dict) else {}
                meta_info = item.get('meta_info', {}) if isinstance(item, dict) else {}
                
                # å¦‚æœæ²¡æœ‰åµŒå¥—ç»“æ„ï¼Œç›´æ¥ä½¿ç”¨ item
                if not torrent_info and isinstance(item, dict):
                    torrent_info = item
                
                # è·å–ç§å­ä¿¡æ¯
                torrent_id = torrent_info.get('id') or torrent_info.get('torrent_id') or ''
                title = torrent_info.get('title') or meta_info.get('title') or torrent_info.get('name') or ''
                description = torrent_info.get('description') or ''
                size = torrent_info.get('size', 0)
                seeders = torrent_info.get('seeders') or torrent_info.get('seeder', 0)
                leechers = torrent_info.get('peers') or torrent_info.get('leechers') or 0
                site_name = torrent_info.get('site_name') or torrent_info.get('site') or 'MoviePilot'
                download_url = torrent_info.get('enclosure') or torrent_info.get('download_url') or ''
                page_url = torrent_info.get('page_url') or ''
                
                # ä¿ƒé”€çŠ¶æ€
                promotion = ''
                upload_ratio = torrent_info.get('uploadvolumefactor', 1)
                download_ratio = torrent_info.get('downloadvolumefactor', 1)
                if download_ratio == 0:
                    promotion = 'free'
                elif download_ratio == 0.5:
                    promotion = 'half'
                if upload_ratio == 2:
                    promotion = 'double' if not promotion else promotion
                
                # ç»„åˆæ ‡é¢˜å’Œæè¿°
                display_title = title
                if description and description != title:
                    display_title = f"{title} | {description}"
                
                results.append({
                    'id': str(torrent_id) if torrent_id else page_url,
                    'title': display_title,
                    'download_url': download_url,
                    'page_url': page_url,
                    'size': size,
                    'size_text': self._format_size(size) if size else 'æœªçŸ¥',
                    'seeders': seeders,
                    'leechers': leechers,
                    'promotion': promotion,
                    'category': torrent_info.get('category', ''),
                    'created_at': torrent_info.get('pubdate', ''),
                    'source': site_name,
                })
            
            app.logger.info(f"[{self.name}] æœç´¢ç»“æœ: {len(results)} æ¡")
            
        except requests.exceptions.Timeout:
            app.logger.error(f"[{self.name}] è¯·æ±‚è¶…æ—¶")
        except requests.exceptions.RequestException as e:
            app.logger.error(f"[{self.name}] è¯·æ±‚å¤±è´¥: {e}")
        except Exception as e:
            app.logger.error(f"[{self.name}] æœç´¢å¼‚å¸¸: {e}")
        
        return self._add_source_to_results(results)
    
    def build_download_url(self, torrent_id: Optional[Union[str, int]]) -> Optional[str]:
        # MoviePilot è¿”å›çš„ download_url å·²ç»æ˜¯å®Œæ•´é“¾æ¥
        return None
    
    def download_torrent(self, download_url: str, title: str = '', description: str = '') -> Optional[dict]:
        """é€šè¿‡ MoviePilot ä¸‹è½½ç§å­åˆ°é…ç½®çš„ä¸‹è½½å™¨
        
        Args:
            download_url: ç§å­ä¸‹è½½é“¾æ¥ï¼ˆenclosureï¼‰ï¼Œå¯èƒ½æ˜¯ base64 ç¼–ç çš„ JSON
            title: ç§å­æ ‡é¢˜ï¼Œç”¨äº MoviePilot è¯†åˆ«åª’ä½“ä¿¡æ¯
            description: ç§å­å‰¯æ ‡é¢˜/æè¿°
        """
        if not download_url or not self.is_enabled():
            return None
        
        # ç¡®ä¿æœ‰æœ‰æ•ˆçš„ token
        if not self._ensure_token():
            app.logger.error(f"[{self.name}] ä¸‹è½½å¤±è´¥: æ— æ³•è·å–æœ‰æ•ˆçš„ access token")
            return None
        
        try:
            import base64
            headers = {
                'Authorization': f'Bearer {self.access_token}',
                'Content-Type': 'application/json',
            }
            
            clean_url = download_url.strip()
            app.logger.debug(f"[{self.name}] åŸå§‹ä¸‹è½½é“¾æ¥: {clean_url[:100]}...")
            
            url = f"{self.base_url}/api/v1/download/add"
            
            # MoviePilot çš„ /api/v1/download/add éœ€è¦ TorrentInfo å¯¹è±¡
            # TorrentInfo åŒ…å«: title, description, enclosure ç­‰å­—æ®µ
            # enclosure å°±æ˜¯ç§å­ä¸‹è½½é“¾æ¥ï¼ˆå¯ä»¥æ˜¯ base64 ç¼–ç çš„ JSON è¯·æ±‚ä¿¡æ¯ï¼‰
            torrent_info = {
                'title': title or 'æœªçŸ¥æ ‡é¢˜',
                'description': description or '',
                'enclosure': clean_url,  # ä¿æŒåŸå§‹æ ¼å¼ï¼ŒMoviePilot ä¼šè‡ªè¡Œè§£æ
            }
            
            payload = {'torrent_in': torrent_info}
            app.logger.info(f"[{self.name}] è°ƒç”¨ä¸‹è½½ API: {url}")
            app.logger.info(f"[{self.name}] torrent_in: title={title[:50] if title else 'æœªçŸ¥'}..., enclosure={clean_url[:50]}...")
            
            response = self.session.post(url, json=payload, headers=headers, timeout=30)
            
            if response.status_code == 200:
                result = response.json()
                # æ£€æŸ¥ API è¿”å›çš„ success å­—æ®µ
                if result.get('success') == True:
                    app.logger.info(f"[{self.name}] ä¸‹è½½æˆåŠŸ: {result}")
                    return {'success': True, 'data': result}
                else:
                    error_msg = result.get('message', 'æœªçŸ¥é”™è¯¯')
                    app.logger.error(f"[{self.name}] API è¿”å›å¤±è´¥: {error_msg}, å®Œæ•´å“åº”: {result}")
                    return {'success': False, 'error': error_msg, 'data': result}
            else:
                app.logger.error(f"[{self.name}] ä¸‹è½½å¤±è´¥: {response.status_code} - {response.text}")
                return None
        except Exception as e:
            app.logger.error(f"[{self.name}] ä¸‹è½½å¼‚å¸¸: {e}", exc_info=True)
            return None


# ==================== PT ç«™ç®¡ç†å™¨ ====================
class PTManager:
    """PT ç«™ç‚¹ç»Ÿä¸€ç®¡ç†å™¨ï¼ˆç›®å‰ä»…ä½¿ç”¨ MoviePilotï¼‰"""
    
    def __init__(self):
        self.clients: list[MoviePilotClient] = []
    
    def register(self, client: MoviePilotClient):
        """æ³¨å†Œä¸€ä¸ª PT ç«™å®¢æˆ·ç«¯"""
        if client.is_enabled():
            self.clients.append(client)
            app.logger.info(f"PTç«™ç‚¹å·²æ³¨å†Œ: {client.name} (ä¼˜å…ˆçº§: {client.priority})")
    
    def is_enabled(self) -> bool:
        """æ˜¯å¦æœ‰ä»»ä½• PT ç«™å¯ç”¨"""
        return any(c.is_enabled() for c in self.clients)
    
    def get_enabled_clients(self) -> list[MoviePilotClient]:
        """è·å–æ‰€æœ‰å·²å¯ç”¨çš„å®¢æˆ·ç«¯"""
        return [c for c in self.clients if c.is_enabled()]
    
    def search(self, keyword: str, media_type: str = 'movie') -> list:
        """
        æœç´¢ç§å­èµ„æº
        :param keyword: æœç´¢å…³é”®è¯
        :param media_type: 'movie' æˆ– 'tv'
        :return: æœç´¢ç»“æœåˆ—è¡¨
        """
        if not self.clients:
            app.logger.warning("æ²¡æœ‰å¯ç”¨çš„ PT ç«™ç‚¹")
            return []
        
        # ç›®å‰åªæœ‰ä¸€ä¸ªå®¢æˆ·ç«¯ï¼Œç›´æ¥ä½¿ç”¨
        client = self.clients[0]
        try:
            results = client.search(keyword, media_type)
            app.logger.info(f"[{client.name}] è¿”å› {len(results) if results else 0} æ¡ç»“æœ")
            return results or []
        except Exception as exc:
            app.logger.error(f"[{client.name}] æœç´¢å¼‚å¸¸: {exc}")
            return []
    
    def get_client(self, source: str = None) -> Optional[MoviePilotClient]:
        """è·å–å®¢æˆ·ç«¯ï¼ˆç›®å‰ä»…æœ‰ä¸€ä¸ªï¼‰"""
        if self.clients:
            return self.clients[0]
        return None


class QbitClient:
    """qBittorrent Web API å®¢æˆ·ç«¯"""
    
    # å¯é‡è¯•çš„å¼‚å¸¸ç±»å‹
    RETRYABLE_EXCEPTIONS = (
        requests.exceptions.ConnectionError,
        requests.exceptions.Timeout,
        requests.exceptions.ChunkedEncodingError,
    )

    def __init__(self, base_url: str, username: str, password: str):
        self.base_url = base_url
        self.username = username
        self.password = password
        self.session = requests.Session()
        self.authenticated = False
        self.last_login_at = 0
        self.login_lock = Lock()
        self.max_retries = 3  # æœ€å¤§é‡è¯•æ¬¡æ•°
        self.retry_delay = 1  # é‡è¯•é—´éš”ï¼ˆç§’ï¼‰
        if PROXY_URL:
            self.session.proxies = http_session.proxies

    def _with_retry(self, func, *args, **kwargs):
        """å¸¦é‡è¯•çš„è¯·æ±‚æ‰§è¡Œå™¨"""
        last_error = None
        for attempt in range(self.max_retries):
            try:
                return func(*args, **kwargs)
            except self.RETRYABLE_EXCEPTIONS as e:
                last_error = e
                if attempt < self.max_retries - 1:
                    # è¿æ¥æ–­å¼€æ—¶ï¼Œé‡ç½®è®¤è¯çŠ¶æ€ï¼Œå¼ºåˆ¶é‡æ–°ç™»å½•
                    self.authenticated = False
                    wait_time = self.retry_delay * (attempt + 1)  # é€’å¢ç­‰å¾…æ—¶é—´
                    app.logger.warning(f'[qBittorrent] è¿æ¥é”™è¯¯ ({attempt + 1}/{self.max_retries}): {e}, {wait_time}ç§’åé‡è¯•')
                    time.sleep(wait_time)
                    # é‡æ–°ç™»å½•
                    try:
                        self.ensure_login()
                    except Exception as login_error:
                        app.logger.warning(f'[qBittorrent] é‡æ–°ç™»å½•å¤±è´¥: {login_error}')
        # æ‰€æœ‰é‡è¯•éƒ½å¤±è´¥
        raise last_error

    def is_enabled(self) -> bool:
        return bool(self.base_url and self.username and self.password)

    def ensure_login(self):
        if not self.is_enabled():
            raise RuntimeError('qBittorrent æœªé…ç½®')
        if self.authenticated and (time.time() - self.last_login_at) < 900:
            return
        with self.login_lock:
            if self.authenticated and (time.time() - self.last_login_at) < 900:
                return
            self._login()

    def _login(self):
        url = f"{self.base_url}/api/v2/auth/login"
        response = self.session.post(url, data={'username': self.username, 'password': self.password}, timeout=10)
        response.raise_for_status()
        if response.text.strip() != 'Ok.':
            raise RuntimeError('qBittorrent ç™»å½•å¤±è´¥')
        self.authenticated = True
        self.last_login_at = time.time()

    def add_torrent(self, download_url: str, *, save_path: Optional[str] = None, category: Optional[str] = None,
                    tags: Optional[list[str]] = None) -> dict:
        def _do_add():
            self.ensure_login()
            url = f"{self.base_url}/api/v2/torrents/add"
            data = {'urls': download_url}
            if category:
                data['category'] = category
            if tags:
                data['tags'] = ','.join(tags)
            if save_path:
                data['savepath'] = save_path
            
            app.logger.info(f'[qBittorrent] æ·»åŠ ç§å­: category={category}, tags={tags}')
            app.logger.debug(f'[qBittorrent] ä¸‹è½½é“¾æ¥: {download_url[:100]}...')
            
            response = self.session.post(url, data=data, timeout=30)
            response.raise_for_status()
            
            # æ£€æŸ¥å“åº”å†…å®¹ï¼ŒqBittorrent è¿”å› "Ok." è¡¨ç¤ºæˆåŠŸï¼Œ"Fails." è¡¨ç¤ºå¤±è´¥
            response_text = response.text.strip()
            if response_text == 'Fails.':
                app.logger.error(f'[qBittorrent] æ·»åŠ ç§å­å¤±è´¥: å“åº”={response_text}')
                raise RuntimeError('qBittorrent æ‹’ç»æ·»åŠ ç§å­ï¼ˆå¯èƒ½æ˜¯é“¾æ¥æ— æ•ˆæˆ–ç§å­å·²å­˜åœ¨ï¼‰')
            
            app.logger.info(f'[qBittorrent] æ·»åŠ ç§å­æˆåŠŸ: å“åº”={response_text}')
            return {'success': True}
        
        return self._with_retry(_do_add)

    def get_torrents_info(self, *, hashes: Optional[list[str]] = None, tags: Optional[str] = None) -> list:
        def _do_get():
            self.ensure_login()
            params = {}
            if hashes:
                params['hashes'] = '|'.join(hashes)
            if tags:
                params['tag'] = tags  # qBittorrent API ä½¿ç”¨ 'tag' å‚æ•°ï¼ˆå•æ•°ï¼‰
            url = f"{self.base_url}/api/v2/torrents/info"
            response = self.session.get(url, params=params, timeout=15)
            response.raise_for_status()
            return response.json()
        
        return self._with_retry(_do_get)

    def get_torrent_by_tag(self, tag: str):
        """è·å–æŒ‡å®š tag çš„ç§å­ï¼Œè¿”å›æœ€æ–°æ·»åŠ çš„ä¸€ä¸ª"""
        results = self.get_torrents_info(tags=tag)
        app.logger.debug(f'[qBittorrent] æŒ‰ tag={tag} æŸ¥è¯¢ï¼Œè¿”å› {len(results) if results else 0} ä¸ªç§å­')
        if not results:
            # å°è¯•è·å–æ‰€æœ‰ç§å­æ¥æ’æŸ¥é—®é¢˜
            all_torrents = self.get_torrents_info()
            if all_torrents:
                app.logger.debug(f'[qBittorrent] å½“å‰å…±æœ‰ {len(all_torrents)} ä¸ªç§å­')
                # æ£€æŸ¥æ˜¯å¦æœ‰æœ€è¿‘æ·»åŠ çš„ç§å­
                recent = [t for t in all_torrents if t.get('tags', '')]
                if recent:
                    app.logger.debug(f'[qBittorrent] æœ‰ tag çš„ç§å­: {[(t.get("name", "")[:30], t.get("tags", "")) for t in recent[:5]]}')
            return None
        # ç²¾ç¡®åŒ¹é… tagï¼Œå¹¶æŒ‰æ·»åŠ æ—¶é—´æ’åºå–æœ€æ–°çš„
        matching = [t for t in results if tag in (t.get('tags') or '').split(', ')]
        if not matching:
            return results[0]  # å›é€€åˆ°ç¬¬ä¸€ä¸ª
        # æŒ‰ added_on æ—¶é—´æˆ³é™åºæ’åºï¼Œå–æœ€æ–°çš„
        matching.sort(key=lambda x: x.get('added_on', 0), reverse=True)
        return matching[0]


class EmbyClient:
    """Emby åª’ä½“åº“å®¢æˆ·ç«¯"""

    def __init__(self, base_url: str, api_key: str):
        self.base_url = base_url
        self.api_key = api_key
        self.session = requests.Session()
        self.session.headers.update({
            'X-Emby-Token': api_key,
            'Accept': 'application/json',
        })
        # åª’ä½“åº“ç»Ÿè®¡ç¼“å­˜ï¼ˆ5åˆ†é’Ÿï¼‰
        self._library_counts_cache = None
        self._library_counts_cache_time = 0
        # TMDB ID æŸ¥è¯¢ç¼“å­˜ï¼ˆ10åˆ†é’Ÿï¼‰
        self._tmdb_cache = {}
        self._tmdb_cache_ttl = 600  # 10åˆ†é’Ÿ

    def is_enabled(self) -> bool:
        return bool(self.base_url and self.api_key)

    @staticmethod
    def _clean_policy_readonly_fields(policy: dict):
        """ç§»é™¤ Emby Policy ä¸­çš„åªè¯»å­—æ®µï¼Œé¿å… POST å›å»æ—¶è¿”å› 400 Bad Request
        
        ä¸åŒç‰ˆæœ¬çš„ Emby å¯¹ Policy å­—æ®µçš„å¤„ç†ä¸ä¸€è‡´ï¼š
        - æŸäº›ç‰ˆæœ¬æ¥å—å®Œæ•´çš„ Policy å¯¹è±¡ç›´æ¥å›ä¼ 
        - æŸäº›ç‰ˆæœ¬ä¼šå› ä¸ºåŒ…å«åªè¯»å­—æ®µè€Œè¿”å› 400
        ç§»é™¤è¿™äº›å­—æ®µæ˜¯æœ€å®‰å…¨çš„åšæ³•ï¼Œä¸å½±å“åŠŸèƒ½ã€‚
        """
        readonly_fields = [
            'AuthenticationProviderId',
            'PasswordResetProviderId', 
            'InvalidLoginAttemptCount',
            'LoginAttemptsBeforeLockout',
            'RemoteClientBitrateLimit',
            'AuthenticatedFolders',
        ]
        for field in readonly_fields:
            policy.pop(field, None)

    def search_by_tmdb_id(self, tmdb_id: str, media_type: str = 'movie', timeout: int = 3) -> Optional[dict]:
        """é€šè¿‡ TMDB ID æŸ¥è¯¢ Emby åº“ä¸­æ˜¯å¦å­˜åœ¨ï¼ˆå¸¦ç¼“å­˜ï¼Œå¿«é€Ÿè¶…æ—¶ï¼‰"""
        if not self.is_enabled():
            return None
        
        # æ£€æŸ¥ç¼“å­˜
        cache_key = f"{tmdb_id}_{media_type}"
        if cache_key in self._tmdb_cache:
            cached_time, cached_result = self._tmdb_cache[cache_key]
            if time.time() - cached_time < self._tmdb_cache_ttl:
                return cached_result
        
        try:
            # Emby ä½¿ç”¨ AnyProviderIdEquals æŸ¥è¯¢
            url = f"{self.base_url}/Items"
            params = {
                'api_key': self.api_key,
                'AnyProviderIdEquals': f'Tmdb.{tmdb_id}',
                'Recursive': 'true',
                'IncludeItemTypes': 'Movie' if media_type == 'movie' else 'Series',
                'Fields': 'ProviderIds,Path,Overview',
            }
            response = self.session.get(url, params=params, timeout=timeout)
            response.raise_for_status()
            data = response.json()
            items = data.get('Items', [])
            result = items[0] if items else None
            
            # å­˜å…¥ç¼“å­˜
            self._tmdb_cache[cache_key] = (time.time(), result)
            
            return result
        except requests.exceptions.Timeout:
            app.logger.warning(f'Emby æŸ¥è¯¢è¶…æ—¶: TMDB {tmdb_id}')
            return None
        except Exception as e:
            app.logger.error(f'Emby æŸ¥è¯¢å¤±è´¥: {e}')
            return None

    def search_by_name(self, name: str, year: Optional[str] = None, media_type: str = 'movie') -> Optional[dict]:
        """é€šè¿‡åç§°æŸ¥è¯¢ Emby åº“ä¸­æ˜¯å¦å­˜åœ¨"""
        if not self.is_enabled():
            return None
        try:
            url = f"{self.base_url}/Items"
            params = {
                'api_key': self.api_key,
                'SearchTerm': name,
                'Recursive': 'true',
                'IncludeItemTypes': 'Movie' if media_type == 'movie' else 'Series',
                'Fields': 'ProviderIds,Path,Overview,ProductionYear',
            }
            if year:
                params['Years'] = year
            response = self.session.get(url, params=params, timeout=10)
            response.raise_for_status()
            data = response.json()
            items = data.get('Items', [])
            # æ¨¡ç³ŠåŒ¹é…åç§°
            for item in items:
                item_name = item.get('Name', '').lower()
                if name.lower() in item_name or item_name in name.lower():
                    return item
            return None
        except Exception as e:
            app.logger.error(f'Emby åç§°æŸ¥è¯¢å¤±è´¥: {e}')
            return None

    def get_tv_seasons(self, series_id: str) -> list:
        """è·å–å‰§é›†çš„å­£åˆ—è¡¨"""
        if not self.is_enabled():
            return []
        try:
            url = f"{self.base_url}/Shows/{series_id}/Seasons"
            params = {
                'api_key': self.api_key,
                'Fields': 'IndexNumber'
            }
            response = self.session.get(url, params=params, timeout=5)
            response.raise_for_status()
            data = response.json()
            return data.get('Items', [])
        except Exception as e:
            app.logger.error(f'è·å–å‰§é›†å­£åˆ—è¡¨å¤±è´¥: {e}')
            return []
    
    def get_library_counts(self) -> dict:
        """è·å–åª’ä½“åº“çš„ç”µå½±å’Œå‰§é›†æ•°é‡ï¼ˆå¸¦5åˆ†é’Ÿç¼“å­˜ï¼‰
        
        è¿”å›:
            movies: ç”µå½±éƒ¨æ•°
            series: å‰§é›†éƒ¨æ•°ï¼ˆå‡ éƒ¨å‰§ï¼‰
            episodes: å‰§é›†æ€»é›†æ•°ï¼ˆæ‰€æœ‰å‰§çš„æ‰€æœ‰é›†ï¼‰
            total: ç”µå½±éƒ¨æ•° + å‰§é›†æ€»é›†æ•°
        """
        if not self.is_enabled():
            return {'movies': 0, 'series': 0, 'episodes': 0, 'total': 0}
        
        # æ£€æŸ¥ç¼“å­˜ï¼ˆ5åˆ†é’Ÿå†…æœ‰æ•ˆï¼‰
        import time
        current_time = time.time()
        if self._library_counts_cache and (current_time - self._library_counts_cache_time) < 300:
            return self._library_counts_cache
        
        try:
            url = f"{self.base_url}/Items/Counts"
            params = {'api_key': self.api_key}
            response = self.session.get(url, params=params, timeout=5)
            response.raise_for_status()
            data = response.json()
            
            movies = data.get('MovieCount', 0)
            series = data.get('SeriesCount', 0)  # å‰§é›†éƒ¨æ•°
            episodes = data.get('EpisodeCount', 0)  # å‰§é›†æ€»é›†æ•°
            
            result = {
                'movies': movies,
                'series': series,
                'episodes': episodes,
                'total': movies + episodes  # æ€»è®¡ = ç”µå½±éƒ¨æ•° + å‰§é›†æ€»é›†æ•°
            }
            
            # æ›´æ–°ç¼“å­˜
            self._library_counts_cache = result
            self._library_counts_cache_time = current_time
            
            return result
        except Exception as e:
            app.logger.error(f'è·å–Embyåª’ä½“åº“æ•°é‡å¤±è´¥: {e}')
            # å¦‚æœæœ‰æ—§ç¼“å­˜ï¼Œè¿”å›æ—§ç¼“å­˜
            if self._library_counts_cache:
                return self._library_counts_cache
            return {'movies': 0, 'series': 0, 'episodes': 0, 'total': 0}
    
    def check_exists(self, tmdb_id: Optional[str], name: str, year: Optional[str] = None, media_type: str = 'movie') -> dict:
        """æ£€æŸ¥åª’ä½“æ˜¯å¦å­˜åœ¨äº Emby åº“ä¸­"""
        result = {'exists': False, 'item': None}
        
        if not self.is_enabled():
            return result
        
        # ä¼˜å…ˆé€šè¿‡ TMDB ID æŸ¥è¯¢
        if tmdb_id:
            item = self.search_by_tmdb_id(tmdb_id, media_type)
            if item:
                result['exists'] = True
                result['item'] = item
                return result
        
        # å¤‡é€‰ï¼šé€šè¿‡åç§°æŸ¥è¯¢
        if name:
            item = self.search_by_name(name, year, media_type)
            if item:
                result['exists'] = True
                result['item'] = item
                return result
        
        return result

    def get_sessions(self, active_within_seconds: int = 960) -> list:
        """è·å–æ‰€æœ‰æ´»è·ƒçš„æ’­æ”¾ä¼šè¯
        
        Args:
            active_within_seconds: åœ¨å¤šå°‘ç§’å†…æ´»è·ƒçš„ä¼šè¯ï¼ˆé»˜è®¤ 960 ç§’ = 16 åˆ†é’Ÿï¼‰
            
        Returns:
            list: ä¼šè¯åˆ—è¡¨ï¼Œæ¯ä¸ªä¼šè¯åŒ…å«è®¾å¤‡ä¿¡æ¯ã€æ­£åœ¨æ’­æ”¾çš„å†…å®¹ç­‰
        """
        if not self.is_enabled():
            return []
        
        try:
            url = f"{self.base_url}/Sessions"
            params = {
                'api_key': self.api_key,
                'ActiveWithinSeconds': active_within_seconds
            }
            response = self.session.get(url, params=params, timeout=10)
            response.raise_for_status()
            sessions = response.json()
            
            # æ ¼å¼åŒ–ä¼šè¯æ•°æ®
            formatted_sessions = []
            for session in sessions:
                formatted = {
                    'id': session.get('Id'),
                    'user_id': session.get('UserId'),
                    'user_name': session.get('UserName', 'æœªçŸ¥ç”¨æˆ·'),
                    'device_id': session.get('DeviceId'),
                    'device_name': session.get('DeviceName', 'æœªçŸ¥è®¾å¤‡'),
                    'client': session.get('Client', 'æœªçŸ¥å®¢æˆ·ç«¯'),
                    'app_version': session.get('ApplicationVersion', ''),
                    'last_activity_date': session.get('LastActivityDate'),
                    'is_playing': False,
                    'now_playing': None,
                    'play_state': None,
                    'remote_end_point': session.get('RemoteEndPoint', ''),
                }
                
                # æ£€æŸ¥æ˜¯å¦æ­£åœ¨æ’­æ”¾
                if session.get('NowPlayingItem'):
                    formatted['is_playing'] = True
                    now_playing = session['NowPlayingItem']
                    formatted['now_playing'] = {
                        'id': now_playing.get('Id'),
                        'name': now_playing.get('Name', 'æœªçŸ¥å†…å®¹'),
                        'type': now_playing.get('Type', ''),
                        'series_name': now_playing.get('SeriesName', ''),
                        'season_name': now_playing.get('SeasonName', ''),
                        'season_number': now_playing.get('ParentIndexNumber'),
                        'episode_number': now_playing.get('IndexNumber'),
                        'episode_title': now_playing.get('Name', ''),
                        'run_time_ticks': now_playing.get('RunTimeTicks', 0),
                        'primary_image_tag': now_playing.get('ImageTags', {}).get('Primary', ''),
                        'thumb_image_tag': now_playing.get('ImageTags', {}).get('Thumb', ''),
                    }
                    
                    # å¦‚æœæ˜¯å‰§é›†ï¼Œç»„åˆæ˜¾ç¤ºåç§°
                    if now_playing.get('Type') == 'Episode':
                        series = now_playing.get('SeriesName', '')
                        season = now_playing.get('ParentIndexNumber', '')
                        episode = now_playing.get('IndexNumber', '')
                        ep_name = now_playing.get('Name', '')
                        formatted['now_playing']['display_name'] = f"{series} S{season:02d}E{episode:02d} - {ep_name}" if series else ep_name
                    else:
                        formatted['now_playing']['display_name'] = now_playing.get('Name', 'æœªçŸ¥å†…å®¹')
                
                # æ’­æ”¾çŠ¶æ€
                if session.get('PlayState'):
                    play_state = session['PlayState']
                    formatted['play_state'] = {
                        'is_paused': play_state.get('IsPaused', False),
                        'is_muted': play_state.get('IsMuted', False),
                        'position_ticks': play_state.get('PositionTicks', 0),
                        'volume_level': play_state.get('VolumeLevel', 100),
                        'audio_stream_index': play_state.get('AudioStreamIndex'),
                        'subtitle_stream_index': play_state.get('SubtitleStreamIndex'),
                        'media_source_id': play_state.get('MediaSourceId'),
                        'play_method': play_state.get('PlayMethod', ''),
                    }
                
                formatted_sessions.append(formatted)
            
            return formatted_sessions
        except requests.exceptions.Timeout:
            app.logger.warning('è·å– Emby ä¼šè¯è¶…æ—¶')
            return []
        except Exception as e:
            app.logger.error(f'è·å– Emby ä¼šè¯å¤±è´¥: {e}')
            return []

    def get_user_sessions(self, emby_user_id: str) -> list:
        """è·å–æŒ‡å®šç”¨æˆ·çš„æ’­æ”¾ä¼šè¯
        
        Args:
            emby_user_id: Emby ç”¨æˆ· ID
            
        Returns:
            list: è¯¥ç”¨æˆ·çš„ä¼šè¯åˆ—è¡¨
        """
        all_sessions = self.get_sessions()
        return [s for s in all_sessions if s.get('user_id') == emby_user_id]

    def get_user_playing_count(self, emby_user_id: str) -> tuple:
        """ç›´æ¥ä» Emby API è·å–æŒ‡å®šç”¨æˆ·æ­£åœ¨æ’­æ”¾çš„ä¼šè¯æ•°å’Œä¼šè¯åˆ—è¡¨
        
        ä¸ä¾èµ– formatted sessionsï¼Œç›´æ¥æŸ¥åŸå§‹ /Sessions APIï¼Œç¡®ä¿å®æ—¶å‡†ç¡®ã€‚
        
        Args:
            emby_user_id: Emby ç”¨æˆ· ID
            
        Returns:
            tuple: (æ­£åœ¨æ’­æ”¾çš„ä¼šè¯æ•°, æ­£åœ¨æ’­æ”¾çš„ä¼šè¯åˆ—è¡¨[{session_id, device_name, client, item_name}])
        """
        if not self.is_enabled() or not emby_user_id:
            return 0, []
        
        try:
            url = f"{self.base_url}/Sessions"
            params = {'api_key': self.api_key}
            response = self.session.get(url, params=params, timeout=10)
            
            if response.status_code != 200:
                app.logger.warning(f'æŸ¥è¯¢ç”¨æˆ·æ’­æ”¾ä¼šè¯å¤±è´¥: status={response.status_code}')
                return 0, []
            
            sessions = response.json()
            playing_sessions = []
            
            for s in sessions:
                # åŒ¹é…ç”¨æˆ· ID ä¸”æ­£åœ¨æ’­æ”¾
                if s.get('UserId') == emby_user_id and s.get('NowPlayingItem'):
                    playing_sessions.append({
                        'session_id': s.get('Id'),
                        'device_name': s.get('DeviceName', 'æœªçŸ¥è®¾å¤‡'),
                        'client': s.get('Client', 'æœªçŸ¥å®¢æˆ·ç«¯'),
                        'item_name': s.get('NowPlayingItem', {}).get('Name', 'æœªçŸ¥å†…å®¹'),
                        'last_activity': s.get('LastActivityDate', ''),
                    })
            
            return len(playing_sessions), playing_sessions
        except Exception as e:
            app.logger.error(f'æŸ¥è¯¢ç”¨æˆ·æ’­æ”¾ä¼šè¯æ•°å¼‚å¸¸: {emby_user_id}, error={e}')
            return 0, []

    def get_playback_stats(self) -> dict:
        """è·å–æ’­æ”¾ç»Ÿè®¡ä¿¡æ¯
        
        Returns:
            dict: åŒ…å«åœ¨çº¿äººæ•°ã€æ­£åœ¨æ’­æ”¾äººæ•°ã€è®¾å¤‡ç»Ÿè®¡ç­‰ä¿¡æ¯
        """
        sessions = self.get_sessions()
        
        # ç»Ÿè®¡
        total_sessions = len(sessions)
        playing_sessions = [s for s in sessions if s.get('is_playing')]
        playing_count = len(playing_sessions)
        
        # æŒ‰è®¾å¤‡ç±»å‹åˆ†ç»„
        devices = {}
        for s in sessions:
            client = s.get('client', 'å…¶ä»–')
            if client not in devices:
                devices[client] = 0
            devices[client] += 1
        
        # æŒ‰ç”¨æˆ·åˆ†ç»„
        users = {}
        for s in sessions:
            user_name = s.get('user_name', 'æœªçŸ¥')
            if user_name not in users:
                users[user_name] = {'sessions': 0, 'playing': 0}
            users[user_name]['sessions'] += 1
            if s.get('is_playing'):
                users[user_name]['playing'] += 1
        
        return {
            'total_sessions': total_sessions,
            'playing_count': playing_count,
            'devices': devices,
            'users': users,
            'sessions': sessions
        }

    def get_user_playback_history(self, emby_user_id: str, limit: int = 20) -> list:
        """è·å–ç”¨æˆ·çš„æ’­æ”¾å†å²
        
        Args:
            emby_user_id: Emby ç”¨æˆ· ID
            limit: è¿”å›çš„è®°å½•æ•°
            
        Returns:
            list: æ’­æ”¾å†å²åˆ—è¡¨
        """
        if not self.is_enabled() or not emby_user_id:
            return []
        
        try:
            # è·å–æœ€è¿‘æ’­æ”¾çš„é¡¹ç›®
            url = f"{self.base_url}/Users/{emby_user_id}/Items"
            params = {
                'api_key': self.api_key,
                'SortBy': 'DatePlayed',
                'SortOrder': 'Descending',
                'Filters': 'IsPlayed',
                'Recursive': 'true',
                'Fields': 'DateLastMediaAdded,Path,Overview,UserData,MediaSources',
                'IncludeItemTypes': 'Movie,Episode',
                'Limit': limit
            }
            response = self.session.get(url, params=params, timeout=10)
            response.raise_for_status()
            data = response.json()
            
            history = []
            for item in data.get('Items', []):
                user_data = item.get('UserData', {})
                history_item = {
                    'id': item.get('Id'),
                    'name': item.get('Name', 'æœªçŸ¥'),
                    'type': item.get('Type', ''),
                    'series_name': item.get('SeriesName', ''),
                    'season_name': item.get('SeasonName', ''),
                    'last_played_date': user_data.get('LastPlayedDate'),
                    'play_count': user_data.get('PlayCount', 0),
                    'played_percentage': user_data.get('PlayedPercentage', 0),
                    'is_favorite': user_data.get('IsFavorite', False),
                    'primary_image_tag': item.get('ImageTags', {}).get('Primary', ''),
                    'run_time_ticks': item.get('RunTimeTicks', 0),
                }
                
                # ç»„åˆæ˜¾ç¤ºåç§°
                if item.get('Type') == 'Episode':
                    series = item.get('SeriesName', '')
                    season = item.get('ParentIndexNumber', '')
                    episode = item.get('IndexNumber', '')
                    ep_name = item.get('Name', '')
                    if series and season and episode:
                        history_item['display_name'] = f"{series} S{season:02d}E{episode:02d} - {ep_name}"
                    else:
                        history_item['display_name'] = ep_name
                else:
                    history_item['display_name'] = item.get('Name', 'æœªçŸ¥')
                
                history.append(history_item)
            
            return history
        except requests.exceptions.Timeout:
            app.logger.warning(f'è·å–ç”¨æˆ· {emby_user_id} æ’­æ”¾å†å²è¶…æ—¶')
            return []
        except Exception as e:
            app.logger.error(f'è·å–ç”¨æˆ· {emby_user_id} æ’­æ”¾å†å²å¤±è´¥: {e}')
            return []

    def get_playback_report_history(self, days: int = 30, user_id: str = None, limit: int = 100) -> list:
        """ä» Playback Reporting æ’ä»¶è·å–æ’­æ”¾å†å²
        
        ä½¿ç”¨ GetItems API è·å–è¯¦ç»†çš„æ’­æ”¾å†å²ï¼ˆåŒ…å« IPã€æ’­æ”¾æ–¹å¼ã€è¿›åº¦ç­‰ï¼‰
        ä¼˜åŒ–ç‰ˆï¼šé™åˆ¶å¤©æ•°å’Œè¯·æ±‚æ•°é‡ï¼Œä¼˜å…ˆè·å–æœ€è¿‘çš„è®°å½•
        
        Args:
            days: è·å–å¤šå°‘å¤©çš„å†å²ï¼ˆæœ€å¤š7å¤©ä»¥ä¼˜åŒ–æ€§èƒ½ï¼‰
            user_id: å¯é€‰ï¼ŒæŒ‡å®šç”¨æˆ·ID
            limit: æœ€å¤§è¿”å›è®°å½•æ•°
            
        Returns:
            list: æ’­æ”¾å†å²è®°å½•åˆ—è¡¨
        """
        if not self.is_enabled():
            return []
        
        try:
            history = []
            end_date = datetime.now()
            
            # ä¼˜åŒ–ï¼šé™åˆ¶æœ€å¤šæŸ¥è¯¢7å¤©ä»¥æé«˜æ€§èƒ½
            actual_days = min(days, 7)
            
            # 1. é¦–å…ˆè·å–æ‰€æœ‰ç”¨æˆ·åˆ—è¡¨ï¼ˆå¦‚æœæ²¡æœ‰æŒ‡å®šç”¨æˆ·ï¼‰
            user_ids = []
            if user_id:
                user_ids = [user_id]
            else:
                # ä» user_activity è·å–æ´»è·ƒç”¨æˆ·
                try:
                    ua_url = f"{self.base_url}/user_usage_stats/user_activity"
                    ua_params = {
                        'api_key': self.api_key,
                        'days': actual_days,
                        'end_date': end_date.strftime('%Y-%m-%d')
                    }
                    ua_response = self.session.get(ua_url, params=ua_params, timeout=10)
                    if ua_response.status_code == 200:
                        ua_data = ua_response.json()
                        for user_data in ua_data:
                            uid = user_data.get('user_id', '')
                            if uid:
                                user_ids.append(uid)
                except Exception as e:
                    app.logger.debug(f'è·å– user_activity å¤±è´¥: {e}')
            
            # å¦‚æœæ²¡æœ‰è·å–åˆ°ç”¨æˆ·ï¼Œä½¿ç”¨å¤‡ç”¨æ–¹æ³•
            if not user_ids:
                app.logger.warning('æœªè·å–åˆ°æ´»è·ƒç”¨æˆ·åˆ—è¡¨ï¼Œä½¿ç”¨ UserPlaylist å¤‡ç”¨æ–¹æ³•')
                return self._get_playback_from_playlist_simple(actual_days, user_id)
            
            # ä¼˜åŒ–ï¼šé™åˆ¶ç”¨æˆ·æ•°é‡ï¼Œä¼˜å…ˆå¤„ç†
            max_users = 20  # æœ€å¤šå¤„ç†20ä¸ªç”¨æˆ·
            user_ids = user_ids[:max_users]
            
            # 2. å¹¶è¡Œè·å–æ‰€æœ‰ç”¨æˆ· Ã— æ‰€æœ‰å¤©çš„æ’­æ”¾æ•°æ®ï¼ˆå¤§å¹…æå‡é€Ÿåº¦ï¼‰
            from concurrent.futures import ThreadPoolExecutor, as_completed
            
            # æ„å»ºæ‰€æœ‰éœ€è¦è¯·æ±‚çš„ (uid, date_str) ä»»åŠ¡
            fetch_tasks = []
            for day_offset in range(actual_days):
                date = end_date - timedelta(days=day_offset)
                date_str = date.strftime('%Y-%m-%d')
                for uid in user_ids:
                    fetch_tasks.append((uid, date_str))
            
            def fetch_user_day(uid, date_str):
                """è·å–å•ä¸ªç”¨æˆ·å•å¤©çš„æ’­æ”¾è®°å½•"""
                try:
                    url = f"{self.base_url}/user_usage_stats/{uid}/{date_str}/GetItems"
                    params = {'api_key': self.api_key}
                    response = self.session.get(url, params=params, timeout=5)
                    if response.status_code != 200:
                        return []
                    items = response.json()
                    if not items:
                        return []
                    results = []
                    for item in items:
                        time_str = item.get('Time', '') or ''
                        started_at = f"{date_str} {time_str}".strip()
                        total_duration = int(item.get('Duration', 0) or 0)
                        play_duration = int(item.get('PlayDuration', 0) or 0)
                        play_percentage = None
                        if total_duration > 0 and play_duration > 0:
                            play_percentage = min(100, round(play_duration / total_duration * 100, 1))
                        results.append({
                            'id': str(item.get('RowId', '')),
                            'user_id': uid,
                            'user_name': item.get('UserName', '') or 'æœªçŸ¥',
                            'item_id': str(item.get('Id', '')),
                            'item_name': item.get('Name', '') or 'æœªçŸ¥',
                            'item_type': item.get('Type', 'Movie'),
                            'client': item.get('Client', '') or '',
                            'device_name': item.get('Device', '') or item.get('Client', '') or '',
                            'play_method': item.get('Method', '') or '',
                            'play_duration': play_duration,
                            'date': started_at,
                            'started_at': started_at,
                            'series_name': '',
                            'season_number': None,
                            'episode_number': None,
                            'play_percentage': play_percentage,
                            'display_name': item.get('Name', '') or 'æœªçŸ¥',
                            'remote_address': item.get('RemoteAddress', '') or '',
                        })
                    return results
                except Exception:
                    return []
            
            # å¹¶è¡Œæ‰§è¡Œï¼Œæœ€å¤š10ä¸ªå¹¶å‘çº¿ç¨‹
            with ThreadPoolExecutor(max_workers=10) as executor:
                futures = {executor.submit(fetch_user_day, uid, ds): (uid, ds) for uid, ds in fetch_tasks}
                for future in as_completed(futures):
                    results = future.result()
                    history.extend(results)
                    if len(history) >= limit:
                        # å–æ¶ˆå‰©ä½™ä»»åŠ¡
                        for f in futures:
                            f.cancel()
                        break
            
            # æ‰¹é‡è¡¥å……ç¼ºå¤±è¿›åº¦ï¼šå¯¹æ²¡æœ‰ play_percentage ä½†æœ‰ play_duration çš„è®°å½•ï¼Œæ‰¹é‡è·å– RunTimeTicks
            missing_items = [r for r in history if r.get('play_percentage') is None and r.get('play_duration', 0) > 0]
            if missing_items:
                # æ”¶é›†å”¯ä¸€çš„ item_id
                unique_ids = list(set(r['item_id'] for r in missing_items if r.get('item_id')))
                runtime_cache = {}
                # æ‰¹é‡è·å–ï¼ˆé€šè¿‡ Items API çš„ Ids å‚æ•°ä¸€æ¬¡æŸ¥å¤šä¸ªï¼‰
                batch_size = 50
                for i in range(0, len(unique_ids), batch_size):
                    batch_ids = unique_ids[i:i+batch_size]
                    try:
                        items_url = f"{self.base_url}/Items"
                        items_params = {
                            'api_key': self.api_key,
                            'Ids': ','.join(batch_ids),
                            'Fields': 'RunTimeTicks',
                            'Recursive': 'true'
                        }
                        items_resp = self.session.get(items_url, params=items_params, timeout=10)
                        if items_resp.status_code == 200:
                            items_data = items_resp.json()
                            for itm in items_data.get('Items', []):
                                itm_id = str(itm.get('Id', ''))
                                rtt = itm.get('RunTimeTicks', 0) or 0
                                if itm_id and rtt > 0:
                                    runtime_cache[itm_id] = rtt // 10000000  # ticks -> seconds
                        app.logger.debug(f'RunTimeTicks æ‰¹é‡è·å–: è¯·æ±‚ {len(batch_ids)} ä¸ª, å‘½ä¸­ {len(runtime_cache)} ä¸ª')
                    except Exception as e:
                        app.logger.debug(f'æ‰¹é‡è·å– RunTimeTicks å¤±è´¥: {e}')
                
                # ç”¨ç¼“å­˜è¡¥å……è¿›åº¦
                filled = 0
                for r in missing_items:
                    total_sec = runtime_cache.get(r['item_id'], 0)
                    if total_sec > 0 and r['play_duration'] > 0:
                        r['play_percentage'] = min(100, round(r['play_duration'] / total_sec * 100, 1))
                        filled += 1
                app.logger.debug(f'RunTimeTicks è¡¥å……è¿›åº¦: {filled}/{len(missing_items)} æ¡')
            
            # æŒ‰æ—¥æœŸæ’åº
            history.sort(key=lambda x: x.get('started_at', ''), reverse=True)
            
            # é™åˆ¶è¿”å›æ•°é‡
            history = history[:limit]
            
            app.logger.info(f'GetItems API è·å–åˆ° {len(history)} æ¡æ’­æ”¾å†å²è®°å½•')
            
            # å¦‚æœ GetItems æ²¡æœ‰è·å–åˆ°æ•°æ®ï¼Œä½¿ç”¨å¤‡ç”¨æ–¹æ³•
            if not history:
                app.logger.info('GetItems æ— æ•°æ®ï¼Œä½¿ç”¨ UserPlaylist å¤‡ç”¨æ–¹æ³•')
                return self._get_playback_from_playlist_simple(actual_days, user_id)
            
            return history
            
        except Exception as e:
            app.logger.error(f'ä» Playback Reporting è·å–æ’­æ”¾å†å²å¤±è´¥: {e}')
            import traceback
            app.logger.error(traceback.format_exc())
            # é™çº§åˆ° UserPlaylist
            return self._get_playback_from_playlist_simple(days, user_id)

    def _get_playback_from_playlist_simple(self, days: int = 30, user_id: str = None) -> list:
        """ä» UserPlaylist API è·å–æ’­æ”¾å†å²ï¼Œä» user_activity è¡¥å……è®¾å¤‡ä¿¡æ¯"""
        try:
            # 1. é¦–å…ˆä» user_activity è·å–ç”¨æˆ·çš„è®¾å¤‡ä¿¡æ¯
            user_device_map = {}  # user_id -> client_name
            try:
                ua_url = f"{self.base_url}/user_usage_stats/user_activity"
                ua_params = {
                    'api_key': self.api_key,
                    'days': days,
                    'end_date': datetime.now().strftime('%Y-%m-%d')
                }
                ua_response = self.session.get(ua_url, params=ua_params, timeout=15)
                if ua_response.status_code == 200:
                    ua_data = ua_response.json()
                    for user_data in ua_data:
                        uid = user_data.get('user_id', '')
                        if uid:
                            user_device_map[uid] = user_data.get('client_name', '') or ''
                    app.logger.info(f'user_activity è·å–åˆ° {len(user_device_map)} ä¸ªç”¨æˆ·çš„è®¾å¤‡ä¿¡æ¯')
            except Exception as e:
                app.logger.debug(f'è·å– user_activity å¤±è´¥: {e}')
            
            # 2. ä» UserPlaylist è·å–æ’­æ”¾å†å²
            url = f"{self.base_url}/user_usage_stats/UserPlaylist"
            params = {
                'api_key': self.api_key,
                'days': days,
                'end_date': datetime.now().strftime('%Y-%m-%d'),
                'filter': ''
            }
            if user_id:
                params['user_id'] = user_id
            
            response = self.session.get(url, params=params, timeout=30)
            if response.status_code != 200:
                return []
            
            data = response.json()
            history = []
            
            for item in data:
                date_str = item.get('date', '') or ''
                time_str = item.get('time', '') or ''
                started_at = f"{date_str} {time_str}".strip()
                
                uid = item.get('user_id', '')
                
                # ä» user_activity è·å–è®¾å¤‡åç§°
                device_name = user_device_map.get(uid, '') or ''
                
                record = {
                    'id': '',
                    'user_id': uid,
                    'user_name': item.get('user_name', '') or 'æœªçŸ¥',
                    'item_id': str(item.get('item_id', '')),
                    'item_name': item.get('item_name', '') or 'æœªçŸ¥',
                    'item_type': item.get('item_type', 'Movie'),
                    'client': device_name,
                    'device_name': device_name,  # ä½¿ç”¨ user_activity çš„ client_name
                    'play_duration': int(item.get('duration', 0) or 0),
                    'date': started_at,
                    'started_at': started_at,
                    'series_name': '',
                    'season_number': None,
                    'episode_number': None,
                    'play_percentage': None,  # è¿›åº¦éœ€è¦å•ç‹¬è·å–
                    'display_name': item.get('item_name', '') or 'æœªçŸ¥',
                    'remote_address': item.get('remote_address', '') or '',
                }
                history.append(record)
            
            app.logger.info(f'UserPlaylist è·å–åˆ° {len(history)} æ¡æ’­æ”¾å†å²')
            return history
        except Exception as e:
            app.logger.error(f'UserPlaylist å¤‡ç”¨æ–¹æ³•å¤±è´¥: {e}')
            return []

    def _get_playback_from_playlist(self, days: int = 30, user_id: str = None) -> list:
        """ä» UserPlaylist API è·å–æ’­æ”¾å†å²ï¼ˆå…¼å®¹æ—§è°ƒç”¨ï¼‰"""
        return self._get_playback_from_playlist_simple(days, user_id)

    def get_playback_report_devices(self) -> list:
        """ä» Playback Reporting æ’ä»¶è·å–è®¾å¤‡ç»Ÿè®¡
        
        ä½¿ç”¨ user_activity API è·å–ç”¨æˆ·æœ€è¿‘ä½¿ç”¨çš„è®¾å¤‡
        
        Returns:
            list: è®¾å¤‡åˆ—è¡¨
        """
        if not self.is_enabled():
            return []
        
        try:
            # 1. é¦–å…ˆä» Emby Sessions API è·å–å½“å‰è®¾å¤‡çš„ IP å’Œ User-Agent ä¿¡æ¯
            device_ip_map = {}  # device_id -> ip
            user_device_info_map = {}  # user_id -> {ip, device_name, client, app_version}
            try:
                sessions_url = f"{self.base_url}/Sessions"
                sessions_params = {
                    'api_key': self.api_key,
                    'ActiveWithinSeconds': 86400 * 30  # 30å¤©å†…æ´»è·ƒçš„ä¼šè¯
                }
                sessions_response = self.session.get(sessions_url, params=sessions_params, timeout=15)
                if sessions_response.status_code == 200:
                    sessions_data = sessions_response.json()
                    for session in sessions_data:
                        device_id = session.get('DeviceId', '')
                        user_id = session.get('UserId', '')
                        remote_ip = session.get('RemoteEndPoint', '')
                        device_name = session.get('DeviceName', '')
                        client = session.get('Client', '')  # å®¢æˆ·ç«¯åç§°
                        app_version = session.get('ApplicationVersion', '')  # ç‰ˆæœ¬å·
                        
                        if device_id and remote_ip:
                            device_ip_map[device_id] = remote_ip
                        if user_id:
                            # æ„å»ºå®Œæ•´çš„å®¢æˆ·ç«¯ä¿¡æ¯ï¼ˆç±»ä¼¼ User-Agentï¼‰
                            client_info = client
                            if app_version:
                                client_info = f"{client} {app_version}"
                            
                            user_device_info_map[user_id] = {
                                'ip': remote_ip,
                                'device_name': device_name,
                                'client': client,
                                'app_version': app_version,
                                'client_info': client_info,  # å®Œæ•´å®¢æˆ·ç«¯ä¿¡æ¯
                            }
                    app.logger.info(f'Sessions API è·å–åˆ° {len(device_ip_map)} ä¸ªè®¾å¤‡IP')
            except Exception as e:
                app.logger.debug(f'è·å– Sessions å¤±è´¥: {e}')
            
            # 2. å°è¯•ä» Emby Devices API è·å–æ›´å®Œæ•´çš„è®¾å¤‡åˆ—è¡¨å’Œ User-Agent
            device_user_agent_map = {}  # device_id -> {name, app_name, app_version, last_user_id}
            try:
                devices_url = f"{self.base_url}/Devices"
                devices_params = {'api_key': self.api_key}
                devices_response = self.session.get(devices_url, params=devices_params, timeout=15)
                if devices_response.status_code == 200:
                    devices_data = devices_response.json()
                    items = devices_data.get('Items', devices_data) if isinstance(devices_data, dict) else devices_data
                    for dev in items:
                        dev_id = dev.get('Id', '')
                        last_user_id = dev.get('LastUserId', '')
                        
                        # Devices API å­—æ®µ
                        dev_name = dev.get('Name', '')
                        app_name = dev.get('AppName', '')  # åº”ç”¨å
                        app_version = dev.get('AppVersion', '')  # åº”ç”¨ç‰ˆæœ¬
                        last_ip = dev.get('LastIpAddress', '')
                        
                        # æ„å»º User-Agent é£æ ¼çš„å®¢æˆ·ç«¯ä¿¡æ¯
                        client_info = app_name
                        if app_version:
                            client_info = f"{app_name} {app_version}"
                        
                        if dev_id:
                            device_user_agent_map[dev_id] = {
                                'name': dev_name,
                                'app_name': app_name,
                                'app_version': app_version,
                                'client_info': client_info,
                                'last_ip': last_ip,
                            }
                        
                        # è¡¥å…… IP
                        if dev_id and dev_id not in device_ip_map and last_ip:
                            device_ip_map[dev_id] = last_ip
                        
                        # è¡¥å……ç”¨æˆ·è®¾å¤‡ä¿¡æ¯
                        if last_user_id and last_user_id not in user_device_info_map:
                            user_device_info_map[last_user_id] = {
                                'ip': last_ip,
                                'device_name': dev_name,
                                'client': app_name,
                                'app_version': app_version,
                                'client_info': client_info,
                            }
                        elif last_user_id and last_user_id in user_device_info_map:
                            # æ›´æ–°å®¢æˆ·ç«¯ä¿¡æ¯ï¼ˆDevices API å¯èƒ½æ›´å®Œæ•´ï¼‰
                            if not user_device_info_map[last_user_id].get('client_info') and client_info:
                                user_device_info_map[last_user_id]['client_info'] = client_info
                            
            except Exception as e:
                app.logger.debug(f'è·å– Devices å¤±è´¥: {e}')
            
            # 3. IP ä¿¡æ¯å·²ä» Sessions API å’Œ Devices API è·å–ï¼Œæ— éœ€å†é€ç”¨æˆ·æŸ¥è¯¢å†å²
            history_ip_map = {}  # ä¿ç•™å˜é‡å…¼å®¹åç»­ä»£ç 
            
            # 4. ä½¿ç”¨ user_activity API è·å–ç”¨æˆ·æ´»åŠ¨ç»Ÿè®¡
            url = f"{self.base_url}/user_usage_stats/user_activity"
            params = {
                'api_key': self.api_key,
                'days': 30,
                'end_date': datetime.now().strftime('%Y-%m-%d')
            }
            
            response = self.session.get(url, params=params, timeout=15)
            if response.status_code != 200:
                app.logger.warning(f'user_activity API è¿”å› {response.status_code}')
                return []
            
            user_report = response.json()
            app.logger.info(f'user_activity è¿”å› {len(user_report)} æ¡ç”¨æˆ·è®°å½•')
            
            devices = []
            device_id_counter = 1
            
            for user_data in user_report:
                user_id = user_data.get('user_id', '')
                user_name = user_data.get('user_name', '') or 'æœªçŸ¥'
                client_name = user_data.get('client_name', '') or ''
                latest_date = user_data.get('latest_date', '')
                last_seen = user_data.get('last_seen', '')
                total_count = user_data.get('total_count', 0)
                total_time = user_data.get('total_time', 0)
                
                # æ ¼å¼åŒ–æœ€åæ´»è·ƒæ—¶é—´
                if isinstance(latest_date, str) and latest_date:
                    last_active = latest_date
                else:
                    last_active = str(latest_date) if latest_date else ''
                
                # è·å– IP åœ°å€ï¼ˆä¼˜å…ˆçº§ï¼šå†å²è®°å½• > Sessions > é»˜è®¤ï¼‰
                last_ip = '-'
                if user_id in history_ip_map:
                    last_ip = history_ip_map[user_id]
                elif user_id in user_device_info_map:
                    last_ip = user_device_info_map[user_id].get('ip', '-') or '-'
                
                # è·å–å®¢æˆ·ç«¯ä¿¡æ¯ï¼ˆUser-Agent é£æ ¼ï¼‰
                client_info = client_name
                app_version = ''
                if user_id in user_device_info_map:
                    device_info = user_device_info_map[user_id]
                    client_base = device_info.get('client', '') or client_name
                    app_version = device_info.get('app_version', '')
                    # åªæ‹¼æ¥ä¸€æ¬¡ç‰ˆæœ¬å·ï¼Œé¿å…é‡å¤
                    if app_version and app_version not in client_base:
                        client_info = f"{client_base} {app_version}"
                    else:
                        client_info = client_base
                
                device = {
                    'id': device_id_counter,
                    'user_id': user_id,
                    'user_name': user_name,
                    'device_name': client_name or 'æœªçŸ¥è®¾å¤‡',
                    'client': client_info or client_name,  # ä½¿ç”¨å®Œæ•´å®¢æˆ·ç«¯ä¿¡æ¯ï¼ˆå«ç‰ˆæœ¬å·ï¼‰
                    'client_version': app_version,
                    'play_count': total_count,
                    'total_duration': total_time,
                    'last_active': last_active,
                    'last_ip': last_ip,
                    'is_blocked': False,
                }
                devices.append(device)
                device_id_counter += 1
            
            return devices
        except Exception as e:
            app.logger.error(f'ä» Playback Reporting è·å–è®¾å¤‡åˆ—è¡¨å¤±è´¥: {e}')
            return []

    def stop_session(self, session_id: str, reason: str = None) -> bool:
        """åœæ­¢æŒ‡å®šçš„æ’­æ”¾ä¼šè¯
        
        Args:
            session_id: ä¼šè¯ID
            reason: ç»ˆæ­¢åŸå› ï¼ˆå¯é€‰ï¼Œä¼šæ˜¾ç¤ºç»™ç”¨æˆ·ï¼‰
            
        Returns:
            bool: æ˜¯å¦æˆåŠŸ
        """
        if not self.is_enabled() or not session_id:
            return False
        
        try:
            # Emby API: POST /Sessions/{sessionId}/Playing/Stop
            url = f"{self.base_url}/Sessions/{session_id}/Playing/Stop"
            params = {'api_key': self.api_key}
            response = self.session.post(url, params=params, timeout=10)
            
            stop_success = response.status_code in [200, 204]
            
            if stop_success:
                app.logger.info(f'å·²åœæ­¢æ’­æ”¾ä¼šè¯: {session_id}')
                
                # å‘é€æ¶ˆæ¯ç»™å®¢æˆ·ç«¯ï¼ˆå¯é€‰ï¼‰
                if reason:
                    try:
                        msg_url = f"{self.base_url}/Sessions/{session_id}/Message"
                        msg_data = {
                            "Text": f"ğŸš« {reason}",
                            "Header": "æ’­æ”¾å·²åœæ­¢",
                            "TimeoutMs": 10000
                        }
                        self.session.post(msg_url, params=params, json=msg_data, timeout=5)
                    except:
                        pass  # æ¶ˆæ¯å‘é€å¤±è´¥ä¸å½±å“ä¸»æµç¨‹
                
                return True
            else:
                app.logger.warning(f'åœæ­¢æ’­æ”¾ä¼šè¯å¤±è´¥: {session_id}, status={response.status_code}')
                return False
        except Exception as e:
            app.logger.error(f'åœæ­¢æ’­æ”¾ä¼šè¯å¼‚å¸¸: {session_id}, error={e}')
            return False

    def disable_user(self, emby_user_id: str) -> bool:
        """ç¦ç”¨ Emby ç”¨æˆ·è´¦å·
        
        å…¼å®¹ä¸åŒ Emby ç‰ˆæœ¬ï¼š
        - æ–¹å¼1: POST /Users/{id}/Policy æ›´æ–°ç­–ç•¥
        - æ–¹å¼2 (fallback): POST /Users/{id} æ›´æ–°å®Œæ•´ç”¨æˆ·å¯¹è±¡
        
        Args:
            emby_user_id: Emby ç”¨æˆ·ID
            
        Returns:
            bool: æ˜¯å¦æˆåŠŸ
        """
        if not self.is_enabled() or not emby_user_id:
            return False
        
        try:
            # å…ˆè·å–ç”¨æˆ·ä¿¡æ¯
            url = f"{self.base_url}/Users/{emby_user_id}"
            params = {'api_key': self.api_key}
            response = self.session.get(url, params=params, timeout=10)
            
            if response.status_code != 200:
                app.logger.warning(f'è·å–ç”¨æˆ·ä¿¡æ¯å¤±è´¥: {emby_user_id}, status={response.status_code}')
                return False
            
            user_info = response.json()
            
            # æ›´æ–°ç”¨æˆ·ç­–ç•¥ï¼Œè®¾ç½® IsDisabled = True
            policy = user_info.get('Policy', {})
            policy['IsDisabled'] = True
            
            # ç§»é™¤å¯èƒ½å¯¼è‡´ 400 é”™è¯¯çš„åªè¯»å­—æ®µï¼ˆä¸åŒ Emby ç‰ˆæœ¬å¯¹è¿™äº›å­—æ®µæ•æ„Ÿåº¦ä¸åŒï¼‰
            self._clean_policy_readonly_fields(policy)
            
            # === æ–¹å¼1: POST /Users/{id}/Policy ===
            policy_url = f"{self.base_url}/Users/{emby_user_id}/Policy"
            response = self.session.post(
                policy_url, 
                params=params,
                json=policy,
                headers={'Content-Type': 'application/json'},
                timeout=10
            )
            
            if response.status_code in [200, 204]:
                app.logger.info(f'å·²ç¦ç”¨ Emby ç”¨æˆ·: {emby_user_id}')
                return True
            
            # === æ–¹å¼2 (fallback): POST å®Œæ•´ç”¨æˆ·å¯¹è±¡ ===
            if response.status_code == 404:
                app.logger.info(f'Policy ç«¯ç‚¹ 404ï¼Œå°è¯•æ›´æ–°å®Œæ•´ç”¨æˆ·å¯¹è±¡: {emby_user_id}')
                user_info['Policy'] = policy
                fallback_resp = self.session.post(
                    url,
                    params=params,
                    json=user_info,
                    headers={'Content-Type': 'application/json'},
                    timeout=10
                )
                if fallback_resp.status_code in [200, 204]:
                    app.logger.info(f'å·²ç¦ç”¨ Emby ç”¨æˆ· (fallback): {emby_user_id}')
                    return True
                resp_text = fallback_resp.text[:500] if fallback_resp.text else ''
                app.logger.warning(f'ç¦ç”¨ç”¨æˆ· fallback ä¹Ÿå¤±è´¥: {emby_user_id}, status={fallback_resp.status_code}, body={resp_text}')
                return False
            
            resp_text = response.text[:500] if response.text else ''
            app.logger.warning(f'ç¦ç”¨ç”¨æˆ·å¤±è´¥: {emby_user_id}, status={response.status_code}, body={resp_text}')
            return False
        except Exception as e:
            app.logger.error(f'ç¦ç”¨ç”¨æˆ·å¼‚å¸¸: {emby_user_id}, error={e}')
            return False

    def kill_user_sessions(self, emby_user_id: str) -> int:
        """å¼ºåˆ¶ç»“æŸç”¨æˆ·çš„æ‰€æœ‰æ’­æ”¾ä¼šè¯
        
        Args:
            emby_user_id: Emby ç”¨æˆ·ID
            
        Returns:
            int: æˆåŠŸåœæ­¢çš„ä¼šè¯æ•°
        """
        if not self.is_enabled() or not emby_user_id:
            return 0
        
        try:
            # è·å–è¯¥ç”¨æˆ·çš„æ‰€æœ‰ä¼šè¯
            sessions = self.get_user_sessions(emby_user_id)
            stopped_count = 0
            
            for session in sessions:
                session_id = session.get('id')
                if session_id and self.stop_session(session_id):
                    stopped_count += 1
            
            return stopped_count
        except Exception as e:
            app.logger.error(f'å¼ºåˆ¶ç»“æŸç”¨æˆ·ä¼šè¯å¤±è´¥: {emby_user_id}, error={e}')
            return 0

    def enable_user(self, emby_user_id: str) -> bool:
        """å¯ç”¨ï¼ˆæ¢å¤ï¼‰Emby ç”¨æˆ·è´¦å·
        
        å…¼å®¹ä¸åŒ Emby ç‰ˆæœ¬ï¼š
        - æ–¹å¼1: POST /Users/{id}/Policy æ›´æ–°ç­–ç•¥
        - æ–¹å¼2 (fallback): POST /Users/{id} æ›´æ–°å®Œæ•´ç”¨æˆ·å¯¹è±¡
        
        Args:
            emby_user_id: Emby ç”¨æˆ·ID
            
        Returns:
            bool: æ˜¯å¦æˆåŠŸ
        """
        if not self.is_enabled() or not emby_user_id:
            return False
        
        try:
            # å…ˆè·å–ç”¨æˆ·ä¿¡æ¯
            url = f"{self.base_url}/Users/{emby_user_id}"
            params = {'api_key': self.api_key}
            response = self.session.get(url, params=params, timeout=10)
            
            if response.status_code != 200:
                app.logger.warning(f'è·å–ç”¨æˆ·ä¿¡æ¯å¤±è´¥: {emby_user_id}, status={response.status_code}')
                return False
            
            user_info = response.json()
            
            # æ›´æ–°ç”¨æˆ·ç­–ç•¥ï¼Œè®¾ç½® IsDisabled = False
            policy = user_info.get('Policy', {})
            policy['IsDisabled'] = False
            
            # ç¡®ä¿åª’ä½“åº“å’Œé¢‘é“è®¿é—®æƒé™æ¢å¤ï¼ˆæŸäº› Emby ç‰ˆæœ¬ç¦ç”¨ç”¨æˆ·æ—¶ä¼šæ¸…é™¤è¿™äº›æƒé™ï¼‰
            policy['EnableAllFolders'] = True
            policy['EnableAllChannels'] = True
            policy['EnableMediaPlayback'] = True
            policy['EnableRemoteAccess'] = True
            
            # åŒæ­¥æœ€å¤§åŒæ—¶æ’­æ”¾æµæ•°é™åˆ¶
            config = load_system_config()
            max_streams = config.get('telegram', {}).get('max_streams', 0)
            if max_streams and max_streams > 0:
                policy['SimultaneousStreamLimit'] = max_streams
                policy['MaxActiveSessions'] = max_streams
            else:
                policy.pop('SimultaneousStreamLimit', None)
                policy.pop('MaxActiveSessions', None)
            
            # ç§»é™¤å¯èƒ½å¯¼è‡´ 400 é”™è¯¯çš„åªè¯»å­—æ®µ
            self._clean_policy_readonly_fields(policy)
            
            # === æ–¹å¼1: POST /Users/{id}/Policy ===
            policy_url = f"{self.base_url}/Users/{emby_user_id}/Policy"
            response = self.session.post(
                policy_url, 
                params=params,
                json=policy,
                headers={'Content-Type': 'application/json'},
                timeout=10
            )
            
            if response.status_code in [200, 204]:
                app.logger.info(f'å·²å¯ç”¨ Emby ç”¨æˆ·: {emby_user_id}')
                return True
            
            # === æ–¹å¼2 (fallback): POST å®Œæ•´ç”¨æˆ·å¯¹è±¡ ===
            # æŸäº› Emby ç‰ˆæœ¬æˆ–åå‘ä»£ç†é…ç½®ä¸‹ /Users/{id}/Policy ä¼šè¿”å› 404
            if response.status_code == 404:
                app.logger.info(f'Policy ç«¯ç‚¹ 404ï¼Œå°è¯•æ›´æ–°å®Œæ•´ç”¨æˆ·å¯¹è±¡: {emby_user_id}')
                user_info['Policy'] = policy
                fallback_resp = self.session.post(
                    url,
                    params=params,
                    json=user_info,
                    headers={'Content-Type': 'application/json'},
                    timeout=10
                )
                if fallback_resp.status_code in [200, 204]:
                    app.logger.info(f'å·²å¯ç”¨ Emby ç”¨æˆ· (fallback): {emby_user_id}')
                    return True
                resp_text = fallback_resp.text[:500] if fallback_resp.text else ''
                app.logger.warning(f'å¯ç”¨ç”¨æˆ· fallback ä¹Ÿå¤±è´¥: {emby_user_id}, status={fallback_resp.status_code}, body={resp_text}')
                return False
            
            resp_text = response.text[:500] if response.text else ''
            app.logger.warning(f'å¯ç”¨ç”¨æˆ·å¤±è´¥: {emby_user_id}, status={response.status_code}, body={resp_text}')
            return False
        except Exception as e:
            app.logger.error(f'å¯ç”¨ç”¨æˆ·å¼‚å¸¸: {emby_user_id}, error={e}')
            return False

    def get_all_users(self) -> list:
        """è·å–æ‰€æœ‰ Emby ç”¨æˆ·åˆ—è¡¨ï¼ˆåŒ…æ‹¬ç¦ç”¨å’Œéšè—çš„ç”¨æˆ·ï¼‰
        
        ä½¿ç”¨ API key è°ƒç”¨ GET /Users ä¸å¸¦ isDisabled/isHidden è¿‡æ»¤å‚æ•°ï¼Œ
        åœ¨ Jellyfin ä¸­ä¼šè¿”å›æ‰€æœ‰ç”¨æˆ·ã€‚
        æŸäº› Emby é—­æºç‰ˆæœ¬å¯èƒ½ä¸è¿”å›ç¦ç”¨/éšè—ç”¨æˆ·ï¼Œ
        è¿™ç§æƒ…å†µä¸‹ authenticate_user ä¸­æœ‰é¢å¤–çš„ fallback æœºåˆ¶å¤„ç†ã€‚
        """
        if not self.is_enabled():
            return []
        
        try:
            url = f"{self.base_url}/Users"
            params = {'api_key': self.api_key}
            response = self.session.get(url, params=params, timeout=10)
            response.raise_for_status()
            return response.json()
        except Exception as e:
            app.logger.error(f'è·å– Emby ç”¨æˆ·åˆ—è¡¨å¤±è´¥: {e}')
            return []

    def get_user_by_id(self, emby_user_id: str) -> Optional[dict]:
        """é€šè¿‡ Emby ç”¨æˆ· ID ç›´æ¥è·å–ç”¨æˆ·ä¿¡æ¯
        
        ä½¿ç”¨ GET /Users/{id} ç›´æ¥è·å–ï¼Œä¸å— /Users åˆ—è¡¨è¿‡æ»¤è§„åˆ™å½±å“ã€‚
        å¯ä»¥è·å–åˆ°ç¦ç”¨/éšè—ç”¨æˆ·çš„ä¿¡æ¯ã€‚
        """
        if not self.is_enabled() or not emby_user_id:
            return None
        
        try:
            url = f"{self.base_url}/Users/{emby_user_id}"
            params = {'api_key': self.api_key}
            response = self.session.get(url, params=params, timeout=10)
            if response.status_code == 200:
                return response.json()
            else:
                app.logger.debug(f'é€šè¿‡ ID è·å– Emby ç”¨æˆ·å¤±è´¥: {emby_user_id}, status={response.status_code}')
                return None
        except Exception as e:
            app.logger.error(f'é€šè¿‡ ID è·å– Emby ç”¨æˆ·å¼‚å¸¸: {emby_user_id}, error={e}')
            return None

    def get_user_by_name(self, username: str) -> Optional[dict]:
        """é€šè¿‡ç”¨æˆ·åæŸ¥æ‰¾ Emby ç”¨æˆ·
        
        æŸäº› Emby é—­æºç‰ˆæœ¬çš„ GET /Users å¯èƒ½ä¸è¿”å›ç¦ç”¨/éšè—ç”¨æˆ·ï¼Œ
        å› æ­¤åœ¨ä¸»åˆ—è¡¨æ‰¾ä¸åˆ°æ—¶ï¼Œä¼šé¢å¤–æŸ¥è¯¢ IsDisabled=true å’Œ IsHidden=true çš„ç”¨æˆ·åˆ—è¡¨ã€‚
        """
        if not self.is_enabled() or not username:
            return None
        
        try:
            # ç¬¬ä¸€æ­¥ï¼šä»ä¸»ç”¨æˆ·åˆ—è¡¨æŸ¥æ‰¾
            users = self.get_all_users()
            for user in users:
                if user.get('Name', '').lower() == username.lower():
                    return user
            
            # ç¬¬äºŒæ­¥ï¼šä¸»åˆ—è¡¨æ‰¾ä¸åˆ°ï¼Œå°è¯•æŸ¥æ‰¾ç¦ç”¨å’Œéšè—ç”¨æˆ·
            # ï¼ˆæŸäº› Emby ç‰ˆæœ¬çš„ /Users é»˜è®¤ä¸è¿”å›ç¦ç”¨/éšè—ç”¨æˆ·ï¼‰
            for filter_param in [{'IsDisabled': 'true'}, {'IsHidden': 'true'}]:
                try:
                    url = f"{self.base_url}/Users"
                    params = {'api_key': self.api_key}
                    params.update(filter_param)
                    resp = self.session.get(url, params=params, timeout=10)
                    if resp.status_code == 200:
                        filtered_users = resp.json()
                        if isinstance(filtered_users, list):
                            for user in filtered_users:
                                if user.get('Name', '').lower() == username.lower():
                                    app.logger.info(f'åœ¨ {filter_param} ç”¨æˆ·åˆ—è¡¨ä¸­æ‰¾åˆ°ç”¨æˆ·: {username}')
                                    return user
                except Exception as e:
                    app.logger.debug(f'æŸ¥è¯¢ {filter_param} ç”¨æˆ·åˆ—è¡¨å¤±è´¥ï¼ˆå¿½ç•¥ï¼‰: {e}')
            
            return None
        except Exception as e:
            app.logger.error(f'æŸ¥æ‰¾ Emby ç”¨æˆ·å¤±è´¥: {e}')
            return None

    def authenticate_user(self, username: str, password: str, fallback_emby_id: str = None) -> dict:
        """éªŒè¯ Emby ç”¨æˆ·è´¦å·å¯†ç 
        
        Args:
            username: ç”¨æˆ·å
            password: å¯†ç 
            fallback_emby_id: å¯é€‰çš„ Emby ç”¨æˆ· IDï¼Œå½“é€šè¿‡ç”¨æˆ·åæ‰¾ä¸åˆ°ç”¨æˆ·æ—¶ç”¨äºç›´æ¥æŸ¥æ‰¾
                              ï¼ˆç”¨äºç»‘å®šå·²è¿ç§»çš„è´¦å·åœºæ™¯ï¼Œæ•°æ®åº“ä¸­å¯èƒ½ä¿å­˜äº†æ—§çš„ embyidï¼‰
            
        Returns:
            dict: åŒ…å«éªŒè¯ç»“æœçš„å­—å…¸
                - success: bool, æ˜¯å¦éªŒè¯æˆåŠŸ
                - id: str, ç”¨æˆ·IDï¼ˆæˆåŠŸæ—¶ï¼‰
                - name: str, ç”¨æˆ·åï¼ˆæˆåŠŸæ—¶ï¼‰
                - access_token: str, è®¿é—®ä»¤ç‰Œï¼ˆæˆåŠŸæ—¶ï¼‰
                - error: str, é”™è¯¯ä¿¡æ¯ï¼ˆå¤±è´¥æ—¶ï¼‰
                - error_type: str, é”™è¯¯ç±»å‹ï¼ˆå¤±è´¥æ—¶ï¼‰: 'user_not_found', 'wrong_password', 'server_error'
        """
        if not self.is_enabled():
            return {'success': False, 'error': 'Emby æœåŠ¡å™¨æœªé…ç½®', 'error_type': 'server_error'}
        
        try:
            # ç›´æ¥è°ƒç”¨ Emby è®¤è¯ APIï¼Œç”± Emby æœåŠ¡å™¨åˆ¤æ–­ç”¨æˆ·æ˜¯å¦å­˜åœ¨åŠå¯†ç æ˜¯å¦æ­£ç¡®
            # ä¸å†é¢„æ£€æŸ¥ç”¨æˆ·åˆ—è¡¨ï¼Œå› ä¸º /Users API å¯èƒ½ä¸è¿”å›éšè—/ç¦ç”¨ç”¨æˆ·ï¼Œå¯¼è‡´è¯¯æŠ¥"ä¸å­˜åœ¨"
            url = f"{self.base_url}/Users/AuthenticateByName"
            headers = {
                'X-Emby-Authorization': f'MediaBrowser Client="Emby Request System", Device="Web", DeviceId="emby-request-system", Version="1.0"',
                'Content-Type': 'application/json'
            }
            data = {
                'Username': username,
                'Pw': password
            }
            
            app.logger.info(f'Emby è®¤è¯è¯·æ±‚: url={url}, username={username}')
            response = requests.post(url, json=data, headers=headers, timeout=10)
            app.logger.info(f'Emby è®¤è¯å“åº”: status={response.status_code}, body={response.text[:500]}')
            
            if response.status_code == 200:
                result = response.json()
                user_info = result.get('User', {})
                app.logger.info(f'Emby ç”¨æˆ·éªŒè¯æˆåŠŸ: {username}')
                return {
                    'success': True,
                    'id': user_info.get('Id'),
                    'name': user_info.get('Name'),
                    'access_token': result.get('AccessToken')
                }
            elif response.status_code == 401:
                # 401 å¯èƒ½æ˜¯ç”¨æˆ·åä¸å­˜åœ¨ã€å¯†ç é”™è¯¯ã€æˆ–è´¦å·è¢«ç¦ç”¨
                # é€šè¿‡ç®¡ç†å‘˜ API æŸ¥è¯¢ç”¨æˆ·æ¥åŒºåˆ†åŸå› 
                existing_user = self.get_user_by_name(username)
                if existing_user:
                    # æ£€æŸ¥æ˜¯å¦å› ä¸ºè´¦å·è¢«ç¦ç”¨å¯¼è‡´è®¤è¯å¤±è´¥
                    is_disabled = existing_user.get('Policy', {}).get('IsDisabled', False)
                    if is_disabled:
                        # è´¦å·è¢«ç¦ç”¨ï¼Œä¸´æ—¶å¯ç”¨åé‡è¯•è®¤è¯
                        emby_user_id = existing_user.get('Id')
                        app.logger.info(f'Emby ç”¨æˆ· {username} è¢«ç¦ç”¨ï¼Œä¸´æ—¶å¯ç”¨åé‡è¯•è®¤è¯')
                        
                        if self.enable_user(emby_user_id):
                            # é‡è¯•è®¤è¯
                            retry_resp = requests.post(url, json=data, headers=headers, timeout=10)
                            
                            if retry_resp.status_code == 200:
                                result = retry_resp.json()
                                user_info = result.get('User', {})
                                app.logger.info(f'Emby ç”¨æˆ·éªŒè¯æˆåŠŸï¼ˆä¸´æ—¶å¯ç”¨åï¼‰: {username}')
                                
                                # è®¤è¯æˆåŠŸåæŠŠ Emby è´¦å·é‡æ–°ç¦ç”¨ï¼ˆä¿æŒåŸçŠ¶æ€ï¼‰
                                # è°ƒç”¨æ–¹ï¼ˆå¦‚ç»‘å®šæ¥å£ï¼‰ä¼šæ ¹æ®ç”¨æˆ·è®¢é˜…çŠ¶æ€å†³å®šæ˜¯å¦å¯ç”¨
                                self.disable_user(emby_user_id)
                                
                                return {
                                    'success': True,
                                    'id': user_info.get('Id'),
                                    'name': user_info.get('Name'),
                                    'access_token': result.get('AccessToken'),
                                    'was_disabled': True  # æ ‡è®°ï¼šè¯¥è´¦å·åœ¨ Emby ä¸Šæ˜¯ç¦ç”¨çŠ¶æ€
                                }
                            else:
                                # å¯†ç ç¡®å®é”™è¯¯ï¼Œæ¢å¤ç¦ç”¨
                                self.disable_user(emby_user_id)
                                app.logger.warning(f'Emby ç”¨æˆ·å¯†ç é”™è¯¯ï¼ˆä¸´æ—¶å¯ç”¨åç¡®è®¤ï¼‰: {username}')
                                return {'success': False, 'error': 'Emby å¯†ç ä¸æ­£ç¡®', 'error_type': 'wrong_password'}
                        else:
                            app.logger.warning(f'ä¸´æ—¶å¯ç”¨ Emby ç”¨æˆ·å¤±è´¥: {username}')
                            return {'success': False, 'error': 'Emby è´¦å·å·²è¢«ç¦ç”¨ï¼Œå¯ç”¨å¤±è´¥ï¼Œè¯·è”ç³»ç®¡ç†å‘˜', 'error_type': 'user_disabled'}
                    else:
                        app.logger.warning(f'Emby ç”¨æˆ·å¯†ç é”™è¯¯: {username}')
                        return {'success': False, 'error': 'Emby å¯†ç ä¸æ­£ç¡®', 'error_type': 'wrong_password'}
                else:
                    # get_user_by_name æ‰¾ä¸åˆ°ç”¨æˆ·ï¼Œå¯èƒ½æ˜¯ Emby API æœªè¿”å›ç¦ç”¨/éšè—ç”¨æˆ·
                    # å¦‚æœæä¾›äº† fallback_emby_idï¼Œå°è¯•é€šè¿‡ ID ç›´æ¥è·å–ç”¨æˆ·
                    if fallback_emby_id:
                        app.logger.info(f'é€šè¿‡ç”¨æˆ·åæ‰¾ä¸åˆ° Emby ç”¨æˆ· {username}ï¼Œå°è¯•é€šè¿‡ fallback ID {fallback_emby_id} æŸ¥æ‰¾')
                        fallback_user = self.get_user_by_id(fallback_emby_id)
                        if fallback_user and fallback_user.get('Name', '').lower() == username.lower():
                            is_disabled = fallback_user.get('Policy', {}).get('IsDisabled', False)
                            if is_disabled:
                                # é€šè¿‡ ID æ‰¾åˆ°äº†ç¦ç”¨ç”¨æˆ·ï¼Œä¸´æ—¶å¯ç”¨åé‡è¯•
                                app.logger.info(f'é€šè¿‡ fallback ID æ‰¾åˆ°ç¦ç”¨ç”¨æˆ· {username}ï¼Œä¸´æ—¶å¯ç”¨åé‡è¯•è®¤è¯')
                                if self.enable_user(fallback_emby_id):
                                    retry_resp = requests.post(url, json=data, headers=headers, timeout=10)
                                    if retry_resp.status_code == 200:
                                        result = retry_resp.json()
                                        user_info = result.get('User', {})
                                        app.logger.info(f'Emby ç”¨æˆ·éªŒè¯æˆåŠŸï¼ˆé€šè¿‡ fallback ID ä¸´æ—¶å¯ç”¨åï¼‰: {username}')
                                        self.disable_user(fallback_emby_id)
                                        return {
                                            'success': True,
                                            'id': user_info.get('Id'),
                                            'name': user_info.get('Name'),
                                            'access_token': result.get('AccessToken'),
                                            'was_disabled': True
                                        }
                                    else:
                                        self.disable_user(fallback_emby_id)
                                        app.logger.warning(f'Emby ç”¨æˆ·å¯†ç é”™è¯¯ï¼ˆé€šè¿‡ fallback ID ä¸´æ—¶å¯ç”¨åç¡®è®¤ï¼‰: {username}')
                                        return {'success': False, 'error': 'Emby å¯†ç ä¸æ­£ç¡®', 'error_type': 'wrong_password'}
                                else:
                                    app.logger.warning(f'é€šè¿‡ fallback ID ä¸´æ—¶å¯ç”¨ Emby ç”¨æˆ·å¤±è´¥: {username}')
                                    return {'success': False, 'error': 'Emby è´¦å·å·²è¢«ç¦ç”¨ï¼Œå¯ç”¨å¤±è´¥ï¼Œè¯·è”ç³»ç®¡ç†å‘˜', 'error_type': 'user_disabled'}
                            else:
                                # é€šè¿‡ ID æ‰¾åˆ°ç”¨æˆ·ä½†æœªç¦ç”¨ï¼Œç¡®å®æ˜¯å¯†ç é”™è¯¯
                                app.logger.warning(f'Emby ç”¨æˆ·å¯†ç é”™è¯¯ï¼ˆé€šè¿‡ fallback ID ç¡®è®¤ç”¨æˆ·å­˜åœ¨ï¼‰: {username}')
                                return {'success': False, 'error': 'Emby å¯†ç ä¸æ­£ç¡®', 'error_type': 'wrong_password'}
                    
                    app.logger.warning(f'Emby ç”¨æˆ·åæˆ–å¯†ç é”™è¯¯: {username}')
                    return {'success': False, 'error': 'Emby ç”¨æˆ·åæˆ–å¯†ç ä¸æ­£ç¡®', 'error_type': 'wrong_password'}
            else:
                app.logger.warning(f'Emby ç”¨æˆ·éªŒè¯å¤±è´¥: {username}, status={response.status_code}')
                return {'success': False, 'error': f'Emby æœåŠ¡å™¨è¿”å›é”™è¯¯ ({response.status_code})', 'error_type': 'server_error'}
        except requests.exceptions.Timeout:
            app.logger.error(f'Emby ç”¨æˆ·éªŒè¯è¶…æ—¶: {username}')
            return {'success': False, 'error': 'Emby æœåŠ¡å™¨è¿æ¥è¶…æ—¶', 'error_type': 'server_error'}
        except Exception as e:
            app.logger.error(f'Emby ç”¨æˆ·éªŒè¯å¼‚å¸¸: {e}')
            return {'success': False, 'error': f'éªŒè¯å¼‚å¸¸: {str(e)}', 'error_type': 'server_error'}

    def create_user(self, username: str, password: str) -> Optional[dict]:
        """åˆ›å»ºæ–°çš„ Emby ç”¨æˆ·
        
        Args:
            username: ç”¨æˆ·å
            password: å¯†ç 
            
        Returns:
            dict: åˆ›å»ºæˆåŠŸè¿”å›ç”¨æˆ·ä¿¡æ¯ï¼Œå¤±è´¥è¿”å› None
        """
        if not self.is_enabled():
            return None
        
        try:
            # æ£€æŸ¥ç”¨æˆ·åæ˜¯å¦å·²å­˜åœ¨
            existing = self.get_user_by_name(username)
            if existing:
                app.logger.warning(f'Emby ç”¨æˆ·åå·²å­˜åœ¨: {username}')
                return None
            
            # åˆ›å»ºç”¨æˆ·
            url = f"{self.base_url}/Users/New"
            params = {'api_key': self.api_key}
            data = {
                'Name': username
            }
            
            response = self.session.post(url, params=params, json=data, timeout=10)
            
            if response.status_code not in [200, 201]:
                app.logger.error(f'åˆ›å»º Emby ç”¨æˆ·å¤±è´¥: {username}, status={response.status_code}')
                return None
            
            new_user = response.json()
            user_id = new_user.get('Id')
            
            # è®¾ç½®å¯†ç 
            if user_id and password:
                pwd_url = f"{self.base_url}/Users/{user_id}/Password"
                pwd_data = {
                    'CurrentPw': '',
                    'NewPw': password
                }
                pwd_response = self.session.post(pwd_url, params=params, json=pwd_data, timeout=10)
                
                if pwd_response.status_code not in [200, 204]:
                    app.logger.warning(f'è®¾ç½® Emby ç”¨æˆ·å¯†ç å¤±è´¥: {username}')
            
            # è®¾ç½®ç”¨æˆ·ç­–ç•¥ï¼ˆæƒé™æ§åˆ¶ï¼‰
            if user_id:
                self._set_user_policy(user_id)
            
            app.logger.info(f'Emby ç”¨æˆ·åˆ›å»ºæˆåŠŸ: {username} (ID: {user_id})')
            return {
                'id': user_id,
                'name': new_user.get('Name')
            }
        except Exception as e:
            app.logger.error(f'åˆ›å»º Emby ç”¨æˆ·å¼‚å¸¸: {e}')
            return None

    def _set_user_policy(self, user_id: str) -> bool:
        """è®¾ç½®æ–°ç”¨æˆ·çš„é»˜è®¤ç­–ç•¥ï¼ˆæƒé™ï¼‰
        
        Args:
            user_id: Emby ç”¨æˆ·ID
            
        Returns:
            bool: æ˜¯å¦æˆåŠŸ
        """
        try:
            # å…ˆè·å–ç”¨æˆ·å½“å‰ç­–ç•¥
            url = f"{self.base_url}/Users/{user_id}"
            params = {'api_key': self.api_key}
            response = self.session.get(url, params=params, timeout=10)
            
            if response.status_code != 200:
                app.logger.warning(f'è·å–ç”¨æˆ·ç­–ç•¥å¤±è´¥: {user_id}')
                return False
            
            user_info = response.json()
            policy = user_info.get('Policy', {})
            
            # è®¾ç½®ç­–ç•¥ - æ ¹æ®æˆªå›¾é…ç½®
            # åª’ä½“åº“å’Œé¢‘é“è®¿é—®æƒé™ï¼ˆç¡®ä¿æ–°ç”¨æˆ·èƒ½çœ‹åˆ°æ‰€æœ‰å†…å®¹ï¼‰
            policy['EnableAllFolders'] = True  # å…è®¸è®¿é—®æ‰€æœ‰åª’ä½“åº“
            policy['EnableAllChannels'] = True  # å…è®¸è®¿é—®æ‰€æœ‰é¢‘é“
            
            # å¼€å¯çš„é€‰é¡¹
            policy['EnableRemoteAccess'] = True  # å…è®¸è¿œç¨‹è®¿é—®æ­¤ Emby Server
            policy['EnableMediaPlayback'] = True  # å…è®¸åª’ä½“æ’­æ”¾
            policy['EnableLiveTvAccess'] = True  # ç”µè§†ç›´æ’­
            policy['EnableLiveTvManagement'] = False  # ç”µè§†ç›´æ’­å½•åˆ¶ç®¡ç†
            policy['EnableSharedDeviceControl'] = False  # å…è®¸é¥æ§å…±äº«è®¾å¤‡
            policy['EnableRemoteControlOfOtherUsers'] = False  # å…è®¸é¥æ§å…¶ä»–ç”¨æˆ·
            policy['EnablePublicSharing'] = True  # å…è®¸ç¤¾äº¤åª’ä½“åˆ†äº«
            policy['EnableUserPreferenceAccess'] = True  # å…è®¸ç”¨æˆ·æ›´æ”¹å…¶å¤´åƒå’Œå¯†ç 
            
            # å…³é—­çš„é€‰é¡¹
            policy['IsAdministrator'] = False  # å…è®¸æ­¤ç”¨æˆ·ç®¡ç†æœåŠ¡å™¨
            policy['IsDisabled'] = False  # ç¦ç”¨æ­¤ç”¨æˆ·
            policy['EnableAudioPlaybackTranscoding'] = False  # å…è®¸éŸ³é¢‘è½¬ç ä¸ºå…¼å®¹æ ¼å¼
            policy['EnableVideoPlaybackTranscoding'] = False  # å…è®¸è§†é¢‘è½¬ç ä¸ºå…¼å®¹æ ¼å¼
            policy['EnablePlaybackRemuxing'] = False  # å…è®¸æ›´æ”¹å®¹å™¨æ ¼å¼
            policy['EnableContentDownloading'] = False  # å…è®¸ä¸‹è½½åª’ä½“
            policy['EnableSubtitleDownloading'] = False  # å…è®¸å­—å¹•ä¸‹è½½
            policy['EnableSubtitleManagement'] = False  # å…è®¸åˆ é™¤ç°æœ‰å­—å¹•æ–‡ä»¶
            policy['EnableSyncTranscoding'] = False  # å…è®¸ä¸‹è½½éœ€è¦è½¬ç çš„åª’ä½“
            policy['EnableMediaConversion'] = False  # å…è®¸åª’ä½“è½¬æ¢
            policy['EnableAllDevices'] = True  # å…è®¸æ‰€æœ‰è®¾å¤‡
            
            # éšè—ç”¨æˆ·é€‰é¡¹
            policy['IsHiddenRemotely'] = True  # åœ¨è¿œç¨‹è¿æ¥çš„ç™»å½•ç•Œé¢ä¸­éšè—æ­¤ç”¨æˆ·
            policy['IsHiddenFromUnusedDevices'] = False  # åœ¨ä»æœªç™»å½•è¿‡è®¾å¤‡çš„ç™»å½•é¡µé¢ä¸­éšè—æ­¤ç”¨æˆ·
            policy['IsHidden'] = True  # åœ¨æœ¬åœ°ç½‘ç»œçš„ç™»å½•ç•Œé¢ä¸­éšè—æ­¤ç”¨æˆ·
            
            # åˆ é™¤åª’ä½“æƒé™ - å…¨éƒ¨ç¦æ­¢
            policy['EnableContentDeletion'] = False
            policy['EnableContentDeletionFromFolders'] = []
            
            # æœ€å¤§åŒæ—¶æ’­æ”¾æµæ•°é™åˆ¶ï¼ˆå§‹ç»ˆè®¾ç½®ï¼Œ0è§†ä¸ºä¸é™åˆ¶æ—¶ä¸è®¾æ­¤å­—æ®µè®©Embyä½¿ç”¨é»˜è®¤è¡Œä¸ºï¼‰
            # åŒæ—¶è®¾ç½® SimultaneousStreamLimit å’Œ MaxActiveSessionsï¼ˆä¸åŒ Emby ç‰ˆæœ¬è®¤ä¸åŒå­—æ®µï¼‰
            config = load_system_config()
            max_streams = config.get('telegram', {}).get('max_streams', 0)
            if max_streams and max_streams > 0:
                policy['SimultaneousStreamLimit'] = max_streams
                policy['MaxActiveSessions'] = max_streams
            else:
                # æœªé…ç½®æ—¶ç§»é™¤é™åˆ¶è®©Embyä½¿ç”¨é»˜è®¤è¡Œä¸º
                policy.pop('SimultaneousStreamLimit', None)
                policy.pop('MaxActiveSessions', None)
            
            # æœ€å¤§åŒæ­¥è§†é¢‘æµ
            policy['SyncPlayAccess'] = 'CreateAndJoinGroups'
            
            # ç§»é™¤åªè¯»å­—æ®µï¼ˆé˜²æ­¢æŸäº› Emby ç‰ˆæœ¬è¿”å› 400ï¼‰
            self._clean_policy_readonly_fields(policy)
            
            # æ›´æ–°ç”¨æˆ·ç­–ç•¥
            policy_url = f"{self.base_url}/Users/{user_id}/Policy"
            response = self.session.post(
                policy_url,
                params=params,
                json=policy,
                headers={'Content-Type': 'application/json'},
                timeout=10
            )
            
            if response.status_code in [200, 204]:
                app.logger.info(f'å·²è®¾ç½® Emby ç”¨æˆ·ç­–ç•¥: {user_id}, SimultaneousStreamLimit={policy.get("SimultaneousStreamLimit")}, MaxActiveSessions={policy.get("MaxActiveSessions")}')
                return True
            
            # === fallback: POST å®Œæ•´ç”¨æˆ·å¯¹è±¡ ===
            # æŸäº› Emby ç‰ˆæœ¬æˆ–åå‘ä»£ç†é…ç½®ä¸‹ /Users/{id}/Policy ä¼šè¿”å› 404
            if response.status_code == 404:
                app.logger.info(f'Policy ç«¯ç‚¹ 404ï¼Œå°è¯•é€šè¿‡å®Œæ•´ç”¨æˆ·å¯¹è±¡è®¾ç½®ç­–ç•¥: {user_id}')
                user_info['Policy'] = policy
                fallback_resp = self.session.post(
                    url,
                    params=params,
                    json=user_info,
                    headers={'Content-Type': 'application/json'},
                    timeout=10
                )
                if fallback_resp.status_code in [200, 204]:
                    app.logger.info(f'å·²è®¾ç½® Emby ç”¨æˆ·ç­–ç•¥ (fallback): {user_id}')
                    return True
                resp_text = fallback_resp.text[:500] if fallback_resp.text else ''
                app.logger.warning(f'è®¾ç½®ç”¨æˆ·ç­–ç•¥ fallback ä¹Ÿå¤±è´¥: {user_id}, status={fallback_resp.status_code}, body={resp_text}')
                return False
            
            resp_text = response.text[:500] if response.text else ''
            app.logger.warning(f'è®¾ç½®ç”¨æˆ·ç­–ç•¥å¤±è´¥: {user_id}, status={response.status_code}, response={resp_text}')
            return False
                
        except Exception as e:
            app.logger.error(f'è®¾ç½®ç”¨æˆ·ç­–ç•¥å¼‚å¸¸: {user_id}, error={e}')
            return False

    def sync_all_users_stream_limit(self, max_streams: int) -> dict:
        """åŒæ­¥æ‰€æœ‰ Emby ç”¨æˆ·çš„æœ€å¤§åŒæ—¶æ’­æ”¾æµæ•°é™åˆ¶
        
        Args:
            max_streams: æœ€å¤§åŒæ—¶æ’­æ”¾æµæ•°ï¼ˆ0è¡¨ç¤ºä¸é™åˆ¶ï¼‰
            
        Returns:
            dict: {'success': int, 'failed': int, 'total': int}
        """
        if not self.is_enabled():
            return {'success': 0, 'failed': 0, 'total': 0}
        
        result = {'success': 0, 'failed': 0, 'total': 0}
        
        try:
            # è·å–æ‰€æœ‰æœ‰ embyid çš„ç”¨æˆ·
            users = User.query.filter(User.embyid.isnot(None), User.embyid != '').all()
            result['total'] = len(users)
            
            params = {'api_key': self.api_key}
            
            for user in users:
                try:
                    # è·å–ç”¨æˆ·å½“å‰ç­–ç•¥
                    url = f"{self.base_url}/Users/{user.embyid}"
                    response = self.session.get(url, params=params, timeout=10)
                    if response.status_code != 200:
                        result['failed'] += 1
                        continue
                    
                    user_info = response.json()
                    policy = user_info.get('Policy', {})
                    
                    # æ›´æ–°æµæ•°é™åˆ¶ï¼ˆåŒæ—¶è®¾ç½®ä¸¤ä¸ªå­—æ®µï¼Œå…¼å®¹ä¸åŒ Emby ç‰ˆæœ¬ï¼‰
                    if max_streams > 0:
                        policy['SimultaneousStreamLimit'] = max_streams
                        policy['MaxActiveSessions'] = max_streams
                    else:
                        # 0è¡¨ç¤ºä¸é™åˆ¶ï¼Œç§»é™¤é™åˆ¶
                        policy.pop('SimultaneousStreamLimit', None)
                        policy.pop('MaxActiveSessions', None)
                    
                    # ç§»é™¤åªè¯»å­—æ®µ
                    self._clean_policy_readonly_fields(policy)
                    
                    # æäº¤ç­–ç•¥
                    policy_url = f"{self.base_url}/Users/{user.embyid}/Policy"
                    resp = self.session.post(
                        policy_url, params=params, json=policy,
                        headers={'Content-Type': 'application/json'}, timeout=10
                    )
                    if resp.status_code in [200, 204]:
                        result['success'] += 1
                    else:
                        result['failed'] += 1
                except Exception as e:
                    app.logger.warning(f'åŒæ­¥ç”¨æˆ· {user.embyid} æµæ•°é™åˆ¶å¤±è´¥: {e}')
                    result['failed'] += 1
            
            app.logger.info(f'åŒæ­¥æµæ•°é™åˆ¶å®Œæˆ: æ€»è®¡{result["total"]}äºº, æˆåŠŸ{result["success"]}äºº, å¤±è´¥{result["failed"]}äºº')
        except Exception as e:
            app.logger.error(f'æ‰¹é‡åŒæ­¥æµæ•°é™åˆ¶å¼‚å¸¸: {e}')
        
        return result

    def check_username_available(self, username: str) -> bool:
        """æ£€æŸ¥ç”¨æˆ·åæ˜¯å¦å¯ç”¨ï¼ˆä¸å­˜åœ¨ï¼‰"""
        if not self.is_enabled():
            return False
        return self.get_user_by_name(username) is None

    def delete_user(self, emby_user_id: str) -> bool:
        """åˆ é™¤ Emby ç”¨æˆ·è´¦å·
        
        Args:
            emby_user_id: Emby ç”¨æˆ·ID
            
        Returns:
            bool: æ˜¯å¦æˆåŠŸ
        """
        if not self.is_enabled() or not emby_user_id:
            return False
        
        try:
            url = f"{self.base_url}/Users/{emby_user_id}"
            params = {'api_key': self.api_key}
            response = self.session.delete(url, params=params, timeout=10)
            
            if response.status_code in [200, 204]:
                app.logger.info(f'å·²åˆ é™¤ Emby ç”¨æˆ·: {emby_user_id}')
                return True
            else:
                app.logger.warning(f'åˆ é™¤ç”¨æˆ·å¤±è´¥: {emby_user_id}, status={response.status_code}')
                return False
        except Exception as e:
            app.logger.error(f'åˆ é™¤ç”¨æˆ·å¼‚å¸¸: {emby_user_id}, error={e}')
            return False

    def change_user_password(self, user_id: str, current_password: str, new_password: str, emby_username: str = '') -> tuple[bool, str]:
        """ä¿®æ”¹ Emby ç”¨æˆ·å¯†ç 
        
        å…¼å®¹ä¸åŒ Emby ç‰ˆæœ¬å’Œåå‘ä»£ç†é…ç½®ï¼š
        - æ–¹å¼1: ç®¡ç†å‘˜ API key + POST /Users/{UserId}/Password
        - æ–¹å¼2: ç”¨æˆ·å‡­è¯è®¤è¯è·å– tokenï¼Œå†ç”¨ç”¨æˆ· token ä¿®æ”¹
        - æ–¹å¼3 (fallback): ç®¡ç†å‘˜å…ˆé‡ç½®å¯†ç ä¸ºç©ºï¼Œå†è®¾ç½®æ–°å¯†ç 
        
        å½“åå‘ä»£ç†æ‹¦æˆª /Users/{id}/Password è·¯å¾„å¯¼è‡´ 404 æ—¶ï¼Œ
        ä¼šæ ‡è®°ä¸ºåä»£é—®é¢˜ï¼Œé¿å…å°†åç»­è®¤è¯å¤±è´¥(401)è¯¯åˆ¤ä¸º"å¯†ç ä¸æ­£ç¡®"ã€‚
        
        Args:
            user_id: Emby ç”¨æˆ· ID
            current_password: å½“å‰å¯†ç 
            new_password: æ–°å¯†ç 
            emby_username: Emby ç”¨æˆ·åï¼ˆå¯é€‰ï¼Œç”¨äº GET /Users/{id} å¤±è´¥æ—¶çš„ fallbackï¼‰
            
        Returns:
            tuple: (æˆåŠŸæ ‡å¿—, æ¶ˆæ¯)
        """
        if not self.is_enabled():
            return False, 'Emby æœåŠ¡å™¨æœªé…ç½®'
        
        try:
            params = {'api_key': self.api_key}
            is_proxy_issue = False  # æ ‡è®°æ˜¯å¦æ˜¯åå‘ä»£ç† 404 é—®é¢˜
            
            # å°è¯•è·å– Emby ç”¨æˆ·ä¿¡æ¯ï¼ˆç”¨äºè·å–ç”¨æˆ·åï¼Œæ–¹å¼2/3éœ€è¦ç”¨æˆ·åè®¤è¯ï¼‰
            check_url = f"{self.base_url}/Users/{user_id}"
            try:
                check_resp = self.session.get(check_url, params=params, timeout=10)
                if check_resp.status_code == 200:
                    emby_user = check_resp.json()
                    emby_username = emby_user.get('Name', '') or emby_username or ''
                else:
                    app.logger.warning(f'è·å– Emby ç”¨æˆ·ä¿¡æ¯å¤±è´¥ï¼ˆå°†ç»§ç»­å°è¯•ä¿®æ”¹å¯†ç ï¼‰: user_id={user_id}, status={check_resp.status_code}')
                    if check_resp.status_code == 404:
                        is_proxy_issue = True
                    if not emby_username:
                        app.logger.error(f'æ— æ³•è·å–ç”¨æˆ·ä¿¡æ¯ä¸”æ—  fallback ç”¨æˆ·å: user_id={user_id}')
                        return False, 'Emby æœåŠ¡å™¨æš‚æ—¶æ— æ³•è®¿é—®ï¼Œè¯·ç¨åé‡è¯•'
            except Exception as e:
                app.logger.warning(f'è·å– Emby ç”¨æˆ·ä¿¡æ¯å¼‚å¸¸: {e}')
                if not emby_username:
                    return False, 'Emby æœåŠ¡å™¨æš‚æ—¶æ— æ³•è®¿é—®ï¼Œè¯·ç¨åé‡è¯•'
            
            # === æ–¹å¼1: ç®¡ç†å‘˜ API key ç›´æ¥ä¿®æ”¹å¯†ç  ===
            url = f"{self.base_url}/Users/{user_id}/Password"
            pwd_data = {
                'CurrentPw': current_password,
                'NewPw': new_password
            }
            response = self.session.post(url, params=params, json=pwd_data, timeout=10)
            
            if response.status_code in [200, 204]:
                app.logger.info(f'Emby å¯†ç ä¿®æ”¹æˆåŠŸ (æ–¹å¼1-API key): user_id={user_id}')
                return True, 'å¯†ç ä¿®æ”¹æˆåŠŸ'
            elif response.status_code == 403:
                return False, 'å½“å‰ Emby å¯†ç ä¸æ­£ç¡®'
            
            resp_text = response.text[:200] if response.text else ''
            app.logger.warning(f'æ–¹å¼1ä¿®æ”¹å¯†ç å¤±è´¥: status={response.status_code}, body={resp_text}')
            
            # æ£€æŸ¥æ–¹å¼1æ˜¯å¦å› åä»£ 404 å¤±è´¥
            if response.status_code == 404:
                is_proxy_issue = True
            
            # === æ–¹å¼2: ç”¨ç”¨æˆ·å‡­è¯è®¤è¯è·å– AccessTokenï¼Œå†ç”¨ token ä¿®æ”¹å¯†ç  ===
            # å¦‚æœå·²ç¡®è®¤æ˜¯åä»£é—®é¢˜ï¼ˆ/Users/{id}/Password è¢«æ‹¦æˆªï¼‰ï¼Œæ–¹å¼2ä¹Ÿä¼šå¤±è´¥åœ¨åŒä¸€è·¯å¾„ï¼Œè·³è¿‡
            if not is_proxy_issue:
                try:
                    auth_url = f"{self.base_url}/Users/AuthenticateByName"
                    auth_headers = {
                        'Content-Type': 'application/json',
                        'X-Emby-Authorization': 'Emby Client="Emby Request Panel", Device="Server", DeviceId="emby-request-panel", Version="1.0.0"'
                    }
                    auth_data = {
                        'Username': emby_username,
                        'Pw': current_password
                    }
                    auth_resp = requests.post(auth_url, json=auth_data, headers=auth_headers, timeout=10)
                    
                    if auth_resp.status_code in [401, 403]:
                        return False, 'å½“å‰ Emby å¯†ç ä¸æ­£ç¡®'
                    
                    if auth_resp.status_code == 200:
                        user_token = auth_resp.json().get('AccessToken')
                        if user_token:
                            pwd_headers = {
                                'Content-Type': 'application/json',
                                'X-Emby-Token': user_token
                            }
                            pwd_resp = requests.post(url, json=pwd_data, headers=pwd_headers, timeout=10)
                            
                            if pwd_resp.status_code in [200, 204]:
                                app.logger.info(f'Emby å¯†ç ä¿®æ”¹æˆåŠŸ (æ–¹å¼2-ç”¨æˆ·token): user_id={user_id}')
                                return True, 'å¯†ç ä¿®æ”¹æˆåŠŸ'
                            elif pwd_resp.status_code == 403:
                                return False, 'å½“å‰ Emby å¯†ç ä¸æ­£ç¡®'
                            app.logger.warning(f'æ–¹å¼2ä¿®æ”¹å¯†ç å¤±è´¥: status={pwd_resp.status_code}')
                    else:
                        app.logger.warning(f'ç”¨æˆ·è®¤è¯å¤±è´¥: status={auth_resp.status_code}')
                except Exception as e2:
                    app.logger.warning(f'æ–¹å¼2å¼‚å¸¸: {e2}')
            else:
                app.logger.info(f'è·³è¿‡æ–¹å¼2ï¼ˆå·²ç¡®è®¤åä»£æ‹¦æˆª /Users/{{id}}/Passwordï¼‰')
            
            # === æ–¹å¼3 (fallback): ç®¡ç†å‘˜å…ˆè®¤è¯éªŒè¯æ—§å¯†ç ï¼Œå†é‡ç½®åè®¾æ–°å¯†ç  ===
            try:
                # å…ˆéªŒè¯å½“å‰å¯†ç ï¼ˆé€šè¿‡è®¤è¯æ¥å£ï¼‰ï¼Œé˜²æ­¢ä»»æ„å¯†ç é‡ç½®
                # æ³¨æ„ï¼šå¦‚æœ Emby è´¦å·è¢«ç¦ç”¨ï¼ŒAuthenticateByName ä¼šè¿”å› 401
                # æ­¤æ—¶ä¸èƒ½ç›´æ¥åˆ¤å®šä¸º"å¯†ç ä¸æ­£ç¡®"
                verify_url = f"{self.base_url}/Users/AuthenticateByName"
                verify_headers = {
                    'Content-Type': 'application/json',
                    'X-Emby-Authorization': 'Emby Client="Emby Request Panel", Device="Server", DeviceId="emby-request-panel", Version="1.0.0"'
                }
                verify_resp = requests.post(verify_url, json={'Username': emby_username, 'Pw': current_password}, 
                                          headers=verify_headers, timeout=10)
                
                password_verified = (verify_resp.status_code == 200)
                
                was_temporarily_enabled = False  # æ ‡è®°æ˜¯å¦ä¸´æ—¶å¯ç”¨äº†ç”¨æˆ·
                
                if not password_verified:
                    # è®¤è¯å¤±è´¥ï¼Œå¯èƒ½æ˜¯å¯†ç é”™è¯¯ï¼Œä¹Ÿå¯èƒ½æ˜¯è´¦å·è¢«ç¦ç”¨
                    # å¦‚æœæ˜¯åä»£é—®é¢˜ç¯å¢ƒï¼Œç”¨æˆ·è´¦å·å¯èƒ½è¢«ç¦ç”¨å¯¼è‡´è®¤è¯å¤±è´¥
                    # å°è¯•ä¸´æ—¶å¯ç”¨åå†éªŒè¯
                    if is_proxy_issue:
                        app.logger.info(f'åä»£ç¯å¢ƒä¸‹è®¤è¯å¤±è´¥(status={verify_resp.status_code})ï¼Œå°è¯•ä¸´æ—¶å¯ç”¨ç”¨æˆ·åé‡è¯•')
                        enabled_ok = self.enable_user(user_id)
                        if enabled_ok:
                            was_temporarily_enabled = True
                            import time
                            time.sleep(0.5)  # ç­‰å¾… Emby æ›´æ–°çŠ¶æ€
                            retry_verify = requests.post(verify_url, json={'Username': emby_username, 'Pw': current_password},
                                                       headers=verify_headers, timeout=10)
                            if retry_verify.status_code == 200:
                                password_verified = True
                                app.logger.info(f'ä¸´æ—¶å¯ç”¨åå¯†ç éªŒè¯æˆåŠŸ: {emby_username}')
                            else:
                                # å¯ç”¨åä»ç„¶ 401ï¼Œå¯†ç ç¡®å®é”™è¯¯
                                self.disable_user(user_id)
                                return False, 'å½“å‰ Emby å¯†ç ä¸æ­£ç¡®'
                        else:
                            # enable_user ä¹Ÿå¤±è´¥äº†ï¼ˆåä»£ä¹Ÿæ‹¦æˆªäº† /Users/{id}ï¼‰ï¼Œ
                            # æ­¤æ—¶æ— æ³•éªŒè¯å¯†ç çœŸä¼ªï¼Œä¸èƒ½æ–­è¨€"å¯†ç ä¸æ­£ç¡®"
                            app.logger.warning(f'ä¸´æ—¶å¯ç”¨ç”¨æˆ·å¤±è´¥ï¼ˆåä»£å¯èƒ½ä¹Ÿæ‹¦æˆªäº† /Users/{{id}}ï¼‰ï¼Œæ— æ³•éªŒè¯å¯†ç ')
                            # ç›´æ¥è¿”å› PROXY_UNVERIFIEDï¼Œè®©è°ƒç”¨æ–¹çŸ¥é“å¯†ç æœªéªŒè¯
                            return False, 'PROXY_UNVERIFIED:æ— æ³•éªŒè¯å¯†ç ï¼ˆEmby æœåŠ¡å™¨åå‘ä»£ç†é˜»æ­¢äº†è®¿é—®ï¼‰ï¼Œè¯·è”ç³»ç®¡ç†å‘˜æ£€æŸ¥åå‘ä»£ç†é…ç½®åé‡è¯•ã€‚'
                    
                    if not password_verified:
                        return False, 'å½“å‰ Emby å¯†ç ä¸æ­£ç¡®'
                
                # å¯†ç éªŒè¯é€šè¿‡ï¼Œä½¿ç”¨ç®¡ç†å‘˜ API é‡ç½®å¯†ç 
                # æ–¹å¼3a: ç›´æ¥ç”¨ /Users/{id}/Password é‡ç½®ï¼ˆå¦‚æœåä»£æ²¡æ‹¦æˆªçš„è¯ï¼‰
                if not is_proxy_issue:
                    reset_resp = self.session.post(url, params=params, 
                                                  json={'CurrentPw': '', 'NewPw': '', 'ResetPassword': True}, timeout=10)
                    if reset_resp.status_code in [200, 204]:
                        set_resp = self.session.post(url, params=params, 
                                                    json={'CurrentPw': '', 'NewPw': new_password}, timeout=10)
                        if set_resp.status_code in [200, 204]:
                            app.logger.info(f'Emby å¯†ç ä¿®æ”¹æˆåŠŸ (æ–¹å¼3a-ç®¡ç†å‘˜é‡ç½®): user_id={user_id}')
                            if was_temporarily_enabled:
                                self.disable_user(user_id)
                            return True, 'å¯†ç ä¿®æ”¹æˆåŠŸ'
                    app.logger.warning(f'æ–¹å¼3aé‡ç½®å¤±è´¥: status={reset_resp.status_code}')
                
                # æ–¹å¼3b: ç”¨è®¤è¯è·å–çš„ token ä¿®æ”¹å¯†ç 
                # å¯†ç éªŒè¯é€šè¿‡è¯´æ˜ç”¨æˆ·å½“å‰å¯è®¤è¯ï¼Œç”¨ token å°è¯•ä¿®æ”¹
                if password_verified:
                    try:
                        token_resp = requests.post(verify_url, json={'Username': emby_username, 'Pw': current_password},
                                                 headers=verify_headers, timeout=10)
                        if token_resp.status_code == 200:
                            user_token = token_resp.json().get('AccessToken')
                            user_info = token_resp.json().get('User', {})
                            actual_user_id = user_info.get('Id', user_id)
                            
                            if user_token:
                                token_pwd_url = f"{self.base_url}/Users/{actual_user_id}/Password"
                                token_headers = {
                                    'Content-Type': 'application/json',
                                    'X-Emby-Token': user_token
                                }
                                token_pwd_resp = requests.post(token_pwd_url, json=pwd_data, headers=token_headers, timeout=10)
                                
                                if token_pwd_resp.status_code in [200, 204]:
                                    app.logger.info(f'Emby å¯†ç ä¿®æ”¹æˆåŠŸ (æ–¹å¼3b-ç”¨æˆ·token): user_id={user_id}')
                                    if was_temporarily_enabled:
                                        self.disable_user(user_id)
                                    return True, 'å¯†ç ä¿®æ”¹æˆåŠŸ'
                                app.logger.warning(f'æ–¹å¼3bä¿®æ”¹å¯†ç å¤±è´¥: status={token_pwd_resp.status_code}')
                    except Exception as e3b:
                        app.logger.warning(f'æ–¹å¼3bå¼‚å¸¸: {e3b}')
                
                # æ¢å¤ä¸´æ—¶å¯ç”¨çš„ç”¨æˆ·
                if was_temporarily_enabled:
                    self.disable_user(user_id)
                
                # æ‰€æœ‰ Emby API æ–¹å¼éƒ½å¤±è´¥
                if is_proxy_issue:
                    app.logger.error(f'åå‘ä»£ç†æ‹¦æˆªäº† Emby å¯†ç ä¿®æ”¹è·¯å¾„ï¼Œæ‰€æœ‰æ–¹å¼å‡å¤±è´¥: user_id={user_id}')
                    # å¯†ç å·²éªŒè¯æ­£ç¡®ï¼Œè¿”å›ç‰¹æ®Šæ ‡è®°è®©è°ƒç”¨æ–¹å¯ä»¥æ›´æ–°æœ¬åœ° pwd2
                    return False, 'PROXY_BLOCKED:å¯†ç éªŒè¯é€šè¿‡ï¼Œä½† Emby æœåŠ¡å™¨åå‘ä»£ç†é˜»æ­¢äº†å¯†ç ä¿®æ”¹ã€‚å·²æ›´æ–°æœ¬åœ°è®°å½•ï¼ŒEmby ç«¯å¯†ç éœ€è”ç³»ç®¡ç†å‘˜ä¿®æ”¹ã€‚'
                
                return False, 'å¯†ç ä¿®æ”¹å¤±è´¥ï¼Œè¯·è”ç³»ç®¡ç†å‘˜'
            except Exception as e3:
                app.logger.error(f'æ–¹å¼3å¼‚å¸¸: {e3}')
                return False, 'æœåŠ¡å™¨é”™è¯¯ï¼Œè¯·ç¨åé‡è¯•'
                
        except Exception as e:
            app.logger.error(f'ä¿®æ”¹ Emby å¯†ç å¼‚å¸¸: {e}')
            return False, 'æœåŠ¡å™¨é”™è¯¯ï¼Œè¯·ç¨åé‡è¯•'


# ==================== åˆå§‹åŒ– PT å®¢æˆ·ç«¯ ====================
# åˆ›å»º PT ç«™ç®¡ç†å™¨
pt_manager = PTManager()

# ä¼˜å…ˆæ³¨å†Œ MoviePilotï¼ˆå¦‚æœé…ç½®äº†ï¼‰
if MOVIEPILOT_URL and (MOVIEPILOT_TOKEN or (MOVIEPILOT_USERNAME and MOVIEPILOT_PASSWORD)):
    moviepilot_client = MoviePilotClient(
        base_url=MOVIEPILOT_URL,
        username=MOVIEPILOT_USERNAME,
        password=MOVIEPILOT_PASSWORD,
        token=MOVIEPILOT_TOKEN,
        priority=20
    )
    pt_manager.register(moviepilot_client)
    app.logger.info(f"MoviePilot å·²æ³¨å†Œ: {MOVIEPILOT_URL}")

qbit_client = QbitClient(QBITTORRENT_BASE_URL, QBITTORRENT_USERNAME, QBITTORRENT_PASSWORD)
emby_client = EmbyClient(EMBY_URL, EMBY_API_KEY)

# é…ç½®æ—¥å¿—
if not os.path.exists('logs'):
    os.mkdir('logs')

# ä½¿ç”¨çº¿ç¨‹å®‰å…¨çš„æ—¥å¿—æ–¹æ¡ˆï¼šQueueHandler + QueueListener
# è§£å†³å¤šçº¿ç¨‹å¹¶å‘å†™ RotatingFileHandler å¯¼è‡´çš„ "reentrant call" é”™è¯¯
import queue
from logging.handlers import QueueHandler, QueueListener

_log_queue = queue.Queue(-1)  # æ— é™é˜Ÿåˆ—

# å®é™…å†™æ–‡ä»¶çš„ handlerï¼ˆç”± QueueListener åœ¨å•ç‹¬çº¿ç¨‹ä¸­è°ƒç”¨ï¼Œæ— å¹¶å‘é—®é¢˜ï¼‰
# æŒ‰å¤©åˆ‡å‰²æ—¥å¿—ï¼šæ¯å¤©åˆå¤œè‡ªåŠ¨ç”Ÿæˆæ–°æ–‡ä»¶ï¼Œä¿ç•™æœ€è¿‘ 30 å¤©
_file_handler = TimedRotatingFileHandler(
    'logs/app.log',
    when='midnight',       # æ¯å¤©åˆå¤œåˆ‡å‰²
    interval=1,
    backupCount=30,        # ä¿ç•™ 30 å¤©
    encoding='utf-8'
)
_file_handler.suffix = '%Y-%m-%d.log'  # å½’æ¡£æ–‡ä»¶å: app.log.2026-02-11.log
_file_handler.setFormatter(logging.Formatter(
    '%(asctime)s %(levelname)s: %(message)s [in %(pathname)s:%(lineno)d]'
))
_file_handler.setLevel(logging.INFO)

# æ§åˆ¶å° handler
console_handler = logging.StreamHandler()
console_handler.setFormatter(logging.Formatter(
    '%(asctime)s %(levelname)s: %(message)s'
))
console_handler.setLevel(logging.INFO)

# QueueHandlerï¼šæ‰€æœ‰çº¿ç¨‹æŠŠæ—¥å¿—å†™å…¥é˜Ÿåˆ—ï¼ˆçº¿ç¨‹å®‰å…¨ï¼‰
_queue_handler = QueueHandler(_log_queue)
app.logger.addHandler(_queue_handler)
app.logger.addHandler(console_handler)

# QueueListenerï¼šå•ç‹¬çº¿ç¨‹ä»é˜Ÿåˆ—å–æ—¥å¿—å†™å…¥æ–‡ä»¶ï¼ˆé¿å…å¤šçº¿ç¨‹ç«äº‰ï¼‰
_log_listener = QueueListener(_log_queue, _file_handler, respect_handler_level=True)
_log_listener.start()

# æ³¨å†Œé€€å‡ºæ—¶åœæ­¢ listener
import atexit
atexit.register(_log_listener.stop)

app.logger.setLevel(logging.INFO)

# å¯åŠ¨æ—¶è®°å½•é…ç½®ä¿¡æ¯
if not db_password:
    app.logger.warning('æœªé…ç½®æ•°æ®åº“å¯†ç ï¼Œä½¿ç”¨SQLiteæ•°æ®åº“')

app.logger.info('Emby Request System å¯åŠ¨')


# è¯·æ±‚æ—¥å¿—ä¸­é—´ä»¶
@app.before_request
def log_request():
    """è®°å½•æ‰€æœ‰è¯·æ±‚"""
    if request.path.startswith('/static/'):
        return  # è·³è¿‡é™æ€æ–‡ä»¶è¯·æ±‚
    # ä¸å†è®°å½• IP åœ°å€ç­‰æ•æ„Ÿä¿¡æ¯
    app.logger.debug(f'{request.method} {request.path}')


# URLè·¯å¾„åˆ°æƒé™çš„æ˜ å°„è§„åˆ™
ADMIN_URL_PERMISSION_MAP = {
    # æ±‚ç‰‡ç®¡ç†
    '/admin/update-request': 'requests',
    '/api/admin/requests': 'requests',
    '/api/admin/batch-update': 'requests',
    '/api/admin/batch-delete': 'requests',
    '/api/admin/pt-search': 'requests',
    '/api/admin/pt-download': 'requests',
    # ç”¨æˆ·ç®¡ç†
    '/api/admin/users': 'users',
    '/api/admin/user': 'users',
    '/api/admin/create-emby': 'users',
    '/api/admin/reset-password': 'users',
    '/api/admin/delete-emby': 'users',
    '/api/admin/toggle-ban': 'users',
    # è®¢å•ç®¡ç†
    '/api/admin/orders': 'orders',
    '/api/admin/subscriptions': 'orders',
    # å…‘æ¢ç ç®¡ç†
    '/api/admin/redeem': 'redeem',
    '/api/admin/generate-codes': 'redeem',
    # æ’­æ”¾ç›‘æ§
    '/api/admin/playback': 'playback',
    '/api/admin/devices': 'playback',
    '/api/admin/all-playback': 'playback',
    # å·¥å•ç®¡ç†
    '/api/admin/tickets': 'tickets',
    '/api/admin/ticket': 'tickets',
    # é‚€è¯·ç»Ÿè®¡
    '/api/admin/invites': 'invites',
    '/api/admin/invite': 'invites',
    # å¥—é¤é…ç½®
    '/api/admin/plans': 'plans',
    # çŸ¥è¯†åº“
    '/api/admin/knowledge': 'knowledge',
    '/api/admin/announcements': 'knowledge',
    # ç³»ç»Ÿè®¾ç½®
    '/api/admin/config': 'settings',
    '/api/admin/save-config': 'settings',
    '/api/admin/change-credentials': 'settings',
    '/api/admin/setup': 'settings',
    '/api/admin/test-': 'settings',
    '/api/admin/lines': 'settings',
    '/api/admin/email': 'settings',
    '/api/admin/site': 'settings',
    '/api/admin/payment': 'settings',
    '/api/admin/database': 'settings',
    '/api/admin/logs': 'settings',
    '/api/admin/audit-logs': 'settings',
    '/api/admin/export': 'settings',
    '/api/admin/category': 'settings',
    # ä»ªè¡¨ç›˜
    '/api/admin/dashboard': 'dashboard',
    '/api/admin/stats': 'dashboard',
    # ç®¡ç†å‘˜ç®¡ç† - ä»…è¶…çº§ç®¡ç†å‘˜ï¼ˆåœ¨APIé‡Œå•ç‹¬æ£€æŸ¥ï¼‰
}


@app.before_request
def check_admin_permission():
    """åŸºäºURLè·¯å¾„çš„æƒé™æ£€æŸ¥ä¸­é—´ä»¶"""
    path = request.path
    
    # åªæ£€æŸ¥ç®¡ç†åå°ç›¸å…³è·¯å¾„
    if not (path.startswith('/admin') or path.startswith('/api/admin')):
        return
    
    # è·³è¿‡ä¸éœ€è¦æƒé™æ£€æŸ¥çš„è·¯å¾„
    skip_paths = ['/admin', '/api/admin-login', '/api/admin-logout', 
                  '/api/admin/current-permissions', '/api/admin/admins']
    if path in skip_paths:
        return
    
    # åªæœ‰ç™»å½•çš„ç®¡ç†å‘˜æ‰éœ€è¦æ£€æŸ¥æƒé™
    if not session.get('admin_logged_in'):
        return
    
    admin_id = session.get('admin_user_id')
    if not admin_id:
        return  # æ—§sessionå…¼å®¹ï¼Œè§†ä¸ºè¶…çº§ç®¡ç†å‘˜
    
    # æ£€æŸ¥æ˜¯å¦è¶…çº§ç®¡ç†å‘˜
    if session.get('admin_is_super'):
        return
    
    try:
        admin_user = db.session.get(AdminUser, admin_id)
        if not admin_user or not admin_user.is_active:
            return  # admin_required ä¼šå¤„ç†
        
        if admin_user.is_super:
            return
        
        # åŒ¹é…URLåˆ°æƒé™
        required_perm = None
        for url_prefix, perm in ADMIN_URL_PERMISSION_MAP.items():
            if path.startswith(url_prefix):
                required_perm = perm
                break
        
        if required_perm and not admin_user.has_permission(required_perm):
            perm_name = ADMIN_PERMISSION_GROUPS.get(required_perm, required_perm)
            return jsonify({'error': f'æ— æƒé™æ‰§è¡Œæ­¤æ“ä½œï¼ˆéœ€è¦: {perm_name}ï¼‰'}), 403
    except Exception as e:
        app.logger.warning(f'æƒé™æ£€æŸ¥å¼‚å¸¸: {e}')


@app.after_request
def log_response(response):
    """è®°å½•å“åº”çŠ¶æ€å’Œä¼˜åŒ–å“åº”å¤´"""
    # ===== å®‰å…¨å“åº”å¤´ =====
    response.headers['X-Content-Type-Options'] = 'nosniff'
    response.headers['X-Frame-Options'] = 'SAMEORIGIN'
    response.headers['X-XSS-Protection'] = '1; mode=block'
    response.headers['Referrer-Policy'] = 'strict-origin-when-cross-origin'
    
    # é™æ€æ–‡ä»¶ç¼“å­˜ï¼ˆ1å°æ—¶ï¼‰
    if request.path.startswith('/static/'):
        response.cache_control.max_age = 3600
        response.cache_control.public = True
        return response
    
    # API å“åº”ä¸ç¼“å­˜ï¼ˆæ’é™¤æ–‡ä»¶ä¸‹è½½ï¼‰
    if request.path.startswith('/api/') or request.is_json or request.method in ['POST', 'PUT', 'DELETE']:
        if not response.headers.get('Content-Disposition', '').startswith('attachment'):
            response.cache_control.no_cache = True
            response.cache_control.no_store = True
            response.cache_control.must_revalidate = True
    
    # Gzip å‹ç¼©å¤§å“åº”ï¼ˆæå‡ä¼ è¾“é€Ÿåº¦ï¼‰
    # è·³è¿‡æ–‡ä»¶ä¸‹è½½ï¼ˆContent-Disposition: attachmentï¼‰å’Œæ˜¾å¼æ ‡è®°è·³è¿‡çš„å“åº”
    skip_gzip = (
        response.headers.get('X-Skip-Gzip') or
        (response.headers.get('Content-Disposition', '').startswith('attachment'))
    )
    if not skip_gzip and response.content_length and response.content_length > 1000:
        if 'gzip' in request.headers.get('Accept-Encoding', '').lower():
            response.direct_passthrough = False
            if response.data:
                gzip_buffer = gzip.compress(response.data, compresslevel=5)
                response.data = gzip_buffer
                response.headers['Content-Encoding'] = 'gzip'
                response.headers['Content-Length'] = len(gzip_buffer)
                response.headers['Vary'] = 'Accept-Encoding'
    # æ¸…ç†å†…éƒ¨æ ‡è®°å¤´
    response.headers.pop('X-Skip-Gzip', None)
    
    # è®°å½•é”™è¯¯å“åº”ï¼ˆè‡ªåŠ¨æå– JSON ä¸­çš„ error è¯¦æƒ…ï¼‰
    if response.status_code >= 400:
        error_detail = ''
        try:
            if response.content_type and 'json' in response.content_type:
                resp_data = response.get_json(silent=True)
                if resp_data:
                    error_detail = resp_data.get('error', '') or resp_data.get('message', '')
        except Exception:
            pass
        if error_detail:
            app.logger.warning(f'{request.method} {request.path} - Status: {response.status_code} - {error_detail}')
        else:
            app.logger.warning(f'{request.method} {request.path} - Status: {response.status_code}')
    
    return response


# å…¨å±€é”™è¯¯å¤„ç†
@app.errorhandler(404)
def not_found(error):
    # é™é»˜å¿½ç•¥æµè§ˆå™¨/æ—§SWç¼“å­˜è‡ªåŠ¨è¯·æ±‚çš„èµ„æºæ–‡ä»¶
    ignored_paths = (
        '/favicon.ico',
        '/apple-touch-icon.png',
        '/apple-touch-icon-precomposed.png',
        '/static/logo.png',        # æ—§ç‰ˆ Service Worker ç¼“å­˜æ®‹ç•™
        '/static/manifest.json',   # æ—§ç‰ˆ Service Worker ç¼“å­˜æ®‹ç•™
    )
    if request.path in ignored_paths:
        return '', 204
    app.logger.warning(f'404 é”™è¯¯: {request.path}')
    if request.path.startswith('/api/') or request.is_json:
        return jsonify({'error': 'è¯·æ±‚çš„èµ„æºä¸å­˜åœ¨'}), 404
    return jsonify({'error': 'é¡µé¢ä¸å­˜åœ¨'}), 404


@app.errorhandler(500)
def internal_error(error):
    app.logger.error(f'500 é”™è¯¯: {error}', exc_info=True)
    db.session.rollback()
    if request.is_json:
        return jsonify({'error': 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯'}), 500
    return jsonify({'error': 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯', 'detail': str(error)}), 500


# æ•°æ®åº“æ¨¡å‹ - æ˜ å°„åˆ°å·²å­˜åœ¨çš„embyè¡¨
class User(db.Model):
    __tablename__ = 'emby'
    
    tg = db.Column(db.BigInteger, primary_key=True, autoincrement=False)  # ç”¨æˆ·IDï¼ˆä¸»é”®ï¼Œç³»ç»Ÿç”Ÿæˆï¼‰
    telegram_id = db.Column(db.BigInteger, nullable=True, unique=True, index=True)  # Telegram IDï¼ˆé€šè¿‡ /bind å‘½ä»¤ç»‘å®šï¼‰
    embyid = db.Column(db.String(255), nullable=True)  # Embyç”¨æˆ·ID
    name = db.Column(db.String(255), nullable=True)  # ç½‘ç«™ç”¨æˆ·åï¼ˆç™»å½•ç”¨ï¼‰
    emby_name = db.Column(db.String(255), nullable=True)  # Embyç”¨æˆ·åï¼ˆç‹¬ç«‹äºç½‘ç«™ç”¨æˆ·åï¼‰
    pwd = db.Column(db.String(255), nullable=True)  # å¯†ç 
    pwd2 = db.Column(db.String(255), nullable=True)  # å¤‡ç”¨å¯†ç 
    lv = db.Column(db.String(1), default='d')  # ç”¨æˆ·ç­‰çº§: a=æ—§ç™½åå•(å·²åºŸå¼ƒ,ç­‰åŒb), b=æ™®é€š, c=ç¦ç”¨, d=æ— è´¦å·
    cr = db.Column(db.DateTime, nullable=True)  # åˆ›å»ºæ—¶é—´
    ex = db.Column(db.DateTime, nullable=True)  # è¿‡æœŸæ—¶é—´
    us = db.Column(db.Integer, default=1)  # ä½¿ç”¨çŠ¶æ€
    iv = db.Column(db.Integer, default=0)  # é‚€è¯·æ•°
    ch = db.Column(db.DateTime, nullable=True)  # ç­¾åˆ°æ—¶é—´
    coins = db.Column(db.Integer, default=0)  # ç­¾åˆ°ç§¯åˆ†ï¼ˆè´§å¸ï¼‰
    email = db.Column(db.String(255), nullable=True)  # ç»‘å®šé‚®ç®±ï¼ˆç”¨äºæ‰¾å›å¯†ç ã€æ¥æ”¶é€šçŸ¥ï¼‰
    
    # ä¸ªæ€§åŒ–é‚€è¯·è¿”åˆ©é…ç½®ï¼ˆç®¡ç†å‘˜å¯ä¸ºæ¯ä¸ªç”¨æˆ·å•ç‹¬è®¾ç½®ï¼‰
    invite_reward_mode = db.Column(db.String(20), nullable=True)  # once/recurring/None(è·Ÿéšå…¨å±€)
    invite_reward_percent = db.Column(db.Float, nullable=True)  # 0-100, None=è·Ÿéšå…¨å±€
    
    # å°ç¦å‰çŠ¶æ€å¤‡ä»½ï¼ˆç”¨äºè§£é™¤å°ç¦æ—¶æ¢å¤ï¼‰
    ban_prev_lv = db.Column(db.String(1), nullable=True)  # å°ç¦å‰çš„ç­‰çº§
    ban_prev_ex = db.Column(db.DateTime, nullable=True)  # å°ç¦å‰çš„åˆ°æœŸæ—¶é—´
    ban_time = db.Column(db.DateTime, nullable=True)  # å°ç¦æ—¶é—´
    ban_reason = db.Column(db.String(500), nullable=True)  # å°ç¦åŸå› 
    
    # ä¼šè¯ä»¤ç‰Œï¼ˆç”¨äºä½¿ç”¨æˆ·é€€å‡ºç™»å½•ï¼‰
    session_token = db.Column(db.String(64), nullable=True)  # ç™»å½•æ—¶ç”Ÿæˆï¼Œé‡ç½®å¯†ç æ—¶æ›´æ–°
    
    # å…³ç³»
    requests = db.relationship('MovieRequest', backref='user', lazy=True, foreign_keys='MovieRequest.user_tg')

    @property
    def is_admin(self):
        """ç®¡ç†å‘˜åˆ¤æ–­ï¼šä¸å†ä½¿ç”¨ç”¨æˆ·ååˆ—è¡¨ï¼Œç®¡ç†åå°ä½¿ç”¨ç‹¬ç«‹çš„å®‰å…¨å…¥å£ç™»å½•"""
        # æ­¤å±æ€§ä¿ç•™ç”¨äºå…¼å®¹æ€§ï¼Œä½†å§‹ç»ˆè¿”å› False
        # ç®¡ç†åå°ç°åœ¨ä½¿ç”¨ç‹¬ç«‹çš„è´¦å·å¯†ç è®¤è¯
        return False
    
    @property
    def is_active(self):
        """æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å¯ç”¨ï¼šå¿…é¡»æ˜¯Aæˆ–Bç­‰çº§"""
        # C = å·²ç¦ç”¨ç”¨æˆ·ï¼ŒD = æ— è´¦å·ç”¨æˆ·ï¼Œéƒ½ä¸èƒ½ä½¿ç”¨
        if self.lv not in ['a', 'b']:
            return False
        
        # A = ç™½åå•ç”¨æˆ·ï¼ˆex=9999-12-31ï¼Œæ°¸ä¸è¿‡æœŸï¼‰
        # B = æ™®é€šç”¨æˆ·ï¼ŒæŒ‰ ex åˆ¤æ–­
        if self.ex:
            return datetime.now() < self.ex
        return False  # æ²¡æœ‰è¿‡æœŸæ—¶é—´è§†ä¸ºéæ´»è·ƒ
    
    @property
    def username(self):
        """è¿”å›ç½‘ç«™ç”¨æˆ·å"""
        return self.name
    
    @property
    def display_name(self):
        """è¿”å›æ˜¾ç¤ºåç§°ï¼ˆä¼˜å…ˆEmbyç”¨æˆ·åï¼Œå…¶æ¬¡ç½‘ç«™ç”¨æˆ·åï¼‰"""
        return self.emby_name or self.name
    
    def get_daily_limit(self):
        """æ ¹æ®ç”¨æˆ·ç±»å‹è¿”å›æ¯æ—¥æ±‚ç‰‡é™åˆ¶
        - ç®¡ç†å‘˜: æ— é™åˆ¶ï¼ˆåœ¨ can_request ä¸­å•ç‹¬å¤„ç†ï¼‰
        - ç™½åå•ç”¨æˆ· (å¥—é¤plan_type='whitelist'): ä»é…ç½®è¯»å– (é»˜è®¤3æ¬¡/å¤©)
        - è®¢é˜…ç”¨æˆ· (æœ‰æœ‰æ•ˆè®¢é˜…): ä»é…ç½®è¯»å– (é»˜è®¤1æ¬¡/å¤©)
        - Cçº§ç”¨æˆ· (å·²ç¦ç”¨): ä»é…ç½®è¯»å– (é»˜è®¤0æ¬¡/å¤©)
        - æœªè®¢é˜…ç”¨æˆ·: ä»é…ç½®è¯»å– (é»˜è®¤0æ¬¡/å¤©)
        """
        # è¯»å–é…ç½®
        config = load_system_config()
        limit_config = config.get('request_limit', {})
        
        # Cçº§: å·²ç¦ç”¨ç”¨æˆ·
        if self.lv == 'c':
            return limit_config.get('level_c', 0)
        
        # æ£€æŸ¥æ˜¯å¦ç™½åå•å¥—é¤ç”¨æˆ·ï¼ˆé€šè¿‡ Subscription.plan_type='whitelist'ï¼‰
        if self.lv in ['a', 'b'] and self.ex and self.ex > datetime.now():
            active_sub = Subscription.query.filter_by(
                user_tg=self.tg, status='active'
            ).order_by(Subscription.end_date.desc()).first()
            if active_sub and active_sub.plan_type == 'whitelist':
                return limit_config.get('level_a', 3)
            # æ™®é€šè®¢é˜…ç”¨æˆ·
            return limit_config.get('level_b', 1)
        
        # æœªè®¢é˜…ç”¨æˆ·
        return limit_config.get('level_d', 0)

    def get_today_request_count(self):
        """è·å–ä»Šæ—¥æ±‚ç‰‡æ¬¡æ•°ï¼ˆåŒ…æ‹¬æ‰€æœ‰çŠ¶æ€ï¼‰"""
        # ä½¿ç”¨æœ¬åœ°æ—¶é—´è®¡ç®—ä»Šæ—¥èŒƒå›´ï¼ˆæ•°æ®åº“å­˜å‚¨çš„æ˜¯æœ¬åœ°æ—¶é—´ï¼‰
        now_local = datetime.now()
        today_start = now_local.replace(hour=0, minute=0, second=0, microsecond=0)
        today_end = today_start + timedelta(days=1)
        
        return MovieRequest.query.filter(
            MovieRequest.user_tg == self.tg,
            MovieRequest.created_at >= today_start,
            MovieRequest.created_at < today_end
        ).count()

    def can_request(self):
        if not self.is_active:
            return False
        if self.is_admin:
            return True
        return self.get_today_request_count() < self.get_daily_limit()


class MovieRequest(db.Model):
    __tablename__ = 'movie_requests'
    
    id = db.Column(db.Integer, primary_key=True)
    user_tg = db.Column(db.BigInteger, db.ForeignKey('emby.tg'), nullable=False)  # å…³è”åˆ°embyè¡¨çš„tgå­—æ®µ
    tmdb_id = db.Column(db.Integer, nullable=False)
    title = db.Column(db.String(200), nullable=False)
    year = db.Column(db.String(10))
    poster_path = db.Column(db.String(200))
    overview = db.Column(db.Text)
    media_type = db.Column(db.String(20), default='movie')  # movie æˆ– tv
    # å‰§é›†é€‰æ‹©å­—æ®µï¼ˆä»…å¯¹ tv ç±»å‹æœ‰æ•ˆï¼‰
    request_type = db.Column(db.String(20), default='all')  # all=å…¨å‰§, season=æŒ‡å®šå­£, episode=æŒ‡å®šé›†
    season_number = db.Column(db.Integer)  # æŒ‡å®šçš„å­£æ•°
    episode_number = db.Column(db.Integer)  # æŒ‡å®šçš„é›†æ•°
    total_seasons = db.Column(db.Integer)  # æ€»å­£æ•°ï¼ˆç”¨äºæ˜¾ç¤ºï¼‰
    status = db.Column(db.String(20), default='pending')  # pending, approved, rejected, completed
    created_at = db.Column(db.DateTime, default=lambda: datetime.now())
    updated_at = db.Column(db.DateTime, default=lambda: datetime.now(), onupdate=lambda: datetime.now())
    admin_note = db.Column(db.Text)
    user_note = db.Column(db.Text)  # ç”¨æˆ·å¤‡æ³¨
    download_task = db.relationship('DownloadTask', back_populates='request', uselist=False)
    
    def get_request_scope(self):
        """è·å–æ±‚ç‰‡èŒƒå›´çš„å¯è¯»æè¿°"""
        if self.media_type == 'movie':
            return 'ç”µå½±'
        if self.request_type == 'all':
            return f'å…¨å‰§ ({self.total_seasons}å­£)' if self.total_seasons else 'å…¨å‰§'
        elif self.request_type == 'season':
            return f'ç¬¬{self.season_number}å­£'
        elif self.request_type == 'episode':
            return f'S{str(self.season_number).zfill(2)}E{str(self.episode_number).zfill(2)}'
        return ''


class DownloadTask(db.Model):
    __tablename__ = 'download_tasks'

    id = db.Column(db.Integer, primary_key=True)
    request_id = db.Column(db.Integer, db.ForeignKey('movie_requests.id'), nullable=False, unique=True)
    torrent_name = db.Column(db.String(255), nullable=False)
    torrent_hash = db.Column(db.String(64))
    source = db.Column(db.String(50), default='MoviePilot')
    download_url = db.Column(db.String(512))
    qb_tag = db.Column(db.String(128))
    status = db.Column(db.String(20), default='queued')
    progress = db.Column(db.Float, default=0.0)
    download_speed = db.Column(db.Integer, default=0)  # Bytes/s
    eta = db.Column(db.Integer, default=-1)
    error_message = db.Column(db.Text)
    retry_count = db.Column(db.Integer, default=0)  # é‡è¯•æ¬¡æ•°
    max_retries = db.Column(db.Integer, default=3)  # æœ€å¤§é‡è¯•æ¬¡æ•°
    last_retry_at = db.Column(db.DateTime)  # æœ€åé‡è¯•æ—¶é—´
    created_at = db.Column(db.DateTime, default=lambda: datetime.now())
    updated_at = db.Column(db.DateTime, default=lambda: datetime.now(), onupdate=lambda: datetime.now())
    finished_at = db.Column(db.DateTime)

    request = db.relationship('MovieRequest', back_populates='download_task')

    def to_dict(self):
        """è½¬æ¢ä¸ºå­—å…¸æ ¼å¼"""
        return {
            'id': self.id,
            'request_id': self.request_id,
            'torrent_name': self.torrent_name,
            'torrent_hash': self.torrent_hash,
            'source': self.source,
            'status': self.status,
            'progress': self.progress or 0,
            'download_speed': self.download_speed or 0,
            'eta': self.eta if self.eta is not None else -1,
            'error_message': self.error_message,
            'retry_count': self.retry_count or 0,
            'max_retries': self.max_retries or 3,
            'created_at': self.created_at.isoformat() if self.created_at else None,
            'updated_at': self.updated_at.isoformat() if self.updated_at else None,
            'finished_at': self.finished_at.isoformat() if self.finished_at else None,
        }


def generate_next_user_id():
    """ç”Ÿæˆä¸‹ä¸€ä¸ªå¯ç”¨çš„æ­£æ•´æ•°ç”¨æˆ· IDï¼ˆä» 1000 å¼€å§‹é€’å¢ï¼‰"""
    max_tg = db.session.query(db.func.max(User.tg)).scalar()
    if max_tg is None or max_tg < 1000:
        return 1000
    return max_tg + 1


class Subscription(db.Model):
    """è®¢é˜…å¥—é¤è¡¨"""
    __tablename__ = 'subscriptions'
    
    id = db.Column(db.Integer, primary_key=True)
    user_tg = db.Column(db.BigInteger, db.ForeignKey('emby.tg'), nullable=False)
    plan_type = db.Column(db.String(50), nullable=False)  # basic, standard, premium, ultimate
    plan_name = db.Column(db.String(100), nullable=False)
    duration_months = db.Column(db.Integer, nullable=False)  # è®¢é˜…æ—¶é•¿ï¼ˆæœˆï¼‰
    price = db.Column(db.Float, nullable=False)  # ä»·æ ¼
    start_date = db.Column(db.DateTime, nullable=False)
    end_date = db.Column(db.DateTime, nullable=False)
    status = db.Column(db.String(20), default='active')  # active, expired, cancelled
    auto_renew = db.Column(db.Boolean, default=False)  # è‡ªåŠ¨ç»­è´¹
    source = db.Column(db.String(20), default='purchase')  # purchase=è´­ä¹°, gift=ç®¡ç†å‘˜èµ é€, manual=æ‰‹åŠ¨è®¾ç½®
    created_at = db.Column(db.DateTime, default=lambda: datetime.now())
    updated_at = db.Column(db.DateTime, default=lambda: datetime.now(), onupdate=lambda: datetime.now())
    
    def to_dict(self):
        # è®¡ç®—å‰©ä½™å¤©æ•°ï¼Œä½¿ç”¨ä¸å¸¦æ—¶åŒºçš„ datetime è¿›è¡Œæ¯”è¾ƒ
        days_remaining = 0
        if self.end_date:
            now = datetime.now()
            # å¦‚æœ end_date æœ‰æ—¶åŒºä¿¡æ¯ï¼Œç§»é™¤å®ƒ
            end_date = self.end_date.replace(tzinfo=None) if self.end_date.tzinfo else self.end_date
            days_remaining = (end_date - now).days
        
        # è·å–ç”¨æˆ·ä¿¡æ¯
        user = User.query.filter_by(tg=self.user_tg).first()
        user_name = (user.emby_name or user.name) if user else f'ç”¨æˆ·{self.user_tg}'
        
        # åˆ¤æ–­æ¥æº - å…¼å®¹æ—§æ•°æ®
        price = float(self.price) if self.price else 0
        source = self.source
        if not source:
            # æ—§æ•°æ®æ²¡æœ‰sourceå­—æ®µï¼Œæ ¹æ®ä»·æ ¼åˆ¤æ–­
            source = 'gift' if price == 0 else 'purchase'
        
        return {
            'id': self.id,
            'user_tg_id': self.user_tg,
            'user_name': user_name,
            'plan_type': self.plan_type,
            'plan_name': self.plan_name,
            'duration_months': self.duration_months,
            'price': price,
            'start_date': self.start_date.isoformat() if self.start_date else None,
            'end_date': self.end_date.isoformat() if self.end_date else None,
            'status': self.status,
            'auto_renew': self.auto_renew,
            'days_remaining': days_remaining,
            'source': source
        }


class Order(db.Model):
    """è®¢å•è¡¨"""
    __tablename__ = 'orders'
    
    id = db.Column(db.Integer, primary_key=True)
    order_no = db.Column(db.String(64), unique=True, nullable=False)  # è®¢å•å·
    user_tg = db.Column(db.BigInteger, db.ForeignKey('emby.tg'), nullable=False)
    plan_type = db.Column(db.String(50), nullable=False)
    plan_name = db.Column(db.String(100), nullable=False)
    duration_months = db.Column(db.Integer, nullable=False)  # å…¼å®¹æ—§æ•°æ®
    duration_days = db.Column(db.Integer, nullable=True)  # å®é™…å¤©æ•°ï¼ˆæ–°å­—æ®µï¼Œä¼˜å…ˆä½¿ç”¨ï¼‰
    original_price = db.Column(db.Float, nullable=False)  # åŸä»·
    discount = db.Column(db.Float, default=0)  # æŠ˜æ‰£é‡‘é¢
    final_price = db.Column(db.Float, nullable=False)  # å®ä»˜é‡‘é¢
    payment_method = db.Column(db.String(50))  # alipay, wechat, paypal
    payment_status = db.Column(db.String(20), default='pending')  # pending, paid, failed, refunded
    payment_time = db.Column(db.DateTime)  # æ”¯ä»˜æ—¶é—´
    trade_no = db.Column(db.String(128))  # ç¬¬ä¸‰æ–¹äº¤æ˜“å·
    created_at = db.Column(db.DateTime, default=lambda: datetime.now())
    updated_at = db.Column(db.DateTime, default=lambda: datetime.now(), onupdate=lambda: datetime.now())
    
    def to_dict(self):
        return {
            'id': self.id,
            'order_no': self.order_no,
            'plan_type': self.plan_type,
            'plan_name': self.plan_name,
            'duration_months': self.duration_months,
            'duration_days': self.duration_days if self.duration_days else (self.duration_months * 30),
            'original_price': self.original_price,
            'discount': self.discount,
            'final_price': self.final_price,
            'payment_method': self.payment_method,
            'payment_status': self.payment_status,
            'payment_time': self.payment_time.isoformat() if self.payment_time else None,
            'created_at': self.created_at.isoformat() if self.created_at else None
        }


class InviteRecord(db.Model):
    """é‚€è¯·è®°å½•è¡¨"""
    __tablename__ = 'invite_records'
    
    id = db.Column(db.Integer, primary_key=True)
    inviter_tg = db.Column(db.BigInteger, db.ForeignKey('emby.tg'), nullable=False)  # é‚€è¯·äºº
    invitee_tg = db.Column(db.BigInteger, db.ForeignKey('emby.tg'), nullable=False)  # è¢«é‚€è¯·äºº
    invite_code = db.Column(db.String(32), nullable=False)  # é‚€è¯·ç ï¼ˆç§»é™¤ unique çº¦æŸï¼ŒåŒä¸€ä¸ªé‚€è¯·ç å¯ä»¥è¢«å¤šäººä½¿ç”¨ï¼‰
    reward_type = db.Column(db.String(50))  # days, discount, credits, pending
    reward_value = db.Column(db.Float)  # å¥–åŠ±æ•°å€¼
    reward_claimed = db.Column(db.Boolean, default=False)  # å¥–åŠ±æ˜¯å¦å·²å‘æ”¾
    reward_mode = db.Column(db.String(20), nullable=True)  # once=ä¸€æ¬¡æ€§, recurring=å¾ªç¯, null=è·Ÿéšå…¨å±€
    custom_reward_percent = db.Column(db.Float, nullable=True)  # ä¸ªæ€§åŒ–è¿”åˆ©æ¯”ä¾‹(0-100), null=è·Ÿéšå…¨å±€
    pending_reward = db.Column(db.Float, default=0)  # å¾…å®¡æ ¸çš„è¿”åˆ©å¤©æ•°
    created_at = db.Column(db.DateTime, default=lambda: datetime.now())
    claimed_at = db.Column(db.DateTime)  # å‘æ”¾æ—¶é—´
    
    def to_dict(self):
        # å®‰å…¨è·å–é‚€è¯·äººä¿¡æ¯
        inviter = db.session.get(User, self.inviter_tg) if self.inviter_tg else None
        inviter_name = inviter.name if inviter else 'æœªçŸ¥ç”¨æˆ·'
        
        # å®‰å…¨è·å–è¢«é‚€è¯·äººä¿¡æ¯
        invitee = db.session.get(User, self.invitee_tg) if self.invitee_tg else None
        invitee_name = invitee.name if invitee else 'æœªçŸ¥ç”¨æˆ·'
        
        # çŠ¶æ€åˆ¤æ–­
        if self.pending_reward and self.pending_reward > 0:
            status = 'pending'
            status_display = 'å¾…å®¡æ ¸'
        elif self.reward_claimed:
            status = 'approved'
            status_display = 'å·²å‘æ”¾'
        else:
            status = 'waiting'
            status_display = 'ç­‰å¾…è´­ä¹°'
        
        return {
            'id': self.id,
            'inviter_tg': self.inviter_tg,
            'inviter_name': inviter_name,
            'invitee_tg': self.invitee_tg,
            'invitee_name': invitee_name,
            'invite_code': self.invite_code,
            'reward_type': self.reward_type,
            'reward_type_display': {
                'pending': 'å¾…å‘æ”¾',
                'days': 'å¤©æ•°å¥–åŠ±',
                'discount': 'æŠ˜æ‰£å¥–åŠ±',
                'credits': 'ç§¯åˆ†å¥–åŠ±'
            }.get(self.reward_type, self.reward_type),
            'reward_value': self.reward_value,
            'reward_claimed': self.reward_claimed,
            'pending_reward': self.pending_reward or 0,
            'status': status,
            'status_display': status_display,
            'reward_mode': self.reward_mode,
            'custom_reward_percent': self.custom_reward_percent,
            'created_at': self.created_at.isoformat() if self.created_at else None,
            'claimed_at': self.claimed_at.isoformat() if self.claimed_at else None
        }


def process_invite_reward(user, purchased_days, source='purchase'):
    """ç»Ÿä¸€å¤„ç†é‚€è¯·è¿”åˆ©é€»è¾‘
    
    è´­ä¹°åä¸ç›´æ¥åˆ°è´¦ï¼Œè€Œæ˜¯è®°å½•ä¸º"å¾…å®¡æ ¸"ï¼Œç®¡ç†å‘˜åœ¨åå°ç¡®è®¤åæ‰å‘æ”¾åˆ°é‚€è¯·äººè´¦æˆ·ã€‚
    
    Args:
        user: è¢«é‚€è¯·äºº User å¯¹è±¡
        purchased_days: è´­ä¹°/å…‘æ¢çš„å¤©æ•°
        source: æ¥æºæ ‡è¯†ï¼ˆpurchase/redeem/manual ç­‰ï¼‰ï¼Œç”¨äºæ—¥å¿—
    
    Returns:
        dict: {'success': bool, 'reward_days': int, 'status': 'pending'} æˆ– None
    """
    try:
        _invite_cfg = get_system_config().get('invite_reward', {})
        _invite_enabled = _invite_cfg.get('enabled', True)
        if not _invite_enabled:
            return None
        
        invite_record = InviteRecord.query.filter_by(invitee_tg=user.tg).first()
        if not invite_record:
            return None
        
        inviter = db.session.get(User, invite_record.inviter_tg)
        if not inviter:
            return None
        
        # ç¡®å®šè¿”åˆ©æ¨¡å¼ï¼šUserè¡¨ > InviteRecord > å…¨å±€
        global_mode = _invite_cfg.get('reward_mode', 'recurring')
        effective_mode = inviter.invite_reward_mode or invite_record.reward_mode or global_mode
        
        # ä¸€æ¬¡æ€§æ¨¡å¼ï¼šå¦‚æœå·²ç»å‘æ”¾è¿‡ï¼ˆreward_claimed=Trueï¼‰ï¼Œè·³è¿‡
        if effective_mode == 'once' and invite_record.reward_claimed:
            return None
        
        # ç¡®å®šè¿”åˆ©æ¯”ä¾‹ï¼šUserè¡¨ > InviteRecord > å…¨å±€
        global_pct = _invite_cfg.get('reward_percent', 10)
        user_pct = inviter.invite_reward_percent
        record_pct = invite_record.custom_reward_percent
        effective_pct = user_pct if user_pct is not None else (record_pct if record_pct is not None else global_pct)
        _reward_pct = effective_pct / 100.0
        _min_reward = _invite_cfg.get('min_reward_days', 1)
        
        # è®¡ç®—è¿”åˆ©å¤©æ•°
        reward_days = max(_min_reward, int(purchased_days * _reward_pct))
        
        # ä¸ç›´æ¥åˆ°è´¦ï¼Œè®°å½•ä¸ºå¾…å®¡æ ¸
        invite_record.reward_type = 'days'
        invite_record.pending_reward = (invite_record.pending_reward or 0) + reward_days
        
        app.logger.info(
            f'é‚€è¯·è¿”åˆ©å¾…å®¡æ ¸({source}): é‚€è¯·äºº={inviter.name}, è¢«é‚€è¯·äºº={user.name}, '
            f'å¾…å®¡æ ¸å¤©æ•°={reward_days}(æ¯”ä¾‹{effective_pct}%, æ¨¡å¼={effective_mode})'
        )
        
        return {
            'success': True,
            'inviter_name': inviter.name,
            'reward_days': reward_days,
            'effective_pct': effective_pct,
            'effective_mode': effective_mode,
            'status': 'pending'
        }
    except Exception as e:
        app.logger.error(f'é‚€è¯·è¿”åˆ©å¤„ç†å¼‚å¸¸({source}): {e}')
        return None


class RedeemCode(db.Model):
    """å…‘æ¢ç è¡¨"""
    __tablename__ = 'redeem_codes'
    
    id = db.Column(db.Integer, primary_key=True)
    code = db.Column(db.String(32), unique=True, nullable=False)  # å…‘æ¢ç 
    code_type = db.Column(db.String(20), nullable=False)  # new: æ–°è®¢é˜…, renew: ç»­è´¹
    plan_type = db.Column(db.String(50), nullable=False)  # basic, standard, premium, ultimate
    duration_days = db.Column(db.Integer, nullable=False)  # æœ‰æ•ˆå¤©æ•°
    is_used = db.Column(db.Boolean, default=False)  # æ˜¯å¦å·²ä½¿ç”¨
    is_active = db.Column(db.Boolean, default=True)  # æ˜¯å¦å¯ç”¨
    used_by = db.Column(db.BigInteger, db.ForeignKey('emby.tg'))  # ä½¿ç”¨è€…
    used_at = db.Column(db.DateTime)  # ä½¿ç”¨æ—¶é—´
    created_at = db.Column(db.DateTime, default=lambda: datetime.now())
    expires_at = db.Column(db.DateTime)  # å…‘æ¢ç è¿‡æœŸæ—¶é—´ï¼ˆå¯é€‰ï¼‰
    remark = db.Column(db.String(200))  # å¤‡æ³¨
    
    def to_dict(self):
        user_name = None
        if self.used_by:
            user = User.query.filter_by(tg=self.used_by).first()
            user_name = user.name if user else str(self.used_by)
        
        # è·å–å¥—é¤åç§°
        plan_name = self.plan_type
        if self.plan_type == 'custom':
            plan_name = 'è‡ªå®šä¹‰æ—¶é•¿'
        else:
            plans = load_plans_config()
            for plan in plans:
                if plan.get('id') == self.plan_type:
                    plan_name = plan.get('name', self.plan_type)
                    break
        
        return {
            'id': self.id,
            'code': self.code,
            'code_type': self.code_type,
            'plan_type': self.plan_type,
            'plan_name': plan_name,
            'duration_days': self.duration_days,
            'is_used': self.is_used,
            'is_active': self.is_active,
            'used_by': self.used_by,
            'used_by_name': user_name,
            'used_at': self.used_at.isoformat() if self.used_at else None,
            'created_at': self.created_at.isoformat() if self.created_at else None,
            'expires_at': self.expires_at.isoformat() if self.expires_at else None,
            'remark': self.remark
        }


class SupportTicket(db.Model):
    """æŠ€æœ¯æ”¯æŒå·¥å•è¡¨"""
    __tablename__ = 'support_tickets'
    
    id = db.Column(db.Integer, primary_key=True)
    ticket_no = db.Column(db.String(32), unique=True, nullable=False)  # å·¥å•å·
    user_tg = db.Column(db.BigInteger, db.ForeignKey('emby.tg'), nullable=False)
    category = db.Column(db.String(50), nullable=False)  # account, payment, technical, content, other
    subject = db.Column(db.String(200), nullable=False)  # ä¸»é¢˜
    description = db.Column(db.Text, nullable=False)  # è¯¦ç»†æè¿°ï¼ˆåˆå§‹é—®é¢˜ï¼‰
    status = db.Column(db.String(20), default='open')  # open=å¾…å¤„ç†, in_progress=å¤„ç†ä¸­(ç®¡ç†å‘˜å·²å›å¤), closed=å·²å…³é—­
    priority = db.Column(db.String(20), default='normal')  # low, normal, high, urgent
    admin_reply = db.Column(db.Text)  # ç®¡ç†å‘˜æœ€æ–°å›å¤ï¼ˆä¿ç•™å…¼å®¹ï¼‰
    last_reply_by = db.Column(db.String(20), default='user')  # æœ€åå›å¤æ–¹: user æˆ– admin
    last_reply_at = db.Column(db.DateTime)  # æœ€åå›å¤æ—¶é—´
    created_at = db.Column(db.DateTime, default=lambda: datetime.now())
    updated_at = db.Column(db.DateTime, default=lambda: datetime.now(), onupdate=lambda: datetime.now())
    resolved_at = db.Column(db.DateTime)  # å…³é—­æ—¶é—´
    
    # å…³ç³»
    messages = db.relationship('TicketMessage', backref='ticket', lazy=True, order_by='TicketMessage.created_at')
    
    def to_dict(self, include_messages=False):
        # è·å–ç”¨æˆ·å
        user = User.query.filter_by(tg=self.user_tg).first()
        result = {
            'id': self.id,
            'ticket_no': self.ticket_no,
            'user_tg': self.user_tg,
            'user_name': (user.emby_name or user.name) if user else str(self.user_tg),
            'subject': self.subject,
            'description': self.description,
            'status': self.status,
            'priority': self.priority,
            'admin_reply': self.admin_reply,
            'last_reply_by': self.last_reply_by,
            'last_reply_at': self.last_reply_at.isoformat() if self.last_reply_at else None,
            'created_at': self.created_at.isoformat() if self.created_at else None,
            'updated_at': self.updated_at.isoformat() if self.updated_at else None,
            'resolved_at': self.resolved_at.isoformat() if self.resolved_at else None,
            'message_count': len(self.messages) if self.messages else 0
        }
        if include_messages:
            result['messages'] = [msg.to_dict() for msg in self.messages]
        return result
    
    def can_retry(self):
        """æ£€æŸ¥æ˜¯å¦å¯ä»¥é‡è¯•"""
        return self.retry_count < self.max_retries and self.status == 'failed'


class TicketMessage(db.Model):
    """å·¥å•æ¶ˆæ¯è¡¨ - æ”¯æŒå¤šè½®å¯¹è¯"""
    __tablename__ = 'ticket_messages'
    
    id = db.Column(db.Integer, primary_key=True)
    ticket_id = db.Column(db.Integer, db.ForeignKey('support_tickets.id'), nullable=False)
    sender_type = db.Column(db.String(20), nullable=False)  # user æˆ– admin
    sender_id = db.Column(db.BigInteger)  # å‘é€è€…IDï¼ˆç”¨æˆ·tgæˆ–ç®¡ç†å‘˜æ ‡è¯†ï¼‰
    sender_name = db.Column(db.String(100))  # å‘é€è€…åç§°
    content = db.Column(db.Text, nullable=False)  # æ¶ˆæ¯å†…å®¹
    created_at = db.Column(db.DateTime, default=lambda: datetime.now())
    
    def to_dict(self):
        return {
            'id': self.id,
            'ticket_id': self.ticket_id,
            'sender_type': self.sender_type,
            'sender_id': self.sender_id,
            'sender_name': self.sender_name,
            'content': self.content,
            'created_at': self.created_at.isoformat() if self.created_at else None
        }


class ServerLine(db.Model):
    """æœåŠ¡å™¨çº¿è·¯è¡¨"""
    __tablename__ = 'server_lines'
    
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False)  # çº¿è·¯åç§°ï¼Œå¦‚ï¼šä¸»çº¿è·¯ã€å¤‡ç”¨çº¿è·¯
    server_url = db.Column(db.String(255), nullable=False)  # æœåŠ¡å™¨åœ°å€
    port = db.Column(db.Integer, default=8096)  # ç«¯å£
    is_https = db.Column(db.Boolean, default=False)  # æ˜¯å¦HTTPS
    description = db.Column(db.String(500))  # çº¿è·¯æè¿°
    access_level = db.Column(db.String(20), default='whitelist')  # è®¿é—®çº§åˆ«(å…¼å®¹æ—§æ•°æ®)
    allowed_plan_types = db.Column(db.String(500), default='')  # å…è®¸æŸ¥çœ‹çš„å¥—é¤ç±»å‹ï¼ˆé€—å·åˆ†éš”ï¼Œå¦‚ whitelist,basic,standardï¼‰
    sort_order = db.Column(db.Integer, default=0)  # æ’åºé¡ºåº
    is_active = db.Column(db.Boolean, default=True)  # æ˜¯å¦å¯ç”¨
    created_at = db.Column(db.DateTime, default=lambda: datetime.now())
    updated_at = db.Column(db.DateTime, default=lambda: datetime.now(), onupdate=lambda: datetime.now())
    
    def to_dict(self, include_sensitive=True):
        """è½¬æ¢ä¸ºå­—å…¸
        Args:
            include_sensitive: æ˜¯å¦åŒ…å«æ•æ„Ÿä¿¡æ¯ï¼ˆå®Œæ•´URLï¼‰
        """
        plan_types_list = [t.strip() for t in (self.allowed_plan_types or '').split(',') if t.strip()]
        base_dict = {
            'id': self.id,
            'name': self.name,
            'description': self.description,
            'access_level': self.access_level,
            'allowed_plan_types': plan_types_list,
            'sort_order': self.sort_order,
            'is_active': self.is_active,
        }
        
        if include_sensitive:
            protocol = 'https' if self.is_https else 'http'
            base_dict['server_url'] = self.server_url
            base_dict['port'] = self.port
            base_dict['is_https'] = self.is_https
            base_dict['full_url'] = f"{protocol}://{self.server_url}:{self.port}"
        
        return base_dict
    
    def get_access_level_name(self):
        """è·å–è®¿é—®çº§åˆ«åç§°"""
        names = {
            'whitelist': 'ç™½åå•ç”¨æˆ·',
            'subscriber': 'è®¢é˜…ç”¨æˆ·',
            'all': 'æ‰€æœ‰ç”¨æˆ·'
        }
        return names.get(self.access_level, self.access_level)


class UserActivityLog(db.Model):
    """ç”¨æˆ·æ“ä½œæ—¥å¿—è¡¨ - è®°å½•æ‰€æœ‰ç”¨æˆ·æ“ä½œ"""
    __tablename__ = 'user_activity_logs'
    
    id = db.Column(db.Integer, primary_key=True)
    user_tg = db.Column(db.BigInteger, db.ForeignKey('emby.tg'), nullable=True)  # ç”¨æˆ·TG IDï¼Œå¯ä¸ºç©ºï¼ˆæœªç™»å½•æ“ä½œï¼‰
    user_name = db.Column(db.String(100))  # ç”¨æˆ·åï¼ˆå†—ä½™å­˜å‚¨ï¼Œæ–¹ä¾¿æŸ¥è¯¢ï¼‰
    action_type = db.Column(db.String(50), nullable=False)  # æ“ä½œç±»å‹
    action_detail = db.Column(db.Text)  # æ“ä½œè¯¦æƒ…ï¼ˆJSONæ ¼å¼ï¼‰
    ip_address = db.Column(db.String(50))  # IPåœ°å€
    user_agent = db.Column(db.String(500))  # æµè§ˆå™¨/å®¢æˆ·ç«¯ä¿¡æ¯
    status = db.Column(db.String(20), default='success')  # æ“ä½œçŠ¶æ€: success, failed
    extra_data = db.Column(db.Text)  # é¢å¤–æ•°æ®ï¼ˆJSONæ ¼å¼ï¼‰
    created_at = db.Column(db.DateTime, default=lambda: datetime.now())
    
    # å…³è”ç”¨æˆ·
    user = db.relationship('User', backref=db.backref('activity_logs', lazy='dynamic'))
    
    # æ“ä½œç±»å‹å¸¸é‡
    ACTION_LOGIN = 'login'  # ç™»å½•
    ACTION_LOGOUT = 'logout'  # ç™»å‡º
    ACTION_REGISTER = 'register'  # æ³¨å†Œ
    ACTION_PASSWORD_CHANGE = 'password_change'  # ä¿®æ”¹å¯†ç 
    ACTION_PASSWORD_RESET = 'password_reset'  # å¿˜è®°å¯†ç é‡ç½®
    ACTION_REQUEST_MOVIE = 'request_movie'  # æ±‚ç‰‡
    ACTION_CANCEL_REQUEST = 'cancel_request'  # å–æ¶ˆæ±‚ç‰‡
    ACTION_REDEEM_CODE = 'redeem_code'  # å…‘æ¢ç 
    ACTION_CREATE_ORDER = 'create_order'  # åˆ›å»ºè®¢å•
    ACTION_PAYMENT_SUCCESS = 'payment_success'  # æ”¯ä»˜æˆåŠŸ
    ACTION_PAYMENT_FAILED = 'payment_failed'  # æ”¯ä»˜å¤±è´¥
    ACTION_SUBMIT_TICKET = 'submit_ticket'  # æäº¤å·¥å•
    ACTION_REPLY_TICKET = 'reply_ticket'  # å›å¤å·¥å•
    ACTION_BIND_TELEGRAM = 'bind_telegram'  # ç»‘å®šTelegram
    ACTION_PLAYBACK_START = 'playback_start'  # å¼€å§‹æ’­æ”¾
    ACTION_DEVICE_BLOCKED = 'device_blocked'  # è®¾å¤‡è¢«å°ç¦
    ACTION_ACCOUNT_BANNED = 'account_banned'  # è´¦å·è¢«å°ç¦
    ACTION_ACCOUNT_UNBANNED = 'account_unbanned'  # è´¦å·è§£å°
    ACTION_LEVEL_CHANGE = 'level_change'  # ç­‰çº§å˜æ›´
    ACTION_SUBSCRIPTION_CHANGE = 'subscription_change'  # è®¢é˜…å˜æ›´
    ACTION_INVITE_USED = 'invite_used'  # ä½¿ç”¨é‚€è¯·ç 
    ACTION_INVITE_CREATED = 'invite_created'  # åˆ›å»ºé‚€è¯·ç 
    ACTION_VIEW_LINES = 'view_lines'  # æŸ¥çœ‹çº¿è·¯
    ACTION_EMBY_ACCOUNT_CREATE = 'emby_account_create'  # åˆ›å»ºEmbyè´¦å·
    ACTION_EMBY_PASSWORD_RESET = 'emby_password_reset'  # é‡ç½®Embyå¯†ç 
    ACTION_COIN_CHANGE = 'coin_change'  # ç§¯åˆ†å˜æ›´
    ACTION_SUBSCRIPTION_GIFT = 'subscription_gift'  # èµ é€è®¢é˜…
    ACTION_SUBSCRIPTION_REDUCE = 'subscription_reduce'  # å‡å°‘è®¢é˜…
    
    def to_dict(self):
        # æ˜¾ç¤ºæ—¶é—´ï¼ˆæ•°æ®åº“å­˜å‚¨çš„æ˜¯æœ¬åœ°æ—¶é—´ï¼‰
        created_at_local = None
        if self.created_at:
            created_at_local = self.created_at.strftime('%Y-%m-%d %H:%M:%S')
        
        return {
            'id': self.id,
            'user_tg': self.user_tg,
            'user_name': self.user_name,
            'action_type': self.action_type,
            'action_type_display': self.get_action_display(),
            'action_detail': self.action_detail,
            'ip_address': self.ip_address,
            'user_agent': self.user_agent,
            'status': self.status,
            'extra_data': self.extra_data,
            'created_at': created_at_local
        }
    
    def get_action_display(self):
        """è·å–æ“ä½œç±»å‹çš„ä¸­æ–‡æ˜¾ç¤ºåç§°"""
        displays = {
            'login': 'ğŸ” ç™»å½•',
            'logout': 'ğŸšª ç™»å‡º',
            'register': 'ğŸ“ æ³¨å†Œ',
            'password_change': 'ğŸ”‘ ä¿®æ”¹å¯†ç ',
            'password_reset': 'ğŸ”“ é‡ç½®å¯†ç ',
            'request_movie': 'ğŸ¬ æäº¤æ±‚ç‰‡',
            'cancel_request': 'âŒ å–æ¶ˆæ±‚ç‰‡',
            'redeem_code': 'ğŸŸï¸ å…‘æ¢ç ',
            'create_order': 'ğŸ›’ åˆ›å»ºè®¢å•',
            'payment_success': 'ğŸ’³ æ”¯ä»˜æˆåŠŸ',
            'payment_failed': 'âŒ æ”¯ä»˜å¤±è´¥',
            'submit_ticket': 'ğŸ« æäº¤å·¥å•',
            'reply_ticket': 'ğŸ’¬ å›å¤å·¥å•',
            'bind_telegram': 'ğŸ¤– ç»‘å®šTelegram',
            'playback_start': 'â–¶ï¸ å¼€å§‹æ’­æ”¾',
            'device_blocked': 'ğŸš« è®¾å¤‡å°ç¦',
            'account_banned': 'â›” è´¦å·å°ç¦',
            'account_unbanned': 'âœ… è´¦å·è§£å°',
            'level_change': 'ğŸ“Š ç­‰çº§å˜æ›´',
            'subscription_change': 'ğŸ’ è®¢é˜…å˜æ›´',
            'invite_used': 'ğŸ ä½¿ç”¨é‚€è¯·ç ',
            'invite_created': 'ğŸ åˆ›å»ºé‚€è¯·ç ',
            'view_lines': 'ğŸ”— æŸ¥çœ‹çº¿è·¯',
            'emby_account_create': 'ğŸ†• åˆ›å»ºEmbyè´¦å·',
            'emby_password_reset': 'ğŸ”„ é‡ç½®Embyå¯†ç ',
            'coin_change': 'ğŸ’° ç§¯åˆ†å˜æ›´',
            'subscription_gift': 'ğŸ èµ é€è®¢é˜…',
            'subscription_reduce': 'â³ å‡å°‘è®¢é˜…',
        }
        return displays.get(self.action_type, self.action_type)


class DeviceBlacklist(db.Model):
    """è®¾å¤‡é»‘åå•è§„åˆ™è¡¨"""
    __tablename__ = 'device_blacklist'
    
    id = db.Column(db.Integer, primary_key=True)
    rule_name = db.Column(db.String(100), nullable=False)  # è§„åˆ™åç§°
    client_pattern = db.Column(db.String(255))  # å®¢æˆ·ç«¯åŒ¹é…æ¨¡å¼ï¼ˆæ”¯æŒé€šé…ç¬¦ï¼‰
    device_name_pattern = db.Column(db.String(255))  # è®¾å¤‡åç§°åŒ¹é…æ¨¡å¼
    action = db.Column(db.String(20), default='stop_only')  # å¤„ç†æ–¹å¼: stop_only(ä»…åœæ­¢æ’­æ”¾), stop_and_ban(åœæ­¢+ç¦ç”¨è´¦å·)
    is_enabled = db.Column(db.Boolean, default=True)  # æ˜¯å¦å¯ç”¨
    description = db.Column(db.String(500))  # è§„åˆ™æè¿°
    created_at = db.Column(db.DateTime, default=lambda: datetime.now())
    updated_at = db.Column(db.DateTime, default=lambda: datetime.now(), onupdate=lambda: datetime.now())
    
    def matches(self, client, device_name):
        """æ£€æŸ¥è®¾å¤‡æ˜¯å¦åŒ¹é…æ­¤è§„åˆ™"""
        if not self.is_enabled:
            return False
        
        import re
        
        # æ£€æŸ¥å®¢æˆ·ç«¯åŒ¹é…
        if self.client_pattern:
            # å°†é€šé…ç¬¦è½¬æ¢ä¸ºæ­£åˆ™è¡¨è¾¾å¼
            pattern = self.client_pattern.replace('*', '.*').replace('?', '.')
            if not re.search(pattern, client or '', re.IGNORECASE):
                return False
        
        # æ£€æŸ¥è®¾å¤‡åç§°åŒ¹é…
        if self.device_name_pattern:
            pattern = self.device_name_pattern.replace('*', '.*').replace('?', '.')
            if not re.search(pattern, device_name or '', re.IGNORECASE):
                return False
        
        return True
    
    def to_dict(self):
        return {
            'id': self.id,
            'rule_name': self.rule_name,
            'client_pattern': self.client_pattern,
            'device_name_pattern': self.device_name_pattern,
            'action': self.action,
            'is_enabled': self.is_enabled,
            'description': self.description,
            'created_at': self.created_at.isoformat() if self.created_at else None,
            'updated_at': self.updated_at.isoformat() if self.updated_at else None
        }


class AdminAuditLog(db.Model):
    """ç®¡ç†å‘˜æ“ä½œå®¡è®¡æ—¥å¿—è¡¨ - è®°å½•æ‰€æœ‰ç®¡ç†åå°æ“ä½œ"""
    __tablename__ = 'admin_audit_logs'
    
    id = db.Column(db.Integer, primary_key=True)
    admin_username = db.Column(db.String(100), nullable=False, index=True)  # ç®¡ç†å‘˜ç”¨æˆ·å
    admin_id = db.Column(db.Integer, nullable=True)  # ç®¡ç†å‘˜IDï¼ˆå¯ä¸ºç©ºï¼Œå…¼å®¹æ—§sessionï¼‰
    action_type = db.Column(db.String(50), nullable=False, index=True)  # æ“ä½œç±»å‹
    action_detail = db.Column(db.Text)  # æ“ä½œè¯¦æƒ…
    target_type = db.Column(db.String(50))  # ç›®æ ‡ç±»å‹ (user, order, config, etc.)
    target_id = db.Column(db.String(100))  # ç›®æ ‡ID
    ip_address = db.Column(db.String(50))  # æ“ä½œIP
    user_agent = db.Column(db.String(500))  # æµè§ˆå™¨ä¿¡æ¯
    created_at = db.Column(db.DateTime, default=lambda: datetime.now(), index=True)
    
    # æ“ä½œç±»å‹å¸¸é‡
    ACTION_LOGIN = 'admin_login'
    ACTION_LOGOUT = 'admin_logout'
    ACTION_CONFIG_CHANGE = 'config_change'
    ACTION_USER_BAN = 'user_ban'
    ACTION_USER_UNBAN = 'user_unban'
    ACTION_USER_LEVEL_CHANGE = 'user_level_change'
    ACTION_USER_RESET_PASSWORD = 'user_reset_password'
    ACTION_USER_GIFT_SUB = 'user_gift_subscription'
    ACTION_USER_REDUCE_SUB = 'user_reduce_subscription'
    ACTION_ORDER_MARK_PAID = 'order_mark_paid'
    ACTION_ORDER_CANCEL = 'order_cancel'
    ACTION_REDEEM_CREATE = 'redeem_create'
    ACTION_REDEEM_DELETE = 'redeem_delete'
    ACTION_REDEEM_TOGGLE = 'redeem_toggle'
    ACTION_PLAN_CHANGE = 'plan_change'
    ACTION_ADMIN_CREATE = 'admin_create'
    ACTION_ADMIN_DELETE = 'admin_delete'
    ACTION_ADMIN_UPDATE = 'admin_update'
    ACTION_EXPORT_DATA = 'export_data'
    ACTION_BATCH_OPERATION = 'batch_operation'
    ACTION_ANNOUNCEMENT = 'announcement'
    ACTION_KNOWLEDGE = 'knowledge'
    ACTION_LINE_CHANGE = 'line_change'
    ACTION_DEVICE_RULE = 'device_rule'
    
    def to_dict(self):
        return {
            'id': self.id,
            'admin_username': self.admin_username,
            'admin_id': self.admin_id,
            'action_type': self.action_type,
            'action_type_display': self.get_action_display(),
            'action_detail': self.action_detail,
            'target_type': self.target_type,
            'target_id': self.target_id,
            'ip_address': self.ip_address,
            'created_at': self.created_at.strftime('%Y-%m-%d %H:%M:%S') if self.created_at else None
        }
    
    def get_action_display(self):
        """è·å–æ“ä½œç±»å‹çš„ä¸­æ–‡æ˜¾ç¤º"""
        displays = {
            'admin_login': 'ğŸ” ç®¡ç†å‘˜ç™»å½•',
            'admin_logout': 'ğŸšª ç®¡ç†å‘˜ç™»å‡º',
            'config_change': 'âš™ï¸ ä¿®æ”¹é…ç½®',
            'user_ban': 'â›” å°ç¦ç”¨æˆ·',
            'user_unban': 'âœ… è§£å°ç”¨æˆ·',
            'user_level_change': 'ğŸ“Š ä¿®æ”¹ç”¨æˆ·ç­‰çº§',
            'user_reset_password': 'ğŸ”‘ é‡ç½®ç”¨æˆ·å¯†ç ',
            'user_gift_subscription': 'ğŸ èµ é€è®¢é˜…',
            'user_reduce_subscription': 'â³ å‡å°‘è®¢é˜…',
            'order_mark_paid': 'ğŸ’³ æ‰‹åŠ¨æ ‡è®°ä»˜æ¬¾',
            'order_cancel': 'âŒ å–æ¶ˆè®¢å•',
            'redeem_create': 'ğŸŸï¸ åˆ›å»ºå…‘æ¢ç ',
            'redeem_delete': 'ğŸ—‘ï¸ åˆ é™¤å…‘æ¢ç ',
            'redeem_toggle': 'ğŸ”„ åˆ‡æ¢å…‘æ¢ç çŠ¶æ€',
            'plan_change': 'ğŸ’° ä¿®æ”¹å¥—é¤',
            'admin_create': 'ğŸ‘¤ åˆ›å»ºç®¡ç†å‘˜',
            'admin_delete': 'ğŸ—‘ï¸ åˆ é™¤ç®¡ç†å‘˜',
            'admin_update': 'âœï¸ ä¿®æ”¹ç®¡ç†å‘˜',
            'admin_change_password': 'ğŸ”‘ ç®¡ç†å‘˜ä¿®æ”¹å¯†ç ',
            'export_data': 'ğŸ“¥ å¯¼å‡ºæ•°æ®',
            'batch_operation': 'ğŸ“‹ æ‰¹é‡æ“ä½œ',
            'announcement': 'ğŸ“¢ å…¬å‘Šç®¡ç†',
            'knowledge': 'ğŸ“š çŸ¥è¯†åº“ç®¡ç†',
            'line_change': 'ğŸ”— çº¿è·¯ç®¡ç†',
            'device_rule': 'ğŸ“± è®¾å¤‡è§„åˆ™',
        }
        return displays.get(self.action_type, self.action_type)


class UserDevice(db.Model):
    """ç”¨æˆ·è®¾å¤‡è®°å½•è¡¨"""
    __tablename__ = 'user_devices'
    
    id = db.Column(db.Integer, primary_key=True)
    user_tg = db.Column(db.BigInteger, db.ForeignKey('emby.tg'), nullable=False)
    device_id = db.Column(db.String(255), nullable=False)  # Emby è®¾å¤‡ ID
    device_name = db.Column(db.String(255))  # è®¾å¤‡åç§°
    client = db.Column(db.String(100))  # å®¢æˆ·ç«¯ç±»å‹ (Emby Web, iOS, Android ç­‰)
    client_version = db.Column(db.String(50))  # å®¢æˆ·ç«¯ç‰ˆæœ¬
    last_ip = db.Column(db.String(50))  # æœ€åä½¿ç”¨çš„ IP
    last_active = db.Column(db.DateTime)  # æœ€åæ´»è·ƒæ—¶é—´
    is_blocked = db.Column(db.Boolean, default=False)  # æ˜¯å¦è¢«ç¦ç”¨
    created_at = db.Column(db.DateTime, default=lambda: datetime.now())
    updated_at = db.Column(db.DateTime, default=lambda: datetime.now(), onupdate=lambda: datetime.now())
    
    # å¤åˆå”¯ä¸€ç´¢å¼•ï¼šåŒä¸€ç”¨æˆ·çš„åŒä¸€è®¾å¤‡
    __table_args__ = (
        db.UniqueConstraint('user_tg', 'device_id', name='uix_user_device'),
    )
    
    def to_dict(self):
        user = User.query.filter_by(tg=self.user_tg).first()
        # ç¡®ä¿ last_active å¸¦æ—¶åŒºä¿¡æ¯ï¼ˆUTCï¼‰
        last_active_str = None
        if self.last_active:
            if self.last_active.tzinfo is None:
                # å¦‚æœæ²¡æœ‰æ—¶åŒºä¿¡æ¯ï¼Œå‡å®šæ˜¯ UTC
                last_active_str = self.last_active.isoformat() + 'Z'
            else:
                last_active_str = self.last_active.isoformat()
        
        created_at_str = None
        if self.created_at:
            if self.created_at.tzinfo is None:
                created_at_str = self.created_at.isoformat() + 'Z'
            else:
                created_at_str = self.created_at.isoformat()
        
        return {
            'id': self.id,
            'user_tg': self.user_tg,
            'user_name': (user.emby_name or user.name) if user else str(self.user_tg),
            'device_id': self.device_id,
            'device_name': self.device_name,
            'client': self.client,
            'client_version': self.client_version,
            'last_ip': self.last_ip,
            'last_active': last_active_str,
            'is_blocked': self.is_blocked,
            'created_at': created_at_str
        }


class Announcement(db.Model):
    """ç³»ç»Ÿå…¬å‘Šè¡¨"""
    __tablename__ = 'announcements'
    
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(200), nullable=False)  # å…¬å‘Šæ ‡é¢˜
    content = db.Column(db.Text, nullable=False)  # å…¬å‘Šå†…å®¹
    type = db.Column(db.String(20), default='info')  # å…¬å‘Šç±»å‹: info, warning, success, error
    is_active = db.Column(db.Boolean, default=True)  # æ˜¯å¦å¯ç”¨
    is_pinned = db.Column(db.Boolean, default=False)  # æ˜¯å¦ç½®é¡¶
    start_time = db.Column(db.DateTime)  # å¼€å§‹æ˜¾ç¤ºæ—¶é—´
    end_time = db.Column(db.DateTime)  # ç»“æŸæ˜¾ç¤ºæ—¶é—´
    created_at = db.Column(db.DateTime, default=lambda: datetime.now())
    updated_at = db.Column(db.DateTime, default=lambda: datetime.now(), onupdate=lambda: datetime.now())
    
    def to_dict(self):
        return {
            'id': self.id,
            'title': self.title,
            'content': self.content,
            'type': self.type,
            'is_active': self.is_active,
            'is_pinned': self.is_pinned,
            'start_time': self.start_time.isoformat() + 'Z' if self.start_time else None,
            'end_time': self.end_time.isoformat() + 'Z' if self.end_time else None,
            'created_at': self.created_at.isoformat() + 'Z' if self.created_at else None,
            'updated_at': self.updated_at.isoformat() + 'Z' if self.updated_at else None
        }
    
    @staticmethod
    def get_active_announcements():
        """è·å–å½“å‰æœ‰æ•ˆçš„å…¬å‘Š"""
        now = datetime.now()
        query = Announcement.query.filter(Announcement.is_active == True)
        # è¿‡æ»¤æ—¶é—´èŒƒå›´
        query = query.filter(
            db.or_(Announcement.start_time == None, Announcement.start_time <= now)
        )
        query = query.filter(
            db.or_(Announcement.end_time == None, Announcement.end_time >= now)
        )
        # ç½®é¡¶çš„åœ¨å‰ï¼Œç„¶åæŒ‰åˆ›å»ºæ—¶é—´å€’åº
        return query.order_by(Announcement.is_pinned.desc(), Announcement.created_at.desc()).all()


class PlaybackRecord(db.Model):
    """æ’­æ”¾è®°å½•è¡¨"""
    __tablename__ = 'playback_records'
    
    id = db.Column(db.Integer, primary_key=True)
    user_tg = db.Column(db.BigInteger, db.ForeignKey('emby.tg'), nullable=False)
    device_id = db.Column(db.Integer, db.ForeignKey('user_devices.id'))  # å…³è”è®¾å¤‡
    emby_item_id = db.Column(db.String(100))  # Emby åª’ä½“ ID
    item_name = db.Column(db.String(255))  # åª’ä½“åç§°
    item_type = db.Column(db.String(50))  # Movie, Episode ç­‰
    series_name = db.Column(db.String(255))  # å‰§é›†åç§°ï¼ˆå¦‚æœæ˜¯å‰§é›†ï¼‰
    season_number = db.Column(db.Integer)  # å­£æ•°
    episode_number = db.Column(db.Integer)  # é›†æ•°
    play_duration = db.Column(db.Integer, default=0)  # æ’­æ”¾æ—¶é•¿ï¼ˆç§’ï¼‰
    total_duration = db.Column(db.Integer, default=0)  # æ€»æ—¶é•¿ï¼ˆç§’ï¼‰
    play_percentage = db.Column(db.Float, default=0)  # æ’­æ”¾è¿›åº¦ç™¾åˆ†æ¯”
    play_method = db.Column(db.String(50))  # DirectPlay, Transcode
    started_at = db.Column(db.DateTime, default=lambda: datetime.now())  # å¼€å§‹æ’­æ”¾æ—¶é—´
    ended_at = db.Column(db.DateTime)  # ç»“æŸæ’­æ”¾æ—¶é—´
    client_ip = db.Column(db.String(50))  # å®¢æˆ·ç«¯ IP
    
    # å…³ç³»
    device = db.relationship('UserDevice', backref='playback_records')
    
    def to_dict(self):
        user = User.query.filter_by(tg=self.user_tg).first()
        device = db.session.get(UserDevice, self.device_id) if self.device_id else None
        
        # ç»„åˆæ˜¾ç¤ºåç§°
        display_name = self.item_name
        if self.item_type == 'Episode' and self.series_name:
            if self.season_number and self.episode_number:
                display_name = f"{self.series_name} S{self.season_number:02d}E{self.episode_number:02d} - {self.item_name}"
            else:
                display_name = f"{self.series_name} - {self.item_name}"
        
        return {
            'id': self.id,
            'user_tg': self.user_tg,
            'user_name': (user.emby_name or user.name) if user else str(self.user_tg),
            'device_id': self.device_id,
            'device_name': device.device_name if device else 'æœªçŸ¥è®¾å¤‡',
            'client': device.client if device else None,
            'emby_item_id': self.emby_item_id,
            'item_name': self.item_name,
            'display_name': display_name,
            'item_type': self.item_type,
            'series_name': self.series_name,
            'season_number': self.season_number,
            'episode_number': self.episode_number,
            'play_duration': self.play_duration,
            'total_duration': self.total_duration,
            'play_percentage': min(100.0, self.play_percentage) if self.play_percentage else 0,
            'play_method': self.play_method,
            'started_at': self.started_at.isoformat() if self.started_at else None,
            'ended_at': self.ended_at.isoformat() if self.ended_at else None,
            'client_ip': self.client_ip
        }


class SystemConfig(db.Model):
    """ç³»ç»Ÿé…ç½®è¡¨ - å­˜å‚¨æ‰€æœ‰åå°è®¾ç½®"""
    __tablename__ = 'system_config'
    
    id = db.Column(db.Integer, primary_key=True)
    config_key = db.Column(db.String(100), unique=True, nullable=False, index=True)  # é…ç½®åˆ†ç±»é”®
    config_value = db.Column(db.Text, nullable=True)  # JSON æ ¼å¼å­˜å‚¨é…ç½®å€¼
    description = db.Column(db.String(255), nullable=True)  # é…ç½®æè¿°
    updated_at = db.Column(db.DateTime, default=lambda: datetime.now(), 
                          onupdate=lambda: datetime.now())  # æ›´æ–°æ—¶é—´
    
    # é…ç½®é”®å¸¸é‡
    KEY_ADMIN = 'admin'              # ç®¡ç†å‘˜é…ç½®
    KEY_EMBY = 'emby'                # Emby æœåŠ¡å™¨é…ç½®
    KEY_TELEGRAM = 'telegram'        # Telegram BOTé…ç½®
    KEY_TMDB = 'tmdb'                # TMDB API é…ç½®
    KEY_MOVIEPILOT = 'moviepilot'    # MoviePilot é…ç½®
    KEY_QBITTORRENT = 'qbittorrent'  # qBittorrent é…ç½®
    KEY_SEARCH = 'search'            # æœç´¢ç­–ç•¥é…ç½®
    KEY_REQUEST_LIMIT = 'request_limit'  # æ±‚ç‰‡é™åˆ¶é…ç½®
    KEY_CATEGORY = 'category'        # äºŒçº§åˆ†ç±»ç­–ç•¥
    KEY_EPAY = 'epay'                # æ˜“æ”¯ä»˜é…ç½®
    KEY_SITE = 'site'                # å‰ç«¯ç«™ç‚¹é…ç½®
    KEY_PLANS = 'plans'              # å¥—é¤é…ç½®
    KEY_PROXY = 'proxy'              # ä»£ç†é…ç½®
    KEY_CHECKIN = 'checkin'          # ç­¾åˆ°ç³»ç»Ÿé…ç½®
    
    @staticmethod
    def get_config(key: str, default=None):
        """è·å–æŒ‡å®šé…ç½®"""
        try:
            config = SystemConfig.query.filter_by(config_key=key).first()
            if config and config.config_value:
                return json.loads(config.config_value)
            return default
        except Exception as e:
            print(f"[WARNING] è·å–é…ç½® {key} å¤±è´¥: {e}")
            return default
    
    @staticmethod
    def set_config(key: str, value: dict, description: str = None):
        """è®¾ç½®æŒ‡å®šé…ç½®"""
        try:
            config = SystemConfig.query.filter_by(config_key=key).first()
            if config:
                config.config_value = json.dumps(value, ensure_ascii=False)
                if description:
                    config.description = description
            else:
                config = SystemConfig(
                    config_key=key,
                    config_value=json.dumps(value, ensure_ascii=False),
                    description=description
                )
                db.session.add(config)
            db.session.commit()
            return True
        except Exception as e:
            print(f"[ERROR] ä¿å­˜é…ç½® {key} å¤±è´¥: {e}")
            db.session.rollback()
            return False
    
    @staticmethod
    def get_all_configs():
        """è·å–æ‰€æœ‰é…ç½®"""
        try:
            configs = SystemConfig.query.all()
            result = {}
            for config in configs:
                if config.config_value:
                    try:
                        result[config.config_key] = json.loads(config.config_value)
                    except:
                        result[config.config_key] = config.config_value
            return result
        except Exception as e:
            print(f"[WARNING] è·å–æ‰€æœ‰é…ç½®å¤±è´¥: {e}")
            return {}
    
    @staticmethod
    def delete_config(key: str):
        """åˆ é™¤æŒ‡å®šé…ç½®"""
        try:
            config = SystemConfig.query.filter_by(config_key=key).first()
            if config:
                db.session.delete(config)
                db.session.commit()
            return True
        except Exception as e:
            print(f"[ERROR] åˆ é™¤é…ç½® {key} å¤±è´¥: {e}")
            db.session.rollback()
            return False


# ==================== å¤šç®¡ç†å‘˜æƒé™ç³»ç»Ÿ ====================
# æƒé™åˆ†ç±»å®šä¹‰
ADMIN_PERMISSION_GROUPS = {
    'requests': 'æ±‚ç‰‡ç®¡ç†',
    'users': 'ç”¨æˆ·ç®¡ç†',
    'orders': 'è®¢å•ç®¡ç†',
    'redeem': 'å…‘æ¢ç ç®¡ç†',
    'playback': 'æ’­æ”¾ç›‘æ§',
    'tickets': 'å·¥å•ç®¡ç†',
    'invites': 'é‚€è¯·ç»Ÿè®¡',
    'plans': 'å¥—é¤é…ç½®',
    'knowledge': 'çŸ¥è¯†åº“',
    'settings': 'ç³»ç»Ÿè®¾ç½®',
    'dashboard': 'ä»ªè¡¨ç›˜',
}


class AdminUser(db.Model):
    """ç®¡ç†å‘˜ç”¨æˆ·è¡¨ - æ”¯æŒå¤šç®¡ç†å‘˜å’Œæƒé™æ§åˆ¶"""
    __tablename__ = 'admin_users'
    
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(100), unique=True, nullable=False, index=True)
    password_hash = db.Column(db.String(255), nullable=False)
    password_plain = db.Column(db.String(255), nullable=True)  # å­ç®¡ç†å‘˜æ˜æ–‡å¯†ç ï¼ˆä»…è¶…çº§ç®¡ç†å‘˜å¯è§ï¼‰
    is_super = db.Column(db.Boolean, default=False)  # è¶…çº§ç®¡ç†å‘˜ï¼ˆç«™ç‚¹æ‰€æœ‰è€…ï¼‰
    permissions = db.Column(db.Text, nullable=True)   # JSON æ•°ç»„ï¼Œå¦‚ ["requests","users","orders"]
    is_active = db.Column(db.Boolean, default=True)   # æ˜¯å¦å¯ç”¨
    created_by = db.Column(db.String(100), nullable=True)  # ç”±è°åˆ›å»º
    created_at = db.Column(db.DateTime, default=lambda: datetime.now())
    last_login = db.Column(db.DateTime, nullable=True)
    
    def get_permissions(self):
        """è·å–æƒé™åˆ—è¡¨"""
        if self.is_super:
            return list(ADMIN_PERMISSION_GROUPS.keys())
        if self.permissions:
            try:
                return json.loads(self.permissions)
            except:
                return []
        return []
    
    def set_permissions(self, perm_list):
        """è®¾ç½®æƒé™åˆ—è¡¨"""
        self.permissions = json.dumps(perm_list, ensure_ascii=False)
    
    def has_permission(self, perm):
        """æ£€æŸ¥æ˜¯å¦æœ‰æŸé¡¹æƒé™"""
        if self.is_super:
            return True
        return perm in self.get_permissions()
    
    def to_dict(self, include_password=False):
        d = {
            'id': self.id,
            'username': self.username,
            'is_super': self.is_super,
            'permissions': self.get_permissions(),
            'is_active': self.is_active,
            'created_by': self.created_by,
            'created_at': self.created_at.isoformat() if self.created_at else None,
            'last_login': self.last_login.isoformat() if self.last_login else None,
        }
        if include_password and not self.is_super:
            d['password_plain'] = self.password_plain or ''
        return d


class CheckInRecord(db.Model):
    """ç­¾åˆ°è®°å½•è¡¨"""
    __tablename__ = 'checkin_records'
    
    id = db.Column(db.Integer, primary_key=True)
    user_tg = db.Column(db.BigInteger, db.ForeignKey('emby.tg'), nullable=False, index=True)
    checkin_date = db.Column(db.Date, nullable=False, index=True)  # ç­¾åˆ°æ—¥æœŸï¼ˆåªå­˜æ—¥æœŸï¼Œä¸å«æ—¶é—´ï¼‰
    coins_earned = db.Column(db.Integer, nullable=False)  # æœ¬æ¬¡ç­¾åˆ°è·å¾—çš„ç§¯åˆ†
    continuous_days = db.Column(db.Integer, default=1)  # è¿ç»­ç­¾åˆ°å¤©æ•°
    created_at = db.Column(db.DateTime, default=lambda: datetime.now())
    
    # å…³ç³»
    user = db.relationship('User', backref='checkin_records', foreign_keys=[user_tg])
    
    __table_args__ = (
        db.UniqueConstraint('user_tg', 'checkin_date', name='uq_user_checkin_date'),
    )


class CoinTransaction(db.Model):
    """ç§¯åˆ†äº¤æ˜“è®°å½•è¡¨"""
    __tablename__ = 'coin_transactions'
    
    id = db.Column(db.Integer, primary_key=True)
    user_tg = db.Column(db.BigInteger, db.ForeignKey('emby.tg'), nullable=False, index=True)
    amount = db.Column(db.Integer, nullable=False)  # ç§¯åˆ†å˜åŠ¨æ•°é‡ï¼ˆæ­£æ•°ä¸ºå¢åŠ ï¼Œè´Ÿæ•°ä¸ºå‡å°‘ï¼‰
    balance_after = db.Column(db.Integer, nullable=False)  # äº¤æ˜“åä½™é¢
    trans_type = db.Column(db.String(50), nullable=False)  # äº¤æ˜“ç±»å‹: checkin, exchange, admin_grant, admin_deduct
    description = db.Column(db.String(255), nullable=True)  # äº¤æ˜“æè¿°
    related_id = db.Column(db.Integer, nullable=True)  # å…³è”IDï¼ˆå¦‚å…‘æ¢è®°å½•IDï¼‰
    created_at = db.Column(db.DateTime, default=lambda: datetime.now(), index=True)
    
    # å…³ç³»
    user = db.relationship('User', backref='coin_transactions', foreign_keys=[user_tg])


class ExchangeRecord(db.Model):
    """å¥—é¤å…‘æ¢è®°å½•è¡¨"""
    __tablename__ = 'exchange_records'
    
    id = db.Column(db.Integer, primary_key=True)
    user_tg = db.Column(db.BigInteger, db.ForeignKey('emby.tg'), nullable=False, index=True)
    plan_id = db.Column(db.String(50), nullable=False)  # å¥—é¤ID
    plan_name = db.Column(db.String(100), nullable=False)  # å¥—é¤åç§°
    coins_cost = db.Column(db.Integer, nullable=False)  # èŠ±è´¹çš„ç§¯åˆ†
    duration_days = db.Column(db.Integer, nullable=False)  # å…‘æ¢çš„å¤©æ•°
    status = db.Column(db.String(20), default='completed')  # å…‘æ¢çŠ¶æ€: completed, failed
    created_at = db.Column(db.DateTime, default=lambda: datetime.now(), index=True)
    
    # å…³ç³»
    user = db.relationship('User', backref='exchange_records', foreign_keys=[user_tg])


class TaskMonitor:

    """å•ä¸ªä¸‹è½½ä»»åŠ¡çš„ç‹¬ç«‹ç›‘æ§çº¿ç¨‹"""
    
    def __init__(self, app_instance: Flask, task_id: int, interval: int = 5):
        self.app = app_instance
        self.task_id = task_id
        self.interval = max(interval, 3)
        self.thread: Optional[Thread] = None
        self.stop_event = Event()
    
    def start(self):
        if self.thread and self.thread.is_alive():
            return
        self.thread = Thread(
            target=self._run, 
            name=f'TaskMonitor-{self.task_id}', 
            daemon=True
        )
        self.thread.start()
        app.logger.info(f'ä»»åŠ¡ {self.task_id} ç›‘æ§çº¿ç¨‹å·²å¯åŠ¨')
    
    def stop(self):
        self.stop_event.set()
    
    def _run(self):
        with self.app.app_context():
            retry_count = 0
            max_retries = 60  # æœ€å¤šé‡è¯•60æ¬¡ï¼ˆ5åˆ†é’Ÿï¼‰è·å–hash
            
            while not self.stop_event.is_set():
                try:
                    task = db.session.get(DownloadTask, self.task_id)
                    if not task:
                        app.logger.warning(f'ä»»åŠ¡ {self.task_id} ä¸å­˜åœ¨ï¼Œåœæ­¢ç›‘æ§')
                        break
                    
                    # ä»»åŠ¡å·²å®Œæˆæˆ–å¤±è´¥ï¼Œåœæ­¢ç›‘æ§
                    if task.status in {'completed', 'failed', 'cancelled'}:
                        app.logger.info(f'ä»»åŠ¡ {self.task_id} çŠ¶æ€ä¸º {task.status}ï¼Œåœæ­¢ç›‘æ§')
                        break
                    
                    # å¦‚æœæ²¡æœ‰ hashï¼Œå°è¯•é€šè¿‡ tag è·å–
                    if not task.torrent_hash and task.qb_tag:
                        retry_count += 1
                        if retry_count > max_retries:
                            app.logger.error(f'ä»»åŠ¡ {self.task_id} æ— æ³•è·å– torrent hashï¼Œåœæ­¢ç›‘æ§')
                            task.status = 'failed'
                            task.error_message = 'æ— æ³•ä» qBittorrent è·å–ç§å­ä¿¡æ¯'
                            db.session.commit()
                            break
                        
                        try:
                            info = qbit_client.get_torrent_by_tag(task.qb_tag)
                            if info:
                                task.torrent_hash = info.get('hash')
                                self._update_task_with_info(task, info)
                                db.session.commit()
                                app.logger.info(f'ä»»åŠ¡ {self.task_id} è·å–åˆ° hash: {task.torrent_hash[:16]}...')
                        except Exception as exc:
                            app.logger.warning(f'ä»»åŠ¡ {self.task_id} è·å– hash å¤±è´¥ ({retry_count}/{max_retries}): {exc}')
                    
                    # æœ‰ hashï¼Œè·å–å®æ—¶è¿›åº¦
                    elif task.torrent_hash:
                        try:
                            infos = qbit_client.get_torrents_info(hashes=[task.torrent_hash])
                            if infos:
                                self._update_task_with_info(task, infos[0])
                                db.session.commit()
                            else:
                                # ä»»åŠ¡åœ¨ qBittorrent ä¸­ä¸å­˜åœ¨
                                app.logger.warning(f'ä»»åŠ¡ {self.task_id} åœ¨ qBittorrent ä¸­æœªæ‰¾åˆ°')
                                
                                # å¦‚æœè¿›åº¦å·²ç»æ˜¯100%ï¼Œè¯´æ˜ä¹‹å‰ä¸‹è½½å®Œæˆäº†ï¼Œä¿æŒçŠ¶æ€
                                if task.progress >= 100:
                                    app.logger.info(f'ä»»åŠ¡ {self.task_id} å·²ä¸‹è½½å®Œæˆï¼ŒqBä»»åŠ¡å·²åˆ é™¤ï¼Œä¿æŒ completed çŠ¶æ€')
                                    task.status = 'completed'
                                    task.finished_at = task.finished_at or datetime.now()
                                    if task.request:
                                        task.request.status = 'downloaded'
                                    db.session.commit()
                                    break  # åœæ­¢ç›‘æ§
                                else:
                                    # æœªå®Œæˆå°±è¢«åˆ é™¤ï¼Œæ ‡è®°ä¸ºå¤±è´¥
                                    app.logger.warning(f'ä»»åŠ¡ {self.task_id} æœªå®Œæˆä½† qB ä»»åŠ¡å·²åˆ é™¤ï¼Œæ ‡è®°ä¸ºå¤±è´¥')
                                    task.status = 'failed'
                                    task.error_message = 'qBittorrent ä¸­çš„ä»»åŠ¡å·²è¢«åˆ é™¤'
                                    if task.request:
                                        task.request.status = 'failed'
                                    db.session.commit()
                                    break  # åœæ­¢ç›‘æ§
                                    
                        except Exception as exc:
                            app.logger.error(f'ä»»åŠ¡ {self.task_id} è·å–è¿›åº¦å¤±è´¥: {exc}')
                    
                except Exception as exc:
                    app.logger.error(f'ä»»åŠ¡ {self.task_id} ç›‘æ§å¼‚å¸¸: {exc}', exc_info=True)
                    db.session.rollback()
                
                self.stop_event.wait(self.interval)
        
        # æ¸…ç†ï¼šä»æ´»è·ƒç›‘æ§åˆ—è¡¨ä¸­ç§»é™¤
        active_monitors.pop(self.task_id, None)
        app.logger.info(f'ä»»åŠ¡ {self.task_id} ç›‘æ§çº¿ç¨‹å·²ç»“æŸ')
    
    def _update_task_with_info(self, task: DownloadTask, info: dict):
        old_progress = task.progress or 0
        progress = round((info.get('progress') or 0) * 100, 2)
        task.progress = progress
        task.download_speed = info.get('dlspeed', 0)
        task.eta = info.get('eta', -1)
        qb_state = info.get('state', '')
        mapped = self._map_qb_state(qb_state)
        
        # è®°å½•æ˜¾è‘—çš„è¿›åº¦å˜åŒ–ï¼ˆæ¯å˜åŒ– 5% ä»¥ä¸Šæˆ–çŠ¶æ€æ”¹å˜æ—¶ï¼‰
        if abs(progress - old_progress) >= 5 or (mapped and mapped != task.status):
            app.logger.debug(f'ä»»åŠ¡ {self.task_id} è¿›åº¦æ›´æ–°: {old_progress:.1f}% -> {progress:.1f}%, qBçŠ¶æ€: {qb_state}, æ˜ å°„çŠ¶æ€: {mapped}')
        
        if mapped:
            previous_status = task.status
            task.status = mapped
            
            if mapped == 'completed' and previous_status != 'completed':
                task.finished_at = datetime.now()
                task.progress = 100.0
                if task.request:
                    task.request.status = 'downloaded'
                app.logger.info(f'ä»»åŠ¡ {self.task_id} ä¸‹è½½å®Œæˆï¼æœ€ç»ˆè¿›åº¦: 100%')
                # å‘é€ Telegram é€šçŸ¥
                self._send_completion_notification(task)
                
            elif mapped == 'failed':
                task.error_message = qb_state
                if task.request:
                    task.request.status = 'failed'
                app.logger.warning(f'ä»»åŠ¡ {self.task_id} ä¸‹è½½å¤±è´¥ï¼ŒqBçŠ¶æ€: {qb_state}')
                    
            elif mapped == 'downloading' and task.request:
                task.request.status = 'downloading'
    
    def _send_completion_notification(self, task: DownloadTask):
        """ä¸‹è½½å®Œæˆæ—¶è®°å½•æ—¥å¿—ï¼ˆä¸å‘é€é€šçŸ¥ï¼Œå…¥åº“åå†é€šçŸ¥ï¼‰"""
        if not task.request:
            return
        try:
            req = task.request
            user = req.user
            app.logger.info(
                f"ä¸‹è½½å®Œæˆ: {req.title} ({req.year}) - "
                f"ç”¨æˆ·: {user.username if user else 'æœªçŸ¥'} - "
                f"ç§å­: {task.torrent_name[:50]}..."
            )
        except Exception as exc:
            app.logger.warning(f'è®°å½•ä¸‹è½½å®Œæˆæ—¥å¿—å¤±è´¥: {exc}')
    
    def _map_qb_state(self, qb_state: str) -> Optional[str]:
        qb_state = (qb_state or '').lower()
        # ä¸‹è½½ä¸­çŠ¶æ€
        if qb_state in {'downloading', 'stalleddl', 'forceddl', 'metadl', 'checkingdl', 'allocating', 'moving'}:
            return 'downloading'
        # æ’é˜ŸçŠ¶æ€
        if qb_state in {'queueddl', 'pauseddl', 'checkingresumedata'}:
            return 'queued'
        # å®ŒæˆçŠ¶æ€ï¼ˆå·²åšç§æˆ–å·²æš‚åœåšç§ï¼‰
        if qb_state in {'uploading', 'stalledup', 'queuedup', 'checkingup', 'pausedup', 'completed', 'forcedup', 'seeding'}:
            return 'completed'
        # å¤±è´¥çŠ¶æ€
        if qb_state in {'error', 'missingfiles', 'unknown'}:
            return 'failed'
        # æœªçŸ¥çŠ¶æ€è®°å½•æ—¥å¿—
        if qb_state:
            app.logger.warning(f'æœªçŸ¥çš„ qBittorrent çŠ¶æ€: {qb_state}')
        return None


# æ´»è·ƒçš„ä»»åŠ¡ç›‘æ§å™¨å­—å…¸ {task_id: TaskMonitor}
active_monitors: dict[int, TaskMonitor] = {}


def start_task_monitor(task_id: int, interval: int = 5):
    """å¯åŠ¨å•ä¸ªä»»åŠ¡çš„ç›‘æ§çº¿ç¨‹"""
    if not ENABLE_DOWNLOAD_MONITOR:
        app.logger.info(f'ä¸‹è½½ç›‘æ§å·²ç¦ç”¨ï¼Œè·³è¿‡ä»»åŠ¡ {task_id}')
        return
    if not qbit_client.is_enabled():
        app.logger.warning(f'æœªé…ç½® qBittorrentï¼Œè·³è¿‡ä»»åŠ¡ {task_id}')
        return
    
    # å¦‚æœè¯¥ä»»åŠ¡å·²æœ‰ç›‘æ§çº¿ç¨‹åœ¨è¿è¡Œï¼Œä¸é‡å¤å¯åŠ¨
    if task_id in active_monitors and active_monitors[task_id].thread and active_monitors[task_id].thread.is_alive():
        app.logger.info(f'ä»»åŠ¡ {task_id} ç›‘æ§å·²åœ¨è¿è¡Œ')
        return
    
    monitor = TaskMonitor(app, task_id, interval)
    active_monitors[task_id] = monitor
    monitor.start()


def stop_task_monitor(task_id: int):
    """åœæ­¢å•ä¸ªä»»åŠ¡çš„ç›‘æ§çº¿ç¨‹"""
    if task_id in active_monitors:
        active_monitors[task_id].stop()
        active_monitors.pop(task_id, None)


class DownloadMonitor:
    """åå°å…¨å±€ç›‘æ§ - å¯åŠ¨æ—¶æ¢å¤æœªå®Œæˆä»»åŠ¡çš„ç›‘æ§"""

    def __init__(self, app_instance: Flask, interval: int = 12):
        self.app = app_instance
        self.interval = max(interval, 5)
        self.thread: Optional[Thread] = None
        self.stop_event = Event()

    def start(self):
        if not ENABLE_DOWNLOAD_MONITOR:
            app.logger.info('ä¸‹è½½ç›‘æ§å·²ç¦ç”¨ï¼Œè·³è¿‡å¯åŠ¨')
            return
        if not qbit_client.is_enabled():
            app.logger.warning('æœªé…ç½® qBittorrentï¼Œä¸‹è½½ç›‘æ§ä¸å¯åŠ¨')
            return
        if self.thread and self.thread.is_alive():
            return
        self.thread = Thread(target=self._run, name='DownloadMonitor', daemon=True)
        self.thread.start()
        app.logger.info('ä¸‹è½½ç›‘æ§çº¿ç¨‹å·²å¯åŠ¨')

    def _run(self):
        with self.app.app_context():
            # å¯åŠ¨æ—¶æ¢å¤æ‰€æœ‰æœªå®Œæˆä»»åŠ¡çš„ç›‘æ§
            self._recover_pending_tasks()
            
            # ä¹‹åå®šæœŸæ£€æŸ¥æ˜¯å¦æœ‰é—æ¼çš„ä»»åŠ¡
            while not self.stop_event.is_set():
                try:
                    self._check_orphan_tasks()
                except Exception as exc:
                    app.logger.error(f'æ£€æŸ¥é—æ¼ä»»åŠ¡å¤±è´¥: {exc}', exc_info=True)
                self.stop_event.wait(self.interval * 3)  # æ¯éš” interval*3 ç§’æ£€æŸ¥ä¸€æ¬¡
    
    def _recover_pending_tasks(self):
        """æ¢å¤æ‰€æœ‰æœªå®Œæˆä»»åŠ¡çš„ç›‘æ§ï¼Œå…ˆåŒæ­¥ qBittorrent ä¸­çš„çœŸå®çŠ¶æ€"""
        tasks = DownloadTask.query.filter(
            DownloadTask.status.in_(['queued', 'downloading'])
        ).all()
        
        if not tasks:
            app.logger.info('æ²¡æœ‰éœ€è¦æ¢å¤çš„ä¸‹è½½ä»»åŠ¡')
            return
        
        app.logger.info(f'å‘ç° {len(tasks)} ä¸ªæœªå®Œæˆä»»åŠ¡ï¼Œæ£€æŸ¥ qBittorrent çŠ¶æ€...')
        
        for task in tasks:
            try:
                # å¦‚æœæœ‰ torrent_hashï¼Œæ£€æŸ¥ qBittorrent ä¸­çš„çœŸå®çŠ¶æ€
                if task.torrent_hash:
                    infos = qbit_client.get_torrents_info(hashes=[task.torrent_hash])
                    if infos:
                        info = infos[0]
                        qb_state = info.get('state', '').lower()
                        progress = round((info.get('progress') or 0) * 100, 2)
                        
                        # æ£€æŸ¥æ˜¯å¦å·²å®Œæˆï¼ˆåšç§çŠ¶æ€ï¼‰
                        if qb_state in {'uploading', 'stalledup', 'queuedup', 'checkingup', 'pausedup', 'completed', 'forcedup'}:
                            app.logger.info(f'ä»»åŠ¡ {task.id} ({task.torrent_name[:30]}...) åœ¨ qBittorrent ä¸­å·²å®Œæˆï¼Œæ›´æ–°çŠ¶æ€')
                            task.status = 'completed'
                            task.progress = 100.0
                            task.finished_at = task.finished_at or datetime.now()
                            if task.request:
                                task.request.status = 'downloaded'
                            db.session.commit()
                            continue  # ä¸å¯åŠ¨ç›‘æ§
                        
                        # æ›´æ–°è¿›åº¦ä¿¡æ¯
                        task.progress = progress
                        task.download_speed = info.get('dlspeed', 0)
                        task.eta = info.get('eta', -1)
                        db.session.commit()
                    else:
                        # qBittorrent ä¸­ä»»åŠ¡ä¸å­˜åœ¨
                        app.logger.warning(f'ä»»åŠ¡ {task.id} åœ¨ qBittorrent ä¸­æœªæ‰¾åˆ°')
                        
                        # å¦‚æœè¿›åº¦å·²ç»æ˜¯100%ï¼Œè¯´æ˜ä¹‹å‰ä¸‹è½½å®Œæˆäº†
                        if task.progress >= 100:
                            app.logger.info(f'ä»»åŠ¡ {task.id} å·²ä¸‹è½½å®Œæˆï¼ŒqBä»»åŠ¡å·²åˆ é™¤ï¼Œæ ‡è®°ä¸º completed')
                            task.status = 'completed'
                            task.finished_at = task.finished_at or datetime.now()
                            if task.request:
                                task.request.status = 'downloaded'
                            db.session.commit()
                            continue  # ä¸å¯åŠ¨ç›‘æ§
                        else:
                            # æœªå®Œæˆå°±è¢«åˆ é™¤
                            app.logger.warning(f'ä»»åŠ¡ {task.id} æœªå®Œæˆä½† qB ä»»åŠ¡å·²åˆ é™¤ï¼Œæ ‡è®°ä¸ºå¤±è´¥')
                            task.status = 'failed'
                            task.error_message = 'qBittorrent ä¸­çš„ä»»åŠ¡å·²è¢«åˆ é™¤'
                            if task.request:
                                task.request.status = 'failed'
                            db.session.commit()
                            continue  # ä¸å¯åŠ¨ç›‘æ§
                
                # å¯åŠ¨ç›‘æ§
                start_task_monitor(task.id, self.interval)
                
            except Exception as exc:
                app.logger.error(f'æ¢å¤ä»»åŠ¡ {task.id} çŠ¶æ€å¤±è´¥: {exc}')
                db.session.rollback()  # ç¡®ä¿å›æ»šä»¥é˜²æ­¢äº‹åŠ¡é—®é¢˜
    
    def _check_orphan_tasks(self):
        """æ£€æŸ¥æ˜¯å¦æœ‰ä»»åŠ¡æ²¡æœ‰è¢«ç›‘æ§ï¼ŒåŒæ—¶æ£€æŸ¥ qBittorrent çœŸå®çŠ¶æ€"""
        tasks = DownloadTask.query.filter(
            DownloadTask.status.in_(['queued', 'downloading'])
        ).all()
        
        for task in tasks:
            try:
                # å…ˆæ£€æŸ¥ qBittorrent ä¸­çš„çŠ¶æ€
                if task.torrent_hash:
                    infos = qbit_client.get_torrents_info(hashes=[task.torrent_hash])
                    if infos:
                        qb_state = infos[0].get('state', '').lower()
                        if qb_state in {'uploading', 'stalledup', 'queuedup', 'checkingup', 'pausedup', 'completed', 'forcedup'}:
                            app.logger.info(f'ä»»åŠ¡ {task.id} åœ¨ qBittorrent ä¸­å·²å®Œæˆï¼Œæ›´æ–°çŠ¶æ€')
                            task.status = 'completed'
                            task.progress = 100.0
                            task.finished_at = task.finished_at or datetime.now()
                            if task.request:
                                task.request.status = 'downloaded'
                            db.session.commit()
                            continue  # ä¸å¯åŠ¨ç›‘æ§
                    else:
                        # qBittorrent ä¸­ä»»åŠ¡ä¸å­˜åœ¨
                        if task.progress >= 100:
                            app.logger.info(f'ä»»åŠ¡ {task.id} å·²ä¸‹è½½å®Œæˆï¼ŒqBä»»åŠ¡å·²åˆ é™¤ï¼Œæ ‡è®°ä¸º completed')
                            task.status = 'completed'
                            task.finished_at = task.finished_at or datetime.now()
                            if task.request:
                                task.request.status = 'downloaded'
                            db.session.commit()
                            continue
                        else:
                            app.logger.warning(f'ä»»åŠ¡ {task.id} æœªå®Œæˆä½† qB ä»»åŠ¡å·²åˆ é™¤ï¼Œæ ‡è®°ä¸ºå¤±è´¥')
                            task.status = 'failed'
                            task.error_message = 'qBittorrent ä¸­çš„ä»»åŠ¡å·²è¢«åˆ é™¤'
                            if task.request:
                                task.request.status = 'failed'
                            db.session.commit()
                            continue
                
                # å¦‚æœä»»åŠ¡æ²¡æœ‰è¢«ç›‘æ§ï¼Œå¯åŠ¨ç›‘æ§
                if task.id not in active_monitors or not active_monitors[task.id].thread or not active_monitors[task.id].thread.is_alive():
                    app.logger.info(f'å‘ç°é—æ¼ä»»åŠ¡ {task.id}ï¼Œå¯åŠ¨ç›‘æ§')
                    start_task_monitor(task.id, self.interval)
            except Exception as exc:
                app.logger.error(f'æ£€æŸ¥ä»»åŠ¡ {task.id} çŠ¶æ€å¤±è´¥: {exc}')
                db.session.rollback()  # ç¡®ä¿å›æ»šä»¥é˜²æ­¢äº‹åŠ¡é—®é¢˜


# ç™»å½•éªŒè¯è£…é¥°å™¨
def login_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        # åˆ¤æ–­æ˜¯å¦æ˜¯ API è¯·æ±‚
        is_api_request = request.path.startswith('/api/') or request.headers.get('X-Requested-With') == 'XMLHttpRequest'
        
        if 'user_id' not in session:
            app.logger.warning(f'[AUTH] {request.path} - sessionä¸­æ— user_id, session keys: {list(session.keys())}')
            if is_api_request:
                return jsonify({'success': False, 'error': 'è¯·å…ˆç™»å½•', 'need_login': True}), 401
            return redirect(url_for('login'))
        
        # éªŒè¯session_tokenæ˜¯å¦æœ‰æ•ˆï¼ˆé˜²æ­¢å¯†ç é‡ç½®åç»§ç»­è®¿é—®ï¼‰
        user = db.session.get(User, session['user_id'])
        if not user:
            # ç”¨æˆ·ä¸å­˜åœ¨ï¼Œæ¸…é™¤ç”¨æˆ·session
            app.logger.warning(f'[AUTH] {request.path} - user_id={session["user_id"]} ç”¨æˆ·ä¸å­˜åœ¨')
            for _k in ['user_id', 'username', 'session_token', 'is_admin', 'user_level']:
                session.pop(_k, None)
            if is_api_request:
                return jsonify({'success': False, 'error': 'ç”¨æˆ·ä¸å­˜åœ¨ï¼Œè¯·é‡æ–°ç™»å½•', 'need_login': True}), 401
            return redirect(url_for('login'))
        
        # æ£€æŸ¥session_tokenæ˜¯å¦åŒ¹é…
        if user.session_token and session.get('session_token') != user.session_token:
            # tokenä¸åŒ¹é…ï¼Œè¯´æ˜å¯†ç å·²è¢«é‡ç½®ï¼Œå¼ºåˆ¶é€€å‡º
            app.logger.warning(f'[AUTH] {request.path} - user={user.name} session_tokenä¸åŒ¹é…: session={session.get("session_token", "")[:8]}... db={user.session_token[:8] if user.session_token else "None"}...')
            for _k in ['user_id', 'username', 'session_token', 'is_admin', 'user_level']:
                session.pop(_k, None)
            if is_api_request:
                return jsonify({'success': False, 'error': 'ç™»å½•å·²è¿‡æœŸï¼Œè¯·é‡æ–°ç™»å½•', 'need_login': True}), 401
            return redirect(url_for('login'))
        
        return f(*args, **kwargs)
    return decorated_function


def admin_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        # æ£€æŸ¥ç®¡ç†å‘˜æƒé™
        # æ–¹å¼1: é€šè¿‡å®‰å…¨å…¥å£ç™»å½•ï¼ˆå¤šç®¡ç†å‘˜ç³»ç»Ÿï¼‰
        if session.get('admin_logged_in'):
            admin_id = session.get('admin_user_id')
            if admin_id:
                admin_user = db.session.get(AdminUser, admin_id)
                if admin_user and admin_user.is_active:
                    g.current_admin = admin_user
                    return f(*args, **kwargs)
                else:
                    # ç®¡ç†å‘˜å·²è¢«ç¦ç”¨æˆ–åˆ é™¤ï¼Œæ¸…é™¤session
                    for _k in ['admin_logged_in', 'admin_user_id', 'admin_username', 'admin_is_super', 'admin_login_time']:
                        session.pop(_k, None)
                    return jsonify({'error': 'ç®¡ç†å‘˜è´¦å·å·²è¢«ç¦ç”¨', 'redirect': f'/{ADMIN_SECRET_PATH}'}), 403
            else:
                # å…¼å®¹æ—§sessionï¼ˆè¶…çº§ç®¡ç†å‘˜é€šè¿‡é…ç½®æ–‡ä»¶ç™»å½•ï¼‰
                g.current_admin = None
                return f(*args, **kwargs)
        
        # æ–¹å¼2: ç”¨æˆ·è¡¨ä¸­çš„ç®¡ç†å‘˜ï¼ˆä¿ç•™å…¼å®¹ï¼‰
        if 'user_id' in session:
            user = db.session.get(User, session['user_id'])
            if user and user.is_admin:
                g.current_admin = None
                return f(*args, **kwargs)
        
        app.logger.warning('è®¿é—®ç®¡ç†åå°å¤±è´¥: æ— ç®¡ç†å‘˜æƒé™')
        return jsonify({'error': 'éœ€è¦ç®¡ç†å‘˜æƒé™', 'redirect': f'/{ADMIN_SECRET_PATH}'}), 403
    return decorated_function


def permission_required(perm):
    """æƒé™æ£€æŸ¥è£…é¥°å™¨ - åœ¨ admin_required ä¹‹åä½¿ç”¨"""
    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            admin = getattr(g, 'current_admin', None)
            if admin is None:
                # è¶…çº§ç®¡ç†å‘˜ï¼ˆæ—§æ–¹å¼ç™»å½•ï¼‰ï¼Œæ‹¥æœ‰æ‰€æœ‰æƒé™
                return f(*args, **kwargs)
            if admin.is_super or admin.has_permission(perm):
                return f(*args, **kwargs)
            return jsonify({'error': f'æ— æƒé™æ‰§è¡Œæ­¤æ“ä½œï¼ˆéœ€è¦: {ADMIN_PERMISSION_GROUPS.get(perm, perm)}ï¼‰'}), 403
        return decorated_function
    return decorator


def get_current_admin():
    """è·å–å½“å‰ç™»å½•çš„ç®¡ç†å‘˜å¯¹è±¡"""
    admin = getattr(g, 'current_admin', None)
    if admin:
        return admin
    # å…¼å®¹ï¼šå¦‚æœæ²¡æœ‰ admin å¯¹è±¡ä½†æœ‰ sessionï¼Œåˆ›å»ºä¸€ä¸ªè™šæ‹Ÿè¶…çº§ç®¡ç†å‘˜
    if session.get('admin_logged_in'):
        return type('SuperAdmin', (), {
            'id': 0,
            'username': session.get('admin_username', 'admin'),
            'is_super': True,
            'is_active': True,
            'has_permission': lambda self, p: True,
            'get_permissions': lambda self: list(ADMIN_PERMISSION_GROUPS.keys()),
        })()
    return None


def is_admin_user():
    """æ£€æŸ¥å½“å‰ç”¨æˆ·æ˜¯å¦æœ‰ç®¡ç†å‘˜æƒé™"""
    if session.get('admin_logged_in'):
        admin_id = session.get('admin_user_id')
        if admin_id:
            admin_user = db.session.get(AdminUser, admin_id)
            return admin_user and admin_user.is_active
        return True  # å…¼å®¹æ—§session
    
    if 'user_id' in session:
        user = db.session.get(User, session['user_id'])
        if user and user.is_admin:
            return True
    
    return False


# TMDB API è¾…åŠ©å‡½æ•°ï¼ˆå¸¦ç¼“å­˜ï¼‰
def search_tmdb(query, media_type='movie'):
    """æœç´¢TMDBç”µå½±æˆ–å‰§é›†ï¼ˆå¸¦ç¼“å­˜ï¼‰"""
    if not TMDB_API_KEY:
        return {'results': []}
    
    # æ£€æŸ¥ç¼“å­˜
    cache_key = tmdb_cache._make_key('search', query, media_type)
    cached = tmdb_cache.get(cache_key)
    if cached:
        app.logger.debug(f"TMDBæœç´¢ç¼“å­˜å‘½ä¸­: {query}")
        return cached
    
    url = f'{TMDB_BASE_URL}/search/{media_type}'
    params = {
        'api_key': TMDB_API_KEY,
        'query': query,
        'language': 'zh-CN'
    }
    
    try:
        response = http_session.get(url, params=params, timeout=5)
        response.raise_for_status()
        result = response.json()
        # ç¼“å­˜ç»“æœï¼ˆæœç´¢ç»“æœç¼“å­˜1å¤©ï¼‰
        tmdb_cache.set(cache_key, result, ttl=86400)
        return result
    except requests.exceptions.Timeout:
        app.logger.error(f"TMDBæœç´¢è¶…æ—¶: query={query}, URL={url}")
        return {'results': []}
    except requests.exceptions.ConnectionError as e:
        app.logger.error(f"TMDBè¿æ¥å¤±è´¥: {e}, è¯·æ£€æŸ¥ç½‘ç»œæˆ–é…ç½®ä»£ç†")
        return {'results': []}
    except requests.exceptions.HTTPError as e:
        app.logger.error(f"TMDB HTTPé”™è¯¯: {e.response.status_code}, {e}")
        return {'results': []}
    except Exception as e:
        app.logger.error(f"TMDBæœç´¢é”™è¯¯: {type(e).__name__}: {e}")
        return {'results': []}


def get_media_category(media_type, tmdb_id=None):
    """
    æ ¹æ®åª’ä½“ç±»å‹å’ŒTMDB IDè·å–æ­£ç¡®çš„åˆ†ç±»åç§°
    ä»ç³»ç»Ÿé…ç½®ä¸­è¯»å–åˆ†ç±»è§„åˆ™ï¼Œæ”¯æŒè‡ªå®šä¹‰
    
    åˆ†ç±»è§„åˆ™æ”¯æŒä»¥ä¸‹æ¡ä»¶ï¼š
    - genre_ids: å†…å®¹ç±»å‹IDåˆ—è¡¨ï¼ˆå¦‚[16]è¡¨ç¤ºåŠ¨ç”»ï¼‰
    - origin_country: åˆ¶ä½œå›½å®¶åˆ—è¡¨ï¼ˆå¦‚['CN', 'TW', 'HK']ï¼‰
    - original_language: è¯­è¨€åˆ—è¡¨ï¼ˆå¦‚['zh', 'cn']ï¼‰
    
    åŒä¸€åˆ†ç±»ä¸‹çš„å¤šä¸ªæ¡ä»¶æ˜¯"ä¸"çš„å…³ç³»
    """
    # è·å–åˆ†ç±»é…ç½®
    config = load_system_config()
    category_config = config.get('category', DEFAULT_CATEGORY_CONFIG)
    
    # è·å–å¯¹åº”åª’ä½“ç±»å‹çš„åˆ†ç±»è§„åˆ™
    rules = category_config.get(media_type, {})
    
    if not tmdb_id or not rules:
        # æ²¡æœ‰TMDB IDæˆ–æ²¡æœ‰è§„åˆ™ï¼Œè¿”å›é»˜è®¤åˆ†ç±»
        default_categories = list(rules.keys()) if rules else []
        if default_categories:
            # è¿”å›æœ€åä¸€ä¸ªåˆ†ç±»ï¼ˆé€šå¸¸æ˜¯é»˜è®¤åˆ†ç±»ï¼‰
            return default_categories[-1]
        return 'ç”µå½±' if media_type == 'movie' else 'å‰§é›†'
    
    details = get_tmdb_details(tmdb_id, media_type)
    if not details:
        default_categories = list(rules.keys()) if rules else []
        if default_categories:
            return default_categories[-1]
        return 'ç”µå½±' if media_type == 'movie' else 'å‰§é›†'
    
    # è·å–åª’ä½“çš„å±æ€§
    genre_ids = [g.get('id') for g in details.get('genres', [])]
    origin_countries = details.get('origin_country', [])
    original_language = details.get('original_language', '')
    
    # æŒ‰é¡ºåºåŒ¹é…åˆ†ç±»è§„åˆ™
    for category_name, conditions in rules.items():
        if not conditions:
            # ç©ºæ¡ä»¶è¡¨ç¤ºé»˜è®¤åˆ†ç±»ï¼Œè·³è¿‡ï¼ˆæœ€åå¤„ç†ï¼‰
            continue
        
        matched = True
        
        # æ£€æŸ¥ genre_ids æ¡ä»¶
        if 'genre_ids' in conditions:
            required_genres = conditions['genre_ids']
            if not any(g in genre_ids for g in required_genres):
                matched = False
        
        # æ£€æŸ¥ origin_country æ¡ä»¶
        if matched and 'origin_country' in conditions:
            required_countries = conditions['origin_country']
            if not any(c in origin_countries for c in required_countries):
                matched = False
        
        # æ£€æŸ¥ original_language æ¡ä»¶
        if matched and 'original_language' in conditions:
            required_languages = conditions['original_language']
            if original_language not in required_languages:
                matched = False
        
        if matched:
            return category_name
    
    # æ²¡æœ‰åŒ¹é…åˆ°ä»»ä½•è§„åˆ™ï¼Œè¿”å›æœ€åä¸€ä¸ªåˆ†ç±»ï¼ˆé»˜è®¤åˆ†ç±»ï¼‰
    default_categories = [name for name, cond in rules.items() if not cond]
    if default_categories:
        return default_categories[0]
    
    # å¦‚æœè¿˜æ˜¯æ²¡æœ‰ï¼Œè¿”å›è§„åˆ™ä¸­çš„æœ€åä¸€ä¸ªåˆ†ç±»
    all_categories = list(rules.keys())
    if all_categories:
        return all_categories[-1]
    
    return 'ç”µå½±' if media_type == 'movie' else 'å‰§é›†'


def get_tmdb_details(tmdb_id, media_type='movie'):
    """è·å–TMDBè¯¦ç»†ä¿¡æ¯ï¼ˆå¸¦ç¼“å­˜ï¼‰"""
    if not TMDB_API_KEY:
        return None
    
    # æ£€æŸ¥ç¼“å­˜
    cache_key = tmdb_cache._make_key('details', tmdb_id, media_type)
    cached = tmdb_cache.get(cache_key)
    if cached:
        app.logger.debug(f"TMDBè¯¦æƒ…ç¼“å­˜å‘½ä¸­: {tmdb_id}")
        return cached
    
    url = f'{TMDB_BASE_URL}/{media_type}/{tmdb_id}'
    params = {
        'api_key': TMDB_API_KEY,
        'language': 'zh-CN'
    }
    
    try:
        response = http_session.get(url, params=params, timeout=10)
        response.raise_for_status()
        result = response.json()
        # ç¼“å­˜ç»“æœï¼ˆè¯¦æƒ…ç¼“å­˜1å¤©ï¼‰
        tmdb_cache.set(cache_key, result, ttl=86400)
        return result
    except requests.exceptions.Timeout:
        app.logger.error(f"TMDBè¯¦æƒ…è·å–è¶…æ—¶: tmdb_id={tmdb_id}, type={media_type}, URL={url}")
        return None
    except requests.exceptions.ConnectionError as e:
        app.logger.error(f"TMDBè¿æ¥å¤±è´¥: {e}, è¯·æ£€æŸ¥ç½‘ç»œæˆ–é…ç½®ä»£ç†")
        return None
    except requests.exceptions.HTTPError as e:
        app.logger.error(f"TMDB HTTPé”™è¯¯: {e.response.status_code}, {e}")
        return None
    except Exception as e:
        app.logger.error(f"TMDBè¯¦æƒ…é”™è¯¯: {type(e).__name__}: {e}")
        return None


def get_tmdb_tv_seasons(tmdb_id):
    """è·å–ç”µè§†å‰§çš„å­£ä¿¡æ¯"""
    details = get_tmdb_details(tmdb_id, 'tv')
    if not details:
        return None
    
    seasons = details.get('seasons', [])
    # åŒ…å«ç¬¬0å­£ï¼ˆç‰¹åˆ«ç¯‡/OVAï¼‰ï¼ŒæŒ‰å­£å·æ’åº
    seasons = [s for s in seasons if s.get('season_number') is not None]
    seasons.sort(key=lambda s: s.get('season_number', 0))
    
    return {
        'name': details.get('name'),
        'total_seasons': details.get('number_of_seasons', len(seasons)),
        'total_episodes': details.get('number_of_episodes', 0),
        'seasons': [{
            'season_number': s.get('season_number'),
            'name': s.get('name'),
            'episode_count': s.get('episode_count', 0),
            'air_date': s.get('air_date'),
            'poster_path': s.get('poster_path'),
        } for s in seasons]
    }


def get_tmdb_season_episodes(tmdb_id, season_number):
    """è·å–æŒ‡å®šå­£çš„å‰§é›†åˆ—è¡¨"""
    if not TMDB_API_KEY:
        return None
    
    url = f'{TMDB_BASE_URL}/tv/{tmdb_id}/season/{season_number}'
    params = {
        'api_key': TMDB_API_KEY,
        'language': 'zh-CN'
    }
    
    try:
        response = http_session.get(url, params=params, timeout=10)
        response.raise_for_status()
        result = response.json()
        
        episodes = result.get('episodes', [])
        return {
            'season_number': season_number,
            'name': result.get('name'),
            'episode_count': len(episodes),
            'episodes': [{
                'episode_number': e.get('episode_number'),
                'name': e.get('name'),
                'air_date': e.get('air_date'),
                'overview': e.get('overview', '')[:100],
            } for e in episodes]
        }
    except Exception as e:
        app.logger.error(f"è·å–å­£è¯¦æƒ…å¤±è´¥: {e}")
        return None


def get_trending(media_type='movie', page=1):
    """è·å–çƒ­é—¨å½±ç‰‡ï¼ˆå¸¦ç¼“å­˜ï¼ŒEmbyæ£€æŸ¥å¯é€‰ï¼‰"""
    if not TMDB_API_KEY:
        app.logger.warning('TMDB_API_KEY æœªé…ç½®')
        return {'results': []}
    
    # æ£€æŸ¥ç¼“å­˜
    cache_key = tmdb_cache._make_key('trending', media_type, page)
    cached = tmdb_cache.get(cache_key)
    if cached:
        app.logger.debug(f"TMDBçƒ­é—¨ç¼“å­˜å‘½ä¸­: {media_type}, page={page}")
        return cached
    
    # ä½¿ç”¨ discover æ¥å£æŒ‰çƒ­åº¦æ’åºï¼ˆä¸é™åˆ¶æ—¥æœŸï¼Œè·å–æ‰€æœ‰æ—¶é—´çš„çƒ­é—¨å†…å®¹ï¼‰
    url = f'{TMDB_BASE_URL}/discover/{media_type}'
    params = {
        'api_key': TMDB_API_KEY,
        'language': 'zh-CN',
        'page': page,
        'sort_by': 'popularity.desc',  # æŒ‰çƒ­åº¦é™åºæ’åˆ—
        'vote_count.gte': 50,  # é™ä½è¯„åˆ†æ•°è¦æ±‚ï¼Œä»100æ”¹ä¸º50
    }
    
    app.logger.info(f'è¯·æ±‚TMDBçƒ­é—¨: type={media_type}, page={page}, url={url}')
    
    try:
        response = http_session.get(url, params=params, timeout=15)
        app.logger.info(f'TMDBå“åº”: status={response.status_code}, content_length={len(response.content)}')
        
        response.raise_for_status()
        data = response.json()
        
        result_count = len(data.get('results', []))
        app.logger.info(f'TMDBçƒ­é—¨è·å–æˆåŠŸ: type={media_type}, page={page}, ç»“æœæ•°={result_count}')
        
        # é»˜è®¤æ ‡è®°æ‰€æœ‰ä¸ºæœªå…¥åº“ï¼ˆEmbyæ£€æŸ¥æ”¹ä¸ºå‰ç«¯å¼‚æ­¥åŠ è½½ï¼‰
        for item in data.get('results', []):
            item['in_emby'] = False
        
        # ç¼“å­˜ç»“æœï¼ˆçƒ­é—¨ç¼“å­˜1å¤©ï¼‰
        tmdb_cache.set(cache_key, data, ttl=86400)
        return data
    except requests.exceptions.Timeout:
        app.logger.error(f"TMDBçƒ­é—¨è·å–è¶…æ—¶: type={media_type}, page={page}, URL={url}")
        return {'results': []}
    except requests.exceptions.ConnectionError as e:
        app.logger.error(f"TMDBè¿æ¥å¤±è´¥: {e}, è¯·æ£€æŸ¥ç½‘ç»œæˆ–é…ç½®ä»£ç†")
        return {'results': []}
    except requests.exceptions.HTTPError as e:
        app.logger.error(f"TMDB HTTPé”™è¯¯: status={e.response.status_code}, {e}, response={e.response.text[:200]}")
        return {'results': []}
    except Exception as e:
        app.logger.error(f"TMDBçƒ­é—¨è·å–é”™è¯¯: {type(e).__name__}: {e}", exc_info=True)
        return {'results': []}


def send_user_telegram_notification(user_tg_id, title, status, admin_note=None, media_type='movie', tmdb_id=None, poster_path=None):
    """å‘é€çŠ¶æ€å˜æ›´é€šçŸ¥ç»™ç”¨æˆ·ï¼ˆå¸¦å›¾ç‰‡å’ŒTMDBé“¾æ¥ï¼‰"""
    if not user_tg_id or not TELEGRAM_BOT_TOKEN:
        return False

    status_emoji = {
        'approved': 'âœ…',
        'completed': 'ğŸ‰',
        'rejected': 'âŒ'
    }
    
    status_text = {
        'approved': 'å·²æ‰¹å‡†',
        'completed': 'å·²å…¥åº“',
        'rejected': 'å·²æ‹’ç»'
    }
    
    media_type_cn = 'ğŸ¬ ç”µå½±' if media_type == 'movie' else 'ğŸ“º å‰§é›†'
    
    message_lines = [
        f"{status_emoji.get(status, 'ğŸ“¢')} <b>æ±‚ç‰‡çŠ¶æ€æ›´æ–°</b>",
        f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”",
        f"ğŸ <b>å½±ç‰‡ï¼š</b><b>{title}</b>",
        f"ğŸ“ <b>ç±»å‹ï¼š</b>{media_type_cn}",
        f"ğŸ“Š <b>çŠ¶æ€ï¼š</b><b>{status_text.get(status, status)}</b>",
    ]
    
    if admin_note:
        message_lines.append(f"ğŸ’¬ <b>ç®¡ç†å‘˜å¤‡æ³¨ï¼š</b>{admin_note}")
    
    # æ·»åŠ TMDBé“¾æ¥
    if tmdb_id:
        tmdb_url = f"https://www.themoviedb.org/{media_type}/{tmdb_id}"
        message_lines.append(f"ğŸ”— <a href='{tmdb_url}'>æŸ¥çœ‹ TMDB è¯¦æƒ…</a>")
    
    message_lines.extend([
        f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”",
        f"â° <b>æ›´æ–°æ—¶é—´ï¼š</b>{datetime.now(timezone(timedelta(hours=8))).strftime('%Y-%m-%d %H:%M:%S')}"
    ])
    
    message = '\n'.join(message_lines)
    
    try:
        # å¦‚æœæœ‰æµ·æŠ¥ï¼Œå‘é€å¸¦å›¾ç‰‡çš„æ¶ˆæ¯
        if poster_path:
            poster_url = f"{TMDB_IMAGE_BASE_URL}{poster_path}"
            url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendPhoto"
            response = http_session.post(url, json={
                'chat_id': user_tg_id,
                'photo': poster_url,
                'caption': message,
                'parse_mode': 'HTML'
            }, timeout=5)
        else:
            # æ²¡æœ‰æµ·æŠ¥å°±å‘é€çº¯æ–‡æœ¬æ¶ˆæ¯
            url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendMessage"
            response = http_session.post(url, json={
                'chat_id': user_tg_id,
                'text': message,
                'parse_mode': 'HTML',
                'disable_web_page_preview': False
            }, timeout=5)
        
        response.raise_for_status()
        app.logger.info(f'ç”¨æˆ·é€šçŸ¥å‘é€æˆåŠŸ: {title} -> {user_tg_id}')
        return True
    except Exception as e:
        app.logger.error(f'ç”¨æˆ·é€šçŸ¥å‘é€å¤±è´¥: {e}')
        return False


def send_admin_review_notification(movie_request, user):
    """æ±‚ç‰‡åå‘æ‰€æœ‰ bot_admin ç§èŠå‘é€å®¡æ ¸é€šçŸ¥ï¼ˆå¸¦ç¡®è®¤/æ‹’ç»æŒ‰é’®ï¼‰
    
    Args:
        movie_request: MovieRequest å®ä¾‹
        user: User å®ä¾‹ï¼ˆæ±‚ç‰‡ç”¨æˆ·ï¼‰
    """
    if not TELEGRAM_BOT_TOKEN:
        return
    
    config = load_system_config()
    bot_admins_str = config.get('telegram', {}).get('bot_admins', '')
    bot_admin_ids = [x.strip() for x in bot_admins_str.split(',') if x.strip()]
    
    if not bot_admin_ids:
        app.logger.info('[å®¡æ ¸é€šçŸ¥] æœªé…ç½® bot_adminsï¼Œè·³è¿‡ç®¡ç†å‘˜å®¡æ ¸é€šçŸ¥')
        return
    
    # æ„å»ºé€šçŸ¥æ¶ˆæ¯
    media_type_cn = 'ğŸ¬ ç”µå½±' if movie_request.media_type == 'movie' else 'ğŸ“º å‰§é›†'
    scope_info = movie_request.get_request_scope() if movie_request.media_type == 'tv' else ''
    user_display = user.emby_name or user.name or str(user.tg)
    
    # å°è¯•é€šè¿‡ Telegram API è·å–ç”¨æˆ·çš„ TG æ˜¾ç¤ºåç§°
    tg_id = user.telegram_id or user.tg
    if tg_id:
        try:
            chat_url = f'https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/getChat'
            chat_resp = PROXY_SESSION.post(chat_url, json={'chat_id': tg_id}, timeout=5)
            chat_data = chat_resp.json()
            if chat_data.get('ok'):
                tg_result = chat_data.get('result', {})
                if tg_result.get('username'):
                    user_display = tg_result['username']
                elif tg_result.get('first_name'):
                    user_display = tg_result['first_name']
        except Exception as e:
            app.logger.warning(f'[å®¡æ ¸é€šçŸ¥] è·å–ç”¨æˆ· {tg_id} TGæ˜¾ç¤ºåç§°å¤±è´¥: {e}')
    
    # ç”¨æˆ· TG mention
    user_mention = f'<a href="tg://user?id={tg_id}">{user_display}</a>'
    
    tmdb_url = f"https://www.themoviedb.org/{movie_request.media_type}/{movie_request.tmdb_id}"
    now = datetime.now(timezone(timedelta(hours=8))).strftime('%Y-%m-%d %H:%M:%S')
    
    message_lines = [
        f"ğŸ“‹ <b>æ–°æ±‚ç‰‡å¾…å®¡æ ¸</b>",
        f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”",
        f"ğŸ‘¤ <b>ç”¨æˆ·ï¼š</b>{user_mention}",
        f"ğŸ <b>å½±ç‰‡ï¼š</b><b>{movie_request.title}</b> ({movie_request.year or 'æœªçŸ¥'})",
        f"ğŸ“ <b>ç±»å‹ï¼š</b>{media_type_cn}",
    ]
    
    if scope_info:
        message_lines.append(f"ğŸ“‘ <b>èŒƒå›´ï¼š</b>{scope_info}")
    
    message_lines.append(f"ğŸ†” <b>TMDBï¼š</b><code>{movie_request.tmdb_id}</code>")
    
    if movie_request.user_note:
        message_lines.append(f"ğŸ’¬ <b>ç”¨æˆ·å¤‡æ³¨ï¼š</b>{movie_request.user_note}")
    
    if movie_request.overview:
        overview_text = movie_request.overview[:120] + '...' if len(movie_request.overview) > 120 else movie_request.overview
        message_lines.append(f"ğŸ“ <b>ç®€ä»‹ï¼š</b>{overview_text}")
    
    message_lines.extend([
        f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”",
        f"ğŸ”— <a href='{tmdb_url}'>æŸ¥çœ‹ TMDB è¯¦æƒ…</a>",
        f"â° <b>æ±‚ç‰‡æ—¶é—´ï¼š</b>{now}"
    ])
    
    message = '\n'.join(message_lines)
    req_id = movie_request.id
    
    # æ„å»ºå®¡æ ¸æŒ‰é’®
    reply_markup = {
        'inline_keyboard': [[
            {'text': 'âœ… æ‰¹å‡†', 'callback_data': f'mreq_approve_{req_id}'},
            {'text': 'âŒ æ‹’ç»', 'callback_data': f'mreq_reject_{req_id}'}
        ]]
    }
    
    # å‘æ¯ä¸ªç®¡ç†å‘˜å‘é€ç§èŠé€šçŸ¥
    for admin_id in bot_admin_ids:
        try:
            if movie_request.poster_path:
                poster_url = f"{TMDB_IMAGE_BASE_URL}{movie_request.poster_path}"
                url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendPhoto"
                payload = {
                    'chat_id': admin_id,
                    'photo': poster_url,
                    'caption': message,
                    'parse_mode': 'HTML',
                    'reply_markup': reply_markup
                }
            else:
                url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendMessage"
                payload = {
                    'chat_id': admin_id,
                    'text': message,
                    'parse_mode': 'HTML',
                    'reply_markup': reply_markup
                }
            
            resp = PROXY_SESSION.post(url, json=payload, timeout=10)
            data = resp.json()
            if data.get('ok'):
                app.logger.info(f'[å®¡æ ¸é€šçŸ¥] å·²å‘é€ç»™ç®¡ç†å‘˜ {admin_id}: {movie_request.title}')
            else:
                app.logger.warning(f'[å®¡æ ¸é€šçŸ¥] å‘é€ç»™ç®¡ç†å‘˜ {admin_id} å¤±è´¥: {data.get("description")}')
        except Exception as e:
            app.logger.error(f'[å®¡æ ¸é€šçŸ¥] å‘é€ç»™ç®¡ç†å‘˜ {admin_id} å¼‚å¸¸: {e}')


def send_group_completion_notification(user_tg_id, username, title, year, media_type, tmdb_id, poster_path, 
                                        rating=None, quality=None, size=None, file_count=None):
    """
    å‘é€å…¥åº“å®Œæˆé€šçŸ¥åˆ°ç¾¤ç»„ï¼Œå¹¶@ç”¨æˆ·
    ç±»ä¼¼: @ç”¨æˆ·å âœ… æ‚¨è¯·æ±‚çš„å½±ç‰‡å·²å…¥åº“å®Œæˆï¼
    """
    group_id = TELEGRAM_GROUP_ID or TELEGRAM_CHAT_ID
    if not TELEGRAM_BOT_TOKEN or not group_id:
        app.logger.warning("Telegram ç¾¤ç»„é€šçŸ¥æœªé…ç½®ï¼Œè·³è¿‡å‘é€")
        return False
    
    # ä½¿ç”¨æ­£ç¡®çš„åª’ä½“åˆ†ç±»
    media_type_cn = get_media_category(media_type, tmdb_id)
    
    # æ„å»º@ç”¨æˆ·çš„ mentionï¼ˆä½¿ç”¨ HTML æ ¼å¼ï¼‰
    # ä½¿ç”¨ tg://user?id= æ ¼å¼å¯ä»¥ç‚¹å‡»å¹¶æ˜¾ç¤ºç”¨æˆ·å
    display_name = username or 'ç”¨æˆ·'
    if user_tg_id:
        user_mention = f'<a href="tg://user?id={user_tg_id}">{display_name}</a>'
    else:
        user_mention = f'<b>{display_name}</b>'
    
    # ä½¿ç”¨ç³»ç»Ÿå†…ç½®é»˜è®¤æ ¼å¼
    message_lines = [
        f"{user_mention} âœ… <b>æ‚¨è¯·æ±‚çš„å½±ç‰‡å·²å…¥åº“å®Œæˆï¼</b>",
        f"",
        f"<b>{title}</b> ({year or 'æœªçŸ¥'})",
    ]
    
    # æ·»åŠ æ–‡ä»¶æ•°é‡ä¿¡æ¯
    if file_count:
        message_lines.append(f"å·²å…¥åº“{file_count}ä¸ªæ–‡ä»¶")
    
    message_lines.append("")  # ç©ºè¡Œ
    
    # æ·»åŠ è¯¦ç»†ä¿¡æ¯
    if rating:
        message_lines.append(f"è¯„åˆ†ï¼š{rating}")
    message_lines.append(f"ç±»åˆ«ï¼š{media_type_cn}")
    if quality:
        message_lines.append(f"è´¨é‡ï¼š{quality}")
    if size:
        message_lines.append(f"å¤§å°ï¼š{size}")
    
    message_lines.extend([
        "",
        "ç°åœ¨å¯ä»¥åœ¨ Emby ä¸­è§‚çœ‹äº†ï¼"
    ])
    
    message = '\n'.join(message_lines)
    
    # å‘é€å¸¦å›¾ç‰‡çš„æ¶ˆæ¯
    try:
        if poster_path:
            poster_url = f"{TMDB_IMAGE_BASE_URL}{poster_path}"
            url = f'https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendPhoto'
            data = {
                'chat_id': group_id,
                'photo': poster_url,
                'caption': message,
                'parse_mode': 'HTML'
            }
        else:
            url = f'https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendMessage'
            data = {
                'chat_id': group_id,
                'text': message,
                'parse_mode': 'HTML',
                'disable_web_page_preview': False
            }
        
        response = http_session.post(url, json=data, timeout=10)
        response.raise_for_status()
        app.logger.info(f'ç¾¤ç»„å…¥åº“é€šçŸ¥å‘é€æˆåŠŸ: {title} -> ç¾¤ç»„ {group_id}')
        return True
    except Exception as e:
        app.logger.error(f"ç¾¤ç»„å…¥åº“é€šçŸ¥å‘é€å¤±è´¥: {e}")
        return False


def send_telegram_notification(username, title, year, media_type, tmdb_id, poster_path, overview=None, scope_info=None, user_tg_id=None):
    """å‘é€ Telegram é€šçŸ¥åˆ°ç®¡ç†å‘˜ç¾¤ç»„"""
    if not TELEGRAM_BOT_TOKEN or not TELEGRAM_CHAT_ID:
        app.logger.warning("Telegram é€šçŸ¥æœªé…ç½®ï¼Œè·³è¿‡å‘é€")
        return False
    
    # è·å–æ±‚ç‰‡é€šçŸ¥é…ç½®
    config = load_system_config()
    notification_config = config.get('telegram', {}).get('request_notification', {})
    
    # åˆ¤æ–­æ¨é€ç›®æ ‡
    send_to = notification_config.get('send_to', 'group')
    
    # ç¡®å®šæ¥æ”¶è€…
    if send_to == 'personal' and user_tg_id:
        # å‘é€ç»™ä¸ªäºº
        target_chat_id = user_tg_id
        app.logger.info(f"å‘é€æ±‚ç‰‡é€šçŸ¥åˆ°ä¸ªäºº: {user_tg_id}")
    else:
        # å‘é€ç»™ç¾¤ç»„ï¼ˆé»˜è®¤ï¼‰
        target_chat_id = TELEGRAM_CHAT_ID
        app.logger.info(f"å‘é€æ±‚ç‰‡é€šçŸ¥åˆ°ç¾¤ç»„: {TELEGRAM_CHAT_ID}")
    
    # ä½¿ç”¨æ­£ç¡®çš„åª’ä½“åˆ†ç±»
    media_category = get_media_category(media_type, tmdb_id)
    media_type_cn = f'ğŸ¬ {media_category}' if media_type == 'movie' else f'ğŸ“º {media_category}'
    tmdb_url = f"https://www.themoviedb.org/{media_type}/{tmdb_id}"
    
    # è·å–è‡ªå®šä¹‰é€šçŸ¥æ–‡æ¡ˆ
    custom_message = notification_config.get('custom_message', '')
    
    # æ„å»ºç®¡ç†å‘˜æé†’æ–‡æœ¬
    admin_mention = ''
    if notification_config.get('mention_admin', True) and UPLOAD_ADMINS:
        # å¤„ç†å¤šä¸ªç®¡ç†å‘˜ï¼ˆç”¨é€—å·åˆ†éš”ï¼‰
        admins = [admin.strip() for admin in UPLOAD_ADMINS.split(',') if admin.strip()]
        if admins:
            # ç¡®ä¿æ¯ä¸ªç®¡ç†å‘˜åå‰é¢æœ‰@ç¬¦å·
            admin_list = []
            for admin in admins:
                if not admin.startswith('@'):
                    admin = '@' + admin
                admin_list.append(admin)
            admin_mention = ' '.join(admin_list)
    
    # æ„å»ºæ±‚ç‰‡ç”¨æˆ· mentionï¼ˆä½¿ç”¨ HTML æ ¼å¼å¯ç‚¹å‡»è·³è½¬ï¼‰
    if user_tg_id:
        user_mention = f'<a href="tg://user?id={user_tg_id}">{username}</a>'
    else:
        user_mention = f'<b>{username}</b>'
    
    # è·å–å½“å‰æ—¶é—´
    now = datetime.now(timezone(timedelta(hours=8))).strftime('%Y-%m-%d %H:%M:%S')
    
    # å¦‚æœæœ‰è‡ªå®šä¹‰é€šçŸ¥æ–‡æ¡ˆï¼Œä½¿ç”¨è‡ªå®šä¹‰æ–‡æ¡ˆ
    if custom_message:
        message = custom_message
        # æ›¿æ¢å˜é‡
        message = message.replace('{user}', user_mention)
        message = message.replace('{admin}', admin_mention)
        message = message.replace('{title}', f'<b>{title}</b>')
        message = message.replace('{year}', str(year or 'æœªçŸ¥'))
        message = message.replace('{category}', media_type_cn)
        message = message.replace('{tmdb_id}', f'<code>{tmdb_id}</code>')
        message = message.replace('{tmdb_url}', f"<a href='{tmdb_url}'>æŸ¥çœ‹ TMDB è¯¦æƒ…</a>")
        message = message.replace('{time}', now)
        message = message.replace('{scope}', scope_info if scope_info else '')
        if notification_config.get('show_overview', True) and overview:
            overview_text = overview[:150] + '...' if len(overview) > 150 else overview
            message = message.replace('{overview}', overview_text)
        else:
            message = message.replace('{overview}', '')
    else:
        # ä½¿ç”¨é»˜è®¤æ ¼å¼
        message_lines = [
            f"ğŸ”” {user_mention} å‘æ¥äº†æ–°çš„æ±‚ç‰‡è¯·æ±‚{(' ' + admin_mention) if admin_mention else ''}",
            f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”",
            f"ğŸ <b>å½±ç‰‡åç§°ï¼š</b><b>{title}</b>",
            f"ğŸ“… <b>ä¸Šæ˜ å¹´ä»½ï¼š</b>{year or 'æœªçŸ¥'}",
            f"ğŸ“ <b>å½±ç‰‡ç±»å‹ï¼š</b>{media_type_cn}",
        ]
        
        # å¦‚æœæ˜¯å‰§é›†ä¸”æœ‰æ±‚ç‰‡èŒƒå›´ä¿¡æ¯
        if media_type == 'tv' and scope_info:
            message_lines.append(f"ğŸ“‘ <b>æ±‚ç‰‡èŒƒå›´ï¼š</b>{scope_info}")
        
        message_lines.append(f"ğŸ†” <b>TMDB IDï¼š</b><code>{tmdb_id}</code>")
        
        # å¦‚æœå¯ç”¨æ˜¾ç¤ºç®€ä»‹ä¸”æœ‰ç®€ä»‹ï¼Œæ·»åŠ ç®€ä»‹ï¼ˆé™åˆ¶é•¿åº¦ï¼‰
        if notification_config.get('show_overview', True) and overview:
            overview_text = overview[:150] + '...' if len(overview) > 150 else overview
            message_lines.append(f"ğŸ“ <b>ç®€ä»‹ï¼š</b>{overview_text}")
        
        message_lines.extend([
            f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”",
            f"ğŸ”— <a href='{tmdb_url}'>æŸ¥çœ‹ TMDB è¯¦æƒ…</a>",
            f"â° <b>æ±‚ç‰‡æ—¶é—´ï¼š</b>{now}"
        ])
        
        message = '\n'.join(message_lines)
    
    # å¦‚æœå¯ç”¨æ˜¾ç¤ºæµ·æŠ¥ä¸”æœ‰æµ·æŠ¥ï¼Œå‘é€å¸¦å›¾ç‰‡çš„æ¶ˆæ¯
    if notification_config.get('show_poster', True) and poster_path:
        poster_url = f"{TMDB_IMAGE_BASE_URL}{poster_path}"
        url = f'https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendPhoto'
        data = {
            'chat_id': target_chat_id,
            'photo': poster_url,
            'caption': message,
            'parse_mode': 'HTML'
        }
    else:
        # æ²¡æœ‰æµ·æŠ¥æˆ–æœªå¯ç”¨æµ·æŠ¥å°±å‘é€çº¯æ–‡æœ¬æ¶ˆæ¯
        url = f'https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendMessage'
        data = {
            'chat_id': target_chat_id,
            'text': message,
            'parse_mode': 'HTML',
            'disable_web_page_preview': False
        }
    
    try:
        response = http_session.post(url, json=data, timeout=5)  # ä½¿ç”¨æŒä¹…åŒ– session
        response.raise_for_status()
        app.logger.info(f'Telegram é€šçŸ¥å‘é€æˆåŠŸ: {title} ({username})')
        return True
    except requests.exceptions.Timeout:
        app.logger.error(f"Telegram é€šçŸ¥å‘é€è¶…æ—¶: {title}")
        return False
    except Exception as e:
        app.logger.error(f"Telegram é€šçŸ¥å‘é€å¤±è´¥: {e}")
        return False


def send_admin_notification(message: str):
    """å‘é€ç®€å•æ–‡æœ¬é€šçŸ¥åˆ°ç®¡ç†å‘˜ç¾¤ç»„ï¼ˆç”¨äºä¸‹è½½å®Œæˆç­‰ç³»ç»Ÿé€šçŸ¥ï¼‰"""
    if not TELEGRAM_BOT_TOKEN or not TELEGRAM_CHAT_ID:
        app.logger.warning("Telegram é€šçŸ¥æœªé…ç½®ï¼Œè·³è¿‡å‘é€")
        return False
    
    url = f'https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendMessage'
    data = {
        'chat_id': TELEGRAM_CHAT_ID,
        'text': message,
        'parse_mode': 'HTML',
        'disable_web_page_preview': True
    }
    
    try:
        response = http_session.post(url, json=data, timeout=5)
        response.raise_for_status()
        app.logger.info('ç®¡ç†å‘˜é€šçŸ¥å‘é€æˆåŠŸ')
        return True
    except requests.exceptions.Timeout:
        app.logger.error("ç®¡ç†å‘˜é€šçŸ¥å‘é€è¶…æ—¶")
        return False
    except Exception as e:
        app.logger.error(f"ç®¡ç†å‘˜é€šçŸ¥å‘é€å¤±è´¥: {e}")
        return False


def send_general_library_notification(title, year=None, season_episode=None, vote_average=None, 
                                       category=None, resource_quality=None, file_count=None, 
                                       total_size=None, tmdb_id=None, release_group=None, 
                                       time_usage=None, overview=None, poster_path=None):
    """
    å‘é€é€šç”¨åª’ä½“å…¥åº“é€šçŸ¥ï¼ˆä¸é™äºæ±‚ç‰‡ï¼‰
    
    å‚æ•°:
        title: æ ‡é¢˜
        year: å¹´ä»½
        season_episode: å­£é›†ä¿¡æ¯ï¼ˆå¦‚ "ç¬¬1å­£ç¬¬3é›†"ï¼‰
        vote_average: è¯„åˆ†
        category: ç±»åˆ«ï¼ˆç”µå½±/å‰§é›†/åŠ¨æ¼«ç­‰ï¼‰
        resource_quality: ç”»è´¨ï¼ˆ4K/1080p/720pç­‰ï¼‰
        file_count: æ–‡ä»¶æ•°é‡
        total_size: æ€»å¤§å°
        tmdb_id: TMDB ID
        release_group: åˆ¶ä½œç»„
        time_usage: å…¥åº“è€—æ—¶
        overview: ç®€ä»‹
        poster_path: æµ·æŠ¥è·¯å¾„
    """
    # æ£€æŸ¥æ˜¯å¦å¯ç”¨é€šç”¨å…¥åº“é€šçŸ¥
    config = load_system_config()
    library_notification = config.get('telegram', {}).get('library_notification', {})
    
    if not library_notification.get('enabled', False):
        app.logger.info('é€šç”¨å…¥åº“é€šçŸ¥æœªå¯ç”¨ï¼Œè·³è¿‡')
        return False
    
    # è·å–æœºå™¨äººé…ç½® (ä¼˜å…ˆä½¿ç”¨å…¥åº“é€šçŸ¥ä¸“ç”¨æœºå™¨äºº)
    bot_token = library_notification.get('bot_token', '').strip() or TELEGRAM_BOT_TOKEN
    target_chat_id = library_notification.get('chat_id', '').strip() or TELEGRAM_CHAT_ID
    
    if not bot_token or not target_chat_id:
        app.logger.warning("Telegram é€šçŸ¥æœªé…ç½®ï¼Œè·³è¿‡å‘é€")
        return False
    
    app.logger.info(f'å…¥åº“é€šçŸ¥é…ç½®: bot_token={"ä¸“ç”¨" if library_notification.get("bot_token") else "é»˜è®¤"}, chat_id={target_chat_id}')
    
    # å‡†å¤‡æ¨¡æ¿å˜é‡
    title_year = f"{title} ({year})" if year else title
    template_vars = {
        'title': title,
        'year': year,
        'title_year': title_year,
        'season_episode': season_episode,
        'vote_average': vote_average,
        'category': category,
        'resource_quality': resource_quality,
        'file_count': file_count,
        'total_size': total_size,
        'tmdb_id': tmdb_id,
        'release_group': release_group,
        'time_usage': time_usage,
        'overview': overview,
    }
    
    # ä½¿ç”¨å†…ç½®æ¨¡æ¿
    full_message = _build_default_notification_full(template_vars)
    
    # å‘é€é€šçŸ¥
    try:
        if poster_path and library_notification.get('show_poster', True):
            # å‘é€å¸¦æµ·æŠ¥çš„æ¶ˆæ¯
            # åˆ¤æ–­æ˜¯å®Œæ•´ URL è¿˜æ˜¯ TMDB ç›¸å¯¹è·¯å¾„
            if poster_path.startswith('http://') or poster_path.startswith('https://'):
                # å·²ç»æ˜¯å®Œæ•´ URLï¼ˆå¦‚ Emby å›¾ç‰‡ï¼‰
                poster_url = poster_path
            else:
                # TMDB ç›¸å¯¹è·¯å¾„
                poster_url = f"{TMDB_IMAGE_BASE_URL}{poster_path}"
            
            url = f'https://api.telegram.org/bot{bot_token}/sendPhoto'
            data = {
                'chat_id': target_chat_id,
                'photo': poster_url,
                'caption': full_message,
                'parse_mode': 'HTML'
            }
        else:
            # çº¯æ–‡æœ¬æ¶ˆæ¯
            url = f'https://api.telegram.org/bot{bot_token}/sendMessage'
            data = {
                'chat_id': target_chat_id,
                'text': full_message,
                'parse_mode': 'HTML',
                'disable_web_page_preview': False
            }
        
        response = http_session.post(url, json=data, timeout=10)
        response.raise_for_status()
        app.logger.info(f'é€šç”¨å…¥åº“é€šçŸ¥å‘é€æˆåŠŸ: {title}')
        return True
    except Exception as e:
        app.logger.error(f"é€šç”¨å…¥åº“é€šçŸ¥å‘é€å¤±è´¥: {e}")
        return False


def _build_default_notification_full(vars):
    """æ„å»ºé»˜è®¤æ ¼å¼çš„å®Œæ•´å…¥åº“é€šçŸ¥æ¶ˆæ¯"""
    from datetime import datetime
    
    # ç¡®å®šåª’ä½“ç±»å‹emojiå’Œç±»å‹åç§°
    category = vars.get('category', 'æœªçŸ¥')
    if category == 'ç”µå½±':
        type_emoji = 'ğŸ¬'
        type_name = 'ç”µå½±'
    elif category == 'å‰§é›†':
        type_emoji = 'ğŸ“º'
        type_name = 'å‰§é›†'
    elif category == 'åŠ¨æ¼«':
        type_emoji = 'ğŸŒ'
        type_name = 'åŠ¨æ¼«'
    else:
        type_emoji = 'ğŸ“€'
        type_name = category if category and category != 'æœªçŸ¥ç±»åˆ«' else 'å½±è§†'
    
    # æ„å»ºæ ‡é¢˜
    title_text = vars.get('title', 'æœªçŸ¥')
    if vars.get('year'):
        title_text += f" ({vars['year']})"
    
    # å¦‚æœæœ‰å­£é›†ä¿¡æ¯ï¼Œé™„åŠ åˆ°æ ‡é¢˜åé¢ï¼ˆå¦‚ "ç”Ÿå‘½æ ‘ (2024) S01 E25-E26"ï¼‰
    if vars.get('season_episode'):
        title_text += f" {vars['season_episode']}"
    
    # æ„å»ºæ¶ˆæ¯
    lines = []
    
    # æ ‡é¢˜è¡Œ
    lines.append(f"{type_emoji} <b>æ–°å…¥åº“ {type_name}</b> {title_text}")
    lines.append("")
    
    # ä¿¡æ¯åŒºåŸŸ
    info_lines = []
    info_lines.append(f"ğŸ“š <b>ç±»å‹ï¼š</b>{type_name}")
    
    if vars.get('vote_average'):
        try:
            rating = float(vars['vote_average'])
            if rating > 0:
                info_lines.append(f"â­ <b>è¯„åˆ†ï¼š</b>{rating}")
        except:
            pass
    
    if vars.get('tmdb_id'):
        info_lines.append(f"ğŸ¬ <b>TMDB IDï¼š</b><code>{vars['tmdb_id']}</code>")
    
    if vars.get('resource_quality'):
        info_lines.append(f"ğŸ“½ <b>ç”»è´¨ï¼š</b>{vars['resource_quality']}")
    
    if vars.get('file_count') and vars['file_count'] > 1:
        info_lines.append(f"ğŸ“ <b>é›†æ•°ï¼š</b>{vars['file_count']} é›†")
    
    if vars.get('total_size'):
        # total_size å¯èƒ½æ˜¯æ•°å­—ï¼ˆå­—èŠ‚ï¼‰æˆ–å­—ç¬¦ä¸²ï¼ˆå¦‚ "2.35GB"ï¼‰
        size = vars['total_size']
        if isinstance(size, str):
            # å·²ç»æ˜¯æ ¼å¼åŒ–çš„å­—ç¬¦ä¸²ï¼Œç›´æ¥ä½¿ç”¨
            info_lines.append(f"ğŸ’¾ <b>å¤§å°ï¼š</b>{size}")
        elif isinstance(size, (int, float)) and size > 0:
            if size >= 1024 * 1024 * 1024:
                size_str = f"{size / (1024 * 1024 * 1024):.2f} GB"
            elif size >= 1024 * 1024:
                size_str = f"{size / (1024 * 1024):.2f} MB"
            else:
                size_str = f"{size / 1024:.2f} KB"
            info_lines.append(f"ğŸ’¾ <b>å¤§å°ï¼š</b>{size_str}")
    
    # å…¥åº“æ—¶é—´
    current_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    info_lines.append(f"ğŸ• <b>æ—¶é—´ï¼š</b>{current_time}")
    
    lines.extend(info_lines)
    
    return '\n'.join(lines)


def log_user_activity(action_type, user=None, user_tg=None, user_name=None, detail=None, status='success', extra_data=None):
    """
    è®°å½•ç”¨æˆ·æ“ä½œæ—¥å¿—
    
    å‚æ•°:
        action_type: æ“ä½œç±»å‹ï¼ˆä½¿ç”¨ UserActivityLog.ACTION_* å¸¸é‡ï¼‰
        user: User å¯¹è±¡ï¼ˆå¯é€‰ï¼Œå¦‚æœæä¾›ä¼šè‡ªåŠ¨è·å– tg å’Œ nameï¼‰
        user_tg: ç”¨æˆ· TG IDï¼ˆå¦‚æœæ²¡æœ‰ user å¯¹è±¡æ—¶ä½¿ç”¨ï¼‰
        user_name: ç”¨æˆ·åï¼ˆå¦‚æœæ²¡æœ‰ user å¯¹è±¡æ—¶ä½¿ç”¨ï¼‰
        detail: æ“ä½œè¯¦æƒ…ï¼ˆå­—ç¬¦ä¸²æˆ–å­—å…¸ï¼Œå­—å…¸ä¼šè½¬ä¸ºJSONï¼‰
        status: æ“ä½œçŠ¶æ€ 'success' æˆ– 'failed'
        extra_data: é¢å¤–æ•°æ®ï¼ˆå­—å…¸ï¼Œä¼šè½¬ä¸ºJSONï¼‰
    
    ç”¨æ³•ç¤ºä¾‹:
        # ä½¿ç”¨ user å¯¹è±¡
        log_user_activity(UserActivityLog.ACTION_LOGIN, user=current_user, detail='ç½‘é¡µç™»å½•')
        
        # ä½¿ç”¨ tg å’Œ name
        log_user_activity(UserActivityLog.ACTION_REQUEST_MOVIE, user_tg=123456, user_name='å¼ ä¸‰', 
                         detail={'movie': 'å¤ä»‡è€…è”ç›Ÿ', 'tmdb_id': 12345})
    """
    import json
    
    try:
        # è·å–ç”¨æˆ·ä¿¡æ¯
        tg = None
        name = None
        
        if user:
            tg = user.tg
            name = user.name
        else:
            tg = user_tg
            name = user_name
        
        # å¤„ç† detail
        if isinstance(detail, dict):
            detail_str = json.dumps(detail, ensure_ascii=False)
        else:
            detail_str = str(detail) if detail else None
        
        # å¤„ç† extra_data
        if isinstance(extra_data, dict):
            extra_str = json.dumps(extra_data, ensure_ascii=False)
        else:
            extra_str = None
        
        # è·å–è¯·æ±‚ä¿¡æ¯
        ip_address = None
        user_agent = None
        try:
            if request:
                ip_address = request.headers.get('X-Forwarded-For', request.remote_addr)
                if ip_address and ',' in ip_address:
                    ip_address = ip_address.split(',')[0].strip()
                user_agent = request.headers.get('User-Agent', '')[:500]
        except RuntimeError:
            # ä¸åœ¨è¯·æ±‚ä¸Šä¸‹æ–‡ä¸­
            pass
        
        # åˆ›å»ºæ—¥å¿—è®°å½•
        log = UserActivityLog(
            user_tg=tg,
            user_name=name,
            action_type=action_type,
            action_detail=detail_str,
            ip_address=ip_address,
            user_agent=user_agent,
            status=status,
            extra_data=extra_str
        )
        
        db.session.add(log)
        db.session.commit()
        
        app.logger.debug(f'è®°å½•ç”¨æˆ·æ“ä½œ: {action_type}, user={name}, status={status}')
        return True
        
    except Exception as e:
        app.logger.error(f'è®°å½•ç”¨æˆ·æ“ä½œæ—¥å¿—å¤±è´¥: {e}')
        try:
            db.session.rollback()
        except:
            pass
        return False


def log_admin_audit(action_type, detail=None, target_type=None, target_id=None):
    """
    è®°å½•ç®¡ç†å‘˜æ“ä½œå®¡è®¡æ—¥å¿—
    
    å‚æ•°:
        action_type: æ“ä½œç±»å‹ï¼ˆä½¿ç”¨ AdminAuditLog.ACTION_* å¸¸é‡ï¼‰
        detail: æ“ä½œè¯¦æƒ…ï¼ˆå­—ç¬¦ä¸²ï¼‰
        target_type: ç›®æ ‡ç±»å‹ (user, order, config, redeem, plan, etc.)
        target_id: ç›®æ ‡IDï¼ˆç”¨æˆ·IDã€è®¢å•å·ç­‰ï¼‰
    """
    try:
        # è·å–å½“å‰ç®¡ç†å‘˜ä¿¡æ¯
        admin_username = session.get('admin_username', 'unknown')
        admin_id = session.get('admin_user_id')
        
        # è·å–è¯·æ±‚ä¿¡æ¯
        ip_address = None
        user_agent = None
        try:
            if request:
                ip_address = request.headers.get('X-Forwarded-For', request.remote_addr)
                if ip_address and ',' in ip_address:
                    ip_address = ip_address.split(',')[0].strip()
                user_agent = request.headers.get('User-Agent', '')[:500]
        except RuntimeError:
            pass
        
        log = AdminAuditLog(
            admin_username=admin_username,
            admin_id=admin_id,
            action_type=action_type,
            action_detail=str(detail) if detail else None,
            target_type=target_type,
            target_id=str(target_id) if target_id else None,
            ip_address=ip_address,
            user_agent=user_agent
        )
        
        db.session.add(log)
        db.session.commit()
        
        app.logger.debug(f'å®¡è®¡æ—¥å¿—: {admin_username} -> {action_type}: {detail}')
        return True
        
    except Exception as e:
        app.logger.error(f'è®°å½•ç®¡ç†å‘˜å®¡è®¡æ—¥å¿—å¤±è´¥: {e}')
        try:
            db.session.rollback()
        except:
            pass
        return False


# è·¯ç”±
@app.route('/')
def index():
    if 'user_id' not in session:
        return redirect(url_for('login'))
    # éªŒè¯session_token
    user = db.session.get(User, session['user_id'])
    if not user or (user.session_token and session.get('session_token') != user.session_token):
        for _k in ['user_id', 'username', 'session_token', 'is_admin', 'user_level']:
            session.pop(_k, None)
        return redirect(url_for('login'))
    return redirect(url_for('dashboard'))


@app.route('/register', methods=['GET'])
def register_page():
    """æ³¨å†Œé¡µé¢"""
    site_config = get_site_config()
    register_mode = site_config.get('register_mode', 'open')
    
    # å¦‚æœæ³¨å†Œå·²å…³é—­ï¼Œè·³è½¬åˆ°ç™»å½•é¡µ
    if register_mode == 'closed':
        return redirect('/login?error=' + quote('æ³¨å†ŒåŠŸèƒ½å·²å…³é—­'))
    
    invite_code = request.args.get('invite', '')
    
    # å¦‚æœæ˜¯ä»…é‚€è¯·æ³¨å†Œæ¨¡å¼ä½†æ²¡æœ‰é‚€è¯·ç ï¼Œè·³è½¬åˆ°ç™»å½•é¡µ
    if register_mode == 'invite' and not invite_code:
        return redirect('/login?error=' + quote('æ³¨å†Œéœ€è¦é‚€è¯·ç '))
    
    sys_cfg = get_system_config()
    invite_reward_enabled = sys_cfg.get('invite_reward', {}).get('enabled', True)
    email_cfg = sys_cfg.get('email', {})
    email_enabled = email_cfg.get('enabled', False)
    require_email_register = email_cfg.get('require_email_register', False)
    
    return render_template('register.html', 
                         invite_code=invite_code, 
                         site_config=site_config,
                         register_mode=register_mode,
                         invite_reward_enabled=invite_reward_enabled,
                         email_enabled=email_enabled,
                         require_email_register=require_email_register)


@app.route('/api/account/register-email-code', methods=['POST'])
def send_register_email_code():
    """æ³¨å†Œæ—¶å‘é€é‚®ç®±éªŒè¯ç ï¼ˆä¸éœ€è¦ç™»å½•ï¼‰"""
    try:
        email_cfg = get_email_config()
        if not email_cfg.get('enabled'):
            return jsonify({'success': False, 'error': 'é‚®ä»¶åŠŸèƒ½æœªå¯ç”¨'}), 400
        
        data = request.get_json()
        email_addr = data.get('email', '').strip().lower()
        
        import re
        if not email_addr or not re.match(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$', email_addr):
            return jsonify({'success': False, 'error': 'è¯·è¾“å…¥æœ‰æ•ˆçš„é‚®ç®±åœ°å€'}), 400
        
        # æ£€æŸ¥é‚®ç®±æ˜¯å¦å·²è¢«ä½¿ç”¨
        existing = User.query.filter_by(email=email_addr).first()
        if existing:
            return jsonify({'success': False, 'error': 'è¯¥é‚®ç®±å·²è¢«æ³¨å†Œ'}), 400
        
        # é™é¢‘ï¼š60ç§’å†…åªèƒ½è¯·æ±‚ä¸€æ¬¡
        cache_key = f'reg_{email_addr}'
        if cache_key in EMAIL_VERIFY_CODES:
            prev = EMAIL_VERIFY_CODES[cache_key]
            if prev.get('created_at') and (datetime.now() - prev['created_at']).total_seconds() < 60:
                remaining = 60 - int((datetime.now() - prev['created_at']).total_seconds())
                return jsonify({'success': False, 'error': f'è¯· {remaining} ç§’åé‡è¯•'}), 429
        
        verify_code = str(random.randint(100000, 999999))
        EMAIL_VERIFY_CODES[cache_key] = {
            'code': verify_code,
            'email': email_addr,
            'created_at': datetime.now(),
            'expires_at': datetime.now() + timedelta(minutes=5)
        }
        
        site_name = get_site_config().get('site_name', 'Emby')
        body = f"""<p>æ‚¨å¥½ï¼</p>
<p>æ‚¨æ­£åœ¨æ³¨å†Œ {site_name} è´¦å·ï¼Œè¯·ä½¿ç”¨ä»¥ä¸‹éªŒè¯ç å®Œæˆé‚®ç®±éªŒè¯ï¼š</p>
<div class="code-box"><div class="code">{verify_code}</div></div>
<p>éªŒè¯ç  <b>5 åˆ†é’Ÿ</b>å†…æœ‰æ•ˆï¼Œè¯·å‹¿å°†éªŒè¯ç å‘ŠçŸ¥ä»–äººã€‚</p>
<p>å¦‚éæœ¬äººæ“ä½œï¼Œè¯·å¿½ç•¥æ­¤é‚®ä»¶ã€‚</p>"""
        
        html = build_email_html(f'{site_name} - æ³¨å†Œé‚®ç®±éªŒè¯', body, site_name)
        success, msg = send_email(email_addr, f'ã€{site_name}ã€‘æ³¨å†Œé‚®ç®±éªŒè¯ç ', html)
        
        if success:
            masked = email_addr[:3] + '***' + email_addr[email_addr.index('@'):]
            return jsonify({'success': True, 'message': f'éªŒè¯ç å·²å‘é€åˆ° {masked}'}), 200
        else:
            del EMAIL_VERIFY_CODES[cache_key]
            return jsonify({'success': False, 'error': f'é‚®ä»¶å‘é€å¤±è´¥: {msg}'}), 500
        
    except Exception as e:
        app.logger.error(f'æ³¨å†Œå‘é€é‚®ç®±éªŒè¯ç å¤±è´¥: {e}', exc_info=True)
        return jsonify({'success': False, 'error': 'å‘é€å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•'}), 500


@app.route('/api/register', methods=['POST'])
def register():
    """ç”¨æˆ·æ³¨å†Œ API"""
    try:
        # æ£€æŸ¥æ³¨å†Œæ¨¡å¼
        site_config = get_site_config()
        register_mode = site_config.get('register_mode', 'open')
        
        data = request.get_json()
        username = data.get('username', '').strip()
        password = data.get('password', '')
        invite_code = data.get('invite_code', '').strip()
        reg_email = data.get('email', '').strip().lower() if data.get('email') else ''
        
        # å¦‚æœæ³¨å†Œå·²å…³é—­ï¼Œç›´æ¥æ‹’ç»
        if register_mode == 'closed':
            return jsonify({'success': False, 'error': 'æ³¨å†ŒåŠŸèƒ½å·²å…³é—­'}), 403
        
        # å¦‚æœæ˜¯ä»…é‚€è¯·æ³¨å†Œæ¨¡å¼ï¼Œå¿…é¡»æä¾›é‚€è¯·ç 
        if register_mode == 'invite' and not invite_code:
            return jsonify({'success': False, 'error': 'ä»…é‚€è¯·æ³¨å†Œæ¨¡å¼ï¼Œå¿…é¡»æä¾›é‚€è¯·ç '}), 403
        
        # éªŒè¯ç”¨æˆ·åï¼ˆæ”¯æŒä¸­æ–‡ã€å­—æ¯ã€æ•°å­—ã€ä¸‹åˆ’çº¿ï¼‰
        if not username or len(username) < 1 or len(username) > 20:
            return jsonify({'success': False, 'error': 'ç”¨æˆ·åé•¿åº¦å¿…é¡»åœ¨1-20ä¸ªå­—ç¬¦ä¹‹é—´'}), 400
        
        import re
        if not re.match(r'^[a-zA-Z0-9_\u4e00-\u9fff]+$', username):
            return jsonify({'success': False, 'error': 'ç”¨æˆ·ååªèƒ½åŒ…å«ä¸­æ–‡ã€å­—æ¯ã€æ•°å­—ã€ä¸‹åˆ’çº¿'}), 400
        
        # éªŒè¯å¯†ç ï¼ˆå…è®¸ä¸ºç©ºï¼Œä¸ä¸ºç©ºæ—¶é•¿åº¦ä¸è¶…è¿‡32ï¼‰
        if password and len(password) > 32:
            return jsonify({'success': False, 'error': 'å¯†ç é•¿åº¦ä¸èƒ½è¶…è¿‡32ä¸ªå­—ç¬¦'}), 400
        
        # æ£€æŸ¥ç”¨æˆ·åæ˜¯å¦å·²å­˜åœ¨
        existing_user = User.query.filter_by(name=username).first()
        if existing_user:
            return jsonify({'success': False, 'error': 'ç”¨æˆ·åå·²è¢«ä½¿ç”¨'}), 400
        
        # æ£€æŸ¥é‚®ç®±
        sys_cfg = get_system_config()
        email_cfg = sys_cfg.get('email', {})
        if email_cfg.get('enabled') and email_cfg.get('require_email_register') and not reg_email:
            return jsonify({'success': False, 'error': 'è¯·å¡«å†™é‚®ç®±åœ°å€'}), 400
        
        if reg_email:
            if not re.match(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$', reg_email):
                return jsonify({'success': False, 'error': 'è¯·è¾“å…¥æœ‰æ•ˆçš„é‚®ç®±åœ°å€'}), 400
            existing_email = User.query.filter_by(email=reg_email).first()
            if existing_email:
                return jsonify({'success': False, 'error': 'è¯¥é‚®ç®±å·²è¢«ä½¿ç”¨'}), 400
            
            # éªŒè¯é‚®ç®±éªŒè¯ç ï¼ˆé‚®ä»¶åŠŸèƒ½å¯ç”¨æ—¶å¿…é¡»éªŒè¯ï¼‰
            if email_cfg.get('enabled'):
                email_code = data.get('email_code', '').strip()
                if not email_code:
                    return jsonify({'success': False, 'error': 'è¯·è¾“å…¥é‚®ç®±éªŒè¯ç '}), 400
                cache_key = f'reg_{reg_email}'
                vdata = EMAIL_VERIFY_CODES.get(cache_key)
                if not vdata:
                    return jsonify({'success': False, 'error': 'è¯·å…ˆå‘é€é‚®ç®±éªŒè¯ç '}), 400
                if datetime.now() > vdata['expires_at']:
                    del EMAIL_VERIFY_CODES[cache_key]
                    return jsonify({'success': False, 'error': 'éªŒè¯ç å·²è¿‡æœŸï¼Œè¯·é‡æ–°å‘é€'}), 400
                # æ£€æŸ¥å°è¯•æ¬¡æ•°ï¼ˆé˜²æš´åŠ›ç ´è§£ï¼‰
                vdata.setdefault('attempts', 0)
                vdata['attempts'] += 1
                if vdata['attempts'] > 5:
                    del EMAIL_VERIFY_CODES[cache_key]
                    return jsonify({'success': False, 'error': 'éªŒè¯ç é”™è¯¯æ¬¡æ•°è¿‡å¤šï¼Œè¯·é‡æ–°è·å–'}), 400
                if vdata['code'] != email_code:
                    remaining = 5 - vdata['attempts']
                    return jsonify({'success': False, 'error': f'é‚®ç®±éªŒè¯ç é”™è¯¯ï¼Œè¿˜å¯å°è¯• {remaining} æ¬¡'}), 400
                # éªŒè¯é€šè¿‡ï¼Œæ¸…é™¤éªŒè¯ç 
                del EMAIL_VERIFY_CODES[cache_key]
        
        # ç”Ÿæˆå”¯ä¸€çš„æ­£æ•´æ•°ç”¨æˆ· IDï¼ˆä» 1000 å¼€å§‹é€’å¢ï¼‰
        new_tg = generate_next_user_id()
        
        # å¤„ç†é‚€è¯·ç 
        inviter = None
        if invite_code:
            # æŸ¥æ‰¾é‚€è¯·äººï¼ˆé€šè¿‡é‚€è¯·ç ï¼‰
            # é‚€è¯·ç æ˜¯åŸºäºç”¨æˆ· tg ID ç”Ÿæˆçš„ MD5 å‰8ä½
            for user in User.query.filter(User.lv.in_(['a', 'b'])).all():
                expected_code = hashlib.md5(f'{user.tg}_invite'.encode()).hexdigest()[:8].upper()
                if expected_code == invite_code.upper():
                    inviter = user
                    break
            
            # å¦‚æœå¡«å†™äº†é‚€è¯·ç ä½†æ‰¾ä¸åˆ°å¯¹åº”çš„é‚€è¯·äººï¼Œè¿”å›é”™è¯¯
            if not inviter:
                return jsonify({'success': False, 'error': 'é‚€è¯·ç æ— æ•ˆï¼Œè¯·æ£€æŸ¥åé‡è¯•æˆ–ç•™ç©ºç›´æ¥æ³¨å†Œ'}), 400
        
        # åˆ›å»ºæ–°ç”¨æˆ·
        new_user = User(
            tg=new_tg,
            name=username,
            pwd=password,
            lv='b',  # æ³¨å†Œç”¨æˆ·ç­‰çº§ä¸º B
            cr=datetime.now(),
            ex=None,  # æ–°ç”¨æˆ·ä¸èµ é€æ—¶é—´
            us=1,
            iv=0,
            ch=None,
            email=reg_email or None
        )
        
        db.session.add(new_user)
        
        # å…ˆæäº¤ç”¨æˆ·è®°å½•ï¼Œç¡®ä¿å¤–é”®çº¦æŸæ»¡è¶³
        db.session.flush()
        
        # å¦‚æœæœ‰é‚€è¯·äººï¼Œåªè®°å½•é‚€è¯·å…³ç³»ï¼ˆå¥–åŠ±åœ¨è¢«é‚€è¯·äººè´­ä¹°æ—¶å‘æ”¾ï¼‰
        if inviter:
            invite_record = InviteRecord(
                inviter_tg=inviter.tg,
                invitee_tg=new_tg,
                invite_code=invite_code.upper(),
                reward_type='pending',  # å¾…å‘æ”¾ï¼Œç­‰è¢«é‚€è¯·äººè´­ä¹°æ—¶å†å¥–åŠ±
                reward_value=0,
                reward_claimed=False
            )
            db.session.add(invite_record)
            
            # å¢åŠ é‚€è¯·äººçš„é‚€è¯·è®¡æ•°
            inviter.iv = (inviter.iv or 0) + 1
            
            app.logger.info(f'ç”¨æˆ· {username} é€šè¿‡é‚€è¯·ç  {invite_code} æ³¨å†Œï¼Œé‚€è¯·äºº: {inviter.name}')
        
        db.session.commit()
        
        app.logger.info(f'æ–°ç”¨æˆ·æ³¨å†ŒæˆåŠŸ: {username} (tg={new_tg})')
        
        # è®°å½•æ³¨å†Œæ—¥å¿—
        log_user_activity(UserActivityLog.ACTION_REGISTER, user=new_user, 
                         detail={'invite_code': invite_code, 'inviter': inviter.name if inviter else None})
        
        # å¦‚æœä½¿ç”¨äº†é‚€è¯·ç ï¼Œè®°å½•é‚€è¯·ç ä½¿ç”¨æ—¥å¿—
        if inviter:
            log_user_activity(UserActivityLog.ACTION_INVITE_USED, user=new_user,
                             detail={'inviter_tg': inviter.tg, 'inviter_name': inviter.name, 'invite_code': invite_code})
        
        return jsonify({
            'success': True,
            'message': 'æ³¨å†ŒæˆåŠŸï¼',
            'user': {
                'username': username,
                'level': 'b',
                'expire_date': new_user.ex.strftime('%Y-%m-%d') if new_user.ex else None
            }
        }), 200
        
    except Exception as e:
        db.session.rollback()
        app.logger.error(f'æ³¨å†Œå¤±è´¥: {e}', exc_info=True)
        return jsonify({'success': False, 'error': 'æ³¨å†Œå¤±è´¥ï¼Œè¯·ç¨åé‡è¯•'}), 500


@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        data = request.get_json()
        username = data.get('username')
        password = data.get('password', '') or ''  # å…è®¸ç©ºå¯†ç 
        
        # ===== æš´åŠ›ç ´è§£é˜²æŠ¤ï¼šæ£€æŸ¥IPæ˜¯å¦è¢«é”å®š =====
        locked, remaining = login_limiter.is_locked(extra_key='user')
        if locked:
            minutes = remaining // 60 + 1
            app.logger.warning(f'ç”¨æˆ·ç™»å½•è¢«é™æµ: IPå·²é”å®šï¼Œå‰©ä½™ {remaining}ç§’')
            return jsonify({'success': False, 'error': f'ç™»å½•å°è¯•è¿‡å¤šï¼Œè¯· {minutes} åˆ†é’Ÿåå†è¯•'}), 429
        
        # é€šè¿‡nameå­—æ®µæŸ¥æ‰¾ç”¨æˆ·
        user = User.query.filter_by(name=username).first()
        
        # éªŒè¯å¯†ç ï¼ˆåªéªŒè¯ç½‘ç«™å¯†ç pwdï¼Œä¸éªŒè¯Embyå¯†ç pwd2ï¼›ç©ºå¯†ç ä¹Ÿå¯åŒ¹é…ï¼‰
        if user and (user.pwd or '') == password:
            # æ£€æŸ¥ç”¨æˆ·æ˜¯å¦è¢«å°ç¦ï¼ˆåªæ‹¦æˆª C çº§ç¦ç”¨ç”¨æˆ·ï¼Œå…¶ä»–ç­‰çº§éƒ½å…è®¸ç™»å½•ï¼‰
            # æ³¨æ„ï¼šç™»å½• â‰  æœ‰Embyä½¿ç”¨æƒï¼Œæ–°æ³¨å†Œç”¨æˆ·(Bçº§æ— è®¢é˜…)å’ŒDçº§ç”¨æˆ·ä¹Ÿåº”èƒ½ç™»å½•ç½‘ç«™
            if user.lv == 'c':
                app.logger.warning(f'ç”¨æˆ· {username} ç™»å½•å¤±è´¥: è´¦æˆ·å·²è¢«ç¦ç”¨')
                log_user_activity(UserActivityLog.ACTION_LOGIN, user=user, detail='è´¦æˆ·å·²è¢«ç¦ç”¨', status='failed')
                login_limiter.record_failure(extra_key='user')
                ban_reason = f'ï¼ˆåŸå› ï¼š{user.ban_reason}ï¼‰' if user.ban_reason else ''
                return jsonify({'success': False, 'error': f'è´¦æˆ·å·²è¢«ç¦ç”¨{ban_reason}'}), 401
            
            # ç™»å½•æˆåŠŸï¼Œæ¸…é™¤å¤±è´¥è®°å½•
            login_limiter.record_success(extra_key='user')
            
            # ç”Ÿæˆæ–°çš„session_token
            import secrets
            new_token = secrets.token_hex(32)
            user.session_token = new_token
            db.session.commit()
            
            # æ¸…é™¤æ—§çš„ç”¨æˆ· session å­—æ®µï¼ˆä¿ç•™ç®¡ç†å‘˜ç™»å½•çŠ¶æ€ï¼Œå…è®¸åŒæ—¶ç™»å½•ï¼‰
            for _k in ['user_id', 'username', 'is_admin', 'user_level', 'session_token']:
                session.pop(_k, None)
            session.permanent = True  # ä½¿ PERMANENT_SESSION_LIFETIME ç”Ÿæ•ˆ
            session['user_id'] = user.tg
            session['username'] = user.name
            session['is_admin'] = user.is_admin
            session['user_level'] = user.lv
            session['session_token'] = new_token  # å­˜å‚¨tokenåˆ°session
            session.modified = True  # å¼ºåˆ¶ Flask å‘é€ Set-Cookie
            app.logger.info(f'ç”¨æˆ· {username} ç™»å½•æˆåŠŸ, user_id={user.tg}, token={new_token[:8]}...')
            log_user_activity(UserActivityLog.ACTION_LOGIN, user=user, detail='ç½‘é¡µç™»å½•æˆåŠŸ')
            
            # ===== ç™»å½•é€šçŸ¥ï¼ˆå¼‚æ­¥ï¼Œä¸é˜»å¡ç™»å½•å“åº”ï¼‰=====
            try:
                _send_login_notification(user)
            except Exception:
                pass  # é€šçŸ¥å¤±è´¥ä¸å½±å“ç™»å½•
            
            # ç™»å½•æ—¶æ£€æŸ¥ï¼šå¦‚æœç”¨æˆ·æœ‰æœ‰æ•ˆè®¢é˜…ä½† Emby è´¦å·å¯èƒ½è¢«ç¦ç”¨ï¼Œè‡ªåŠ¨æ¢å¤ï¼ˆå°ç¦ç”¨æˆ·å’Œé»‘åå•ç¦ç”¨ç”¨æˆ·é™¤å¤–ï¼‰
            if user.lv != 'c' and not user.ban_reason and user.embyid and emby_client.is_enabled():
                has_valid_sub = user.lv in ['a', 'b'] and user.ex and user.ex > datetime.now()
                if has_valid_sub:
                    try:
                        emby_client.enable_user(user.embyid)
                    except Exception:
                        pass  # ä¸å½±å“ç™»å½•
            
            return jsonify({'success': True, 'redirect': url_for('dashboard')}), 200
        else:
            app.logger.warning(f'ç™»å½•å¤±è´¥: ç”¨æˆ·å={username}')
            log_user_activity(UserActivityLog.ACTION_LOGIN, user_name=username, detail='ç”¨æˆ·åæˆ–å¯†ç é”™è¯¯', status='failed')
            # è®°å½•å¤±è´¥å°è¯•ï¼ˆæš´åŠ›ç ´è§£é˜²æŠ¤ï¼‰
            login_limiter.record_failure(extra_key='user')
            return jsonify({'success': False, 'error': 'ç”¨æˆ·åæˆ–å¯†ç é”™è¯¯'}), 401
    
    site_config = get_site_config()
    register_mode = site_config.get('register_mode', 'open')
    error_message = request.args.get('error', '')
    
    return render_template('login.html', 
                         site_config=site_config, 
                         register_mode=register_mode,
                         error_message=error_message)


@app.route('/logout')
def logout():
    user_id = session.get('user_id')
    username = session.get('username')
    if user_id:
        log_user_activity(UserActivityLog.ACTION_LOGOUT, user_tg=user_id, user_name=username, detail='ç½‘é¡µç™»å‡º')
    # åªæ¸…é™¤ç”¨æˆ·ç›¸å…³çš„sessionï¼Œä¿ç•™ç®¡ç†å‘˜session
    for _k in ['user_id', 'username', 'emby_username', 'user_logged_in', 'session_token', 'is_admin', 'user_level']:
        session.pop(_k, None)
    return redirect(url_for('login'))


@app.route('/forgot-password')
def forgot_password_page():
    """å¿˜è®°å¯†ç é¡µé¢"""
    site_config = get_site_config()
    _email_cfg = get_system_config().get('email', {})
    email_enabled = _email_cfg.get('enabled', False)
    return render_template('forgot_password.html', site_config=site_config, email_enabled=email_enabled)


# ==================== ä¿®æ”¹å¯†ç åŠŸèƒ½ ====================

@app.route('/api/account/change-password', methods=['POST'])
@login_required
def change_password():
    """ä¿®æ”¹ç”¨æˆ·å¯†ç """
    try:
        data = request.get_json()
        current_password = data.get('current_password', '') or ''
        new_password = data.get('new_password', '') or ''
        
        if new_password and len(new_password) > 32:
            return jsonify({'success': False, 'error': 'æ–°å¯†ç é•¿åº¦ä¸èƒ½è¶…è¿‡32ä¸ªå­—ç¬¦'}), 400
        
        user = db.session.get(User, session['user_id'])
        if not user:
            return jsonify({'success': False, 'error': 'ç”¨æˆ·ä¸å­˜åœ¨'}), 404
        
        # éªŒè¯å½“å‰å¯†ç ï¼ˆå…¼å®¹ç©ºå¯†ç ï¼‰
        if (user.pwd or '') != current_password and (user.pwd2 or '') != current_password:
            return jsonify({'success': False, 'error': 'å½“å‰å¯†ç ä¸æ­£ç¡®'}), 400
        
        # æ›´æ–°å¯†ç å’Œsession_token
        user.pwd = new_password
        import secrets
        user.session_token = secrets.token_hex(32)  # æ›´æ–°tokenä½¿å…¶ä»–ä¼šè¯å¤±æ•ˆ
        db.session.commit()
        
        app.logger.info(f'ç”¨æˆ·å¯†ç å·²ä¿®æ”¹: {user.name} (tg={user.tg})')
        log_user_activity(UserActivityLog.ACTION_PASSWORD_CHANGE, user=user, detail='ä¿®æ”¹ç™»å½•å¯†ç ')
        
        # å¯†ç ä¿®æ”¹æˆåŠŸåï¼Œæ¸…é™¤å½“å‰ç”¨æˆ·sessionï¼Œå¼ºåˆ¶é‡æ–°ç™»å½•
        for _k in ['user_id', 'username', 'user_logged_in', 'session_token', 'is_admin', 'user_level']:
            session.pop(_k, None)
        
        return jsonify({'success': True, 'message': 'å¯†ç ä¿®æ”¹æˆåŠŸï¼Œè¯·é‡æ–°ç™»å½•', 'require_relogin': True}), 200
        
    except Exception as e:
        db.session.rollback()
        app.logger.error(f'ä¿®æ”¹å¯†ç å¤±è´¥: {e}', exc_info=True)
        return jsonify({'success': False, 'error': 'ä¿®æ”¹å¯†ç å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•'}), 500


# ==================== å¿˜è®°å¯†ç åŠŸèƒ½ ====================

@app.route('/api/account/forgot-password', methods=['POST'])
def forgot_password():
    """å¿˜è®°å¯†ç  - å‘é€éªŒè¯ç åˆ°ç”¨æˆ·ç»‘å®šçš„ Telegram"""
    try:
        data = request.get_json()
        username = data.get('username', '').strip()
        
        if not username:
            return jsonify({'success': False, 'error': 'è¯·è¾“å…¥ç”¨æˆ·å'}), 400
        
        # æŸ¥æ‰¾ç”¨æˆ·
        user = User.query.filter_by(name=username).first()
        if not user:
            return jsonify({'success': False, 'error': 'ç”¨æˆ·åä¸å­˜åœ¨'}), 400
        
        # æ£€æŸ¥ç”¨æˆ·æ˜¯å¦ç»‘å®šäº† Telegram
        if not user.telegram_id:
            # æ£€æŸ¥é‚®ä»¶åŠŸèƒ½æ˜¯å¦å¯ç”¨ä¸”ç”¨æˆ·å·²ç»‘å®šé‚®ç®±ï¼Œå¼•å¯¼ç”¨æˆ·ä½¿ç”¨é‚®ç®±æ‰¾å›
            _email_cfg = get_system_config().get('email', {})
            email_on = _email_cfg.get('enabled', False)
            if email_on and user.email:
                return jsonify({
                    'success': False, 
                    'error': 'è¯¥è´¦å·æœªç»‘å®š Telegram Botï¼Œè¯·ä½¿ç”¨é‚®ç®±æ–¹å¼æ‰¾å›å¯†ç ',
                    'suggest_method': 'email'
                }), 400
            else:
                return jsonify({
                    'success': False, 
                    'error': 'è¯¥è´¦å·æœªç»‘å®š Telegram Botï¼Œæ— æ³•é€šè¿‡æ­¤æ–¹å¼æ‰¾å›å¯†ç ï¼Œè¯·è”ç³»ç®¡ç†å‘˜'
                }), 400
        
        # æ£€æŸ¥æ˜¯å¦é¢‘ç¹è¯·æ±‚ï¼ˆ1åˆ†é’Ÿå†…åªèƒ½è¯·æ±‚ä¸€æ¬¡ï¼‰
        if username in PASSWORD_RESET_CODES:
            existing = PASSWORD_RESET_CODES[username]
            if existing.get('created_at') and (datetime.now() - existing['created_at']).total_seconds() < 60:
                remaining = 60 - int((datetime.now() - existing['created_at']).total_seconds())
                return jsonify({'success': False, 'error': f'è¯·æ±‚è¿‡äºé¢‘ç¹ï¼Œè¯· {remaining} ç§’åé‡è¯•'}), 429
        
        # ç”Ÿæˆ4ä½æ•°å­—éªŒè¯ç 
        import random
        verify_code = str(random.randint(1000, 9999))
        
        # å­˜å‚¨éªŒè¯ç ï¼ˆ5åˆ†é’Ÿæœ‰æ•ˆï¼‰
        PASSWORD_RESET_CODES[username] = {
            'code': verify_code,
            'telegram_id': user.telegram_id,
            'user_tg': user.tg,
            'created_at': datetime.now(),
            'expires_at': datetime.now() + timedelta(minutes=5)
        }
        
        # å‘é€éªŒè¯ç åˆ°ç”¨æˆ·çš„ Telegram
        message = f"""ğŸ” <b>å¯†ç é‡ç½®éªŒè¯ç </b>

æ‚¨æ­£åœ¨é‡ç½®è´¦å· <code>{username}</code> çš„å¯†ç 

éªŒè¯ç ï¼š<code>{verify_code}</code>

â° æœ‰æ•ˆæœŸï¼š5åˆ†é’Ÿ
âš ï¸ è¯·å‹¿å°†éªŒè¯ç å‘ŠçŸ¥ä»–äºº

å¦‚éæœ¬äººæ“ä½œï¼Œè¯·å¿½ç•¥æ­¤æ¶ˆæ¯ã€‚"""
        
        # å‘é€ç§èŠæ¶ˆæ¯
        send_result = send_telegram_private_message(user.telegram_id, message)
        
        if send_result:
            # éšè—éƒ¨åˆ† Telegram ID æ˜¾ç¤º
            tg_id_str = str(user.telegram_id)
            masked_tg = tg_id_str[:3] + '****' + tg_id_str[-2:] if len(tg_id_str) > 5 else '****'
            
            app.logger.info(f'å¿˜è®°å¯†ç éªŒè¯ç å·²å‘é€: ç”¨æˆ·={username}')
            return jsonify({
                'success': True, 
                'message': f'éªŒè¯ç å·²å‘é€åˆ°æ‚¨çš„ Telegramï¼ˆ{masked_tg}ï¼‰',
                'expires_in': 300  # 5åˆ†é’Ÿ
            }), 200
        else:
            # å‘é€å¤±è´¥
            del PASSWORD_RESET_CODES[username]
            return jsonify({'success': False, 'error': 'éªŒè¯ç å‘é€å¤±è´¥ï¼Œè¯·ç¡®ä¿æ‚¨å·²ä¸æœºå™¨äººç§èŠè¿‡'}), 500
        
    except Exception as e:
        app.logger.error(f'å¿˜è®°å¯†ç è¯·æ±‚å¤±è´¥: {e}', exc_info=True)
        return jsonify({'success': False, 'error': 'è¯·æ±‚å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•'}), 500


@app.route('/api/account/verify-reset-code', methods=['POST'])
def verify_reset_code():
    """é¢„éªŒè¯å¯†ç é‡ç½®éªŒè¯ç ï¼ˆæ­¥éª¤1æ ¡éªŒï¼Œä¸æ¶ˆè€—éªŒè¯ç ï¼‰"""
    try:
        data = request.get_json()
        username = data.get('username', '').strip()
        code = data.get('code', '').strip()
        
        if not username or not code:
            return jsonify({'success': False, 'error': 'è¯·å¡«å†™ç”¨æˆ·åå’ŒéªŒè¯ç '}), 400
        
        if username not in PASSWORD_RESET_CODES:
            app.logger.warning(f'[å¯†ç é‡ç½®é¢„éªŒè¯] éªŒè¯ç ä¸å­˜åœ¨: username={username}, '
                             f'å½“å‰å­˜å‚¨çš„keys={list(PASSWORD_RESET_CODES.keys())}')
            return jsonify({'success': False, 'error': 'éªŒè¯ç æ— æ•ˆæˆ–å·²è¿‡æœŸï¼Œè¯·é‡æ–°è·å–'}), 400
        
        reset_data = PASSWORD_RESET_CODES[username]
        
        if datetime.now() > reset_data['expires_at']:
            del PASSWORD_RESET_CODES[username]
            return jsonify({'success': False, 'error': 'éªŒè¯ç å·²è¿‡æœŸï¼Œè¯·é‡æ–°è·å–'}), 400
        
        # æ£€æŸ¥å°è¯•æ¬¡æ•°
        reset_data.setdefault('attempts', 0)
        reset_data['attempts'] += 1
        if reset_data['attempts'] > 5:
            del PASSWORD_RESET_CODES[username]
            return jsonify({'success': False, 'error': 'éªŒè¯ç é”™è¯¯æ¬¡æ•°è¿‡å¤šï¼Œè¯·é‡æ–°è·å–'}), 400
        
        if reset_data['code'] != code:
            remaining = 5 - reset_data['attempts']
            return jsonify({'success': False, 'error': f'éªŒè¯ç é”™è¯¯ï¼Œè¿˜å¯å°è¯• {remaining} æ¬¡'}), 400
        
        # éªŒè¯é€šè¿‡ï¼Œæ ‡è®°ä¸ºå·²éªŒè¯ï¼ˆåç»­ reset-password ç›´æ¥ä¿¡ä»»ï¼‰
        reset_data['verified'] = True
        app.logger.info(f'[å¯†ç é‡ç½®é¢„éªŒè¯] éªŒè¯ç æ­£ç¡®: username={username}')
        return jsonify({'success': True, 'message': 'éªŒè¯ç æ­£ç¡®'}), 200
    except Exception as e:
        app.logger.error(f'é¢„éªŒè¯å¤±è´¥: {e}', exc_info=True)
        return jsonify({'success': False, 'error': 'éªŒè¯å¤±è´¥ï¼Œè¯·é‡è¯•'}), 500


@app.route('/api/account/reset-password', methods=['POST'])
def reset_password():
    """é‡ç½®å¯†ç  - éªŒè¯éªŒè¯ç å¹¶è®¾ç½®æ–°å¯†ç """
    try:
        data = request.get_json()
        username = data.get('username', '').strip()
        code = data.get('code', '').strip()
        new_password = data.get('new_password', '').strip()
        
        if not username or not code or not new_password:
            return jsonify({'success': False, 'error': 'è¯·å¡«å†™å®Œæ•´ä¿¡æ¯'}), 400
        
        if len(new_password) < 6:
            return jsonify({'success': False, 'error': 'æ–°å¯†ç è‡³å°‘éœ€è¦6ä¸ªå­—ç¬¦'}), 400
        
        # æ£€æŸ¥éªŒè¯ç 
        if username not in PASSWORD_RESET_CODES:
            app.logger.warning(f'[å¯†ç é‡ç½®] éªŒè¯ç ä¸å­˜åœ¨: username={username}, '
                             f'å½“å‰å­˜å‚¨çš„keys={list(PASSWORD_RESET_CODES.keys())}')
            return jsonify({'success': False, 'error': 'éªŒè¯ç æ— æ•ˆæˆ–å·²è¿‡æœŸï¼Œè¯·é‡æ–°è·å–'}), 400
        
        reset_data = PASSWORD_RESET_CODES[username]
        
        # å¦‚æœå·²é€šè¿‡é¢„éªŒè¯ï¼Œç›´æ¥ä¿¡ä»»éªŒè¯ç 
        if reset_data.get('verified'):
            app.logger.info(f'[å¯†ç é‡ç½®] ä½¿ç”¨å·²é¢„éªŒè¯çš„éªŒè¯ç : username={username}')
        else:
            # æ£€æŸ¥æ˜¯å¦è¿‡æœŸ
            if datetime.now() > reset_data['expires_at']:
                del PASSWORD_RESET_CODES[username]
                return jsonify({'success': False, 'error': 'éªŒè¯ç å·²è¿‡æœŸï¼Œè¯·é‡æ–°è·å–'}), 400
            
            # æ£€æŸ¥å°è¯•æ¬¡æ•°ï¼ˆé˜²æš´åŠ›ç ´è§£ï¼‰
            reset_data.setdefault('attempts', 0)
            reset_data['attempts'] += 1
            if reset_data['attempts'] > 5:
                del PASSWORD_RESET_CODES[username]
                return jsonify({'success': False, 'error': 'éªŒè¯ç é”™è¯¯æ¬¡æ•°è¿‡å¤šï¼Œè¯·é‡æ–°è·å–'}), 400
            
            # éªŒè¯ç åŒ¹é…
            if reset_data['code'] != code:
                remaining = 5 - reset_data['attempts']
                return jsonify({'success': False, 'error': f'éªŒè¯ç é”™è¯¯ï¼Œè¿˜å¯å°è¯• {remaining} æ¬¡'}), 400
        
        # æŸ¥æ‰¾ç”¨æˆ·å¹¶æ›´æ–°å¯†ç 
        user = User.query.filter_by(name=username).first()
        if not user:
            del PASSWORD_RESET_CODES[username]
            return jsonify({'success': False, 'error': 'ç”¨æˆ·ä¸å­˜åœ¨'}), 400
        
        # æ›´æ–°å¯†ç å’Œsession_token
        import secrets
        user.pwd = new_password
        user.session_token = secrets.token_hex(32)  # ä½¿å…¶ä»–ä¼šè¯å¤±æ•ˆ
        db.session.commit()
        
        # åˆ é™¤éªŒè¯ç 
        del PASSWORD_RESET_CODES[username]
        
        app.logger.info(f'å¯†ç é‡ç½®æˆåŠŸ: ç”¨æˆ·={username}')
        log_user_activity(UserActivityLog.ACTION_PASSWORD_RESET, user=user, detail='é€šè¿‡ Telegram éªŒè¯é‡ç½®å¯†ç ')
        
        # å‘é€é€šçŸ¥åˆ° Telegram
        notify_message = f"""âœ… <b>å¯†ç é‡ç½®æˆåŠŸ</b>

æ‚¨çš„è´¦å· <code>{username}</code> å¯†ç å·²æˆåŠŸé‡ç½®ã€‚

å¦‚éæœ¬äººæ“ä½œï¼Œè¯·ç«‹å³è”ç³»ç®¡ç†å‘˜ï¼"""
        send_telegram_private_message(user.telegram_id, notify_message)
        
        return jsonify({'success': True, 'message': 'å¯†ç é‡ç½®æˆåŠŸï¼Œè¯·ä½¿ç”¨æ–°å¯†ç ç™»å½•'}), 200
        
    except Exception as e:
        db.session.rollback()
        app.logger.error(f'å¯†ç é‡ç½®å¤±è´¥: {e}', exc_info=True)
        return jsonify({'success': False, 'error': 'å¯†ç é‡ç½®å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•'}), 500


def send_telegram_private_message(telegram_id, message):
    """å‘é€ Telegram ç§èŠæ¶ˆæ¯"""
    if not TELEGRAM_BOT_TOKEN:
        return False
    
    try:
        url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendMessage"
        payload = {
            'chat_id': telegram_id,
            'text': message,
            'parse_mode': 'HTML'
        }
        response = PROXY_SESSION.post(url, json=payload, timeout=10)
        data = response.json()
        if data.get('ok'):
            return True
        else:
            app.logger.warning(f'Telegram æ¶ˆæ¯å‘é€å¤±è´¥: {data}')
            return False
    except Exception as e:
        app.logger.error(f'å‘é€ Telegram æ¶ˆæ¯å¼‚å¸¸: {e}')
        return False


def _send_login_notification(user):
    """å‘é€ç™»å½•é€šçŸ¥ï¼ˆé‚®ä»¶ + Telegramï¼‰ï¼Œåœ¨åå°çº¿ç¨‹ä¸­æ‰§è¡Œä»¥å…é˜»å¡"""
    config = get_system_config()
    notify_cfg = config.get('login_notify', {})
    
    if not notify_cfg.get('enabled', False):
        return
    
    # è·å–ç™»å½•ä¿¡æ¯
    ip = request.headers.get('X-Forwarded-For', request.remote_addr) or 'æœªçŸ¥'
    if ',' in ip:
        ip = ip.split(',')[0].strip()
    ua = request.headers.get('User-Agent', 'æœªçŸ¥è®¾å¤‡')[:100]
    login_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    site_name = get_site_config().get('site_name', 'Emby')
    username = user.name or 'ç”¨æˆ·'
    user_email = user.email  # æå‰æå–ï¼Œé¿å…çº¿ç¨‹ä¸­è®¿é—®è¿‡æœŸçš„ session
    user_tg_id = user.telegram_id  # æå‰æå–
    
    def _do_notify():
        with app.app_context():
            # é‚®ä»¶é€šçŸ¥
            if notify_cfg.get('email', True) and user_email:
                try:
                    body = f"""<p>æ‚¨å¥½ï¼Œ<b>{username}</b>ï¼</p>
<p>æ‚¨çš„è´¦å·åˆšåˆšåœ¨æ–°è®¾å¤‡ä¸Šç™»å½•ï¼š</p>
<div style="background:#f8f9fa;border-radius:8px;padding:16px;margin:16px 0;">
    <p style="margin:4px 0;"><b>ğŸ• æ—¶é—´ï¼š</b>{login_time}</p>
    <p style="margin:4px 0;"><b>ğŸŒ IPåœ°å€ï¼š</b>{ip}</p>
    <p style="margin:4px 0;"><b>ğŸ“± è®¾å¤‡ï¼š</b>{ua}</p>
</div>
<p>å¦‚æœè¿™ä¸æ˜¯æ‚¨æœ¬äººæ“ä½œï¼Œè¯·ç«‹å³ä¿®æ”¹å¯†ç ï¼</p>"""
                    html = build_email_html(f'{site_name} - ç™»å½•é€šçŸ¥', body, site_name)
                    send_email(user_email, f'ã€{site_name}ã€‘è´¦å·ç™»å½•é€šçŸ¥', html)
                except Exception as e:
                    app.logger.debug(f'ç™»å½•é€šçŸ¥é‚®ä»¶å‘é€å¤±è´¥: {e}')
            
            # Telegram é€šçŸ¥
            if notify_cfg.get('telegram', True) and user_tg_id and TELEGRAM_BOT_TOKEN:
                try:
                    msg = f"""ğŸ”” <b>ç™»å½•é€šçŸ¥</b>

æ‚¨çš„è´¦å· <code>{username}</code> åˆšåˆšç™»å½•

ğŸ• æ—¶é—´ï¼š{login_time}
ğŸŒ IPï¼š{ip}
ğŸ“± è®¾å¤‡ï¼š{ua[:60]}

å¦‚éæœ¬äººæ“ä½œï¼Œè¯·ç«‹å³ä¿®æ”¹å¯†ç ï¼"""
                    send_telegram_private_message(user_tg_id, msg)
                except Exception as e:
                    app.logger.debug(f'ç™»å½•é€šçŸ¥TGå‘é€å¤±è´¥: {e}')
    
    Thread(target=_do_notify, daemon=True).start()


def get_email_config():
    """è·å–é‚®ä»¶ SMTP é…ç½®"""
    config = get_system_config()
    return config.get('email', {
        'enabled': False, 'smtp_host': '', 'smtp_port': 465, 'smtp_ssl': True,
        'smtp_user': '', 'smtp_password': '', 'sender_name': 'Embyç®¡ç†ç³»ç»Ÿ',
        'require_email_register': False
    })


def send_email(to_email, subject, html_content):
    """å‘é€é‚®ä»¶ï¼ˆHTML æ ¼å¼ï¼‰"""
    email_cfg = get_email_config()
    if not email_cfg.get('enabled'):
        app.logger.warning('é‚®ä»¶åŠŸèƒ½æœªå¯ç”¨')
        return False, 'é‚®ä»¶åŠŸèƒ½æœªå¯ç”¨'
    
    smtp_host = email_cfg.get('smtp_host', '')
    smtp_port = int(email_cfg.get('smtp_port', 465))
    smtp_ssl = email_cfg.get('smtp_ssl', True)
    smtp_user = email_cfg.get('smtp_user', '')
    smtp_password = email_cfg.get('smtp_password', '')
    sender_name = email_cfg.get('sender_name', 'Embyç®¡ç†ç³»ç»Ÿ')
    
    if not smtp_host or not smtp_user or not smtp_password:
        return False, 'SMTP é…ç½®ä¸å®Œæ•´'
    
    try:
        msg = MIMEMultipart('alternative')
        msg['From'] = formataddr((sender_name, smtp_user))
        msg['To'] = to_email
        msg['Subject'] = subject
        msg.attach(MIMEText(html_content, 'html', 'utf-8'))
        
        if smtp_ssl:
            server = smtplib.SMTP_SSL(smtp_host, smtp_port, timeout=15)
        else:
            server = smtplib.SMTP(smtp_host, smtp_port, timeout=15)
            try:
                server.starttls()
            except smtplib.SMTPNotSupportedError:
                # æœåŠ¡å™¨ä¸æ”¯æŒ STARTTLSï¼Œä½¿ç”¨æ˜æ–‡è¿æ¥
                app.logger.debug(f'SMTP æœåŠ¡å™¨ {smtp_host}:{smtp_port} ä¸æ”¯æŒ STARTTLSï¼Œä½¿ç”¨æ˜æ–‡è¿æ¥')
            except Exception:
                pass
        
        server.login(smtp_user, smtp_password)
        server.sendmail(smtp_user, to_email, msg.as_string())
        server.quit()
        
        app.logger.info(f'é‚®ä»¶å‘é€æˆåŠŸ: to={to_email}, subject={subject}')
        return True, 'å‘é€æˆåŠŸ'
    except smtplib.SMTPAuthenticationError:
        app.logger.error(f'SMTP è®¤è¯å¤±è´¥: user={smtp_user}')
        return False, 'SMTP è®¤è¯å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç”¨æˆ·åå’Œå¯†ç /æˆæƒç '
    except smtplib.SMTPConnectError as e:
        app.logger.error(f'SMTP è¿æ¥å¤±è´¥: {e}')
        return False, f'SMTP æœåŠ¡å™¨è¿æ¥å¤±è´¥: {e}'
    except Exception as e:
        app.logger.error(f'é‚®ä»¶å‘é€å¤±è´¥: {e}', exc_info=True)
        return False, f'å‘é€å¤±è´¥: {str(e)}'


def build_email_html(title, body_html, site_name=None):
    """æ„å»ºç»Ÿä¸€é£æ ¼çš„é‚®ä»¶ HTML æ¨¡æ¿"""
    if not site_name:
        site_name = get_site_config().get('site_name', 'Emby')
    return f"""<!DOCTYPE html>
<html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1.0">
<style>body{{margin:0;padding:0;background:#f5f5f5;font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif}}
.container{{max-width:560px;margin:40px auto;background:#fff;border-radius:12px;overflow:hidden;box-shadow:0 2px 12px rgba(0,0,0,.08)}}
.header{{background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);padding:28px 32px;text-align:center}}
.header h1{{color:#fff;font-size:20px;margin:0;font-weight:600}}
.body{{padding:32px;color:#333;font-size:15px;line-height:1.7}}
.code-box{{background:#f0f4ff;border:2px dashed #667eea;border-radius:10px;text-align:center;padding:18px;margin:20px 0}}
.code-box .code{{font-size:32px;font-weight:700;color:#667eea;letter-spacing:8px;font-family:monospace}}
.footer{{padding:20px 32px;background:#fafafa;text-align:center;color:#999;font-size:12px;border-top:1px solid #eee}}
.btn{{display:inline-block;padding:12px 32px;background:linear-gradient(135deg,#667eea,#764ba2);color:#fff!important;text-decoration:none;border-radius:8px;font-weight:600;font-size:15px}}</style>
</head><body><div class="container">
<div class="header"><h1>{title}</h1></div>
<div class="body">{body_html}</div>
<div class="footer">&copy; {site_name} Â· æ­¤é‚®ä»¶ç”±ç³»ç»Ÿè‡ªåŠ¨å‘é€ï¼Œè¯·å‹¿ç›´æ¥å›å¤</div>
</div></body></html>"""


@app.route('/api/account/bind-email', methods=['POST'])
@login_required
def bind_email_send_code():
    """ç»‘å®šé‚®ç®± - å‘é€éªŒè¯ç """
    try:
        email_cfg = get_email_config()
        if not email_cfg.get('enabled'):
            return jsonify({'success': False, 'error': 'é‚®ä»¶åŠŸèƒ½æœªå¯ç”¨ï¼Œè¯·è”ç³»ç®¡ç†å‘˜'}), 400
        
        data = request.get_json()
        email_addr = data.get('email', '').strip().lower()
        
        if not email_addr or not re.match(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$', email_addr):
            return jsonify({'success': False, 'error': 'è¯·è¾“å…¥æœ‰æ•ˆçš„é‚®ç®±åœ°å€'}), 400
        
        user = db.session.get(User, session.get('user_id'))
        if not user:
            return jsonify({'success': False, 'error': 'ç”¨æˆ·ä¸å­˜åœ¨'}), 401
        
        # æ£€æŸ¥é‚®ç®±æ˜¯å¦å·²è¢«å…¶ä»–ç”¨æˆ·ç»‘å®š
        existing = User.query.filter(User.email == email_addr, User.tg != user.tg).first()
        if existing:
            return jsonify({'success': False, 'error': 'è¯¥é‚®ç®±å·²è¢«å…¶ä»–ç”¨æˆ·ç»‘å®š'}), 400
        
        # é™é¢‘ï¼š60ç§’å†…åªèƒ½è¯·æ±‚ä¸€æ¬¡
        cache_key = f'bind_{user.tg}'
        if cache_key in EMAIL_VERIFY_CODES:
            prev = EMAIL_VERIFY_CODES[cache_key]
            if prev.get('created_at') and (datetime.now() - prev['created_at']).total_seconds() < 60:
                remaining = 60 - int((datetime.now() - prev['created_at']).total_seconds())
                return jsonify({'success': False, 'error': f'è¯· {remaining} ç§’åé‡è¯•'}), 429
        
        verify_code = str(random.randint(100000, 999999))
        EMAIL_VERIFY_CODES[cache_key] = {
            'code': verify_code,
            'email': email_addr,
            'user_tg': user.tg,
            'created_at': datetime.now(),
            'expires_at': datetime.now() + timedelta(minutes=10)
        }
        
        site_name = get_site_config().get('site_name', 'Emby')
        body = f"""<p>æ‚¨å¥½ï¼Œ<b>{user.name}</b>ï¼</p>
<p>æ‚¨æ­£åœ¨ç»‘å®šé‚®ç®±åˆ° {site_name} è´¦å·ï¼Œè¯·ä½¿ç”¨ä»¥ä¸‹éªŒè¯ç å®Œæˆç»‘å®šï¼š</p>
<div class="code-box"><div class="code">{verify_code}</div></div>
<p>éªŒè¯ç  <b>10 åˆ†é’Ÿ</b>å†…æœ‰æ•ˆï¼Œè¯·å‹¿å°†éªŒè¯ç å‘ŠçŸ¥ä»–äººã€‚</p>
<p>å¦‚éæœ¬äººæ“ä½œï¼Œè¯·å¿½ç•¥æ­¤é‚®ä»¶ã€‚</p>"""
        
        html = build_email_html(f'{site_name} - é‚®ç®±ç»‘å®šéªŒè¯', body, site_name)
        success, msg = send_email(email_addr, f'ã€{site_name}ã€‘é‚®ç®±ç»‘å®šéªŒè¯ç ', html)
        
        if success:
            masked = email_addr[:3] + '***' + email_addr[email_addr.index('@'):]
            return jsonify({'success': True, 'message': f'éªŒè¯ç å·²å‘é€åˆ° {masked}'}), 200
        else:
            del EMAIL_VERIFY_CODES[cache_key]
            return jsonify({'success': False, 'error': f'é‚®ä»¶å‘é€å¤±è´¥: {msg}'}), 500
        
    except Exception as e:
        app.logger.error(f'å‘é€é‚®ç®±éªŒè¯ç å¤±è´¥: {e}', exc_info=True)
        return jsonify({'success': False, 'error': 'å‘é€å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•'}), 500


@app.route('/api/account/verify-email', methods=['POST'])
@login_required
def verify_email_bind():
    """éªŒè¯é‚®ç®±éªŒè¯ç å¹¶å®Œæˆç»‘å®š"""
    try:
        data = request.get_json()
        code = data.get('code', '').strip()
        
        if not code:
            return jsonify({'success': False, 'error': 'è¯·è¾“å…¥éªŒè¯ç '}), 400
        
        user = db.session.get(User, session.get('user_id'))
        if not user:
            return jsonify({'success': False, 'error': 'ç”¨æˆ·ä¸å­˜åœ¨'}), 401
        
        cache_key = f'bind_{user.tg}'
        if cache_key not in EMAIL_VERIFY_CODES:
            return jsonify({'success': False, 'error': 'éªŒè¯ç æ— æ•ˆæˆ–å·²è¿‡æœŸï¼Œè¯·é‡æ–°è·å–'}), 400
        
        vdata = EMAIL_VERIFY_CODES[cache_key]
        if datetime.now() > vdata['expires_at']:
            del EMAIL_VERIFY_CODES[cache_key]
            return jsonify({'success': False, 'error': 'éªŒè¯ç å·²è¿‡æœŸï¼Œè¯·é‡æ–°è·å–'}), 400
        
        # æ£€æŸ¥å°è¯•æ¬¡æ•°ï¼ˆé˜²æš´åŠ›ç ´è§£ï¼‰
        vdata.setdefault('attempts', 0)
        vdata['attempts'] += 1
        if vdata['attempts'] > 5:
            del EMAIL_VERIFY_CODES[cache_key]
            return jsonify({'success': False, 'error': 'éªŒè¯ç é”™è¯¯æ¬¡æ•°è¿‡å¤šï¼Œè¯·é‡æ–°è·å–'}), 400
        
        if vdata['code'] != code:
            remaining = 5 - vdata['attempts']
            return jsonify({'success': False, 'error': f'éªŒè¯ç é”™è¯¯ï¼Œè¿˜å¯å°è¯• {remaining} æ¬¡'}), 400
        
        # å†æ¬¡æ£€æŸ¥é‚®ç®±å”¯ä¸€æ€§
        email_addr = vdata['email']
        existing = User.query.filter(User.email == email_addr, User.tg != user.tg).first()
        if existing:
            del EMAIL_VERIFY_CODES[cache_key]
            return jsonify({'success': False, 'error': 'è¯¥é‚®ç®±å·²è¢«å…¶ä»–ç”¨æˆ·ç»‘å®š'}), 400
        
        user.email = email_addr
        db.session.commit()
        del EMAIL_VERIFY_CODES[cache_key]
        
        app.logger.info(f'ç”¨æˆ· {user.name}(tg={user.tg}) ç»‘å®šé‚®ç®±: {email_addr}')
        log_user_activity(UserActivityLog.ACTION_EMAIL_BIND if hasattr(UserActivityLog, 'ACTION_EMAIL_BIND') else 'email_bind',
                         user=user, detail={'email': email_addr})
        
        return jsonify({'success': True, 'message': 'é‚®ç®±ç»‘å®šæˆåŠŸï¼'}), 200
        
    except Exception as e:
        db.session.rollback()
        app.logger.error(f'é‚®ç®±ç»‘å®šå¤±è´¥: {e}', exc_info=True)
        return jsonify({'success': False, 'error': 'ç»‘å®šå¤±è´¥ï¼Œè¯·ç¨åé‡è¯•'}), 500


@app.route('/api/account/unbind-email', methods=['POST'])
@login_required
def unbind_email():
    """è§£ç»‘é‚®ç®±"""
    try:
        user = db.session.get(User, session.get('user_id'))
        if not user:
            return jsonify({'success': False, 'error': 'ç”¨æˆ·ä¸å­˜åœ¨'}), 401
        if not user.email:
            return jsonify({'success': False, 'error': 'æ‚¨å°šæœªç»‘å®šé‚®ç®±'}), 400
        
        old_email = user.email
        user.email = None
        db.session.commit()
        
        app.logger.info(f'ç”¨æˆ· {user.name}(tg={user.tg}) è§£ç»‘é‚®ç®±: {old_email}')
        return jsonify({'success': True, 'message': 'é‚®ç®±å·²è§£ç»‘'}), 200
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': 'æ“ä½œå¤±è´¥'}), 500


@app.route('/api/account/forgot-password-email', methods=['POST'])
def forgot_password_email():
    """é€šè¿‡é‚®ç®±æ‰¾å›å¯†ç  - å‘é€éªŒè¯ç """
    try:
        email_cfg = get_email_config()
        if not email_cfg.get('enabled'):
            return jsonify({'success': False, 'error': 'é‚®ä»¶åŠŸèƒ½æœªå¯ç”¨'}), 400
        
        data = request.get_json()
        email_addr = data.get('email', '').strip().lower()
        
        if not email_addr:
            return jsonify({'success': False, 'error': 'è¯·è¾“å…¥é‚®ç®±åœ°å€'}), 400
        
        user = User.query.filter_by(email=email_addr).first()
        if not user:
            return jsonify({
                'success': False, 
                'error': 'è¯¥é‚®ç®±æœªç»‘å®šä»»ä½•è´¦å·ï¼Œè¯·æ£€æŸ¥é‚®ç®±åœ°å€æ˜¯å¦æ­£ç¡®ï¼Œæˆ–ä½¿ç”¨ Telegram æ–¹å¼æ‰¾å›',
                'suggest_method': 'telegram'
            }), 400
        
        # é™é¢‘
        cache_key = f'reset_{email_addr}'
        if cache_key in EMAIL_VERIFY_CODES:
            prev = EMAIL_VERIFY_CODES[cache_key]
            if prev.get('created_at') and (datetime.now() - prev['created_at']).total_seconds() < 60:
                remaining = 60 - int((datetime.now() - prev['created_at']).total_seconds())
                return jsonify({'success': False, 'error': f'è¯· {remaining} ç§’åé‡è¯•'}), 429
        
        verify_code = str(random.randint(100000, 999999))
        EMAIL_VERIFY_CODES[cache_key] = {
            'code': verify_code,
            'email': email_addr,
            'user_tg': user.tg,
            'username': user.name,
            'created_at': datetime.now(),
            'expires_at': datetime.now() + timedelta(minutes=10)
        }
        
        site_name = get_site_config().get('site_name', 'Emby')
        body = f"""<p>æ‚¨å¥½ï¼Œ<b>{user.name}</b>ï¼</p>
<p>æ‚¨æ­£åœ¨é‡ç½® {site_name} è´¦å·å¯†ç ï¼Œè¯·ä½¿ç”¨ä»¥ä¸‹éªŒè¯ç ï¼š</p>
<div class="code-box"><div class="code">{verify_code}</div></div>
<p>éªŒè¯ç  <b>10 åˆ†é’Ÿ</b>å†…æœ‰æ•ˆã€‚å¦‚éæœ¬äººæ“ä½œï¼Œè¯·å¿½ç•¥æ­¤é‚®ä»¶ã€‚</p>"""
        
        html = build_email_html(f'{site_name} - å¯†ç é‡ç½®', body, site_name)
        success, msg = send_email(email_addr, f'ã€{site_name}ã€‘å¯†ç é‡ç½®éªŒè¯ç ', html)
        
        if success:
            masked = email_addr[:3] + '***' + email_addr[email_addr.index('@'):]
            return jsonify({'success': True, 'message': f'éªŒè¯ç å·²å‘é€åˆ° {masked}', 'username': user.name}), 200
        else:
            del EMAIL_VERIFY_CODES[cache_key]
            return jsonify({'success': False, 'error': f'é‚®ä»¶å‘é€å¤±è´¥: {msg}'}), 500
        
    except Exception as e:
        app.logger.error(f'é‚®ç®±æ‰¾å›å¯†ç å¤±è´¥: {e}', exc_info=True)
        return jsonify({'success': False, 'error': 'è¯·æ±‚å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•'}), 500


@app.route('/api/account/reset-password-email', methods=['POST'])
def reset_password_email():
    """é€šè¿‡é‚®ç®±éªŒè¯ç é‡ç½®å¯†ç """
    try:
        data = request.get_json()
        email_addr = data.get('email', '').strip().lower()
        code = data.get('code', '').strip()
        new_password = data.get('new_password', '').strip()
        
        if not email_addr or not code or not new_password:
            return jsonify({'success': False, 'error': 'è¯·å¡«å†™å®Œæ•´ä¿¡æ¯'}), 400
        
        if len(new_password) < 6:
            return jsonify({'success': False, 'error': 'æ–°å¯†ç è‡³å°‘éœ€è¦6ä¸ªå­—ç¬¦'}), 400
        
        cache_key = f'reset_{email_addr}'
        if cache_key not in EMAIL_VERIFY_CODES:
            return jsonify({'success': False, 'error': 'éªŒè¯ç æ— æ•ˆæˆ–å·²è¿‡æœŸ'}), 400
        
        vdata = EMAIL_VERIFY_CODES[cache_key]
        if datetime.now() > vdata['expires_at']:
            del EMAIL_VERIFY_CODES[cache_key]
            return jsonify({'success': False, 'error': 'éªŒè¯ç å·²è¿‡æœŸ'}), 400
        
        # æ£€æŸ¥å°è¯•æ¬¡æ•°ï¼ˆé˜²æš´åŠ›ç ´è§£ï¼‰
        vdata.setdefault('attempts', 0)
        vdata['attempts'] += 1
        if vdata['attempts'] > 5:
            del EMAIL_VERIFY_CODES[cache_key]
            return jsonify({'success': False, 'error': 'éªŒè¯ç é”™è¯¯æ¬¡æ•°è¿‡å¤šï¼Œè¯·é‡æ–°è·å–'}), 400
        
        if vdata['code'] != code:
            remaining = 5 - vdata['attempts']
            return jsonify({'success': False, 'error': f'éªŒè¯ç é”™è¯¯ï¼Œè¿˜å¯å°è¯• {remaining} æ¬¡'}), 400
        
        user = db.session.get(User, vdata['user_tg'])
        if not user:
            del EMAIL_VERIFY_CODES[cache_key]
            return jsonify({'success': False, 'error': 'ç”¨æˆ·ä¸å­˜åœ¨'}), 400
        
        import secrets
        user.pwd = new_password
        user.session_token = secrets.token_hex(32)
        db.session.commit()
        del EMAIL_VERIFY_CODES[cache_key]
        
        app.logger.info(f'é€šè¿‡é‚®ç®±é‡ç½®å¯†ç æˆåŠŸ: ç”¨æˆ·={user.name}, é‚®ç®±={email_addr}')
        log_user_activity(UserActivityLog.ACTION_PASSWORD_RESET, user=user, detail='é€šè¿‡é‚®ç®±éªŒè¯é‡ç½®å¯†ç ')
        
        return jsonify({'success': True, 'message': 'å¯†ç é‡ç½®æˆåŠŸï¼Œè¯·ä½¿ç”¨æ–°å¯†ç ç™»å½•'}), 200
        
    except Exception as e:
        db.session.rollback()
        app.logger.error(f'é‚®ç®±é‡ç½®å¯†ç å¤±è´¥: {e}', exc_info=True)
        return jsonify({'success': False, 'error': 'é‡ç½®å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•'}), 500


@app.route('/api/account/change-emby-password', methods=['POST'])
@login_required
def change_emby_password():
    """ä¿®æ”¹ Emby è´¦å·å¯†ç ï¼ˆç‹¬ç«‹äºç½‘ç«™ç™»å½•å¯†ç ï¼‰"""
    try:
        data = request.get_json()
        current_password = data.get('current_password', '').strip()
        new_password = data.get('new_password', '').strip()
        
        if not current_password or not new_password:
            return jsonify({'success': False, 'error': 'è¯·å¡«å†™å®Œæ•´çš„å¯†ç ä¿¡æ¯'}), 400
        
        if len(new_password) < 6:
            return jsonify({'success': False, 'error': 'æ–°å¯†ç è‡³å°‘éœ€è¦6ä¸ªå­—ç¬¦'}), 400
        
        user = db.session.get(User, session['user_id'])
        if not user:
            return jsonify({'success': False, 'error': 'ç”¨æˆ·ä¸å­˜åœ¨'}), 404
        
        # æ£€æŸ¥æ˜¯å¦å·²ç»‘å®š Emby è´¦å·
        if not user.embyid:
            return jsonify({'success': False, 'error': 'æ‚¨è¿˜æœªç»‘å®š Emby è´¦å·'}), 400
        
        # æ£€æŸ¥ Emby æœåŠ¡å™¨é…ç½®
        if not emby_client.is_enabled():
            return jsonify({'success': False, 'error': 'Emby æœåŠ¡å™¨æœªé…ç½®'}), 500
        
        # è°ƒç”¨ Emby API ä¿®æ”¹å¯†ç ï¼ˆä¼ å…¥ emby_name ä½œä¸º fallbackï¼Œé˜²æ­¢ GET /Users/{id} 404 æ—¶æ— æ³•è·å–ç”¨æˆ·åï¼‰
        success, message = emby_client.change_user_password(user.embyid, current_password, new_password, emby_username=user.emby_name or '')
        
        if success:
            # åŒæ­¥æ›´æ–°æœ¬åœ°å­˜å‚¨çš„ Emby å¯†ç 
            user.pwd2 = new_password
            db.session.commit()
            
            app.logger.info(f'Emby å¯†ç å·²ä¿®æ”¹: {user.name} (embyid={user.embyid})')
            log_user_activity(UserActivityLog.ACTION_PASSWORD_CHANGE, user=user, detail='ä¿®æ”¹Embyå¯†ç ')
            return jsonify({'success': True, 'message': 'Emby å¯†ç ä¿®æ”¹æˆåŠŸ'}), 200
        elif message.startswith('PROXY_BLOCKED:'):
            # åä»£ç¯å¢ƒä¸‹å¯†ç éªŒè¯é€šè¿‡ä½† Emby API æ— æ³•ä¿®æ”¹
            # æ›´æ–°æœ¬åœ° pwd2 è®°å½•ï¼ˆå¯†ç å·²éªŒè¯æ­£ç¡®ï¼Œæœ¬åœ°ä¿æŒåŒæ­¥ï¼‰
            user.pwd2 = new_password
            db.session.commit()
            
            user_msg = message.replace('PROXY_BLOCKED:', '')
            app.logger.warning(f'Emby å¯†ç å› åä»£æ— æ³•ä¿®æ”¹ï¼Œå·²æ›´æ–°æœ¬åœ°è®°å½•: {user.name} (embyid={user.embyid})')
            log_user_activity(UserActivityLog.ACTION_PASSWORD_CHANGE, user=user, detail='ä¿®æ”¹Embyå¯†ç (åä»£å—é™,ä»…æ›´æ–°æœ¬åœ°)')
            return jsonify({'success': True, 'message': user_msg, 'partial': True}), 200
        elif message.startswith('PROXY_UNVERIFIED:'):
            # åä»£ç¯å¢ƒä¸‹è¿å¯†ç éƒ½æ— æ³•éªŒè¯ï¼Œä¸æ›´æ–°æœ¬åœ° pwd2
            user_msg = message.replace('PROXY_UNVERIFIED:', '')
            app.logger.warning(f'Emby å¯†ç å› åä»£æ— æ³•éªŒè¯: {user.name} (embyid={user.embyid})')
            return jsonify({'success': False, 'error': user_msg}), 400
        else:
            return jsonify({'success': False, 'error': message}), 400
        
    except Exception as e:
        app.logger.error(f'ä¿®æ”¹ Emby å¯†ç å¤±è´¥: {e}', exc_info=True)
        return jsonify({'success': False, 'error': 'ä¿®æ”¹å¯†ç å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•'}), 500


# ==================== Emby è´¦å·ç»‘å®š/åˆ›å»º API ====================
@app.route('/api/emby/check-bindable', methods=['GET'])
@login_required
def check_emby_bindable():
    """æ£€æŸ¥å½“å‰ç”¨æˆ·æ˜¯å¦éœ€è¦ç»‘å®š/åˆ›å»º Emby è´¦å·"""
    try:
        user = db.session.get(User, session['user_id'])
        if not user:
            return jsonify({'success': False, 'error': 'ç”¨æˆ·ä¸å­˜åœ¨'}), 404
        
        # æ£€æŸ¥æ˜¯å¦å·²æœ‰ Emby è´¦å·
        has_emby = bool(user.embyid and user.emby_name)
        
        # æ£€æŸ¥æ˜¯å¦æœ‰æœ‰æ•ˆè®¢é˜…ï¼ˆåŒ…å«ç™½åå•å¥—é¤ç”¨æˆ·ï¼‰
        has_valid_subscription = user.lv in ['a', 'b'] and user.ex and user.ex > datetime.now()
        
        # åˆ¤æ–­æ˜¯å¦ç™½åå•å¥—é¤
        is_whitelist = False
        if has_valid_subscription:
            ws = Subscription.query.filter_by(user_tg=user.tg, status='active', plan_type='whitelist').first()
            is_whitelist = bool(ws)
        
        # æ–°å»ºè´¦å·éœ€è¦æœ‰æ•ˆè®¢é˜…ï¼Œç»‘å®šå·²æœ‰è´¦å·ä¸éœ€è¦
        can_create = has_valid_subscription  # æ˜¯å¦å¯ä»¥æ–°å»ºè´¦å·
        can_bind = True  # ä»»ä½•ç”¨æˆ·éƒ½å¯ä»¥ç»‘å®šå·²æœ‰è´¦å·
        
        return jsonify({
            'success': True,
            'has_emby_account': has_emby,
            'emby_username': user.emby_name if has_emby else None,
            'emby_id': user.embyid if has_emby else None,
            'user_level': user.lv,
            'is_active': user.is_active,
            'can_create': can_create,  # æ˜¯å¦å¯ä»¥æ–°å»ºè´¦å·ï¼ˆéœ€è¦æœ‰æ•ˆè®¢é˜…ï¼‰
            'can_bind': can_bind,  # æ˜¯å¦å¯ä»¥ç»‘å®šå·²æœ‰è´¦å·ï¼ˆä»»ä½•ç”¨æˆ·ï¼‰
            'can_bindable': can_create,  # å…¼å®¹æ—§å­—æ®µï¼Œç”¨äºæ–°å»ºè´¦å·
            'is_whitelist': is_whitelist,
            'has_valid_subscription': has_valid_subscription
        }), 200
    except Exception as e:
        app.logger.error(f'æ£€æŸ¥ Emby ç»‘å®šçŠ¶æ€å¤±è´¥: {e}')
        return jsonify({'success': False, 'error': 'æ£€æŸ¥å¤±è´¥'}), 500


@app.route('/api/emby/check-username', methods=['POST'])
@login_required
def check_emby_username():
    """æ£€æŸ¥ Emby ç”¨æˆ·åæ˜¯å¦å¯ç”¨"""
    try:
        data = request.get_json()
        username = data.get('username', '').strip()
        
        if not username:
            return jsonify({'success': False, 'error': 'è¯·è¾“å…¥ç”¨æˆ·å'}), 400
        
        if len(username) < 1 or len(username) > 20:
            return jsonify({'success': False, 'error': 'ç”¨æˆ·åé•¿åº¦å¿…é¡»åœ¨1-20ä¸ªå­—ç¬¦ä¹‹é—´'}), 400
        
        current_user_id = session.get('user_id')
        
        # æ£€æŸ¥æœ¬åœ°æ•°æ®åº“æ˜¯å¦å·²ä½¿ç”¨ï¼ˆæ’é™¤å½“å‰ç”¨æˆ·è‡ªå·±ï¼‰
        existing = User.query.filter_by(emby_name=username).first()
        if existing and existing.tg != current_user_id:
            return jsonify({
                'success': True,
                'available': False,
                'message': 'è¯¥ç”¨æˆ·åå·²è¢«å…¶ä»–ç”¨æˆ·ä½¿ç”¨'
            }), 200
        
        # æ£€æŸ¥ Emby æœåŠ¡å™¨æ˜¯å¦å·²å­˜åœ¨
        if emby_client.is_enabled():
            emby_user = emby_client.get_user_by_name(username)
            if emby_user:
                return jsonify({
                    'success': True,
                    'available': False,
                    'exists_in_emby': True,
                    'message': 'Emby ä¸­å·²å­˜åœ¨æ­¤ç”¨æˆ·åï¼Œæ‚¨å¯ä»¥é€‰æ‹©ç»‘å®š'
                }), 200
        
        return jsonify({
            'success': True,
            'available': True,
            'message': 'ç”¨æˆ·åå¯ç”¨'
        }), 200
    except Exception as e:
        app.logger.error(f'æ£€æŸ¥ Emby ç”¨æˆ·åå¤±è´¥: {e}')
        return jsonify({'success': False, 'error': 'æ£€æŸ¥å¤±è´¥'}), 500


@app.route('/api/emby/bind', methods=['POST'])
@login_required
def bind_emby_account():
    """ç»‘å®šç°æœ‰çš„ Emby è´¦å·ï¼ˆéœ€è¦éªŒè¯å¯†ç ï¼‰- ä»»ä½•ç”¨æˆ·éƒ½å¯ä»¥ç»‘å®š"""
    try:
        data = request.get_json()
        username = data.get('username', '').strip()
        password = data.get('password', '').strip()
        
        if not username:
            return jsonify({'success': False, 'error': 'è¯·è¾“å…¥ç”¨æˆ·å'}), 400
        
        user = db.session.get(User, session['user_id'])
        if not user:
            return jsonify({'success': False, 'error': 'ç”¨æˆ·ä¸å­˜åœ¨'}), 404
        
        # ç»‘å®šå·²æœ‰è´¦å·ä¸éœ€è¦æ£€æŸ¥è®¢é˜…ï¼Œä»»ä½•ç”¨æˆ·éƒ½å¯ä»¥ç»‘å®š
        
        # æ£€æŸ¥æ˜¯å¦å·²ç»‘å®š
        if user.embyid:
            return jsonify({'success': False, 'error': 'æ‚¨å·²ç»‘å®š Emby è´¦å·ï¼Œæ— æ³•é‡å¤ç»‘å®š'}), 400
        
        # æ£€æŸ¥ Emby æœåŠ¡å™¨é…ç½®
        if not emby_client.is_enabled():
            return jsonify({'success': False, 'error': 'Emby æœåŠ¡å™¨æœªé…ç½®'}), 500
        
        # ===== é¢„æ£€æŸ¥ï¼šè¯¥ Emby ç”¨æˆ·åæ˜¯å¦å·²è¢«å…¶ä»–æ­£å¼ç”¨æˆ·ç»‘å®š =====
        # åœ¨éªŒè¯å¯†ç ä¹‹å‰å…ˆæ£€æŸ¥ï¼Œé¿å…å› ä¸ºæ—§è®°å½•å¯¼è‡´ Emby è´¦å·è¢«ç¦ç”¨â†’å¯†ç éªŒè¯401â†’è¯¯æŠ¥"å¯†ç é”™è¯¯"
        # è¿ç§»è®°å½•ï¼ˆtg ä¸ºè´Ÿæ•°ï¼‰ä¸ç®—"å·²è¢«ç»‘å®š"ï¼Œå…è®¸æ–°ç”¨æˆ·ç»§æ‰¿
        existing_bindby_name = User.query.filter(
            User.tg != user.tg,
            User.emby_name == username,
            User.embyid.isnot(None),
            User.tg >= 0  # æ’é™¤è¿ç§»è®°å½•ï¼ˆtg ä¸ºè´Ÿæ•°ï¼‰
        ).first()
        if existing_bindby_name:
            app.logger.warning(f'Emby ç»‘å®šæ‹¦æˆª: ç”¨æˆ· {user.tg} å°è¯•ç»‘å®šå·²è¢« tg={existing_bindby_name.tg} ç»‘å®šçš„ Emby ç”¨æˆ·å "{username}"')
            return jsonify({'success': False, 'error': 'è¯¥ Emby è´¦å·å·²è¢«å…¶ä»–ç”¨æˆ·ç»‘å®šï¼Œå¦‚éœ€è§£ç»‘è¯·è”ç³»ç®¡ç†å‘˜'}), 400
        
        # éªŒè¯ Emby è´¦å·å¯†ç 
        # å…ˆæŸ¥æ‰¾æ•°æ®åº“ä¸­æ˜¯å¦æœ‰è¯¥ Emby ç”¨æˆ·åçš„æ—§è®°å½•ï¼ˆå¯èƒ½ä» embyboss è¿ç§»è¿‡æ¥çš„ï¼‰
        # å¦‚æœæœ‰ embyidï¼Œä¼ ç»™ authenticate_user ä½œä¸º fallbackï¼Œ
        # ä»¥ä¾¿åœ¨ Emby API åˆ—è¡¨ä¸­æ‰¾ä¸åˆ°ç¦ç”¨ç”¨æˆ·æ—¶ï¼Œå¯ä»¥é€šè¿‡ ID ç›´æ¥æŸ¥æ‰¾
        fallback_emby_id = None
        old_emby_record = User.query.filter(
            User.tg != user.tg,
            User.emby_name == username,
            User.embyid.isnot(None)
        ).first()
        if old_emby_record:
            fallback_emby_id = old_emby_record.embyid
            app.logger.info(f'æ‰¾åˆ°æ—§ Emby è®°å½•: emby_name={username}, embyid={fallback_emby_id}, tg={old_emby_record.tg}')
        
        auth_result = emby_client.authenticate_user(username, password, fallback_emby_id=fallback_emby_id)
        if not auth_result.get('success'):
            # è¿”å›è¯¦ç»†çš„é”™è¯¯ä¿¡æ¯ï¼ˆè´¦å·ä¸å­˜åœ¨ or å¯†ç é”™è¯¯ï¼‰
            error_msg = auth_result.get('error', 'Emby éªŒè¯å¤±è´¥')
            # è°ƒè¯•ï¼šåˆ—å‡º Emby æœåŠ¡å™¨ä¸Šæ‰€æœ‰ç”¨æˆ·åï¼Œå¸®åŠ©æ’æŸ¥
            all_emby_users = emby_client.get_all_users()
            emby_names = [u.get('Name', '?') for u in all_emby_users]
            app.logger.warning(f'Emby ç»‘å®šå¤±è´¥: è¾“å…¥ç”¨æˆ·å="{username}", é”™è¯¯: {error_msg}, EmbyæœåŠ¡å™¨ç°æœ‰ç”¨æˆ·: {emby_names}')
            return jsonify({'success': False, 'error': error_msg}), 400
        
        emby_id = auth_result.get('id')
        emby_name = auth_result.get('name')
        
        # æ£€æŸ¥è¯¥ Emby è´¦å·æ˜¯å¦å·²è¢«å…¶ä»–ç”¨æˆ·ç»‘å®šï¼ˆå…¶ä»– tg è´¦å·ï¼‰
        # æ³¨æ„ï¼šå¦‚æœæ˜¯è¿ç§»è¿‡æ¥çš„æ—§è®°å½•ï¼ˆtg ä¸ºè´Ÿæ•°ï¼‰ï¼Œä¸ç®—"å·²è¢«ç»‘å®š"ï¼Œåé¢ä¼šç»§æ‰¿å¹¶åˆ é™¤
        existing_bind = User.query.filter_by(embyid=emby_id).first()
        if existing_bind and existing_bind.tg != user.tg:
            # å¦‚æœæ—§è®°å½•çš„ tg æ˜¯è´Ÿæ•°ï¼ˆè¿ç§»è„šæœ¬ç”Ÿæˆçš„ç³»ç»Ÿä¸»é”®ï¼‰ï¼Œå…è®¸ç»§æ‰¿
            if existing_bind.tg >= 0:
                return jsonify({'success': False, 'error': 'è¯¥ Emby è´¦å·å·²è¢«å…¶ä»–ç”¨æˆ·ç»‘å®š'}), 400
        
        # æŸ¥æ‰¾æ•°æ®åº“ä¸­æ˜¯å¦æœ‰è¯¥ Emby ç”¨æˆ·åçš„æ—§è®°å½•ï¼ˆä» embyboss è¿ç§»è¿‡æ¥çš„è€ç”¨æˆ·ï¼‰
        # é€šè¿‡ Emby ç”¨æˆ·åæˆ– embyid æŸ¥æ‰¾ï¼Œå¯ä»¥ç»§æ‰¿åŸæœ‰çš„ç­‰çº§ã€è®¢é˜…ã€ç§¯åˆ†ç­‰ä¿¡æ¯
        existing_emby_user = User.query.filter(
            User.tg != user.tg,  # æ’é™¤å½“å‰ç”¨æˆ·è‡ªå·±
            db.or_(
                User.emby_name == username,
                User.embyid == emby_id
            )
        ).first()
        
        app.logger.info(f'æŸ¥æ‰¾ç”¨æˆ·å {username} / embyid {emby_id} çš„æ—§è®°å½•: {existing_emby_user}')
        if existing_emby_user:
            app.logger.info(f'æ‰¾åˆ°æ—§è®°å½•: tg={existing_emby_user.tg}, lv={existing_emby_user.lv}, '
                          f'ex={existing_emby_user.ex}, coins={existing_emby_user.coins}')
        
        # ç»‘å®šè´¦å·ï¼ˆç½‘ç«™ç”¨æˆ·å name ä¿æŒä¸å˜ï¼ŒEmbyç”¨æˆ·åå­˜å…¥ emby_nameï¼‰
        user.embyid = emby_id
        user.emby_name = emby_name
        user.pwd2 = password  # ä¿å­˜ Emby å¯†ç åˆ° pwd2 å­—æ®µ
        
        # å¦‚æœæ‰¾åˆ°äº†æ—§è®°å½•ï¼Œå®Œæ•´ç»§æ‰¿æ‰€æœ‰æ•°æ®
        if existing_emby_user and existing_emby_user.lv in ['a', 'b', 'c']:
            old_tg = existing_emby_user.tg
            
            # ç»§æ‰¿ç­‰çº§å’Œæ—¶é—´
            user.lv = existing_emby_user.lv
            user.ex = existing_emby_user.ex
            user.cr = existing_emby_user.cr or user.cr
            
            # ç»§æ‰¿ç§¯åˆ†ï¼ˆcoinsï¼‰ï¼šå–ä¸¤è€…è¾ƒå¤§å€¼ï¼Œé¿å…ç”¨æˆ·æŸå¤±
            old_coins = existing_emby_user.coins or 0
            cur_coins = user.coins or 0
            user.coins = max(old_coins, cur_coins)
            
            # ç»§æ‰¿é‚€è¯·æ•°
            user.iv = (existing_emby_user.iv or 0) + (user.iv or 0)
            
            # ç»§æ‰¿ç­¾åˆ°æ—¶é—´ï¼ˆå–è¾ƒæ–°çš„ï¼‰
            if existing_emby_user.ch:
                if not user.ch or existing_emby_user.ch > user.ch:
                    user.ch = existing_emby_user.ch
            
            # è¿ç§»è®¢é˜…è®°å½•ï¼ˆsubscriptions è¡¨ï¼‰åˆ°æ–°ç”¨æˆ·
            old_subscriptions = Subscription.query.filter_by(user_tg=old_tg).all()
            for sub in old_subscriptions:
                sub.user_tg = user.tg  # å°†è®¢é˜…è®°å½•æŒ‡å‘æ–°ç”¨æˆ·
            
            # è¿ç§»ç­¾åˆ°è®°å½•
            CheckInRecord.query.filter_by(user_tg=old_tg).update({'user_tg': user.tg})
            
            # è¿ç§»ç§¯åˆ†äº¤æ˜“è®°å½•
            CoinTransaction.query.filter_by(user_tg=old_tg).update({'user_tg': user.tg})
            
            app.logger.info(f'ç”¨æˆ· {user.tg} ç»§æ‰¿æ—§è®°å½• tg={old_tg} çš„æ•°æ®: '
                          f'lv={user.lv}, ex={user.ex}, coins={user.coins}, '
                          f'è®¢é˜…è®°å½•={len(old_subscriptions)}æ¡')
            
            # åˆ é™¤æ—§ç”¨æˆ·è®°å½•ï¼ˆé¿å… name å†²çªå’Œæ•°æ®æ®‹ç•™ï¼‰
            # å…ˆæ¸…ç†æ—§è®°å½•çš„å…¶ä»–å…³è”æ•°æ®
            try:
                SupportTicket.query.filter_by(user_tg=old_tg).update({'user_tg': user.tg})
                TicketMessage.query.filter_by(sender_id=old_tg).update({'sender_id': user.tg})
                MovieRequest.query.filter_by(user_tg=old_tg).update({'user_tg': user.tg})
                Order.query.filter_by(user_tg=old_tg).update({'user_tg': user.tg})
                UserActivityLog.query.filter_by(user_tg=old_tg).update({'user_tg': user.tg})
                PlaybackRecord.query.filter_by(user_tg=old_tg).update({'user_tg': user.tg})
                UserDevice.query.filter_by(user_tg=old_tg).update({'user_tg': user.tg})
                InviteRecord.query.filter_by(inviter_tg=old_tg).update({'inviter_tg': user.tg})
                InviteRecord.query.filter_by(invitee_tg=old_tg).update({'invitee_tg': user.tg})
            except Exception as e:
                app.logger.warning(f'è¿ç§»æ—§è®°å½•å…³è”æ•°æ®æ—¶éƒ¨åˆ†å¤±è´¥ï¼ˆä¸å½±å“ç»‘å®šï¼‰: {e}')
            
            db.session.delete(existing_emby_user)
            app.logger.info(f'å·²åˆ é™¤æ—§ç”¨æˆ·è®°å½• tg={old_tg}ï¼Œæ•°æ®å·²å…¨éƒ¨è¿ç§»åˆ° tg={user.tg}')
        else:
            # æ²¡æœ‰æ‰¾åˆ°æ—§è®°å½•ï¼Œè®¾ç½®ä¸ºé»˜è®¤ B çº§ï¼ˆæ™®é€šæ³¨å†Œç”¨æˆ·ï¼‰
            if user.lv == 'd':  # åªæœ‰å½“å‰æ˜¯"æ— è´¦å·"çŠ¶æ€æ‰å‡çº§
                user.lv = 'b'
                app.logger.info(f'ç”¨æˆ· {user.tg} ç»‘å®šæ–°è´¦å·ï¼Œè®¾ç½®ä¸º B çº§æ™®é€šç”¨æˆ·')
        
        db.session.commit()
        
        # å¦‚æœç”¨æˆ·æœ‰æœ‰æ•ˆè®¢é˜…ï¼Œç¡®ä¿Embyè´¦å·åœ¨æœåŠ¡å™¨ä¸Šæ˜¯å¯ç”¨çŠ¶æ€
        # ï¼ˆç”¨æˆ·å¯èƒ½ä»embybossè¿ç§»è¿‡æ¥ï¼ŒEmbyæœåŠ¡å™¨ä¸Šè´¦å·å¯èƒ½ä»å¤„äºç¦ç”¨çŠ¶æ€ï¼‰
        # å°ç¦ç”¨æˆ·å’Œé»‘åå•ç¦ç”¨ç”¨æˆ·é™¤å¤–ï¼Œä¸è‡ªåŠ¨æ¢å¤
        has_valid_sub = user.lv in ['a', 'b'] and user.ex and user.ex > datetime.now()
        if user.lv != 'c' and not user.ban_reason and has_valid_sub and user.embyid and emby_client.is_enabled():
            try:
                if emby_client.enable_user(user.embyid):
                    app.logger.info(f'ç”¨æˆ· {user.tg} ç»‘å®šæ—¶è‡ªåŠ¨å¯ç”¨Embyè´¦å·: {emby_name}')
            except Exception as e:
                app.logger.warning(f'ç»‘å®šæ—¶å¯ç”¨Embyè´¦å·å¤±è´¥ï¼ˆä¸å½±å“ç»‘å®šï¼‰: {e}')
        
        # æ›´æ–° sessionï¼ˆä¿ç•™ç½‘ç«™ç”¨æˆ·åï¼Œæ·»åŠ  Emby ç”¨æˆ·åï¼‰
        session['emby_username'] = emby_name
        
        # è¿”å›ç­‰çº§ä¿¡æ¯
        level_names = {'a': 'è®¢é˜…ç”¨æˆ·', 'b': 'æ™®é€šç”¨æˆ·', 'c': 'å·²ç¦ç”¨', 'd': 'æ— è´¦å·'}
        level_name = level_names.get(user.lv, 'æœªçŸ¥')
        if user.lv in ['a', 'b'] and user.ex and user.ex > datetime.now():
            # æ£€æŸ¥æ˜¯å¦ç™½åå•å¥—é¤
            ws = Subscription.query.filter_by(user_tg=user.tg, status='active', plan_type='whitelist').first()
            level_name = 'ç™½åå•ç”¨æˆ·' if ws else 'è®¢é˜…ç”¨æˆ·'
        
        app.logger.info(f'ç”¨æˆ· {user.tg} ç»‘å®š Emby è´¦å·æˆåŠŸ: {emby_name} (ID: {emby_id}), ç­‰çº§: {level_name}')
        
        return jsonify({
            'success': True,
            'message': f'Emby è´¦å·ç»‘å®šæˆåŠŸï¼Œæ‚¨çš„ç­‰çº§ä¸ºï¼š{level_name}',
            'emby_username': emby_name,
            'emby_id': emby_id,
            'level': user.lv,
            'level_name': level_name,
            'expire_time': user.ex.strftime('%Y-%m-%d %H:%M') if user.ex else None
        }), 200
        
    except Exception as e:
        db.session.rollback()
        app.logger.error(f'ç»‘å®š Emby è´¦å·å¤±è´¥: {e}', exc_info=True)
        return jsonify({'success': False, 'error': 'ç»‘å®šå¤±è´¥ï¼Œè¯·ç¨åé‡è¯•'}), 500


@app.route('/api/emby/unbind', methods=['POST'])
@login_required
def unbind_emby_account():
    """è§£ç»‘ Emby è´¦å·ï¼ˆä»…è§£é™¤å…³è”ï¼Œä¸åˆ é™¤ Emby è´¦å·ï¼‰"""
    try:
        data = request.get_json()
        password = data.get('password', '').strip()
        
        if not password:
            return jsonify({'success': False, 'error': 'è¯·è¾“å…¥å½“å‰å¯†ç ä»¥ç¡®è®¤è§£ç»‘'}), 400
        
        user = db.session.get(User, session['user_id'])
        if not user:
            return jsonify({'success': False, 'error': 'ç”¨æˆ·ä¸å­˜åœ¨'}), 404
        
        # æ£€æŸ¥æ˜¯å¦å·²ç»‘å®š Emby
        if not user.embyid:
            return jsonify({'success': False, 'error': 'æ‚¨å°šæœªç»‘å®š Emby è´¦å·'}), 400
        
        # éªŒè¯å¯†ç 
        if user.pwd != password:
            return jsonify({'success': False, 'error': 'å¯†ç é”™è¯¯'}), 401
        
        old_emby_name = user.emby_name
        old_emby_id = user.embyid
        
        # è§£é™¤ç»‘å®šï¼ˆä¿ç•™ Emby è´¦å·ï¼Œä»…æ¸…é™¤æœ¬åœ°å…³è”ï¼›ç½‘ç«™ç”¨æˆ·å name ä¿æŒä¸å˜ï¼‰
        user.embyid = None
        user.emby_name = None
        
        db.session.commit()
        
        # æ›´æ–° sessionï¼ˆåªæ¸…é™¤Embyç”¨æˆ·åï¼Œä¿ç•™ç½‘ç«™ç”¨æˆ·åï¼‰
        session.pop('emby_username', None)
        
        app.logger.info(f'ç”¨æˆ· {user.tg} è§£ç»‘ Emby è´¦å·æˆåŠŸ: {old_emby_name} (ID: {old_emby_id})')
        
        return jsonify({
            'success': True,
            'message': 'Emby è´¦å·è§£ç»‘æˆåŠŸ',
            'old_emby_username': old_emby_name
        }), 200
        
    except Exception as e:
        db.session.rollback()
        app.logger.error(f'è§£ç»‘ Emby è´¦å·å¤±è´¥: {e}', exc_info=True)
        return jsonify({'success': False, 'error': 'è§£ç»‘å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•'}), 500


@app.route('/api/emby/create', methods=['POST'])
@login_required
def create_emby_account():
    """åˆ›å»ºæ–°çš„ Emby è´¦å·"""
    # è¿è¡Œæ—¶æˆæƒéªŒè¯
    if not is_license_valid():
        _v, _r = check_license()
        if not _v:
            return jsonify({'success': False, 'error': 'ç³»ç»Ÿæˆæƒå¼‚å¸¸ï¼Œè¯·è”ç³»ç®¡ç†å‘˜'}), 503
    try:
        data = request.get_json()
        username = data.get('username', '').strip()
        password = data.get('password', '').strip()
        
        if not username:
            return jsonify({'success': False, 'error': 'è¯·è¾“å…¥ç”¨æˆ·å'}), 400
        
        if len(username) < 1 or len(username) > 20:
            return jsonify({'success': False, 'error': 'ç”¨æˆ·åé•¿åº¦å¿…é¡»åœ¨1-20ä¸ªå­—ç¬¦ä¹‹é—´'}), 400
        
        import re
        if not re.match(r'^[a-zA-Z0-9_\u4e00-\u9fff]+$', username):
            return jsonify({'success': False, 'error': 'ç”¨æˆ·ååªèƒ½åŒ…å«ä¸­æ–‡ã€å­—æ¯ã€æ•°å­—ã€ä¸‹åˆ’çº¿'}), 400
        
        user = db.session.get(User, session['user_id'])
        if not user:
            return jsonify({'success': False, 'error': 'ç”¨æˆ·ä¸å­˜åœ¨'}), 404
        
        # æ£€æŸ¥ç”¨æˆ·æ˜¯å¦æœ‰æœ‰æ•ˆè®¢é˜…ï¼ˆåŒ…å«ç™½åå•å¥—é¤ï¼‰
        has_valid_subscription = user.lv in ['a', 'b'] and user.ex and user.ex > datetime.now()
        
        if not has_valid_subscription:
            return jsonify({'success': False, 'error': 'éœ€è¦æœ‰æ•ˆè®¢é˜…æ‰èƒ½åˆ›å»ºEmbyè´¦å·ï¼Œè¯·å…ˆè´­ä¹°è®¢é˜…'}), 403
        
        # æ£€æŸ¥æ˜¯å¦å·²ç»‘å®š
        if user.embyid:
            return jsonify({'success': False, 'error': 'æ‚¨å·²æœ‰ Emby è´¦å·ï¼Œæ— æ³•é‡å¤åˆ›å»º'}), 400
        
        # æ£€æŸ¥ Emby æœåŠ¡å™¨é…ç½®
        if not emby_client.is_enabled():
            return jsonify({'success': False, 'error': 'Emby æœåŠ¡å™¨æœªé…ç½®'}), 500
        
        # æ£€æŸ¥æœ¬åœ°æ•°æ®åº“Embyç”¨æˆ·åæ˜¯å¦å·²ä½¿ç”¨
        existing = User.query.filter(User.emby_name == username, User.tg != user.tg).first()
        if existing:
            return jsonify({'success': False, 'error': 'è¯¥ç”¨æˆ·åå·²è¢«ä½¿ç”¨'}), 400
        
        # æ£€æŸ¥ Emby ç”¨æˆ·åæ˜¯å¦å­˜åœ¨
        if not emby_client.check_username_available(username):
            return jsonify({'success': False, 'error': 'Emby ä¸­å·²å­˜åœ¨æ­¤ç”¨æˆ·å'}), 400
        
        # åˆ›å»º Emby è´¦å·
        create_result = emby_client.create_user(username, password)
        if not create_result:
            return jsonify({'success': False, 'error': 'åˆ›å»º Emby è´¦å·å¤±è´¥'}), 500
        
        emby_id = create_result.get('id')
        emby_name = create_result.get('name')
        
        # æ›´æ–°æœ¬åœ°ç”¨æˆ·ä¿¡æ¯ï¼ˆç½‘ç«™ç”¨æˆ·å name ä¿æŒä¸å˜ï¼ŒEmbyç”¨æˆ·åå­˜å…¥ emby_nameï¼‰
        user.embyid = emby_id
        user.emby_name = emby_name
        user.pwd2 = password  # ä¿å­˜ Emby å¯†ç åˆ° pwd2 å­—æ®µï¼ˆç½‘ç«™å¯†ç ä¿æŒä¸å˜ï¼‰
        
        db.session.commit()
        
        # æ›´æ–° sessionï¼ˆä¿ç•™ç½‘ç«™ç”¨æˆ·åï¼Œæ·»åŠ  Emby ç”¨æˆ·åï¼‰
        session['emby_username'] = emby_name
        
        app.logger.info(f'ç”¨æˆ· {user.tg} åˆ›å»º Emby è´¦å·æˆåŠŸ: {emby_name} (ID: {emby_id})')
        
        return jsonify({
            'success': True,
            'message': 'Emby è´¦å·åˆ›å»ºæˆåŠŸ',
            'emby_username': emby_name,
            'emby_id': emby_id
        }), 200
        
    except Exception as e:
        db.session.rollback()
        app.logger.error(f'åˆ›å»º Emby è´¦å·å¤±è´¥: {e}', exc_info=True)
        return jsonify({'success': False, 'error': 'åˆ›å»ºå¤±è´¥ï¼Œè¯·ç¨åé‡è¯•'}), 500


@app.route('/api/account/delete', methods=['DELETE'])
@login_required
def delete_account():
    """åˆ é™¤ç”¨æˆ·è´¦å·"""
    try:
        user = db.session.get(User, session['user_id'])
        if not user:
            return jsonify({'success': False, 'error': 'ç”¨æˆ·ä¸å­˜åœ¨'}), 404
        
        # ç®¡ç†å‘˜è´¦å·ä¸èƒ½åˆ é™¤
        if user.is_admin:
            return jsonify({'success': False, 'error': 'ç®¡ç†å‘˜è´¦å·ä¸èƒ½åˆ é™¤'}), 403
        
        user_name = user.name
        user_tg = user.tg
        
        # åˆ é™¤ç”¨æˆ·ç›¸å…³æ•°æ®ï¼ˆä¸ç®¡ç†å‘˜åˆ é™¤ç”¨æˆ·ä¿æŒä¸€è‡´ï¼‰
        # 1. åˆ é™¤æ’­æ”¾è®°å½•
        PlaybackRecord.query.filter_by(user_tg=user_tg).delete(synchronize_session=False)
        
        # 2. åˆ é™¤ç”¨æˆ·è®¾å¤‡
        UserDevice.query.filter_by(user_tg=user_tg).delete()
        
        # 3. åˆ é™¤è®¢é˜…è®°å½•
        Subscription.query.filter_by(user_tg=user_tg).delete()
        
        # 4. åˆ é™¤è®¢å•è®°å½•
        Order.query.filter_by(user_tg=user_tg).delete()
        
        # 5. åˆ é™¤ä¸‹è½½ä»»åŠ¡ï¼ˆå…ˆåˆ é™¤ï¼Œå› ä¸ºæœ‰å¤–é”®å¼•ç”¨ movie_requestsï¼‰
        request_ids = [r.id for r in MovieRequest.query.filter_by(user_tg=user_tg).all()]
        if request_ids:
            DownloadTask.query.filter(DownloadTask.request_id.in_(request_ids)).delete(synchronize_session=False)
        
        # 6. åˆ é™¤æ±‚ç‰‡è®°å½•
        MovieRequest.query.filter_by(user_tg=user_tg).delete()
        
        # 7. åˆ é™¤ç”¨æˆ·å·¥å•ï¼ˆå…ˆåˆ é™¤å·¥å•æ¶ˆæ¯ï¼‰
        ticket_ids = [t.id for t in SupportTicket.query.filter_by(user_tg=user_tg).all()]
        if ticket_ids:
            TicketMessage.query.filter(TicketMessage.ticket_id.in_(ticket_ids)).delete(synchronize_session=False)
        SupportTicket.query.filter_by(user_tg=user_tg).delete()
        
        # 8. åˆ é™¤é‚€è¯·è®°å½•ï¼ˆä½œä¸ºé‚€è¯·äººæˆ–è¢«é‚€è¯·äººï¼‰
        InviteRecord.query.filter(
            (InviteRecord.inviter_tg == user_tg) | (InviteRecord.invitee_tg == user_tg)
        ).delete(synchronize_session=False)
        
        # 9. åˆ é™¤ç”¨æˆ·æ´»åŠ¨æ—¥å¿—
        UserActivityLog.query.filter_by(user_tg=user_tg).delete()
        
        # 10. åˆ é™¤ç­¾åˆ°è®°å½•
        CheckInRecord.query.filter_by(user_tg=user_tg).delete()
        
        # 11. åˆ é™¤ç§¯åˆ†äº¤æ˜“è®°å½•
        CoinTransaction.query.filter_by(user_tg=user_tg).delete()
        
        # 12. åˆ é™¤å…‘æ¢è®°å½•
        ExchangeRecord.query.filter_by(user_tg=user_tg).delete()
        
        # 13. æ¸…é™¤å…‘æ¢ç ä½¿ç”¨è€…å¼•ç”¨ï¼ˆä¸åˆ é™¤å…‘æ¢ç æœ¬èº«ï¼‰
        RedeemCode.query.filter_by(used_by=user_tg).update({'used_by': None}, synchronize_session=False)
        
        # æœ€ååˆ é™¤ç”¨æˆ·
        db.session.delete(user)
        
        db.session.commit()
        
        # æ¸…é™¤ä¼šè¯
        session.clear()
        
        app.logger.info(f'ç”¨æˆ·è´¦å·å·²åˆ é™¤: {user_name} (tg={user_tg})')
        
        return jsonify({'success': True, 'message': 'è´¦å·å·²åˆ é™¤'}), 200
        
    except Exception as e:
        db.session.rollback()
        app.logger.error(f'åˆ é™¤è´¦å·å¤±è´¥: {e}', exc_info=True)
        return jsonify({'success': False, 'error': 'åˆ é™¤å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•'}), 500


@app.route('/manifest.json')
def dynamic_manifest():
    """åŠ¨æ€ç”ŸæˆPWA manifestï¼Œä½¿ç”¨åå°é…ç½®çš„Logo"""
    site_config = get_site_config()
    site_logo = site_config.get('site_logo') or '/static/logo.png'
    site_name = site_config.get('site_name') or 'Embyæ±‚ç‰‡ç³»ç»Ÿ'
    site_title = site_config.get('site_title') or site_name
    
    manifest = {
        "name": site_title,
        "short_name": site_name,
        "description": f"{site_name} - æœç´¢ã€æ”¶è—ã€è¯·æ±‚æ‚¨å–œæ¬¢çš„ç”µå½±å’Œå‰§é›†",
        "start_url": "/dashboard",
        "display": "standalone",
        "background_color": "#f0f4f8",
        "theme_color": "#667eea",
        "orientation": "portrait-primary",
        "icons": [
            {
                "src": site_logo,
                "sizes": "192x192",
                "type": "image/png",
                "purpose": "any maskable"
            },
            {
                "src": site_logo,
                "sizes": "512x512",
                "type": "image/png",
                "purpose": "any maskable"
            }
        ],
        "categories": ["entertainment", "utilities"],
        "lang": "zh-CN",
        "dir": "ltr"
    }
    
    response = app.response_class(
        response=json.dumps(manifest, ensure_ascii=False),
        status=200,
        mimetype='application/manifest+json'
    )
    return response


@app.route('/dashboard')
@login_required
def dashboard():
    try:
        user = db.session.get(User, session['user_id'])
        
        if not user:
            session.clear()
            return redirect(url_for('login'))
        
        # æ£€æŸ¥ç”¨æˆ·æ˜¯å¦è¢«å°ç¦ï¼ˆlv='c' ä¸ºå…¨é¢å°ç¦ï¼‰
        is_banned = user.lv == 'c'
        # æ£€æŸ¥ Emby è´¦å·æ˜¯å¦è¢«é»‘åå•è§„åˆ™ç¦ç”¨ï¼ˆlv æœªå˜ä½† ban_reason æœ‰å€¼ï¼‰
        emby_disabled_by_blacklist = bool(user.ban_reason and user.lv != 'c')
        
        today_count = user.get_today_request_count()
        
        # ç®¡ç†å‘˜æ˜¾ç¤ºæ— é™åˆ¶
        if user.is_admin:
            daily_limit = 'æ— é™åˆ¶'
            remaining = 'æ— é™åˆ¶'
        else:
            daily_limit = user.get_daily_limit()
            remaining = daily_limit - today_count
        
        # ä¼˜åŒ–ï¼šä½¿ç”¨å•ä¸ªæŸ¥è¯¢è·å–æ±‚ç‰‡è®°å½•å’Œæ€»æ•°
        requests_query = MovieRequest.query.options(joinedload(MovieRequest.download_task)).filter_by(user_tg=user.tg).order_by(MovieRequest.created_at.desc())
        requests = requests_query.limit(100).all()  # é™åˆ¶è¿”å›æ•°é‡ï¼Œæå‡æ€§èƒ½
        total_requests = requests_query.count()
        
        # ç”¨æˆ·ç­‰çº§æ˜¾ç¤ºåç§° - æ ¹æ®å®é™…è®¢é˜…çŠ¶æ€åˆ¤æ–­
        _dash_wl = Subscription.query.filter_by(user_tg=user.tg, status='active', plan_type='whitelist').first()
        is_whitelist = bool(_dash_wl) or user.lv == 'a'
        if user.lv == 'c':
            level_name = 'è´¦å·å·²å°ç¦'
        elif is_whitelist:
            level_name = 'ç™½åå•ç”¨æˆ·'
        elif user.lv in ['a', 'b'] and user.ex and user.ex > datetime.now():
            level_name = 'è®¢é˜…ç”¨æˆ·'
        else:
            level_name = 'æœªè®¢é˜…ç”¨æˆ·'
        
        # æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å·²ç»‘å®š Telegram Bot
        user_has_bot = bool(user.tg)
        bot_username = os.getenv('BOT_USERNAME', 'YourBotUsername')
        
        # è·å–Embyåª’ä½“åº“æ•°é‡ç»Ÿè®¡
        library_counts = emby_client.get_library_counts() if emby_client.is_enabled() else {'movies': 0, 'series': 0, 'episodes': 0, 'total': 0}
        
        # åŠ è½½å‰ç«¯é…ç½®
        site_config = get_site_config()
        # å¦‚æœé…ç½®ä¸­è®¾ç½®äº† bot_usernameï¼Œä¼˜å…ˆä½¿ç”¨é…ç½®çš„å€¼
        if site_config.get('telegram_bot_username'):
            bot_username = site_config['telegram_bot_username']
        
        # æ ¹æ®é…ç½®å†³å®šæ˜¯å¦ä½¿ç”¨å›¾ç‰‡ä»£ç†
        # å¤§é™†ç”¨æˆ·å»ºè®®å¼€å¯ä»£ç†ï¼Œæµ·å¤–ç”¨æˆ·å¯å…³é—­ä»¥åŠ é€Ÿ
        if site_config.get('use_image_proxy', True):
            tmdb_image_base = '/api/tmdb-image/w500'
        else:
            tmdb_image_base = 'https://image.tmdb.org/t/p/w500'
        
        # è·å–é‚€è¯·è¿”åˆ©å¼€å…³çŠ¶æ€
        _invite_cfg = get_system_config().get('invite_reward', {})
        invite_reward_enabled = _invite_cfg.get('enabled', True)
        invite_reward_percent = _invite_cfg.get('reward_percent', 10)
        
        # è·å–é‚®ç®±åŠŸèƒ½å¼€å…³çŠ¶æ€
        _email_cfg = get_system_config().get('email', {})
        email_enabled = _email_cfg.get('enabled', False)
        
        # æ£€æŸ¥æ˜¯å¦å¼ºåˆ¶ç»‘å®š Telegram
        _tg_cfg = get_system_config().get('telegram', {})
        require_telegram_bind = _tg_cfg.get('require_bindtg', False)
        user_has_telegram = bool(user.telegram_id)
        
        return render_template('dashboard.html', 
                             user=user, 
                             today_count=today_count, 
                             remaining=remaining,
                             max_daily=daily_limit,
                             total_requests=total_requests,
                             level_name=level_name,
                             requests=requests,
                             tmdb_image_base=tmdb_image_base,
                             announcement_enabled=ANNOUNCEMENT_ENABLED,
                             announcement_content=ANNOUNCEMENT_CONTENT,
                             user_has_bot=user_has_bot,
                             bot_username=bot_username,
                             library_counts=library_counts,
                             is_banned=is_banned,
                             is_whitelist=is_whitelist,
                             emby_disabled_by_blacklist=emby_disabled_by_blacklist,
                             now=datetime.now(),
                             site_config=site_config,
                             invite_reward_enabled=invite_reward_enabled,
                             invite_reward_percent=invite_reward_percent,
                             email_enabled=email_enabled,
                             require_telegram_bind=require_telegram_bind,
                             user_has_telegram=user_has_telegram,
                             app_version=APP_VERSION)
    except Exception as e:
        app.logger.error(f'Dashboard æ¸²æŸ“å¼‚å¸¸: {e}', exc_info=True)
        return f'<h2>é¡µé¢åŠ è½½å¤±è´¥</h2><p>è¯·å°è¯•åˆ·æ–°é¡µé¢ï¼Œæˆ–è”ç³»ç®¡ç†å‘˜ã€‚</p><p>é”™è¯¯: {e}</p><p><a href="/login">è¿”å›ç™»å½•</a></p>', 500


@app.route('/search')
@login_required
def search():
    query = request.args.get('q', '')
    media_type = request.args.get('type', 'movie')
    
    if not query:
        return jsonify({'results': []}), 200
    
    results = search_tmdb(query, media_type)
    return jsonify(results), 200


@app.route('/trending')
@login_required
def trending():
    media_type = request.args.get('type', 'movie')
    page = request.args.get('page', 1, type=int)
    results = get_trending(media_type, page)
    return jsonify(results), 200


# TMDB å›¾ç‰‡ç¼“å­˜ç›®å½•
TMDB_IMAGE_CACHE_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'data', 'tmdb_cache')
os.makedirs(TMDB_IMAGE_CACHE_DIR, exist_ok=True)

@app.route('/api/tmdb-image/<path:image_path>')
def proxy_tmdb_image(image_path):
    """ä»£ç† TMDB å›¾ç‰‡ï¼Œå¸¦æœ¬åœ°æ–‡ä»¶ç¼“å­˜"""
    import hashlib
    from flask import Response, send_file
    
    try:
        # ç”Ÿæˆç¼“å­˜æ–‡ä»¶å
        cache_key = hashlib.md5(image_path.encode()).hexdigest()
        # è·å–æ–‡ä»¶æ‰©å±•å
        ext = os.path.splitext(image_path)[1] or '.jpg'
        cache_file = os.path.join(TMDB_IMAGE_CACHE_DIR, f"{cache_key}{ext}")
        
        # æ£€æŸ¥ç¼“å­˜æ˜¯å¦å­˜åœ¨ä¸”æœªè¿‡æœŸï¼ˆ7å¤©ï¼‰
        if os.path.exists(cache_file):
            file_age = time.time() - os.path.getmtime(cache_file)
            if file_age < 7 * 86400:  # 7å¤©å†…æœ‰æ•ˆ
                # ç›´æ¥è¿”å›ç¼“å­˜æ–‡ä»¶
                content_type = 'image/jpeg' if ext in ['.jpg', '.jpeg'] else 'image/png'
                return send_file(
                    cache_file,
                    mimetype=content_type,
                    max_age=86400  # æµè§ˆå™¨ç¼“å­˜24å°æ—¶
                )
        
        # æ„å»º TMDB å›¾ç‰‡ URL
        tmdb_url = f"https://image.tmdb.org/t/p/{image_path}"
        
        # é€šè¿‡ä»£ç†è·å–å›¾ç‰‡ï¼ˆé™é»˜ï¼Œä¸æ‰“æ—¥å¿—ï¼‰
        response = PROXY_SESSION.get(tmdb_url, timeout=15)
        
        if response.status_code == 200:
            # ä¿å­˜åˆ°ç¼“å­˜
            try:
                with open(cache_file, 'wb') as f:
                    f.write(response.content)
            except Exception:
                pass  # ç¼“å­˜å†™å…¥å¤±è´¥ä¸å½±å“è¿”å›
            
            # è·å–å†…å®¹ç±»å‹
            content_type = response.headers.get('Content-Type', 'image/jpeg')
            
            return Response(
                response.content,
                content_type=content_type,
                headers={
                    'Cache-Control': 'public, max-age=86400',
                }
            )
        else:
            return '', response.status_code
            
    except Exception as e:
        # åªåœ¨çœŸæ­£å‡ºé”™æ—¶æ‰“æ—¥å¿—ï¼Œå‡å°‘æ—¥å¿—å™ªéŸ³
        if 'timeout' not in str(e).lower():
            app.logger.warning(f'TMDBå›¾ç‰‡ä»£ç†å¤±è´¥: {image_path[:50]}... - {type(e).__name__}')
        return '', 502


@app.route('/api/check-emby-batch')
@login_required
def check_emby_batch():
    """æ‰¹é‡æ£€æŸ¥å½±ç‰‡æ˜¯å¦åœ¨Embyåº“ä¸­ï¼ˆå¸¦ç¼“å­˜ï¼Œå¹¶å‘ä¼˜åŒ–ï¼‰
    
    å¯¹äºå‰§é›†ï¼Œè¿”å›æ ¼å¼: {'exists': True, 'is_complete': True/False}
    å¯¹äºç”µå½±ï¼Œè¿”å›æ ¼å¼: True/False
    """
    from concurrent.futures import ThreadPoolExecutor, as_completed
    
    tmdb_ids = request.args.get('ids', '').split(',')
    media_type = request.args.get('type', 'movie')
    
    if not tmdb_ids or not emby_client.is_enabled():
        return jsonify({'success': True, 'results': {}}), 200
    
    # æ¸…ç†IDåˆ—è¡¨
    tmdb_ids = [tid.strip() for tid in tmdb_ids[:20] if tid.strip()]
    
    def check_single(tmdb_id):
        """æ£€æŸ¥å•ä¸ªå½±ç‰‡"""
        try:
            emby_item = emby_client.search_by_tmdb_id(tmdb_id, media_type)
            
            if media_type == 'tv' and emby_item:
                # å¯¹äºå‰§é›†ï¼Œç®€åŒ–æ£€æŸ¥ï¼Œåªè¿”å›å­˜åœ¨å³å¯ï¼ˆè¯¦ç»†æ£€æŸ¥åœ¨ç‚¹å‡»æ—¶åšï¼‰
                return tmdb_id, {'exists': True, 'is_complete': True}
            else:
                return tmdb_id, bool(emby_item)
        except Exception as e:
            app.logger.warning(f'Embyæ£€æŸ¥å¤±è´¥ TMDB:{tmdb_id}, error:{e}')
            return tmdb_id, False
    
    results = {}
    
    # ä½¿ç”¨çº¿ç¨‹æ± å¹¶å‘æ£€æŸ¥ï¼ˆæœ€å¤š5ä¸ªå¹¶å‘ï¼‰
    with ThreadPoolExecutor(max_workers=5) as executor:
        futures = {executor.submit(check_single, tid): tid for tid in tmdb_ids}
        for future in as_completed(futures, timeout=8):
            try:
                tmdb_id, result = future.result(timeout=3)
                results[tmdb_id] = result
            except Exception as e:
                tmdb_id = futures[future]
                results[tmdb_id] = False
    
    return jsonify({'success': True, 'results': results}), 200


# ==================== ç”µè§†å‰§å­£/é›†ä¿¡æ¯æ¥å£ ====================
@app.route('/api/tv/<int:tmdb_id>/seasons')
@login_required
def get_tv_seasons(tmdb_id):
    """è·å–ç”µè§†å‰§çš„å­£ä¿¡æ¯"""
    result = get_tmdb_tv_seasons(tmdb_id)
    if not result:
        return jsonify({'success': False, 'error': 'æ— æ³•è·å–å‰§é›†ä¿¡æ¯'}), 400
    return jsonify({'success': True, **result})


@app.route('/api/tv/<int:tmdb_id>/season/<int:season_number>')
@login_required
def get_season_episodes(tmdb_id, season_number):
    """è·å–æŒ‡å®šå­£çš„å‰§é›†åˆ—è¡¨"""
    result = get_tmdb_season_episodes(tmdb_id, season_number)
    if not result:
        return jsonify({'success': False, 'error': 'æ— æ³•è·å–å‰§é›†ä¿¡æ¯'}), 400
    return jsonify({'success': True, **result})


# ==================== Emby åº“æ£€æŸ¥æ¥å£ ====================
@app.route('/api/emby/check')
@login_required
def check_emby_library():
    """æ£€æŸ¥ Emby åª’ä½“åº“ä¸­æ˜¯å¦å­˜åœ¨æŒ‡å®šå½±ç‰‡"""
    if not emby_client.is_enabled():
        return jsonify({'success': False, 'error': 'Emby æœªé…ç½®', 'enabled': False}), 400
    
    tmdb_id = request.args.get('tmdb_id')
    name = request.args.get('name', '')
    year = request.args.get('year')
    media_type = request.args.get('type', 'movie')
    
    if not tmdb_id and not name:
        return jsonify({'success': False, 'error': 'ç¼ºå°‘æŸ¥è¯¢å‚æ•°'}), 400
    
    result = emby_client.check_exists(tmdb_id, name, year, media_type)
    
    return jsonify({
        'success': True,
        'exists': result['exists'],
        'item': {
            'name': result['item'].get('Name') if result['item'] else None,
            'year': result['item'].get('ProductionYear') if result['item'] else None,
        } if result['item'] else None
    })


@app.route('/api/emby/sessions')
@login_required
def get_emby_sessions():
    """è·å–å½“å‰ç”¨æˆ·çš„ Emby æ’­æ”¾ä¼šè¯ï¼ŒåŒæ—¶è®°å½•/æ›´æ–°è®¾å¤‡ä¿¡æ¯å’Œæ’­æ”¾è®°å½•"""
    if not emby_client.is_enabled():
        return jsonify({'success': False, 'error': 'Emby æœªé…ç½®', 'enabled': False}), 400
    
    user = db.session.get(User, session['user_id'])
    if not user or not user.embyid:
        return jsonify({'success': False, 'error': 'ç”¨æˆ·æœªç»‘å®š Emby è´¦å·'}), 400
    
    # è·å–è¯¥ç”¨æˆ·çš„ä¼šè¯
    sessions = emby_client.get_user_sessions(user.embyid)
    
    # è®°å½•/æ›´æ–°è®¾å¤‡ä¿¡æ¯å’Œæ’­æ”¾è®°å½•
    for s in sessions:
        device_id = s.get('device_id')
        if device_id:
            try:
                # æŸ¥æ‰¾æˆ–åˆ›å»ºè®¾å¤‡è®°å½•
                device = UserDevice.query.filter_by(
                    user_tg=user.tg,
                    device_id=device_id
                ).first()
                
                if not device:
                    device = UserDevice(
                        user_tg=user.tg,
                        device_id=device_id,
                        device_name=s.get('device_name', 'æœªçŸ¥è®¾å¤‡'),
                        client=s.get('client', 'æœªçŸ¥'),
                        client_version=s.get('app_version', ''),
                        last_ip=s.get('remote_end_point', ''),
                        last_active=datetime.now()
                    )
                    db.session.add(device)
                    db.session.flush()  # è·å– device.id
                else:
                    # æ›´æ–°è®¾å¤‡ä¿¡æ¯
                    device.device_name = s.get('device_name', device.device_name)
                    device.client = s.get('client', device.client)
                    device.client_version = s.get('app_version', device.client_version)
                    device.last_ip = s.get('remote_end_point', device.last_ip)
                    device.last_active = datetime.now()
                
                # å°†æ•°æ®åº“è®¾å¤‡IDæ·»åŠ åˆ°ä¼šè¯æ•°æ®ä¸­
                s['db_device_id'] = device.id
                s['is_blocked'] = device.is_blocked
                
                # å¦‚æœæ­£åœ¨æ’­æ”¾ï¼Œè®°å½•æ’­æ”¾è®°å½•
                if s.get('is_playing') and s.get('now_playing'):
                    now_playing = s['now_playing']
                    emby_item_id = now_playing.get('id')
                    
                    if emby_item_id:
                        # æ£€æŸ¥æ˜¯å¦å·²æœ‰è¿™ä¸ªæ’­æ”¾è®°å½•ï¼ˆåŒä¸€ç”¨æˆ·ã€åŒä¸€è®¾å¤‡ã€åŒä¸€åª’ä½“ï¼Œ10åˆ†é’Ÿå†…ï¼‰
                        ten_mins_ago = datetime.now() - timedelta(minutes=10)
                        existing_record = PlaybackRecord.query.filter(
                            PlaybackRecord.user_tg == user.tg,
                            PlaybackRecord.device_id == device.id,
                            PlaybackRecord.emby_item_id == emby_item_id,
                            PlaybackRecord.started_at > ten_mins_ago
                        ).first()
                        
                        play_state = s.get('play_state', {})
                        position_ticks = play_state.get('position_ticks', 0)
                        total_ticks = now_playing.get('run_time_ticks', 0)
                        play_percentage = min(100.0, (position_ticks / total_ticks * 100)) if total_ticks > 0 else 0
                        
                        if existing_record:
                            # æ›´æ–°ç°æœ‰è®°å½•çš„è¿›åº¦
                            existing_record.play_percentage = play_percentage
                            _total_dur = int(total_ticks / 10000000) if total_ticks else 0
                            _play_dur = int(position_ticks / 10000000) if position_ticks else 0
                            if _total_dur > 0 and _play_dur > _total_dur:
                                _play_dur = _total_dur
                            existing_record.play_duration = _play_dur
                            existing_record.total_duration = _total_dur
                        else:
                            # åˆ›å»ºæ–°çš„æ’­æ”¾è®°å½•
                            record = PlaybackRecord(
                                user_tg=user.tg,
                                device_id=device.id,
                                emby_item_id=emby_item_id,
                                item_name=now_playing.get('name', 'æœªçŸ¥'),
                                item_type=now_playing.get('type', ''),
                                series_name=now_playing.get('series_name', ''),
                                season_number=now_playing.get('season_number'),
                                episode_number=now_playing.get('episode_number'),
                                play_duration=min(int(position_ticks / 10000000), int(total_ticks / 10000000)) if position_ticks and total_ticks and total_ticks > 0 else (int(position_ticks / 10000000) if position_ticks else 0),
                                total_duration=int(total_ticks / 10000000) if total_ticks else 0,
                                play_percentage=play_percentage,
                                play_method=play_state.get('play_method', ''),
                                client_ip=s.get('remote_end_point', ''),
                                started_at=datetime.now()
                            )
                            db.session.add(record)
                
                db.session.commit()
                
            except Exception as e:
                app.logger.error(f'æ›´æ–°è®¾å¤‡ä¿¡æ¯æˆ–æ’­æ”¾è®°å½•å¤±è´¥: {e}')
                db.session.rollback()
    
    # è¿‡æ»¤æ‰è¢«ç¦ç”¨çš„è®¾å¤‡
    active_sessions = [s for s in sessions if not s.get('is_blocked', False)]
    
    # ========== åŒæ—¶æ’­æ”¾æµæ•°é™åˆ¶æ£€æŸ¥ ==========
    # åˆ©ç”¨æ’­æ”¾ç›‘æ§çš„è½®è¯¢æœºåˆ¶ï¼ˆæ¯10ç§’ï¼‰ï¼Œå®æ—¶æ£€æµ‹å¹¶åœæ­¢è¶…é™æ’­æ”¾
    stream_limit_info = None
    playing_sessions = [s for s in active_sessions if s.get('is_playing')]
    playing_count = len(playing_sessions)
    
    # æ£€æŸ¥æ˜¯å¦ç™½åå•ç”¨æˆ·ï¼ˆé€šè¿‡è®¢é˜…å¥—é¤ï¼‰
    _wl_sub = Subscription.query.filter_by(user_tg=user.tg, plan_type='whitelist', status='active').first()
    _is_whitelist_user = _wl_sub is not None
    if playing_count > 0 and not _is_whitelist_user:  # ç™½åå•ç”¨æˆ·ä¸é™åˆ¶
        try:
            config = load_system_config()
            max_streams = config.get('telegram', {}).get('max_streams', 0)
            
            if max_streams and max_streams > 0 and playing_count > max_streams:
                # è¶…é™äº†ï¼Œåœæ‰æœ€æ–°çš„ä¼šè¯ï¼ˆä¿ç•™æœ€æ—©å¼€å§‹çš„ï¼‰
                # æŒ‰ last_activity_date æ’åºï¼Œåœæ‰æœ€æ–°çš„
                excess_count = playing_count - max_streams
                # å€’åºï¼šæœ€æ–°çš„æ’å‰é¢
                sorted_playing = sorted(playing_sessions, key=lambda x: x.get('last_activity_date', ''), reverse=True)
                stopped_sessions = []
                
                for i in range(excess_count):
                    s = sorted_playing[i]
                    sid = s.get('id')
                    if sid:
                        emby_client.stop_session(
                            sid,
                            reason=f'åŒæ—¶æ’­æ”¾è®¾å¤‡æ•°å·²è¾¾ä¸Šé™ï¼ˆ{max_streams}ï¼‰ï¼Œè¯·å…ˆå…³é—­å…¶ä»–è®¾å¤‡çš„æ’­æ”¾'
                        )
                        stopped_sessions.append({
                            'device': s.get('device_name', 'æœªçŸ¥'),
                            'client': s.get('client', 'æœªçŸ¥'),
                            'content': s.get('now_playing', {}).get('display_name', '') if s.get('now_playing') else ''
                        })
                        app.logger.warning(
                            f'[æ’­æ”¾é™æµ] ç”¨æˆ· {user.name} åŒæ—¶æ’­æ”¾ {playing_count}/{max_streams}ï¼Œ'
                            f'å·²åœæ­¢ä¼šè¯: {s.get("device_name")}({s.get("client")})'
                        )
                
                stream_limit_info = {
                    'exceeded': True,
                    'max_streams': max_streams,
                    'playing_count': playing_count,
                    'stopped_count': len(stopped_sessions),
                    'stopped_sessions': stopped_sessions,
                    'message': f'åŒæ—¶æ’­æ”¾è®¾å¤‡æ•°è¶…è¿‡é™åˆ¶ï¼ˆ{playing_count}/{max_streams}ï¼‰ï¼Œå·²è‡ªåŠ¨åœæ­¢{len(stopped_sessions)}ä¸ªå¤šä½™çš„æ’­æ”¾'
                }
        except Exception as e:
            app.logger.error(f'æ’­æ”¾é™æµæ£€æŸ¥å¤±è´¥: {e}')
    
    response_data = {
        'success': True,
        'sessions': active_sessions,
        'count': len(active_sessions),
        'playing_count': playing_count
    }
    if stream_limit_info:
        response_data['stream_limit'] = stream_limit_info
    
    return jsonify(response_data)


@app.route('/api/emby/playback-stats')
@login_required
def get_emby_playback_stats():
    """è·å–å½“å‰ç”¨æˆ·çš„æ’­æ”¾ç»Ÿè®¡ä¿¡æ¯"""
    if not emby_client.is_enabled():
        return jsonify({'success': False, 'error': 'Emby æœªé…ç½®', 'enabled': False}), 400
    
    user = db.session.get(User, session['user_id'])
    if not user or not user.embyid:
        return jsonify({'success': False, 'error': 'ç”¨æˆ·æœªç»‘å®š Emby è´¦å·'}), 400
    
    # è·å–è¯¥ç”¨æˆ·çš„ä¼šè¯
    sessions = emby_client.get_user_sessions(user.embyid)
    
    # æŒ‰è®¾å¤‡åˆ†ç»„
    devices = {}
    for s in sessions:
        client = s.get('client', 'å…¶ä»–')
        if client not in devices:
            devices[client] = 0
        devices[client] += 1
    
    return jsonify({
        'success': True,
        'total_sessions': len(sessions),
        'playing_count': len([s for s in sessions if s.get('is_playing')]),
        'devices': devices,
        'sessions': sessions
    })


@app.route('/api/emby/playback-history')
@login_required
def get_emby_playback_history():
    """è·å–å½“å‰ç”¨æˆ·çš„æ’­æ”¾å†å²ï¼ˆä»æœ¬åœ°æ•°æ®åº“ï¼‰"""
    user = db.session.get(User, session['user_id'])
    if not user:
        return jsonify({'success': False, 'error': 'ç”¨æˆ·ä¸å­˜åœ¨'}), 400
    
    limit = request.args.get('limit', 20, type=int)
    limit = min(limit, 100)  # æœ€å¤š 100 æ¡
    
    # ä»æœ¬åœ°æ•°æ®åº“è·å–æ’­æ”¾è®°å½•
    from sqlalchemy import func
    
    # è·å–æ¯ä¸ªå†…å®¹çš„ç»Ÿè®¡ä¿¡æ¯ï¼šæœ€é«˜è¿›åº¦ã€æœ€åæ’­æ”¾æ—¶é—´ã€æ’­æ”¾æ¬¡æ•°
    stats = db.session.query(
        PlaybackRecord.emby_item_id,
        func.max(PlaybackRecord.play_percentage).label('max_percentage'),
        func.max(PlaybackRecord.started_at).label('last_played'),
        func.count(PlaybackRecord.id).label('play_count'),
        func.max(PlaybackRecord.play_duration).label('max_duration'),
        func.max(PlaybackRecord.total_duration).label('total_duration')
    ).filter(
        PlaybackRecord.user_tg == user.tg
    ).group_by(
        PlaybackRecord.emby_item_id
    ).order_by(
        func.max(PlaybackRecord.started_at).desc()
    ).limit(limit).all()
    
    # è·å–æ¯ä¸ªå†…å®¹çš„è¯¦ç»†ä¿¡æ¯ï¼ˆå–ä»»æ„ä¸€æ¡è®°å½•è·å–åç§°ç­‰ä¿¡æ¯ï¼‰
    item_ids = [s[0] for s in stats]
    if not item_ids:
        return jsonify({'success': True, 'history': [], 'count': 0})
    
    # è·å–æ¯ä¸ªå†…å®¹çš„ä¸€æ¡è®°å½•ç”¨äºè·å–åç§°ç­‰ä¿¡æ¯
    records_map = {}
    for item_id in item_ids:
        record = PlaybackRecord.query.filter(
            PlaybackRecord.user_tg == user.tg,
            PlaybackRecord.emby_item_id == item_id
        ).first()
        if record:
            records_map[item_id] = record
    
    history = []
    for stat in stats:
        item_id, max_percentage, last_played, play_count, max_duration, total_duration = stat
        record = records_map.get(item_id)
        if not record:
            continue
            
        # ç»„åˆæ˜¾ç¤ºåç§°
        display_name = record.item_name
        if record.item_type == 'Episode' and record.series_name:
            if record.season_number and record.episode_number:
                display_name = f"{record.series_name} S{record.season_number:02d}E{record.episode_number:02d} - {record.item_name}"
            else:
                display_name = f"{record.series_name} - {record.item_name}"
        
        history.append({
            'id': item_id,
            'name': record.item_name,
            'display_name': display_name,
            'type': record.item_type,
            'series_name': record.series_name,
            'season_number': record.season_number,
            'episode_number': record.episode_number,
            'last_played_date': last_played.isoformat() if last_played else None,
            'play_count': play_count or 1,
            'played_percentage': max_percentage or 0,
            'play_duration': max_duration or 0,
            'total_duration': total_duration or 0,
            'play_method': record.play_method,
            'device_name': record.device.device_name if record.device else None,
            'client': record.device.client if record.device else None
        })
    
    return jsonify({
        'success': True,
        'history': history,
        'count': len(history)
    })


@app.route('/api/emby/devices')
@login_required
def get_user_devices():
    """è·å–å½“å‰ç”¨æˆ·çš„æ‰€æœ‰è®¾å¤‡"""
    user = db.session.get(User, session['user_id'])
    if not user:
        return jsonify({'success': False, 'error': 'ç”¨æˆ·ä¸å­˜åœ¨'}), 400
    
    devices = UserDevice.query.filter_by(user_tg=user.tg).order_by(UserDevice.last_active.desc()).all()
    
    return jsonify({
        'success': True,
        'devices': [d.to_dict() for d in devices],
        'count': len(devices)
    })


@app.route('/api/emby/devices/<int:device_id>', methods=['DELETE'])
@login_required
def delete_user_device(device_id):
    """åˆ é™¤ç”¨æˆ·è®¾å¤‡"""
    user = db.session.get(User, session['user_id'])
    if not user:
        return jsonify({'success': False, 'error': 'ç”¨æˆ·ä¸å­˜åœ¨'}), 400
    
    device = UserDevice.query.filter_by(id=device_id, user_tg=user.tg).first()
    if not device:
        return jsonify({'success': False, 'error': 'è®¾å¤‡ä¸å­˜åœ¨'}), 404
    
    try:
        # åˆ é™¤å…³è”çš„æ’­æ”¾è®°å½•
        PlaybackRecord.query.filter_by(device_id=device_id).delete()
        # åˆ é™¤è®¾å¤‡
        db.session.delete(device)
        db.session.commit()
        return jsonify({'success': True, 'message': 'è®¾å¤‡å·²åˆ é™¤'})
    except Exception as e:
        db.session.rollback()
        app.logger.error(f'åˆ é™¤è®¾å¤‡å¤±è´¥: {e}')
        return jsonify({'success': False, 'error': 'åˆ é™¤å¤±è´¥'}), 500


@app.route('/api/emby/devices/<int:device_id>/block', methods=['POST'])
@login_required
def block_user_device(device_id):
    """ç¦ç”¨/å¯ç”¨ç”¨æˆ·è®¾å¤‡"""
    user = db.session.get(User, session['user_id'])
    if not user:
        return jsonify({'success': False, 'error': 'ç”¨æˆ·ä¸å­˜åœ¨'}), 400
    
    device = UserDevice.query.filter_by(id=device_id, user_tg=user.tg).first()
    if not device:
        return jsonify({'success': False, 'error': 'è®¾å¤‡ä¸å­˜åœ¨'}), 404
    
    data = request.get_json() or {}
    block = data.get('block', True)
    
    try:
        device.is_blocked = block
        db.session.commit()
        status = 'å·²ç¦ç”¨' if block else 'å·²å¯ç”¨'
        return jsonify({'success': True, 'message': f'è®¾å¤‡{status}', 'is_blocked': device.is_blocked})
    except Exception as e:
        db.session.rollback()
        app.logger.error(f'æ›´æ–°è®¾å¤‡çŠ¶æ€å¤±è´¥: {e}')
        return jsonify({'success': False, 'error': 'æ“ä½œå¤±è´¥'}), 500


@app.route('/api/emby/local-history')
@login_required
def get_local_playback_history():
    """è·å–æœ¬åœ°å­˜å‚¨çš„æ’­æ”¾å†å²è®°å½•"""
    user = db.session.get(User, session['user_id'])
    if not user:
        return jsonify({'success': False, 'error': 'ç”¨æˆ·ä¸å­˜åœ¨'}), 400
    
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 20, type=int)
    per_page = min(per_page, 100)
    
    # æŸ¥è¯¢æ’­æ”¾è®°å½•
    query = PlaybackRecord.query.filter_by(user_tg=user.tg).order_by(PlaybackRecord.started_at.desc())
    pagination = query.paginate(page=page, per_page=per_page, error_out=False)
    
    return jsonify({
        'success': True,
        'records': [r.to_dict() for r in pagination.items],
        'total': pagination.total,
        'pages': pagination.pages,
        'current_page': page
    })


# ==================== ç®¡ç†å‘˜æ’­æ”¾ç›‘æ§ API ====================

@app.route('/api/admin/playback/all-sessions')
@admin_required
def admin_get_all_sessions():
    """ç®¡ç†å‘˜è·å–æ‰€æœ‰ç”¨æˆ·çš„å®æ—¶æ’­æ”¾ä¼šè¯ï¼Œå¹¶åŒæ­¥è®°å½•åˆ°æ•°æ®åº“"""
    if not emby_client.is_enabled():
        return jsonify({'success': False, 'error': 'Emby æœªé…ç½®'}), 400
    
    # è·å–æ‰€æœ‰ä¼šè¯
    stats = emby_client.get_playback_stats()
    sessions = stats.get('sessions', [])
    
    # åŒæ­¥è®¾å¤‡å’Œæ’­æ”¾è®°å½•åˆ°æ•°æ®åº“
    for s in sessions:
        device_id = s.get('device_id')
        emby_user_id = s.get('user_id')  # Emby ç”¨æˆ· ID
        
        # æ ¹æ® embyid æŸ¥æ‰¾ç”¨æˆ·ï¼ˆä¼˜å…ˆï¼‰ï¼Œå¦‚æœæ²¡æœ‰åˆ™ç”¨ user_name
        emby_user = None
        if emby_user_id:
            emby_user = User.query.filter_by(embyid=emby_user_id).first()
        if not emby_user:
            user_name = s.get('user_name')
            if user_name:
                emby_user = User.query.filter_by(emby_name=user_name).first()
        
        if not emby_user or not device_id:
            continue
        
        try:
            # æŸ¥æ‰¾æˆ–åˆ›å»ºè®¾å¤‡è®°å½•
            device = UserDevice.query.filter_by(
                user_tg=emby_user.tg,
                device_id=device_id
            ).first()
            
            if not device:
                device = UserDevice(
                    user_tg=emby_user.tg,
                    device_id=device_id,
                    device_name=s.get('device_name', 'æœªçŸ¥è®¾å¤‡'),
                    client=s.get('client', 'æœªçŸ¥'),
                    client_version=s.get('app_version', ''),
                    last_ip=s.get('remote_end_point', ''),
                    last_active=datetime.now()
                )
                db.session.add(device)
                db.session.flush()
            else:
                device.device_name = s.get('device_name', device.device_name)
                device.client = s.get('client', device.client)
                device.client_version = s.get('app_version', device.client_version)
                device.last_ip = s.get('remote_end_point', device.last_ip)
                device.last_active = datetime.now()
            
            # å¦‚æœæ­£åœ¨æ’­æ”¾ï¼Œè®°å½•æ’­æ”¾è®°å½•
            if s.get('is_playing') and s.get('now_playing'):
                now_playing = s['now_playing']
                emby_item_id = now_playing.get('id')
                
                if emby_item_id:
                    # æ£€æŸ¥æ˜¯å¦å·²æœ‰è¿™ä¸ªæ’­æ”¾è®°å½•ï¼ˆåŒä¸€ç”¨æˆ·ã€åŒä¸€è®¾å¤‡ã€åŒä¸€åª’ä½“ï¼Œ10åˆ†é’Ÿå†…ï¼‰
                    ten_mins_ago = datetime.now() - timedelta(minutes=10)
                    existing_record = PlaybackRecord.query.filter(
                        PlaybackRecord.user_tg == emby_user.tg,
                        PlaybackRecord.device_id == device.id,
                        PlaybackRecord.emby_item_id == emby_item_id,
                        PlaybackRecord.started_at > ten_mins_ago
                    ).first()
                    
                    play_state = s.get('play_state', {})
                    position_ticks = play_state.get('position_ticks', 0)
                    total_ticks = now_playing.get('run_time_ticks', 0)
                    play_percentage = min(100.0, (position_ticks / total_ticks * 100)) if total_ticks > 0 else 0
                    
                    if existing_record:
                        existing_record.play_percentage = play_percentage
                        _total_dur2 = int(total_ticks / 10000000) if total_ticks else 0
                        _play_dur2 = int(position_ticks / 10000000) if position_ticks else 0
                        if _total_dur2 > 0 and _play_dur2 > _total_dur2:
                            _play_dur2 = _total_dur2
                        existing_record.play_duration = _play_dur2
                        existing_record.total_duration = _total_dur2
                    else:
                        _total_dur3 = int(total_ticks / 10000000) if total_ticks else 0
                        _play_dur3 = int(position_ticks / 10000000) if position_ticks else 0
                        if _total_dur3 > 0 and _play_dur3 > _total_dur3:
                            _play_dur3 = _total_dur3
                        record = PlaybackRecord(
                            user_tg=emby_user.tg,
                            device_id=device.id,
                            emby_item_id=emby_item_id,
                            item_name=now_playing.get('name', 'æœªçŸ¥'),
                            item_type=now_playing.get('type', ''),
                            series_name=now_playing.get('series_name', ''),
                            season_number=now_playing.get('season_number'),
                            episode_number=now_playing.get('episode_number'),
                            play_duration=_play_dur3,
                            total_duration=_total_dur3,
                            play_percentage=play_percentage,
                            play_method=play_state.get('play_method', ''),
                            client_ip=s.get('remote_end_point', ''),
                            started_at=datetime.now()
                        )
                        db.session.add(record)
            
            db.session.commit()
        except Exception as e:
            app.logger.error(f'åŒæ­¥æ’­æ”¾æ•°æ®å¤±è´¥: {e}')
            db.session.rollback()
    
    # ========== å…¨å±€åŒæ—¶æ’­æ”¾æµæ•°é™åˆ¶æ‰«æ ==========
    # ç®¡ç†å‘˜åˆ·æ–°ç›‘æ§é¡µé¢æ—¶ï¼Œé¡ºå¸¦æ£€æŸ¥æ‰€æœ‰ç”¨æˆ·çš„æ’­æ”¾æµæ•°
    stream_limit_actions = []
    try:
        config = load_system_config()
        max_streams = config.get('telegram', {}).get('max_streams', 0)
        
        if max_streams and max_streams > 0:
            # æŒ‰ç”¨æˆ·åˆ†ç»„ç»Ÿè®¡æ­£åœ¨æ’­æ”¾çš„ä¼šè¯
            user_playing = {}  # {emby_user_id: [session, ...]}
            for s in sessions:
                if s.get('is_playing'):
                    uid = s.get('user_id')
                    if uid:
                        if uid not in user_playing:
                            user_playing[uid] = []
                        user_playing[uid].append(s)
            
            for uid, user_sessions in user_playing.items():
                if len(user_sessions) <= max_streams:
                    continue
                
                # æ£€æŸ¥æ˜¯å¦ç™½åå•ç”¨æˆ·ï¼ˆé€šè¿‡è®¢é˜…å¥—é¤ï¼‰
                u = User.query.filter_by(embyid=uid).first()
                if u:
                    _u_wl = Subscription.query.filter_by(user_tg=u.tg, plan_type='whitelist', status='active').first()
                    if _u_wl:
                        continue
                
                # è¶…é™ï¼Œåœæ‰å¤šä½™çš„
                excess = len(user_sessions) - max_streams
                sorted_s = sorted(user_sessions, key=lambda x: x.get('last_activity_date', ''), reverse=True)
                
                for i in range(excess):
                    s = sorted_s[i]
                    sid = s.get('id')
                    if sid:
                        emby_client.stop_session(
                            sid,
                            reason=f'åŒæ—¶æ’­æ”¾è®¾å¤‡æ•°å·²è¾¾ä¸Šé™ï¼ˆ{max_streams}ï¼‰ï¼Œè¯·å…ˆå…³é—­å…¶ä»–è®¾å¤‡çš„æ’­æ”¾'
                        )
                        uname = u.name if u else s.get('user_name', 'æœªçŸ¥')
                        stream_limit_actions.append({
                            'user': uname,
                            'device': s.get('device_name', 'æœªçŸ¥'),
                            'count': f'{len(user_sessions)}/{max_streams}'
                        })
                        app.logger.warning(
                            f'[ç®¡ç†ç›‘æ§é™æµ] ç”¨æˆ· {uname} åŒæ—¶æ’­æ”¾ {len(user_sessions)}/{max_streams}ï¼Œ'
                            f'å·²åœæ­¢: {s.get("device_name")}({s.get("client")})'
                        )
    except Exception as e:
        app.logger.error(f'å…¨å±€æ’­æ”¾é™æµæ‰«æå¤±è´¥: {e}')
    
    response_data = {
        'success': True,
        'total_sessions': stats.get('playing_count', 0),
        'playing_count': stats.get('playing_count', 0),
        'devices': stats.get('devices', {}),
        'users': stats.get('users', {}),
        'sessions': [s for s in sessions if s.get('is_playing')]
    }
    if stream_limit_actions:
        response_data['stream_limit_actions'] = stream_limit_actions
    
    return jsonify(response_data)


@app.route('/api/admin/playback/rankings')
@admin_required
def admin_get_playback_rankings():
    """è·å–æ’­æ”¾æ’è¡Œæ¦œï¼ˆæ—¥æ¦œ/å‘¨æ¦œï¼‰- åŸºäº Emby Playback Reporting æ’ä»¶"""
    days = request.args.get('days', 1, type=int)  # 1=æ—¥æ¦œ, 7=å‘¨æ¦œ
    days = min(max(days, 1), 30)

    if not emby_client.is_enabled():
        return jsonify({'success': False, 'error': 'Emby æœªé…ç½®'}), 400

    # è¯»å–æ’è¡Œé…ç½®
    ranking_config = load_system_config().get('ranking', {})
    movie_limit = ranking_config.get('movie_limit', 10)
    episode_limit = ranking_config.get('episode_limit', 10)
    user_limit = ranking_config.get('user_limit', 10)
    exclude_users_str = ranking_config.get('exclude_users', '')

    try:
        from datetime import timezone as tz

        end_dt = datetime.now(tz(timedelta(hours=8)))
        start_time = (end_dt - timedelta(days=days)).strftime("%Y-%m-%d %H:%M:%S")
        end_time = end_dt.strftime("%Y-%m-%d %H:%M:%S")

        base = emby_client.base_url
        api_key = emby_client.api_key
        headers = {'X-Emby-Token': api_key, 'Accept': 'application/json', 'Content-Type': 'application/json'}

        import requests as req_lib

        # æ„å»ºæ’é™¤ç”¨æˆ·ååˆ—è¡¨ â†’ æ˜ å°„åˆ° Emby UserId
        exclude_user_ids = set()
        if exclude_users_str:
            exclude_names = [n.strip() for n in exclude_users_str.split(',') if n.strip()]
            if exclude_names:
                try:
                    users_resp = req_lib.get(f"{base}/emby/Users", headers=headers, timeout=10)
                    if users_resp.status_code == 200:
                        for u in users_resp.json():
                            if u.get('Name', '') in exclude_names:
                                exclude_user_ids.add(u.get('Id', ''))
                except Exception:
                    pass

        # æ’é™¤æ¡ä»¶
        exclude_clause = ''
        if exclude_user_ids:
            ids_str = ','.join(f"'{uid}'" for uid in exclude_user_ids)
            exclude_clause = f" AND UserId NOT IN ({ids_str})"

        # ---------- 1. åª’ä½“æ’è¡Œï¼ˆç”µå½± + å‰§é›†ï¼ŒæŒ‰æ’­æ”¾æ¬¡æ•°å’Œæ—¶é•¿ï¼‰ ----------
        movie_sql = (
            "SELECT UserId, ItemId, ItemType, ItemName AS name, "
            "COUNT(1) AS play_count, SUM(PlayDuration - PauseDuration) AS total_duration "
            "FROM PlaybackActivity "
            f"WHERE ItemType = 'Movie' AND DateCreated >= '{start_time}' AND DateCreated <= '{end_time}' "
            "AND UserId NOT IN (SELECT UserId FROM UserList) "
            f"{exclude_clause} "
            f"GROUP BY name ORDER BY play_count DESC, total_duration DESC LIMIT {movie_limit}"
        )
        episode_sql = (
            "SELECT UserId, ItemId, ItemType, "
            "substr(ItemName, 0, instr(ItemName, ' - ')) AS name, "
            "COUNT(1) AS play_count, SUM(PlayDuration - PauseDuration) AS total_duration "
            "FROM PlaybackActivity "
            f"WHERE ItemType = 'Episode' AND DateCreated >= '{start_time}' AND DateCreated <= '{end_time}' "
            "AND UserId NOT IN (SELECT UserId FROM UserList) "
            f"{exclude_clause} "
            f"GROUP BY name ORDER BY play_count DESC, total_duration DESC LIMIT {episode_limit}"
        )

        # ---------- 2. ç”¨æˆ·è§‚å½±æ—¶é•¿æ’è¡Œ ----------
        user_sql = (
            "SELECT UserId, SUM(PlayDuration - PauseDuration) AS WatchTime "
            "FROM PlaybackActivity "
            f"WHERE DateCreated >= '{start_time}' AND DateCreated <= '{end_time}' "
            f"{exclude_clause} "
            f"GROUP BY UserId ORDER BY WatchTime DESC LIMIT {user_limit}"
        )

        submit_url = f"{base}/emby/user_usage_stats/submit_custom_query"

        movies_raw = []
        episodes_raw = []
        users_raw = []

        # ç”µå½±å’Œå‰§é›†æŸ¥è¯¢ç”¨ ReplaceUserId=Trueï¼ˆä¸éœ€è¦ç”¨æˆ·æ˜ å°„ï¼‰
        for sql_query, target in [(movie_sql, 'movies'), (episode_sql, 'episodes')]:
            try:
                resp = req_lib.post(submit_url, json={"CustomQueryString": sql_query, "ReplaceUserId": True},
                                    headers=headers, timeout=15)
                if resp.status_code == 200:
                    data = resp.json()
                    rows = data.get('results', [])
                    if target == 'movies':
                        movies_raw = rows
                    else:
                        episodes_raw = rows
            except Exception as e:
                app.logger.warning(f'æ’­æ”¾æ’è¡ŒæŸ¥è¯¢å¤±è´¥ ({target}): {e}')

        # ç”¨æˆ·æ¦œæŸ¥è¯¢ç”¨ ReplaceUserId=Falseï¼Œä¿ç•™åŸå§‹ UserId (UUID) ç”¨äºæ˜ å°„
        try:
            resp = req_lib.post(submit_url, json={"CustomQueryString": user_sql, "ReplaceUserId": False},
                                headers=headers, timeout=15)
            if resp.status_code == 200:
                users_raw = resp.json().get('results', [])
        except Exception as e:
            app.logger.warning(f'æ’­æ”¾æ’è¡ŒæŸ¥è¯¢å¤±è´¥ (users): {e}')

        # ---------- 3. ç»„è£…ç”µå½±æ’è¡Œ ----------
        def format_duration(seconds):
            """å°†ç§’æ•°æ ¼å¼åŒ–ä¸ºå¯è¯»æ—¶é•¿"""
            try:
                s = int(float(seconds))
            except (ValueError, TypeError):
                return '0åˆ†é’Ÿ'
            if s < 60:
                return f'{s}ç§’'
            h, m = divmod(s // 60, 60)
            if h > 0:
                return f'{h}å°æ—¶{m}åˆ†é’Ÿ'
            return f'{m}åˆ†é’Ÿ'

        movie_list = []
        for row in movies_raw:
            try:
                user_id, item_id, item_type, name, count, duration = row[0], row[1], row[2], row[3], row[4], row[5]
                if not name or not str(name).strip():
                    continue
                movie_list.append({
                    'name': str(name).strip(),
                    'item_id': str(item_id),
                    'play_count': int(count),
                    'duration': format_duration(duration),
                    'duration_seconds': int(float(duration)) if duration else 0,
                    'type': 'movie'
                })
            except (IndexError, ValueError):
                continue

        episode_list = []
        for row in episodes_raw:
            try:
                user_id, item_id, item_type, name, count, duration = row[0], row[1], row[2], row[3], row[4], row[5]
                if not name or not str(name).strip():
                    continue
                episode_list.append({
                    'name': str(name).strip(),
                    'item_id': str(item_id),
                    'play_count': int(count),
                    'duration': format_duration(duration),
                    'duration_seconds': int(float(duration)) if duration else 0,
                    'type': 'episode'
                })
            except (IndexError, ValueError):
                continue

        # ---------- 4. ç»„è£…ç”¨æˆ·æ’è¡Œï¼ŒåŒ¹é…æœ¬åœ°ç”¨æˆ·å ----------
        # è·å– Emby ç”¨æˆ·åæ˜ å°„
        emby_user_map = {}
        try:
            users_resp = req_lib.get(f"{base}/emby/Users", headers=headers, timeout=10)
            if users_resp.status_code == 200:
                for u in users_resp.json():
                    emby_user_map[u.get('Id', '')] = u.get('Name', '')
        except Exception:
            pass

        # è·å–æœ¬åœ°ç”¨æˆ·æ˜ å°„ (emby_name -> web user)
        local_user_map = {}
        try:
            all_local = User.query.filter(User.embyid.isnot(None)).all()
            for u in all_local:
                if u.embyid:
                    local_user_map[u.embyid] = {
                        'name': u.name or u.emby_name or '',
                        'emby_name': u.emby_name or u.name or '',
                        'tg': u.tg
                    }
        except Exception:
            pass

        user_list = []
        for row in users_raw:
            try:
                emby_uid = str(row[0]) if row[0] else ''
                watch_seconds = int(float(row[1])) if row[1] else 0
                if watch_seconds <= 0:
                    continue

                emby_name = emby_user_map.get(emby_uid, '')
                local_info = local_user_map.get(emby_uid, {})
                display_name = local_info.get('name') or emby_name or 'æœªçŸ¥ç”¨æˆ·'

                user_list.append({
                    'emby_user_id': emby_uid,
                    'name': display_name,
                    'emby_name': emby_name,
                    'watch_time': format_duration(watch_seconds),
                    'watch_seconds': watch_seconds,
                })
            except (IndexError, ValueError):
                continue

        return jsonify({
            'success': True,
            'days': days,
            'period': f'{"æ—¥" if days == 1 else str(days) + "å¤©"}',
            'movies': movie_list,
            'episodes': episode_list,
            'users': user_list,
            'generated_at': datetime.now().strftime('%Y-%m-%d %H:%M')
        })

    except Exception as e:
        app.logger.error(f'è·å–æ’­æ”¾æ’è¡Œå¤±è´¥: {e}', exc_info=True)
        return jsonify({'success': False, 'error': str(e)}), 500


# ==================== æ’­æ”¾æ’è¡Œå®šæ—¶æ¨é€ ====================
_ranking_timers = {}  # å­˜å‚¨å®šæ—¶å™¨: {'daily': timer, 'weekly': timer}
_ranking_timer_lock = threading.Lock()  # ä¿æŠ¤ _ranking_timers çš„çº¿ç¨‹é”
_ranking_schedule_version = {'daily': 0, 'weekly': 0}  # è°ƒåº¦ç‰ˆæœ¬å·ï¼Œé˜²æ­¢æ—§Timerå›è°ƒè¦†ç›–æ–°è°ƒåº¦

def _build_ranking_text(days, ranking_config):
    """æ„å»ºæ’è¡Œæ¦œæ–‡æœ¬æ¶ˆæ¯ï¼ˆä¾›å®šæ—¶æ¨é€ä½¿ç”¨ï¼‰
    
    æ¨¡æ¿é£æ ¼å€Ÿé‰´ embyboss (Sakura_embyboss)ï¼š
    - æ’­æ”¾æ—¥æ¦œ/å‘¨æ¦œï¼šç”µå½± + ç”µè§†å‰§ï¼Œå«æ’­æ”¾æ¬¡æ•°å’Œæ—¶é•¿
    - ç”¨æˆ·è§‚å½±æ¦œï¼šç”¨æˆ·è§‚å½±æ—¶é•¿æ’åï¼Œå«å¥–ç‰Œå’Œä¸­æ–‡åæ¬¡
    """
    from datetime import timezone as tz, date as dt_date
    import requests as req_lib

    if not emby_client.is_enabled():
        return None

    movie_limit = ranking_config.get('movie_limit', 10)
    episode_limit = ranking_config.get('episode_limit', 10)
    user_limit = ranking_config.get('user_limit', 10)
    exclude_users_str = ranking_config.get('exclude_users', '')

    # ç«™ç‚¹åç§°ï¼Œç”¨äºæ ‡é¢˜ï¼ˆç±»ä¼¼ embyboss çš„ ranks.logoï¼‰
    try:
        site_cfg = get_site_config()
        site_name = site_cfg.get('site_name', '') if site_cfg else ''
    except Exception:
        site_name = ''
    if not site_name:
        site_name = 'Emby'

    end_dt = datetime.now(tz(timedelta(hours=8)))
    start_time = (end_dt - timedelta(days=days)).strftime("%Y-%m-%d %H:%M:%S")
    end_time = end_dt.strftime("%Y-%m-%d %H:%M:%S")
    today_str = dt_date.today().strftime('%Y-%m-%d')

    base = emby_client.base_url
    api_key = emby_client.api_key
    headers = {'X-Emby-Token': api_key, 'Accept': 'application/json', 'Content-Type': 'application/json'}

    # æ’é™¤ç”¨æˆ·
    exclude_user_ids = set()
    if exclude_users_str:
        exclude_names = [n.strip() for n in exclude_users_str.split(',') if n.strip()]
        if exclude_names:
            try:
                users_resp = req_lib.get(f"{base}/emby/Users", headers=headers, timeout=10)
                if users_resp.status_code == 200:
                    for u in users_resp.json():
                        if u.get('Name', '') in exclude_names:
                            exclude_user_ids.add(u.get('Id', ''))
            except Exception:
                pass

    exclude_clause = ''
    if exclude_user_ids:
        ids_str = ','.join(f"'{uid}'" for uid in exclude_user_ids)
        exclude_clause = f" AND UserId NOT IN ({ids_str})"

    def format_duration(seconds):
        """æ ¼å¼åŒ–ç§’æ•°ä¸ºå¯è¯»æ—¶é•¿ï¼ˆä¸ embyboss convert_s é£æ ¼ä¸€è‡´ï¼‰"""
        try:
            s = int(float(seconds))
        except (ValueError, TypeError):
            return '0 åˆ†é’Ÿ'
        if s < 60:
            return f'{s} ç§’'
        d = timedelta(seconds=s)
        total_days = d.days
        hours, remainder = divmod(d.seconds, 3600)
        minutes, _ = divmod(remainder, 60)
        parts = []
        if total_days > 0:
            parts.append(f'{total_days} å¤©')
        if hours > 0:
            parts.append(f'{hours} å°æ—¶')
        parts.append(f'{minutes} åˆ†é’Ÿ')
        return ' '.join(parts)

    # ä¸­æ–‡æ•°å­—æ˜ å°„ï¼ˆç±»ä¼¼ embyboss çš„ cn2anï¼‰
    cn_nums = ['ä¸€', 'äºŒ', 'ä¸‰', 'å››', 'äº”', 'å…­', 'ä¸ƒ', 'å…«', 'ä¹', 'å',
               'åä¸€', 'åäºŒ', 'åä¸‰', 'åå››', 'åäº”', 'åå…­', 'åä¸ƒ', 'åå…«', 'åä¹', 'äºŒå']

    def rank_to_cn(n):
        """æ•°å­—è½¬ä¸­æ–‡åæ¬¡"""
        if 1 <= n <= len(cn_nums):
            return cn_nums[n - 1]
        return str(n)

    submit_url = f"{base}/emby/user_usage_stats/submit_custom_query"
    rank_medals = ['ğŸ¥‡', 'ğŸ¥ˆ', 'ğŸ¥‰', 'ğŸ…']
    period_name = 'æ—¥' if days == 1 else 'å‘¨'

    # ====== æŸ¥è¯¢æ•°æ® ======
    movie_sql = (
        "SELECT UserId, ItemId, ItemType, ItemName AS name, "
        "COUNT(1) AS play_count, SUM(PlayDuration - PauseDuration) AS total_duration "
        "FROM PlaybackActivity "
        f"WHERE ItemType = 'Movie' AND DateCreated >= '{start_time}' AND DateCreated <= '{end_time}' "
        f"AND UserId NOT IN (SELECT UserId FROM UserList) {exclude_clause} "
        f"GROUP BY name ORDER BY total_duration DESC LIMIT {movie_limit}"
    )
    episode_sql = (
        "SELECT UserId, ItemId, ItemType, "
        "substr(ItemName, 0, instr(ItemName, ' - ')) AS name, "
        "COUNT(1) AS play_count, SUM(PlayDuration - PauseDuration) AS total_duration "
        "FROM PlaybackActivity "
        f"WHERE ItemType = 'Episode' AND DateCreated >= '{start_time}' AND DateCreated <= '{end_time}' "
        f"AND UserId NOT IN (SELECT UserId FROM UserList) {exclude_clause} "
        f"GROUP BY name ORDER BY total_duration DESC LIMIT {episode_limit}"
    )
    user_sql = (
        "SELECT UserId, SUM(PlayDuration - PauseDuration) AS WatchTime "
        "FROM PlaybackActivity "
        f"WHERE DateCreated >= '{start_time}' AND DateCreated <= '{end_time}' {exclude_clause} "
        f"GROUP BY UserId ORDER BY WatchTime DESC LIMIT {user_limit}"
    )

    movies = []
    episodes = []
    users = []

    # ç”µå½±å’Œå‰§é›†æŸ¥è¯¢ä½¿ç”¨ ReplaceUserId=Trueï¼ˆä¸éœ€è¦ç”¨æˆ·æ˜ å°„ï¼‰
    for sql, target in [(movie_sql, 'movies'), (episode_sql, 'episodes')]:
        try:
            resp = req_lib.post(submit_url, json={"CustomQueryString": sql, "ReplaceUserId": True},
                                headers=headers, timeout=15)
            rows = resp.json().get('results', []) if resp.status_code == 200 else []
        except Exception:
            rows = []
        if target == 'movies':
            movies = rows
        else:
            episodes = rows

    # ç”¨æˆ·æ¦œæŸ¥è¯¢ä½¿ç”¨ ReplaceUserId=Falseï¼Œä¿ç•™åŸå§‹ UserId (UUID) ç”¨äºæ˜ å°„
    try:
        resp = req_lib.post(submit_url, json={"CustomQueryString": user_sql, "ReplaceUserId": False},
                            headers=headers, timeout=15)
        users = resp.json().get('results', []) if resp.status_code == 200 else []
    except Exception:
        users = []

    # è·å–ç”¨æˆ·åæ˜ å°„: emby_id -> Embyç”¨æˆ·å
    emby_user_map = {}
    try:
        users_resp = req_lib.get(f"{base}/emby/Users", headers=headers, timeout=10)
        if users_resp.status_code == 200:
            for u in users_resp.json():
                emby_user_map[u.get('Id', '')] = u.get('Name', '')
    except Exception:
        pass

    # æœ¬åœ°ç”¨æˆ·æ˜ å°„: emby_id -> {name, tg_id}ï¼Œç”¨äºæ˜¾ç¤ºåå’Œ TG é“¾æ¥
    local_user_map = {}  # embyid -> {'name': str, 'tg_id': int|None}
    try:
        all_local = User.query.filter(User.embyid.isnot(None)).all()
        for u in all_local:
            if u.embyid:
                display = u.name or u.emby_name or ''
                local_user_map[u.embyid] = {
                    'name': display,
                    'tg_id': u.telegram_id  # Telegram user IDï¼ˆå¯èƒ½ä¸º Noneï¼‰
                }
    except Exception:
        pass

    def get_user_display(uid):
        """æ ¹æ® Emby UserId è¿”å›å¸¦ TG é“¾æ¥çš„ç”¨æˆ·æ˜¾ç¤ºå"""
        local = local_user_map.get(uid)
        if local and local['name']:
            name = local['name']
            tg_id = local.get('tg_id')
            if tg_id:
                return f'<a href="tg://user?id={tg_id}">{name}</a>'
            return name
        # å›é€€åˆ° Emby ç”¨æˆ·å
        emby_name = emby_user_map.get(uid)
        if emby_name:
            return emby_name
        return 'æœªçŸ¥ç”¨æˆ·'

    has_data = bool(movies or episodes or users)
    if not has_data:
        return None

    # ====== ç»„è£…æ–‡æœ¬ï¼ˆembyboss é£æ ¼ï¼‰======
    # ä½¿ç”¨ HTML parse_modeï¼Œç”¨ <b> æ¨¡æ‹Ÿ Markdown çš„ ** ç²—ä½“

    lines = []

    # ---------- æ’­æ”¾æ¦œï¼ˆç”µå½± + ç”µè§†å‰§ï¼‰----------
    # æ ‡é¢˜ï¼šã€ç«™å æ’­æ”¾æ—¥æ¦œ/å‘¨æ¦œã€‘
    lines.append(f'<b>ã€{site_name} æ’­æ”¾{period_name}æ¦œã€‘</b>')
    lines.append('')

    # ç”µå½±éƒ¨åˆ†
    if movies:
        lines.append('<b>â–ç”µå½±:</b>')
        lines.append('')
        for i, row in enumerate(movies):
            try:
                name = str(row[3]).strip() if row[3] else ''
                count = int(row[4]) if row[4] else 0
                duration = format_duration(row[5])
                if not name:
                    continue
                lines.append(f'{i + 1}. {name}')
                lines.append(f'æ’­æ”¾æ¬¡æ•°: {count}  æ—¶é•¿:{duration}')
            except (IndexError, ValueError):
                continue

    # ç”µè§†å‰§éƒ¨åˆ†
    if episodes:
        lines.append('')
        lines.append('<b>â–ç”µè§†å‰§:</b>')
        lines.append('')
        for i, row in enumerate(episodes):
            try:
                name = str(row[3]).strip() if row[3] else ''
                count = int(row[4]) if row[4] else 0
                duration = format_duration(row[5])
                if not name:
                    continue
                lines.append(f'{i + 1}. {name}')
                lines.append(f'æ’­æ”¾æ¬¡æ•°: {count}  æ—¶é•¿:{duration}')
            except (IndexError, ValueError):
                continue

    # hashtag + æ—¥æœŸ
    if movies or episodes:
        tag = '#DayRanks' if days == 1 else '#WeekRanks'
        lines.append('')
        lines.append(f'{tag}  {today_str}')

    # ---------- ç”¨æˆ·è§‚å½±æ—¶é•¿æ¦œ ----------
    if users:
        # å¦‚æœå‰é¢æœ‰ç”µå½±/å‰§é›†æ¦œï¼Œç©ºä¸¤è¡Œåˆ†éš”
        if movies or episodes:
            lines.append('')
            lines.append('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”')
            lines.append('')

        lines.append(f'<b>â–ğŸ†{site_name} {days} å¤©è§‚å½±æ¦œ</b>')
        lines.append('')

        for rank, row in enumerate(users, start=1):
            try:
                uid = str(row[0]) if row[0] else ''
                secs = int(float(row[1])) if row[1] else 0
                if secs <= 0:
                    continue
                display_name = get_user_display(uid)
                medal = rank_medals[rank - 1] if rank <= 3 else rank_medals[3]
                cn_rank = rank_to_cn(rank)
                duration_str = format_duration(secs)
                lines.append(f'{medal}<b>ç¬¬{cn_rank}å</b> | {display_name}')
                lines.append(f'  è§‚å½±æ—¶é•¿ | {duration_str}')
            except (IndexError, ValueError):
                continue

        lines.append('')
        lines.append(f'#UPlaysRank {today_str}')

    return '\n'.join(lines)


def _do_ranking_push(days, ranking_config, _version=0):
    """æ‰§è¡Œä¸€æ¬¡æ’è¡Œæ¨é€åˆ°ç¾¤ç»„"""
    key = 'daily' if days == 1 else 'weekly'
    try:
        with app.app_context():
            # ç‰ˆæœ¬å·æ£€æŸ¥ï¼šå¦‚æœè°ƒåº¦å™¨å·²è¢«é‡å¯ï¼ˆç‰ˆæœ¬å·æ›´æ–°ï¼‰ï¼Œæœ¬æ¬¡å›è°ƒæ”¾å¼ƒæ‰§è¡Œ
            with _ranking_timer_lock:
                current_ver = _ranking_schedule_version.get(key, 0)
                if _version < current_ver:
                    app.logger.info(f'æ’è¡Œæ¨é€: æ—§ç‰ˆæœ¬å›è°ƒ v{_version} < v{current_ver}ï¼Œè·³è¿‡ (days={days})')
                    return

            # é‡æ–°è¯»å–æœ€æ–°é…ç½®ï¼ˆç®¡ç†å‘˜å¯èƒ½å·²ä¿®æ”¹ï¼‰
            fresh_config = load_system_config().get('ranking', {})

            # å¦‚æœæ¨é€å·²è¢«å…³é—­ï¼Œä¸å†ç»§ç»­
            if not fresh_config.get('push_enabled'):
                app.logger.info(f'æ’è¡Œæ¨é€: é…ç½®å·²å…³é—­ï¼Œåœæ­¢è°ƒåº¦ (days={days})')
                return

            text = _build_ranking_text(days, fresh_config)
            if not text:
                app.logger.info(f'æ’è¡Œæ¨é€: æ— æ•°æ®ï¼Œè·³è¿‡ (days={days})')
                # ä»ç„¶è°ƒåº¦ä¸‹ä¸€æ¬¡
                _schedule_next_ranking_push(days, fresh_config)
                return

            bot_token = TELEGRAM_BOT_TOKEN
            chat_id = fresh_config.get('push_chat_id', '').strip() or TELEGRAM_GROUP_ID or TELEGRAM_CHAT_ID
            if not bot_token or not chat_id:
                app.logger.warning('æ’è¡Œæ¨é€: Telegram æœªé…ç½®')
                _schedule_next_ranking_push(days, fresh_config)
                return

            url = f'https://api.telegram.org/bot{bot_token}/sendMessage'
            data = {
                'chat_id': chat_id,
                'text': text,
                'parse_mode': 'HTML',
                'disable_web_page_preview': True
            }

            import requests as req_lib
            resp = req_lib.post(url, json=data, timeout=10)
            if resp.status_code == 200:
                app.logger.info(f'æ’è¡Œæ¨é€æˆåŠŸ: days={days} -> {chat_id}')
            else:
                app.logger.warning(f'æ’è¡Œæ¨é€å¤±è´¥: {resp.status_code} {resp.text[:200]}')

            # æ¨é€å®Œæ¯•åï¼Œç”¨æœ€æ–°é…ç½®é‡æ–°è°ƒåº¦ä¸‹ä¸€æ¬¡
            _schedule_next_ranking_push(days, fresh_config)
    except Exception as e:
        try:
            with app.app_context():
                app.logger.error(f'æ’è¡Œæ¨é€å¼‚å¸¸: {e}', exc_info=True)
                # å¼‚å¸¸æ—¶ä¹Ÿå°è¯•é‡æ–°è°ƒåº¦ï¼Œé¿å…å®šæ—¶ä»»åŠ¡å½»åº•æ­»æ‰
                try:
                    fresh_config = load_system_config().get('ranking', {})
                    if fresh_config.get('push_enabled'):
                        _schedule_next_ranking_push(days, fresh_config)
                except Exception:
                    pass
        except:
            pass


def _schedule_next_ranking_push(days, ranking_config):
    """è®¡ç®—ä¸‹ä¸€æ¬¡æ¨é€æ—¶é—´å¹¶è®¾ç½®å®šæ—¶å™¨"""
    from datetime import timezone as tz
    now = datetime.now(tz(timedelta(hours=8)))

    if days == 1:
        # æ—¥æ¦œï¼šæ¯å¤© push_daily_time
        time_str = ranking_config.get('push_daily_time', '21:00')
        key = 'daily'
    else:
        # å‘¨æ¦œï¼šæ¯å‘¨ push_weekly_day çš„ push_weekly_time
        time_str = ranking_config.get('push_weekly_time', '21:00')
        key = 'weekly'

    try:
        h, m = [int(x) for x in time_str.split(':')]
    except:
        h, m = 21, 0

    # è®¡ç®—ä¸‹ä¸€æ¬¡ç›®æ ‡æ—¶é—´
    target = now.replace(hour=h, minute=m, second=0, microsecond=0)

    if days == 1:
        # æ—¥æ¦œï¼šå¦‚æœä»Šå¤©æ—¶é—´å·²è¿‡ï¼Œå»¶åˆ°æ˜å¤©
        if target <= now:
            target += timedelta(days=1)
    else:
        # å‘¨æ¦œï¼šæ‰¾åˆ°ä¸‹ä¸€ä¸ªç›®æ ‡æ˜ŸæœŸ
        target_day = ranking_config.get('push_weekly_day', 0)  # 0=å‘¨ä¸€
        # Python weekday(): 0=Mon
        days_ahead = target_day - now.weekday()
        if days_ahead < 0 or (days_ahead == 0 and target <= now):
            days_ahead += 7
        target += timedelta(days=days_ahead)

    delay_seconds = (target - now).total_seconds()
    if delay_seconds < 60:
        delay_seconds += 86400 if days == 1 else 604800

    with _ranking_timer_lock:
        # å–æ¶ˆæ—§å®šæ—¶å™¨
        old = _ranking_timers.pop(key, None)
        if old:
            old.cancel()

        # è·å–å½“å‰ç‰ˆæœ¬å·ï¼ˆä¼ ç»™Timerå›è°ƒï¼Œç”¨äºåˆ¤æ–­æ˜¯å¦è¿‡æœŸï¼‰
        ver = _ranking_schedule_version.get(key, 0)

        timer = threading.Timer(delay_seconds, _do_ranking_push, args=[days, ranking_config],
                                kwargs={'_version': ver})
        timer.daemon = True
        _ranking_timers[key] = timer
        timer.start()

    target_str = target.strftime('%Y-%m-%d %H:%M')
    app.logger.info(f'æ’è¡Œ{key}æ¨é€å·²è°ƒåº¦: {target_str} (çº¦{int(delay_seconds)}ç§’å, v{ver})')


def _restart_ranking_scheduler(ranking_config):
    """æ ¹æ®é…ç½®é‡å¯æ’è¡Œæ¨é€è°ƒåº¦å™¨"""
    with _ranking_timer_lock:
        # é€’å¢ç‰ˆæœ¬å·ï¼Œä½¿æ‰€æœ‰æ—§Timerå›è°ƒåœ¨æ‰§è¡Œæ—¶è‡ªåŠ¨æ”¾å¼ƒ
        for key in ['daily', 'weekly']:
            _ranking_schedule_version[key] = _ranking_schedule_version.get(key, 0) + 1
        
        # å–æ¶ˆæ‰€æœ‰ç°æœ‰å®šæ—¶å™¨
        for key in list(_ranking_timers.keys()):
            t = _ranking_timers.pop(key, None)
            if t:
                t.cancel()

    if not ranking_config.get('push_enabled'):
        app.logger.info('æ’è¡Œå®šæ—¶æ¨é€: å·²å…³é—­')
        return

    if ranking_config.get('push_daily', True):
        _schedule_next_ranking_push(1, ranking_config)

    if ranking_config.get('push_weekly', True):
        _schedule_next_ranking_push(7, ranking_config)


@app.route('/api/admin/playback/rankings/push', methods=['POST'])
@admin_required
def admin_push_ranking_now():
    """æ‰‹åŠ¨ç«‹å³æ¨é€æ’è¡Œæ¦œåˆ°ç¾¤ç»„"""
    days = request.args.get('days', 1, type=int)
    days = 7 if days == 7 else 1

    ranking_config = load_system_config().get('ranking', {})

    try:
        text = _build_ranking_text(days, ranking_config)
        if not text:
            return jsonify({'success': False, 'error': 'æ— æ’è¡Œæ•°æ®å¯æ¨é€'}), 400

        bot_token = TELEGRAM_BOT_TOKEN
        chat_id = ranking_config.get('push_chat_id', '').strip() or TELEGRAM_GROUP_ID or TELEGRAM_CHAT_ID
        if not bot_token or not chat_id:
            return jsonify({'success': False, 'error': 'Telegram æœªé…ç½®ï¼Œæ— æ³•æ¨é€'}), 400

        import requests as req_lib
        url = f'https://api.telegram.org/bot{bot_token}/sendMessage'
        data = {
            'chat_id': chat_id,
            'text': text,
            'parse_mode': 'HTML',
            'disable_web_page_preview': True
        }
        resp = req_lib.post(url, json=data, timeout=10)
        if resp.status_code == 200:
            period = 'æ—¥' if days == 1 else 'å‘¨'
            return jsonify({'success': True, 'message': f'{period}æ¦œå·²æ¨é€åˆ°ç¾¤ç»„ {chat_id}'})
        else:
            return jsonify({'success': False, 'error': f'Telegram API è¿”å› {resp.status_code}'}), 500
    except Exception as e:
        app.logger.error(f'æ‰‹åŠ¨æ¨é€æ’è¡Œå¤±è´¥: {e}', exc_info=True)
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/admin/playback/devices')
@admin_required
def admin_get_all_devices():
    """ç®¡ç†å‘˜è·å–æ‰€æœ‰ç”¨æˆ·çš„è®¾å¤‡ï¼ˆä¼˜å…ˆä» Playback Reporting è·å–ï¼‰"""
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 20, type=int)
    search = request.args.get('search', '')
    source = request.args.get('source', 'emby')  # emby æˆ– local
    
    if source == 'emby' and emby_client.is_enabled():
        # ä» Emby Playback Reporting è·å–
        try:
            devices = emby_client.get_playback_report_devices()
            
            # æœç´¢è¿‡æ»¤
            if search:
                search_lower = search.lower()
                devices = [d for d in devices if 
                    search_lower in d.get('user_name', '').lower() or
                    search_lower in d.get('device_name', '').lower() or
                    search_lower in d.get('client', '').lower()
                ]
            
            # åˆ†é¡µ
            total = len(devices)
            start = (page - 1) * per_page
            end = start + per_page
            paged_devices = devices[start:end]
            
            return jsonify({
                'success': True,
                'devices': paged_devices,
                'total': total,
                'pages': (total + per_page - 1) // per_page,
                'current_page': page,
                'source': 'emby'
            })
        except Exception as e:
            app.logger.error(f'ä» Emby è·å–è®¾å¤‡å¤±è´¥ï¼Œå›é€€åˆ°æœ¬åœ°: {e}')
    
    # å›é€€åˆ°æœ¬åœ°æ•°æ®åº“
    query = UserDevice.query.order_by(UserDevice.last_active.desc())
    
    if search:
        query = query.join(User, UserDevice.user_tg == User.tg).filter(
            db.or_(
                User.name.ilike(f'%{search}%'),
                UserDevice.device_name.ilike(f'%{search}%'),
                UserDevice.client.ilike(f'%{search}%')
            )
        )
    
    pagination = query.paginate(page=page, per_page=per_page, error_out=False)
    
    return jsonify({
        'success': True,
        'devices': [d.to_dict() for d in pagination.items],
        'total': pagination.total,
        'pages': pagination.pages,
        'current_page': page,
        'source': 'local'
    })


@app.route('/api/admin/playback/history')
@admin_required
def admin_get_all_playback_history():
    """ç®¡ç†å‘˜è·å–æ‰€æœ‰ç”¨æˆ·çš„æ’­æ”¾å†å²ï¼ˆä¼˜å…ˆä» Playback Reporting è·å–ï¼‰"""
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 20, type=int)
    search = request.args.get('search', '')
    user_id = request.args.get('user_id', '')  # Emby ç”¨æˆ· ID
    days = request.args.get('days', 7, type=int)  # é»˜è®¤7å¤©ä»¥ä¼˜åŒ–æ€§èƒ½
    source = request.args.get('source', 'emby')  # emby æˆ– local
    
    # é™åˆ¶å¤©æ•°èŒƒå›´ä»¥ä¼˜åŒ–æ€§èƒ½
    days = min(days, 14)
    
    if source == 'emby' and emby_client.is_enabled():
        # ä» Emby Playback Reporting è·å–
        try:
            # è®¡ç®—éœ€è¦è·å–çš„è®°å½•æ•°é‡ï¼ˆè€ƒè™‘æœç´¢è¿‡æ»¤åå¯èƒ½å‡å°‘ï¼‰
            limit = per_page * 10 if search else per_page * 5
            history = emby_client.get_playback_report_history(days=days, user_id=user_id if user_id else None, limit=limit)
            
            # æœç´¢è¿‡æ»¤
            if search:
                search_lower = search.lower()
                history = [h for h in history if 
                    search_lower in h.get('item_name', '').lower() or
                    search_lower in h.get('series_name', '').lower() or
                    search_lower in h.get('user_name', '').lower()
                ]
            
            # åˆ†é¡µ
            total = len(history)
            start = (page - 1) * per_page
            end = start + per_page
            paged_history = history[start:end]
            
            # è¡¥å……è¿›åº¦æ•°æ®ï¼šä»æœ¬åœ°æ•°æ®åº“è·å– webhook è®°å½•çš„ç²¾ç¡®æ’­æ”¾è¿›åº¦
            still_missing = []
            for record in paged_history:
                if record.get('play_percentage') is not None and record['play_percentage'] > 0:
                    continue  # å·²æœ‰è¿›åº¦æ•°æ®ï¼Œè·³è¿‡
                
                item_id = record.get('item_id', '')
                uid = record.get('user_id', '')
                if item_id and uid:
                    try:
                        # é€šè¿‡ emby_user_id æ‰¾åˆ°æœ¬åœ°ç”¨æˆ·
                        local_user = User.query.filter_by(embyid=uid).first()
                        if local_user:
                            # æŸ¥æ‰¾æœ¬åœ°æœ€æ–°çš„æ’­æ”¾è®°å½•ï¼ˆåŒ¹é… emby_item_idï¼‰
                            local_record = PlaybackRecord.query.filter_by(
                                user_tg=local_user.tg,
                                emby_item_id=item_id
                            ).order_by(PlaybackRecord.started_at.desc()).first()
                            
                            if local_record and local_record.play_percentage and local_record.play_percentage > 0:
                                record['play_percentage'] = min(100.0, round(local_record.play_percentage, 1))
                                continue
                    except Exception:
                        pass
                
                # ä»ç¼ºå°‘è¿›åº¦ï¼ŒåŠ å…¥å¾…è¡¥å……åˆ—è¡¨
                if record.get('play_percentage') is None and record.get('play_duration', 0) > 0:
                    still_missing.append(record)
            
            # å¯¹ä»ç¼ºå°‘è¿›åº¦çš„è®°å½•ï¼Œé€šè¿‡ Emby Items API æ‰¹é‡è·å– RunTimeTicks è®¡ç®—ç™¾åˆ†æ¯”
            if still_missing and emby_client.is_enabled():
                try:
                    unique_ids = list(set(r['item_id'] for r in still_missing if r.get('item_id')))
                    runtime_cache = {}
                    batch_size = 50
                    for i in range(0, len(unique_ids), batch_size):
                        batch_ids = unique_ids[i:i+batch_size]
                        items_url = f"{emby_client.base_url}/Items"
                        items_params = {
                            'api_key': emby_client.api_key,
                            'Ids': ','.join(batch_ids),
                            'Fields': 'RunTimeTicks',
                            'Recursive': 'true'
                        }
                        items_resp = emby_client.session.get(items_url, params=items_params, timeout=10)
                        if items_resp.status_code == 200:
                            items_data = items_resp.json()
                            for itm in items_data.get('Items', []):
                                itm_id = str(itm.get('Id', ''))
                                rtt = itm.get('RunTimeTicks', 0) or 0
                                if itm_id and rtt > 0:
                                    runtime_cache[itm_id] = rtt // 10000000
                    
                    for r in still_missing:
                        total_sec = runtime_cache.get(r['item_id'], 0)
                        if total_sec > 0 and r['play_duration'] > 0:
                            r['play_percentage'] = min(100, round(r['play_duration'] / total_sec * 100, 1))
                except Exception as e:
                    app.logger.debug(f'æ’­æ”¾å†å²é¡µè¡¥å…… RunTimeTicks å¤±è´¥: {e}')
            
            return jsonify({
                'success': True,
                'records': paged_history,
                'total': total,
                'pages': (total + per_page - 1) // per_page,
                'current_page': page,
                'source': 'emby'
            })
        except Exception as e:
            app.logger.error(f'ä» Emby è·å–æ’­æ”¾å†å²å¤±è´¥ï¼Œå›é€€åˆ°æœ¬åœ°: {e}')
    
    # å›é€€åˆ°æœ¬åœ°æ•°æ®åº“
    user_tg = request.args.get('user_tg', type=int)
    query = PlaybackRecord.query.order_by(PlaybackRecord.started_at.desc())
    
    if user_tg:
        query = query.filter_by(user_tg=user_tg)
    
    if search:
        query = query.filter(
            db.or_(
                PlaybackRecord.item_name.ilike(f'%{search}%'),
                PlaybackRecord.series_name.ilike(f'%{search}%')
            )
        )
    
    pagination = query.paginate(page=page, per_page=per_page, error_out=False)
    
    return jsonify({
        'success': True,
        'records': [r.to_dict() for r in pagination.items],
        'total': pagination.total,
        'pages': pagination.pages,
        'current_page': page,
        'source': 'local'
    })


@app.route('/api/admin/playback/sync-all', methods=['POST'])
@admin_required
def admin_sync_all_playback():
    """ç®¡ç†å‘˜åŒæ­¥æ‰€æœ‰ç”¨æˆ·çš„æ’­æ”¾å†å²åˆ°æ•°æ®åº“ï¼ˆä¼˜åŒ–ç‰ˆï¼‰"""
    if not emby_client.is_enabled():
        return jsonify({'success': False, 'error': 'Emby æœªé…ç½®'}), 400
    
    synced_users = 0
    synced_records = 0
    
    # è·å–æ‰€æœ‰æœ‰ embyid çš„ç”¨æˆ·
    users_with_emby = User.query.filter(User.embyid.isnot(None), User.embyid != '').all()
    
    # é¢„å…ˆæ‰¹é‡è·å–æ‰€æœ‰å·²å­˜åœ¨çš„æ’­æ”¾è®°å½•ï¼ˆuser_tg + emby_item_id ç»„åˆï¼‰
    existing_records = set()
    all_existing = PlaybackRecord.query.with_entities(PlaybackRecord.user_tg, PlaybackRecord.emby_item_id).all()
    for record in all_existing:
        existing_records.add((record.user_tg, record.emby_item_id))
    
    new_records = []
    
    for emby_user in users_with_emby:
        try:
            # è·å–è¯¥ç”¨æˆ·çš„æ’­æ”¾å†å²ï¼ˆé™åˆ¶æ•°é‡ä»¥åŠ å¿«é€Ÿåº¦ï¼‰
            history = emby_client.get_user_playback_history(emby_user.embyid, limit=30)
            
            for item in history:
                record_key = (emby_user.tg, item.get('id'))
                
                # ä½¿ç”¨é›†åˆå¿«é€Ÿåˆ¤æ–­æ˜¯å¦å­˜åœ¨
                if record_key not in existing_records:
                    # åˆ›å»ºæ–°è®°å½•
                    record = PlaybackRecord(
                        user_tg=emby_user.tg,
                        emby_item_id=item.get('id'),
                        item_name=item.get('name', 'æœªçŸ¥'),
                        item_type=item.get('type', ''),
                        series_name=item.get('series_name', ''),
                        play_percentage=item.get('played_percentage', 100) if item.get('play_count', 0) > 0 else 0,
                        started_at=datetime.fromisoformat(item['last_played_date'].replace('Z', '+00:00')).replace(tzinfo=None) if item.get('last_played_date') else datetime.now()
                    )
                    new_records.append(record)
                    existing_records.add(record_key)  # é¿å…åŒæ‰¹æ¬¡é‡å¤
                    synced_records += 1
            
            synced_users += 1
            
        except Exception as e:
            app.logger.error(f'åŒæ­¥ç”¨æˆ· {emby_user.name} æ’­æ”¾å†å²å¤±è´¥: {e}')
            continue
    
    # æ‰¹é‡æäº¤æ‰€æœ‰æ–°è®°å½•
    if new_records:
        try:
            db.session.bulk_save_objects(new_records)
            db.session.commit()
        except Exception as e:
            db.session.rollback()
            app.logger.error(f'æ‰¹é‡ä¿å­˜æ’­æ”¾è®°å½•å¤±è´¥: {e}')
            return jsonify({'success': False, 'error': 'ä¿å­˜å¤±è´¥'}), 500
    
    return jsonify({
        'success': True,
        'message': f'å·²åŒæ­¥ {synced_users} ä¸ªç”¨æˆ·çš„ {synced_records} æ¡æ’­æ”¾è®°å½•'
    })


@app.route('/api/admin/playback/devices/<int:device_id>', methods=['DELETE'])
@admin_required
def admin_delete_device(device_id):
    """ç®¡ç†å‘˜åˆ é™¤è®¾å¤‡"""
    device = db.session.get(UserDevice, device_id)
    if not device:
        return jsonify({'success': False, 'error': 'è®¾å¤‡ä¸å­˜åœ¨'}), 404
    
    try:
        PlaybackRecord.query.filter_by(device_id=device_id).delete()
        db.session.delete(device)
        db.session.commit()
        return jsonify({'success': True, 'message': 'è®¾å¤‡å·²åˆ é™¤'})
    except Exception as e:
        db.session.rollback()
        app.logger.error(f'ç®¡ç†å‘˜åˆ é™¤è®¾å¤‡å¤±è´¥: {e}')
        return jsonify({'success': False, 'error': 'åˆ é™¤å¤±è´¥'}), 500


@app.route('/api/admin/playback/devices/<int:device_id>/block', methods=['POST'])
@admin_required
def admin_block_device(device_id):
    """ç®¡ç†å‘˜ç¦ç”¨/å¯ç”¨è®¾å¤‡"""
    device = db.session.get(UserDevice, device_id)
    if not device:
        return jsonify({'success': False, 'error': 'è®¾å¤‡ä¸å­˜åœ¨'}), 404
    
    data = request.get_json() or {}
    block = data.get('block', True)
    
    try:
        device.is_blocked = block
        db.session.commit()
        status = 'å·²ç¦ç”¨' if block else 'å·²å¯ç”¨'
        return jsonify({'success': True, 'message': f'è®¾å¤‡{status}', 'is_blocked': device.is_blocked})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': 'æ“ä½œå¤±è´¥'}), 500


@app.route('/api/emby/season-details')
@login_required
def get_emby_season_details():
    """è·å–å‰§é›†çš„è¯¦ç»†å­£ä¿¡æ¯ï¼ˆå·²æœ‰vsç¼ºå¤±ï¼‰"""
    if not emby_client.is_enabled():
        return jsonify({
            'success': False, 
            'error': 'Embyåª’ä½“åº“æœªé…ç½®ï¼Œè¯·è”ç³»ç®¡ç†å‘˜',
            'user_friendly': True
        }), 400
    
    tmdb_id = request.args.get('tmdb_id')
    if not tmdb_id:
        return jsonify({
            'success': False, 
            'error': 'å‚æ•°é”™è¯¯ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•',
            'user_friendly': True
        }), 400
    
    try:
        # è·å–Embyä¸­çš„å‰§é›†
        emby_item = emby_client.search_by_tmdb_id(tmdb_id, 'tv')
        if not emby_item:
            return jsonify({
                'success': False, 
                'error': 'è¯¥å‰§é›†å°šæœªå…¥åº“åˆ°Emby',
                'user_friendly': True
            }), 404
        
        # è·å–Embyä¸­çš„å­£
        emby_seasons = emby_client.get_tv_seasons(emby_item.get('Id'))
        has_seasons = sorted([s.get('IndexNumber') for s in emby_seasons if s.get('IndexNumber') is not None and s.get('IndexNumber') > 0])
        
        # è·å–TMDBæ€»å­£æ•°
        tmdb_seasons = get_tmdb_tv_seasons(int(tmdb_id))
        total_seasons = tmdb_seasons.get('total_seasons', 0) if tmdb_seasons else 0
        
        # è®¡ç®—ç¼ºå¤±çš„å­£
        all_seasons = set(range(1, total_seasons + 1))
        missing_seasons = sorted(all_seasons - set(has_seasons))
        
        return jsonify({
            'success': True,
            'hasSeasons': has_seasons,
            'totalSeasons': total_seasons,
            'missingSeasons': missing_seasons
        })
    except Exception as e:
        app.logger.error(f'è·å–Embyå­£è¯¦æƒ…å¤±è´¥: {e}')
        return jsonify({
            'success': False, 
            'error': 'EmbyæœåŠ¡æš‚æ—¶æ— æ³•è®¿é—®ï¼Œè¯·ç¨åå†è¯•',
            'user_friendly': True,
            'technical_error': str(e)
        }), 500


@app.route('/request-movie', methods=['POST'])
@login_required
def request_movie():
    user = db.session.get(User, session['user_id'])
    
    if not user:
        return jsonify({
            'success': False,
            'error': 'ç”¨æˆ·ä¿¡æ¯ä¸å­˜åœ¨ï¼Œè¯·é‡æ–°ç™»å½•'
        }), 401
    
    if not user.can_request():
        daily_limit = user.get_daily_limit()
        today_count = user.get_today_request_count()
        
        # æ£€æŸ¥æ±‚ç‰‡ä¸Šé™æ˜¯å¦ä¸º0ï¼ˆæ— æœ‰æ•ˆè®¢é˜…æˆ–è¢«ç¦ç”¨ï¼‰
        if daily_limit == 0:
            # æ£€æŸ¥æ˜¯å¦æ˜¯è¢«ç¦ç”¨çš„ç”¨æˆ·
            if user.lv == 'c':
                app.logger.warning(f'ç”¨æˆ· {user.name} æ±‚ç‰‡è¢«é™åˆ¶: è´¦å·å·²ç¦ç”¨')
                return jsonify({
                    'success': False, 
                    'error': 'æ‚¨çš„è´¦å·å·²è¢«ç¦ç”¨ï¼Œæ— æ³•æ±‚ç‰‡'
                }), 403
            
            # æ— æœ‰æ•ˆè®¢é˜…
            app.logger.warning(f'ç”¨æˆ· {user.name} æ±‚ç‰‡è¢«é™åˆ¶: æ— æœ‰æ•ˆè®¢é˜…')
            return jsonify({
                'success': False, 
                'error': 'æ‚¨æ²¡æœ‰æœ‰æ•ˆè®¢é˜…ï¼Œæ— æ³•æ±‚ç‰‡'
            }), 403
        
        # å·²è¾¾åˆ°æ¯æ—¥æ±‚ç‰‡ä¸Šé™
        app.logger.warning(f'ç”¨æˆ· {user.name} æ±‚ç‰‡è¢«é™åˆ¶: {today_count}/{daily_limit}')
        return jsonify({
            'success': False, 
            'error': f'æ‚¨ä»Šå¤©å·²è¾¾åˆ°æ±‚ç‰‡ä¸Šé™ï¼ˆ{today_count}/{daily_limit}æ¬¡ï¼‰'
        }), 429
    
    data = request.get_json()
    tmdb_id = data.get('tmdb_id')
    media_type = data.get('media_type', 'movie')
    
    # ç”µè§†å‰§å­£/é›†é€‰æ‹©å‚æ•°
    request_type = data.get('request_type', 'all')  # all, season, episode
    season_number = data.get('season_number')  # æŒ‡å®šçš„å­£æ•°
    episode_number = data.get('episode_number')  # æŒ‡å®šçš„é›†æ•°
    user_note = data.get('user_note', '')  # ç”¨æˆ·å¤‡æ³¨
    
    # éªŒè¯è¾“å…¥
    if not tmdb_id:
        app.logger.warning(f'ç”¨æˆ· {user.name} æäº¤äº†æ— æ•ˆçš„æ±‚ç‰‡è¯·æ±‚: ç¼ºå°‘tmdb_id')
        return jsonify({
            'success': False,
            'error': 'æ— æ•ˆçš„è¯·æ±‚å‚æ•°'
        }), 400
    
    if media_type not in ['movie', 'tv']:
        media_type = 'movie'
    
    # éªŒè¯ç”µè§†å‰§æ±‚ç‰‡ç±»å‹
    if media_type == 'tv':
        if request_type not in ['all', 'season', 'episode']:
            request_type = 'all'
        if request_type == 'season' and not season_number:
            return jsonify({
                'success': False,
                'error': 'è¯·é€‰æ‹©è¦æ±‚ç‰‡çš„å­£æ•°'
            }), 400
        if request_type == 'episode' and (not season_number or not episode_number):
            return jsonify({
                'success': False,
                'error': 'è¯·é€‰æ‹©è¦æ±‚ç‰‡çš„å­£æ•°å’Œé›†æ•°'
            }), 400
    
    # ä»TMDBè·å–è¯¦ç»†ä¿¡æ¯ï¼ˆå…ˆè·å–ï¼Œç”¨äºåç»­æ£€æŸ¥ï¼‰
    details = get_tmdb_details(tmdb_id, media_type)
    
    if not details:
        app.logger.error(f'æ— æ³•è·å–TMDBè¯¦æƒ…: tmdb_id={tmdb_id}, type={media_type}')
        return jsonify({
            'success': False,
            'error': 'æ— æ³•è·å–å½±ç‰‡ä¿¡æ¯'
        }), 400
    
    title = details.get('title') or details.get('name')
    year = details.get('release_date', '')[:4] if media_type == 'movie' else details.get('first_air_date', '')[:4]
    
    # ========== æ£€æŸ¥ Emby åº“ä¸­æ˜¯å¦å·²å­˜åœ¨ ==========
    if emby_client.is_enabled():
        emby_check = emby_client.check_exists(str(tmdb_id), title, year, media_type)
        if emby_check['exists']:
            app.logger.info(f'ç”¨æˆ· {user.name} æ±‚ç‰‡å·²åœ¨ Emby åº“ä¸­: {title} ({year})')
            return jsonify({
                'success': False,
                'error': f'ğŸ‰ å¥½æ¶ˆæ¯ï¼ã€Š{title}ã€‹å·²åœ¨åª’ä½“åº“ä¸­ï¼Œå¯ä»¥ç›´æ¥è§‚çœ‹å•¦ï¼',
                'in_library': True
            }), 400
    
    # æ£€æŸ¥æ˜¯å¦å·²ç»æ±‚è¿‡è¿™ä¸ªç‰‡ (ç²¾å‡†æ£€æµ‹)
    query = MovieRequest.query.filter_by(
        user_tg=user.tg,
        tmdb_id=tmdb_id,
        media_type=media_type
    ).filter(MovieRequest.status != 'rejected')
    
    # ç”µè§†å‰§éœ€è¦ç²¾ç¡®åŒ¹é…å­£/é›†
    if media_type == 'tv':
        if request_type == 'all':
            # æ±‚å…¨å‰§: æ£€æŸ¥æ˜¯å¦å·²æœ‰å…¨å‰§æˆ–ä»»æ„å­£çš„æ±‚ç‰‡
            existing = query.filter(
                (MovieRequest.request_type == 'all') |
                (MovieRequest.request_type == 'season') |
                (MovieRequest.request_type == 'episode')
            ).first()
            if existing:
                scope = existing.get_request_scope()
                app.logger.info(f'ç”¨æˆ· {user.name} é‡å¤æ±‚ç‰‡: TMDB={tmdb_id} [{scope}] (å·²å­˜åœ¨ID={existing.id})')
                return jsonify({
                    'success': False,
                    'error': f'æ‚¨å·²æ±‚è¿‡è¯¥å‰§çš„{scope}ï¼Œæ— éœ€é‡å¤æ±‚ç‰‡'
                }), 400
        elif request_type == 'season':
            # æ±‚æŒ‡å®šå­£: æ£€æŸ¥æ˜¯å¦å·²æœ‰å…¨å‰§æˆ–è¯¥å­£çš„æ±‚ç‰‡
            existing = query.filter(
                (MovieRequest.request_type == 'all') |
                ((MovieRequest.request_type == 'season') & (MovieRequest.season_number == int(season_number)))
            ).first()
            if existing:
                scope = existing.get_request_scope()
                app.logger.info(f'ç”¨æˆ· {user.name} é‡å¤æ±‚ç‰‡: TMDB={tmdb_id} ç¬¬{season_number}å­£ (å·²å­˜åœ¨{scope}, ID={existing.id})')
                return jsonify({
                    'success': False,
                    'error': f'æ‚¨å·²æ±‚è¿‡{scope}ï¼ŒåŒ…å«ç¬¬{season_number}å­£'
                }), 400
        elif request_type == 'episode':
            # æ±‚æŒ‡å®šé›†: æ£€æŸ¥æ˜¯å¦å·²æœ‰å…¨å‰§ã€è¯¥å­£æˆ–è¯¥é›†çš„æ±‚ç‰‡
            existing = query.filter(
                (MovieRequest.request_type == 'all') |
                ((MovieRequest.request_type == 'season') & (MovieRequest.season_number == int(season_number))) |
                ((MovieRequest.request_type == 'episode') & 
                 (MovieRequest.season_number == int(season_number)) & 
                 (MovieRequest.episode_number == int(episode_number)))
            ).first()
            if existing:
                scope = existing.get_request_scope()
                app.logger.info(f'ç”¨æˆ· {user.name} é‡å¤æ±‚ç‰‡: TMDB={tmdb_id} S{season_number}E{episode_number} (å·²å­˜åœ¨{scope}, ID={existing.id})')
                return jsonify({
                    'success': False,
                    'error': f'æ‚¨å·²æ±‚è¿‡{scope}ï¼ŒåŒ…å«è¯¥é›†'
                }), 400
    else:
        # ç”µå½±: ç®€å•æ£€æµ‹
        existing = query.first()
        if existing:
            app.logger.info(f'ç”¨æˆ· {user.name} é‡å¤æ±‚ç‰‡: TMDB={tmdb_id} (å·²å­˜åœ¨ID={existing.id})')
            return jsonify({
                'success': False,
                'error': 'æ‚¨å·²ç»æ±‚è¿‡è¿™éƒ¨ç”µå½±äº†'
            }), 400
    
    poster_path = details.get('poster_path')
    
    # è·å–ç”µè§†å‰§æ€»å­£æ•°
    total_seasons = None
    if media_type == 'tv':
        total_seasons = details.get('number_of_seasons')
    
    # åˆ›å»ºæ±‚ç‰‡è®°å½•
    try:
        movie_request = MovieRequest(
            user_tg=user.tg,
            tmdb_id=tmdb_id,
            title=title,
            year=year,
            poster_path=poster_path,
            overview=details.get('overview'),
            media_type=media_type,
            request_type=request_type if media_type == 'tv' else 'all',
            season_number=int(season_number) if season_number else None,
            episode_number=int(episode_number) if episode_number else None,
            total_seasons=total_seasons,
            user_note=user_note
        )
        
        db.session.add(movie_request)
        db.session.commit()
    except Exception as e:
        db.session.rollback()
        app.logger.error(f'ç”¨æˆ· {user.name} æ±‚ç‰‡ä¿å­˜å¤±è´¥: {title} ({year}) - {type(e).__name__}: {e}')
        return jsonify({
            'success': False,
            'error': f'ä¿å­˜æ±‚ç‰‡è®°å½•å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•'
        }), 500
    
    # æ„å»ºæ—¥å¿—ä¿¡æ¯
    scope_info = movie_request.get_request_scope() if media_type == 'tv' else ''
    log_msg = f'ç”¨æˆ· {user.name} æ±‚ç‰‡æˆåŠŸ: {title} ({year}) [TMDB:{tmdb_id}]'
    if scope_info:
        log_msg += f' [{scope_info}]'
    app.logger.info(log_msg)
    
    # è®°å½•æ±‚ç‰‡æ—¥å¿—
    log_user_activity(UserActivityLog.ACTION_REQUEST_MOVIE, user=user, 
                     detail={'title': title, 'year': year, 'tmdb_id': tmdb_id, 'media_type': media_type, 'scope': scope_info})
    
    # å…ˆè¿”å›æˆåŠŸå“åº”ç»™ç”¨æˆ·ï¼Œç„¶åå¼‚æ­¥å‘é€ Telegram é€šçŸ¥
    daily_limit = user.get_daily_limit()
    remaining = daily_limit - user.get_today_request_count() if not user.is_admin else 'æ— é™åˆ¶'
    
    # åœ¨åå°å‘é€ Telegram é€šçŸ¥ï¼ˆä¸é˜»å¡å“åº”ï¼‰
    try:
        overview = details.get('overview')
        user_tg_id = user.telegram_id or user.tg
        # å°è¯•é€šè¿‡ Telegram API è·å–ç”¨æˆ·çš„ TG æ˜¾ç¤ºåç§°ï¼Œè€Œé Emby è´¦å·å
        display_name = user.name  # é»˜è®¤ä½¿ç”¨ Emby è´¦å·å
        if user_tg_id:
            try:
                chat_url = f'https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/getChat'
                chat_resp = PROXY_SESSION.post(chat_url, json={'chat_id': user_tg_id}, timeout=5)
                chat_data = chat_resp.json()
                if chat_data.get('ok'):
                    tg_result = chat_data.get('result', {})
                    # ä¼˜å…ˆä½¿ç”¨ usernameï¼ˆ@xxxï¼‰ï¼Œå…¶æ¬¡ first_name
                    if tg_result.get('username'):
                        display_name = tg_result['username']
                    elif tg_result.get('first_name'):
                        display_name = tg_result['first_name']
            except Exception as e:
                app.logger.warning(f'è·å–ç”¨æˆ· {user_tg_id} TGæ˜¾ç¤ºåç§°å¤±è´¥: {e}')
        # ä¼ é€’æ±‚ç‰‡èŒƒå›´ä¿¡æ¯å’Œç”¨æˆ· Telegram ID åˆ°é€šçŸ¥ï¼ˆä½¿ç”¨çœŸæ­£çš„ telegram_id è€Œéç³»ç»Ÿä¸»é”® tgï¼‰
        send_telegram_notification(display_name, title, year, media_type, tmdb_id, poster_path, overview, scope_info, user_tg_id)
    except Exception as e:
        # å³ä½¿ Telegram å‘é€å¤±è´¥ä¹Ÿä¸å½±å“ç”¨æˆ·ä½“éªŒ
        app.logger.error(f'Telegram é€šçŸ¥å¼‚å¸¸: {e}')
    
    # å‘ bot_admin ç®¡ç†å‘˜ç§èŠå‘é€å®¡æ ¸é€šçŸ¥ï¼ˆå¸¦æ‰¹å‡†/æ‹’ç»æŒ‰é’®ï¼‰
    try:
        send_admin_review_notification(movie_request, user)
    except Exception as e:
        app.logger.error(f'ç®¡ç†å‘˜å®¡æ ¸é€šçŸ¥å¼‚å¸¸: {e}')
    
    return jsonify({
        'success': True,
        'message': 'æ±‚ç‰‡æˆåŠŸï¼',
        'remaining': remaining
    }), 200


# ==================== ç®¡ç†åå°å®‰å…¨å…¥å£ ====================

@app.route('/<path:secret_path>')
def admin_dynamic_entry(secret_path):
    """åŠ¨æ€ç®¡ç†åå°å…¥å£ - æ ¹æ®é…ç½®æ–‡ä»¶ä¸­çš„è·¯å¾„è®¿é—®
    ç›´æ¥è®¿é—® /embypanel å³å¯ï¼ˆé»˜è®¤è·¯å¾„ï¼‰
    """
    admin_config = get_admin_config()
    config_path = admin_config.get('secret_path', '')
    
    if not config_path or secret_path != config_path:
        # è¿”å› 404ï¼Œä¸æš´éœ²å®‰å…¨å…¥å£
        abort(404)
    
    # å¦‚æœå·²ç™»å½•ï¼Œæ£€æŸ¥æ˜¯å¦éœ€è¦å¼ºåˆ¶ä¿®æ”¹é…ç½®
    if session.get('admin_logged_in'):
        if not admin_config.get('initialized', False):
            return redirect('/admin/setup')
        return redirect('/admin')
    
    # æ˜¾ç¤ºç®¡ç†å‘˜ç™»å½•é¡µé¢
    site_config = get_site_config()
    return render_template('admin_login.html', site_config=site_config)


@app.route('/api/admin-login', methods=['POST'])
def admin_login_api():
    """ç®¡ç†å‘˜ç™»å½•API - æ”¯æŒå¤šç®¡ç†å‘˜"""
    # ===== æš´åŠ›ç ´è§£é˜²æŠ¤ï¼šç®¡ç†å‘˜ç™»å½•ï¼ˆ10æ¬¡/5åˆ†é’Ÿ â†’ é”å®š10åˆ†é’Ÿï¼‰=====
    locked, remaining = admin_login_limiter.is_locked(extra_key='admin')
    if locked:
        minutes = remaining // 60 + 1
        app.logger.warning(f'ç®¡ç†å‘˜ç™»å½•è¢«é™æµ: IPå·²é”å®šï¼Œå‰©ä½™ {remaining}ç§’')
        return jsonify({'success': False, 'error': f'ç™»å½•å°è¯•è¿‡å¤šï¼Œè¯· {minutes} åˆ†é’Ÿåå†è¯•'}), 429
    
    data = request.get_json()
    username = data.get('username', '').strip()
    password = data.get('password', '').strip()
    
    if not username or not password:
        return jsonify({'success': False, 'error': 'è¯·è¾“å…¥ç”¨æˆ·åå’Œå¯†ç '}), 400
    
    password_hash = hash_admin_password(password)
    
    # ä¼˜å…ˆæ£€æŸ¥ AdminUser è¡¨ï¼ˆå¤šç®¡ç†å‘˜ï¼‰
    try:
        admin_user = AdminUser.query.filter_by(username=username).first()
        if admin_user:
            if not admin_user.is_active:
                app.logger.warning(f'ç®¡ç†å‘˜ {username} ç™»å½•å¤±è´¥: è´¦å·å·²è¢«ç¦ç”¨')
                admin_login_limiter.record_failure(extra_key='admin')
                return jsonify({'success': False, 'error': 'ç”¨æˆ·åæˆ–å¯†ç é”™è¯¯'}), 401
            
            if admin_user.password_hash == password_hash:
                # AdminUser è¡¨å¯†ç åŒ¹é…ï¼Œç›´æ¥ç™»å½•
                admin_login_limiter.record_success(extra_key='admin')
                # æ¸…é™¤æ—§çš„ç®¡ç†å‘˜ session å­—æ®µï¼ˆä¿ç•™ç”¨æˆ·ç™»å½•çŠ¶æ€ï¼Œå…è®¸åŒæ—¶ç™»å½•ï¼‰
                for _k in ['admin_logged_in', 'admin_username', 'admin_user_id', 'admin_is_super', 'admin_login_time']:
                    session.pop(_k, None)
                session.permanent = True
                session['admin_logged_in'] = True
                session['admin_username'] = username
                session['admin_user_id'] = admin_user.id
                session['admin_is_super'] = admin_user.is_super
                session['admin_login_time'] = datetime.now().isoformat()
                session.modified = True
                admin_user.last_login = datetime.now()
                db.session.commit()
                app.logger.info(f'ç®¡ç†å‘˜ {username} (ID:{admin_user.id}) ç™»å½•æˆåŠŸ')
                log_admin_audit('admin_login', detail=f'ç®¡ç†å‘˜ {username} ç™»å½•æˆåŠŸ')
                
                if admin_user.is_super:
                    admin_config = get_admin_config()
                    if not admin_config.get('initialized', False):
                        return jsonify({'success': True, 'redirect': '/admin/setup', 'need_setup': True})
                
                return jsonify({'success': True, 'redirect': '/admin'})
            
            # AdminUser è¡¨å¯†ç ä¸åŒ¹é…
            if admin_user.is_super:
                # è¶…çº§ç®¡ç†å‘˜ï¼šå†ç”¨ SystemConfig éªŒè¯ï¼ˆå¤„ç†å¯†ç ä¸åŒæ­¥çš„æƒ…å†µï¼‰
                admin_config = get_admin_config()
                stored_username = admin_config.get('username', '')
                stored_password_hash = admin_config.get('password', '')
                
                if username == stored_username and password_hash == stored_password_hash:
                    # SystemConfig å¯†ç åŒ¹é…ï¼ŒåŒæ­¥åˆ° AdminUser è¡¨å¹¶ç™»å½•
                    admin_login_limiter.record_success(extra_key='admin')
                    admin_user.password_hash = password_hash
                    admin_user.last_login = datetime.now()
                    db.session.commit()
                    
                    # æ¸…é™¤æ—§çš„ç®¡ç†å‘˜ session å­—æ®µï¼ˆä¿ç•™ç”¨æˆ·ç™»å½•çŠ¶æ€ï¼‰
                    for _k in ['admin_logged_in', 'admin_username', 'admin_user_id', 'admin_is_super', 'admin_login_time']:
                        session.pop(_k, None)
                    session.permanent = True
                    session['admin_logged_in'] = True
                    session['admin_username'] = username
                    session['admin_user_id'] = admin_user.id
                    session['admin_is_super'] = True
                    session['admin_login_time'] = datetime.now().isoformat()
                    session.modified = True
                    
                    app.logger.info(f'è¶…çº§ç®¡ç†å‘˜ {username} ç™»å½•æˆåŠŸï¼ˆSystemConfigè®¤è¯ï¼Œå·²åŒæ­¥å¯†ç åˆ°AdminUserè¡¨ï¼‰')
                    log_admin_audit('admin_login', detail=f'è¶…çº§ç®¡ç†å‘˜ {username} ç™»å½•æˆåŠŸï¼ˆSystemConfigè®¤è¯ï¼‰')
                    
                    if not admin_config.get('initialized', False):
                        return jsonify({'success': True, 'redirect': '/admin/setup', 'need_setup': True})
                    
                    return jsonify({'success': True, 'redirect': '/admin'})
            
            # éè¶…çº§ç®¡ç†å‘˜æˆ–æ‰€æœ‰å¯†ç éƒ½ä¸åŒ¹é…
            app.logger.warning(f'ç®¡ç†å‘˜ {username} ç™»å½•å¤±è´¥: å¯†ç é”™è¯¯ (IP: {request.remote_addr})')
            admin_login_limiter.record_failure(extra_key='admin')
            return jsonify({'success': False, 'error': 'ç”¨æˆ·åæˆ–å¯†ç é”™è¯¯'}), 401
    except Exception as e:
        app.logger.warning(f'AdminUserè¡¨æŸ¥è¯¢å¤±è´¥(å¯èƒ½è¡¨ä¸å­˜åœ¨): {e}')
    
    # å›é€€ï¼šæ£€æŸ¥ SystemConfig ä¸­çš„è¶…çº§ç®¡ç†å‘˜é…ç½®
    admin_config = get_admin_config()
    stored_username = admin_config.get('username', '')
    stored_password_hash = admin_config.get('password', '')
    
    if not stored_username:
        return jsonify({'success': False, 'error': 'ç®¡ç†å‘˜æœªé…ç½®ï¼Œè¯·è”ç³»ç³»ç»Ÿç®¡ç†å‘˜'}), 500
    
    if username == stored_username and password_hash == stored_password_hash:
        admin_login_limiter.record_success(extra_key='admin')
        # æ¸…é™¤æ—§çš„ç®¡ç†å‘˜ session å­—æ®µï¼ˆä¿ç•™ç”¨æˆ·ç™»å½•çŠ¶æ€ï¼‰
        for _k in ['admin_logged_in', 'admin_username', 'admin_user_id', 'admin_is_super', 'admin_login_time']:
            session.pop(_k, None)
        session.permanent = True
        session['admin_logged_in'] = True
        session['admin_username'] = username
        session['admin_is_super'] = True
        session['admin_login_time'] = datetime.now().isoformat()
        session.modified = True
        
        # å°è¯•åŒæ­¥åˆ° AdminUser è¡¨ï¼ˆç¡®ä¿è¶…çº§ç®¡ç†å‘˜å­˜åœ¨äºè¡¨ä¸­ï¼‰
        try:
            _sync_super_admin_to_table(username, password_hash)
        except Exception as e:
            app.logger.warning(f'åŒæ­¥è¶…çº§ç®¡ç†å‘˜åˆ°AdminUserè¡¨å¤±è´¥: {e}')
        
        app.logger.info(f'è¶…çº§ç®¡ç†å‘˜ {username} ç™»å½•æˆåŠŸï¼ˆé…ç½®æ–‡ä»¶è®¤è¯ï¼‰')
        log_admin_audit('admin_login', detail=f'è¶…çº§ç®¡ç†å‘˜ {username} ç™»å½•æˆåŠŸï¼ˆé…ç½®æ–‡ä»¶è®¤è¯ï¼‰')
        
        if not admin_config.get('initialized', False):
            return jsonify({'success': True, 'redirect': '/admin/setup', 'need_setup': True})
        
        return jsonify({'success': True, 'redirect': '/admin'})
    else:
        app.logger.warning(f'ç®¡ç†å‘˜ç™»å½•å¤±è´¥: ç”¨æˆ·åæˆ–å¯†ç é”™è¯¯ (å°è¯•ç”¨æˆ·å: {username}, IP: {request.remote_addr})')
        admin_login_limiter.record_failure(extra_key='admin')
        return jsonify({'success': False, 'error': 'ç”¨æˆ·åæˆ–å¯†ç é”™è¯¯'}), 401


def _sync_super_admin_to_table(username, password_hash):
    """å°†è¶…çº§ç®¡ç†å‘˜åŒæ­¥åˆ° AdminUser è¡¨"""
    try:
        # å…ˆæŸ¥æ‰¾æ˜¯å¦å·²æœ‰è¶…çº§ç®¡ç†å‘˜è®°å½•ï¼ˆæ— è®ºç”¨æˆ·åæ˜¯å¦å˜æ›´ï¼‰
        existing_super = AdminUser.query.filter_by(is_super=True).first()
        existing_by_name = AdminUser.query.filter_by(username=username).first()
        
        if existing_super and existing_super.username != username:
            # è¶…çº§ç®¡ç†å‘˜æ”¹äº†ç”¨æˆ·åï¼Œæ›´æ–°æ—§è®°å½•çš„ç”¨æˆ·å
            # å¦‚æœæ–°ç”¨æˆ·åå·²è¢«æ™®é€šç®¡ç†å‘˜å ç”¨ï¼Œå…ˆåˆ é™¤é‚£ä¸ªæ™®é€šç®¡ç†å‘˜è®°å½•
            if existing_by_name and existing_by_name.id != existing_super.id:
                db.session.delete(existing_by_name)
            existing_super.username = username
            existing_super.password_hash = password_hash
            existing_super.last_login = datetime.now()
            db.session.commit()
            session['admin_user_id'] = existing_super.id
        elif existing_super:
            # ç”¨æˆ·åæ²¡å˜ï¼Œæ›´æ–°å¯†ç 
            existing_super.password_hash = password_hash
            existing_super.is_super = True
            existing_super.last_login = datetime.now()
            db.session.commit()
            session['admin_user_id'] = existing_super.id
        elif existing_by_name:
            # è¡¨ä¸­æœ‰åŒåç”¨æˆ·ä½†ä¸æ˜¯è¶…çº§ç®¡ç†å‘˜ï¼ˆå¼‚å¸¸æƒ…å†µï¼‰ï¼Œå‡çº§ä¸ºè¶…çº§ç®¡ç†å‘˜
            existing_by_name.password_hash = password_hash
            existing_by_name.is_super = True
            existing_by_name.is_active = True
            existing_by_name.last_login = datetime.now()
            db.session.commit()
            session['admin_user_id'] = existing_by_name.id
        else:
            # å®Œå…¨æ–°å»º
            admin_user = AdminUser(
                username=username,
                password_hash=password_hash,
                is_super=True,
                is_active=True,
                created_by='system',
                last_login=datetime.now()
            )
            db.session.add(admin_user)
            db.session.commit()
            session['admin_user_id'] = admin_user.id
    except Exception as e:
        db.session.rollback()
        app.logger.warning(f'åŒæ­¥è¶…çº§ç®¡ç†å‘˜å¤±è´¥: {e}')


@app.route('/admin/setup')
@admin_required
def admin_setup_page():
    """é¦–æ¬¡é…ç½®é¡µé¢ - å¼ºåˆ¶ä¿®æ”¹ç®¡ç†å‘˜ä¿¡æ¯"""
    admin_config = get_admin_config()
    
    # å¦‚æœå·²ç»åˆå§‹åŒ–è¿‡ï¼Œè·³è½¬åˆ°ç®¡ç†åå°
    if admin_config.get('initialized', False):
        return redirect('/admin')
    
    site_config = get_site_config()
    return render_template('admin_setup.html', site_config=site_config)


@app.route('/api/admin/setup', methods=['POST'])
@admin_required
def admin_setup_api():
    """ä¿å­˜é¦–æ¬¡é…ç½®"""
    data = request.get_json()
    
    new_username = data.get('username', '').strip()
    new_password = data.get('password', '').strip()
    confirm_password = data.get('confirm_password', '').strip()
    new_path = data.get('secret_path', '').strip()
    
    # éªŒè¯
    if not new_username or len(new_username) < 2:
        return jsonify({'success': False, 'error': 'ç”¨æˆ·åè‡³å°‘2ä¸ªå­—ç¬¦'}), 400
    
    if not new_password or len(new_password) < 6:
        return jsonify({'success': False, 'error': 'å¯†ç è‡³å°‘6ä¸ªå­—ç¬¦'}), 400
    
    if new_password != confirm_password:
        return jsonify({'success': False, 'error': 'ä¸¤æ¬¡è¾“å…¥çš„å¯†ç ä¸ä¸€è‡´'}), 400
    
    if not new_path or len(new_path) < 5:
        return jsonify({'success': False, 'error': 'åå°è·¯å¾„è‡³å°‘5ä¸ªå­—ç¬¦'}), 400
    
    # è·¯å¾„ä¸èƒ½åŒ…å«ç‰¹æ®Šå­—ç¬¦
    import re
    if not re.match(r'^[a-zA-Z0-9_-]+$', new_path):
        return jsonify({'success': False, 'error': 'åå°è·¯å¾„åªèƒ½åŒ…å«å­—æ¯ã€æ•°å­—ã€ä¸‹åˆ’çº¿å’Œæ¨ªçº¿'}), 400
    
    # æ›´æ–°é…ç½®
    config = load_system_config()
    config['admin'] = {
        'username': new_username,
        'password': hash_admin_password(new_password),
        'secret_path': new_path,
        'initialized': True
    }
    
    if save_system_config(config):
        # åŒæ­¥è¶…çº§ç®¡ç†å‘˜åˆ° AdminUser è¡¨
        try:
            _sync_super_admin_to_table(new_username, hash_admin_password(new_password))
        except Exception as e:
            app.logger.warning(f'Setup: åŒæ­¥è¶…çº§ç®¡ç†å‘˜åˆ°AdminUserè¡¨å¤±è´¥: {e}')
        
        # æ¸…é™¤ç™»å½•çŠ¶æ€ï¼Œå¼ºåˆ¶é‡æ–°ç™»å½•
        session.clear()
        app.logger.info(f'ç®¡ç†å‘˜é…ç½®å·²æ›´æ–°: username={new_username}, path={new_path}')
        return jsonify({
            'success': True, 
            'message': 'é…ç½®å·²ä¿å­˜ï¼Œè¯·ä½¿ç”¨æ–°çš„å…¥å£å’Œè´¦å·é‡æ–°ç™»å½•',
            'new_path': f'/{new_path}'
        })
    else:
        return jsonify({'success': False, 'error': 'ä¿å­˜é…ç½®å¤±è´¥'}), 500


@app.route('/api/admin/change-credentials', methods=['POST'])
@admin_required
def admin_change_credentials():
    """ä¿®æ”¹ç®¡ç†å‘˜è´¦å·å¯†ç ï¼ˆå·²åˆå§‹åŒ–åä½¿ç”¨ï¼‰"""
    data = request.get_json()
    
    current_password = data.get('current_password', '').strip()
    new_username = data.get('new_username', '').strip()
    new_password = data.get('new_password', '').strip()
    new_path = data.get('new_path', '').strip()
    
    # éªŒè¯å½“å‰å¯†ç 
    admin_config = get_admin_config()
    if hash_admin_password(current_password) != admin_config.get('password', ''):
        return jsonify({'success': False, 'error': 'å½“å‰å¯†ç é”™è¯¯'}), 400
    
    # æ›´æ–°é…ç½®
    config = load_system_config()
    
    if new_username and len(new_username) >= 2:
        config['admin']['username'] = new_username
    
    if new_password and len(new_password) >= 6:
        config['admin']['password'] = hash_admin_password(new_password)
    
    if new_path and len(new_path) >= 5:
        import re
        if re.match(r'^[a-zA-Z0-9_-]+$', new_path):
            config['admin']['secret_path'] = new_path
    
    if save_system_config(config):
        # åŒæ­¥è¶…çº§ç®¡ç†å‘˜åˆ° AdminUser è¡¨
        try:
            final_username = config['admin']['username']
            final_password_hash = config['admin']['password']
            _sync_super_admin_to_table(final_username, final_password_hash)
        except Exception as e:
            app.logger.warning(f'ä¿®æ”¹å‡­æ®: åŒæ­¥è¶…çº§ç®¡ç†å‘˜åˆ°AdminUserè¡¨å¤±è´¥: {e}')
        
        # æ¸…é™¤ç™»å½•çŠ¶æ€
        session.clear()
        return jsonify({
            'success': True,
            'message': 'é…ç½®å·²æ›´æ–°ï¼Œè¯·é‡æ–°ç™»å½•',
            'new_path': f"/{config['admin']['secret_path']}"
        })
    else:
        return jsonify({'success': False, 'error': 'ä¿å­˜å¤±è´¥'}), 500


@app.route('/api/admin-logout', methods=['POST'])
def admin_logout_api():
    """ç®¡ç†å‘˜ç™»å‡ºAPI"""
    username = session.get('admin_username', 'unknown')
    session.pop('admin_logged_in', None)
    session.pop('admin_username', None)
    session.pop('admin_login_time', None)
    session.pop('admin_user_id', None)
    session.pop('admin_is_super', None)
    app.logger.info(f'ç®¡ç†å‘˜ {username} å·²ç™»å‡º')
    return jsonify({'success': True, 'message': 'å·²é€€å‡ºç™»å½•'})


# ==================== å¤šç®¡ç†å‘˜ç®¡ç† API ====================

@app.route('/api/admin/admins', methods=['GET'])
@admin_required
def get_admin_list():
    """è·å–ç®¡ç†å‘˜åˆ—è¡¨ - ä»…è¶…çº§ç®¡ç†å‘˜"""
    current_admin = get_current_admin()
    if not current_admin or not current_admin.is_super:
        return jsonify({'error': 'ä»…è¶…çº§ç®¡ç†å‘˜å¯ç®¡ç†ç®¡ç†å‘˜'}), 403
    
    try:
        admins = AdminUser.query.order_by(AdminUser.is_super.desc(), AdminUser.created_at.asc()).all()
        return jsonify({
            'success': True,
            'admins': [a.to_dict(include_password=True) for a in admins],
            'permission_groups': ADMIN_PERMISSION_GROUPS
        })
    except Exception as e:
        app.logger.error(f'è·å–ç®¡ç†å‘˜åˆ—è¡¨å¤±è´¥: {e}')
        return jsonify({'error': 'è·å–ç®¡ç†å‘˜åˆ—è¡¨å¤±è´¥'}), 500


@app.route('/api/admin/admins', methods=['POST'])
@admin_required
def create_admin():
    """åˆ›å»ºç®¡ç†å‘˜ - ä»…è¶…çº§ç®¡ç†å‘˜"""
    current_admin = get_current_admin()
    if not current_admin or not current_admin.is_super:
        return jsonify({'error': 'ä»…è¶…çº§ç®¡ç†å‘˜å¯åˆ›å»ºç®¡ç†å‘˜'}), 403
    
    data = request.get_json()
    username = data.get('username', '').strip()
    password = data.get('password', '').strip()
    permissions = data.get('permissions', [])
    
    if not username or len(username) < 2:
        return jsonify({'error': 'ç”¨æˆ·åè‡³å°‘2ä¸ªå­—ç¬¦'}), 400
    if not password or len(password) < 6:
        return jsonify({'error': 'å¯†ç è‡³å°‘6ä¸ªå­—ç¬¦'}), 400
    
    # æ£€æŸ¥ç”¨æˆ·åæ˜¯å¦å·²å­˜åœ¨
    existing = AdminUser.query.filter_by(username=username).first()
    if existing:
        return jsonify({'error': 'ç”¨æˆ·åå·²å­˜åœ¨'}), 400
    
    # ä¹Ÿæ£€æŸ¥ç³»ç»Ÿé…ç½®ä¸­çš„è¶…çº§ç®¡ç†å‘˜ç”¨æˆ·å
    admin_config = get_admin_config()
    if username == admin_config.get('username', ''):
        existing_super = AdminUser.query.filter_by(username=username).first()
        if existing_super:
            return jsonify({'error': 'ç”¨æˆ·åå·²å­˜åœ¨'}), 400
    
    # éªŒè¯æƒé™
    valid_perms = [p for p in permissions if p in ADMIN_PERMISSION_GROUPS]
    
    try:
        admin_user = AdminUser(
            username=username,
            password_hash=hash_admin_password(password),
            password_plain=password,  # å­˜å‚¨æ˜æ–‡å¯†ç ä¾›è¶…çº§ç®¡ç†å‘˜æŸ¥çœ‹
            is_super=False,
            is_active=True,
            created_by=current_admin.username
        )
        admin_user.set_permissions(valid_perms)
        db.session.add(admin_user)
        db.session.commit()
        
        app.logger.info(f'è¶…çº§ç®¡ç†å‘˜ {current_admin.username} åˆ›å»ºäº†æ–°ç®¡ç†å‘˜ {username}ï¼Œæƒé™: {valid_perms}')
        log_admin_audit('admin_create', detail=f'åˆ›å»ºç®¡ç†å‘˜ {username}ï¼Œæƒé™: {valid_perms}', target_type='admin', target_id=str(admin_user.id))
        return jsonify({'success': True, 'admin': admin_user.to_dict()})
    except Exception as e:
        db.session.rollback()
        app.logger.error(f'åˆ›å»ºç®¡ç†å‘˜å¤±è´¥: {e}')
        return jsonify({'error': 'åˆ›å»ºç®¡ç†å‘˜å¤±è´¥'}), 500


@app.route('/api/admin/admins/<int:admin_id>', methods=['PUT'])
@admin_required
def update_admin(admin_id):
    """æ›´æ–°ç®¡ç†å‘˜ä¿¡æ¯ - ä»…è¶…çº§ç®¡ç†å‘˜"""
    current_admin = get_current_admin()
    if not current_admin or not current_admin.is_super:
        return jsonify({'error': 'ä»…è¶…çº§ç®¡ç†å‘˜å¯ä¿®æ”¹ç®¡ç†å‘˜'}), 403
    
    admin_user = db.session.get(AdminUser, admin_id)
    if not admin_user:
        return jsonify({'error': 'ç®¡ç†å‘˜ä¸å­˜åœ¨'}), 404
    
    # ä¸èƒ½ä¿®æ”¹è‡ªå·±çš„è¶…çº§ç®¡ç†å‘˜çŠ¶æ€
    if admin_user.is_super and admin_user.username == current_admin.username:
        data = request.get_json()
        # è¶…çº§ç®¡ç†å‘˜åªèƒ½æ”¹å¯†ç 
        new_password = data.get('password', '').strip()
        if new_password and len(new_password) >= 6:
            admin_user.password_hash = hash_admin_password(new_password)
            # åŒæ­¥æ›´æ–°ç³»ç»Ÿé…ç½®
            config = load_system_config()
            config['admin']['password'] = hash_admin_password(new_password)
            save_system_config(config)
            db.session.commit()
            return jsonify({'success': True, 'admin': admin_user.to_dict(), 'message': 'å¯†ç å·²æ›´æ–°'})
        return jsonify({'error': 'è¶…çº§ç®¡ç†å‘˜åªèƒ½åœ¨æ­¤å¤„ä¿®æ”¹å¯†ç '}), 400
    
    data = request.get_json()
    
    # æ›´æ–°ç”¨æˆ·å
    new_username = data.get('username', '').strip()
    if new_username and new_username != admin_user.username:
        if len(new_username) < 2:
            return jsonify({'error': 'ç”¨æˆ·åè‡³å°‘2ä¸ªå­—ç¬¦'}), 400
        existing = AdminUser.query.filter_by(username=new_username).first()
        if existing:
            return jsonify({'error': 'ç”¨æˆ·åå·²å­˜åœ¨'}), 400
        admin_user.username = new_username
    
    # æ›´æ–°å¯†ç 
    new_password = data.get('password', '').strip()
    if new_password:
        if len(new_password) < 6:
            return jsonify({'error': 'å¯†ç è‡³å°‘6ä¸ªå­—ç¬¦'}), 400
        admin_user.password_hash = hash_admin_password(new_password)
        if not admin_user.is_super:
            admin_user.password_plain = new_password  # åŒæ­¥æ›´æ–°æ˜æ–‡å¯†ç 
    
    # æ›´æ–°æƒé™
    permissions = data.get('permissions')
    if permissions is not None and not admin_user.is_super:
        valid_perms = [p for p in permissions if p in ADMIN_PERMISSION_GROUPS]
        admin_user.set_permissions(valid_perms)
    
    # æ›´æ–°å¯ç”¨çŠ¶æ€
    is_active = data.get('is_active')
    if is_active is not None and not admin_user.is_super:
        admin_user.is_active = bool(is_active)
    
    try:
        db.session.commit()
        app.logger.info(f'è¶…çº§ç®¡ç†å‘˜ {current_admin.username} æ›´æ–°äº†ç®¡ç†å‘˜ {admin_user.username}')
        log_admin_audit('admin_update', detail=f'æ›´æ–°ç®¡ç†å‘˜ {admin_user.username}', target_type='admin', target_id=str(admin_id))
        return jsonify({'success': True, 'admin': admin_user.to_dict()})
    except Exception as e:
        db.session.rollback()
        app.logger.error(f'æ›´æ–°ç®¡ç†å‘˜å¤±è´¥: {e}')
        return jsonify({'error': 'æ›´æ–°ç®¡ç†å‘˜å¤±è´¥'}), 500


@app.route('/api/admin/admins/<int:admin_id>', methods=['DELETE'])
@admin_required
def delete_admin(admin_id):
    """åˆ é™¤ç®¡ç†å‘˜ - ä»…è¶…çº§ç®¡ç†å‘˜"""
    current_admin = get_current_admin()
    if not current_admin or not current_admin.is_super:
        return jsonify({'error': 'ä»…è¶…çº§ç®¡ç†å‘˜å¯åˆ é™¤ç®¡ç†å‘˜'}), 403
    
    admin_user = db.session.get(AdminUser, admin_id)
    if not admin_user:
        return jsonify({'error': 'ç®¡ç†å‘˜ä¸å­˜åœ¨'}), 404
    
    if admin_user.is_super:
        return jsonify({'error': 'ä¸èƒ½åˆ é™¤è¶…çº§ç®¡ç†å‘˜'}), 400
    
    try:
        username = admin_user.username
        db.session.delete(admin_user)
        db.session.commit()
        app.logger.info(f'è¶…çº§ç®¡ç†å‘˜ {current_admin.username} åˆ é™¤äº†ç®¡ç†å‘˜ {username}')
        log_admin_audit('admin_delete', detail=f'åˆ é™¤ç®¡ç†å‘˜ {username}', target_type='admin', target_id=str(admin_id))
        return jsonify({'success': True, 'message': f'ç®¡ç†å‘˜ {username} å·²åˆ é™¤'})
    except Exception as e:
        db.session.rollback()
        app.logger.error(f'åˆ é™¤ç®¡ç†å‘˜å¤±è´¥: {e}')
        return jsonify({'error': 'åˆ é™¤ç®¡ç†å‘˜å¤±è´¥'}), 500


@app.route('/api/admin/admins/<int:admin_id>/toggle', methods=['POST'])
@admin_required
def toggle_admin_status(admin_id):
    """å¯ç”¨/ç¦ç”¨ç®¡ç†å‘˜ - ä»…è¶…çº§ç®¡ç†å‘˜"""
    current_admin = get_current_admin()
    if not current_admin or not current_admin.is_super:
        return jsonify({'error': 'ä»…è¶…çº§ç®¡ç†å‘˜å¯æ“ä½œ'}), 403
    
    admin_user = db.session.get(AdminUser, admin_id)
    if not admin_user:
        return jsonify({'error': 'ç®¡ç†å‘˜ä¸å­˜åœ¨'}), 404
    
    if admin_user.is_super:
        return jsonify({'error': 'ä¸èƒ½ç¦ç”¨è¶…çº§ç®¡ç†å‘˜'}), 400
    
    admin_user.is_active = not admin_user.is_active
    try:
        db.session.commit()
        status = 'å¯ç”¨' if admin_user.is_active else 'ç¦ç”¨'
        app.logger.info(f'è¶…çº§ç®¡ç†å‘˜ {current_admin.username} {status}äº†ç®¡ç†å‘˜ {admin_user.username}')
        return jsonify({'success': True, 'admin': admin_user.to_dict(), 'message': f'ç®¡ç†å‘˜å·²{status}'})
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': 'æ“ä½œå¤±è´¥'}), 500


@app.route('/api/admin/change-my-password', methods=['POST'])
@admin_required
def admin_change_my_password():
    """ç®¡ç†å‘˜ä¿®æ”¹è‡ªå·±çš„å¯†ç """
    current_admin = get_current_admin()
    if not current_admin:
        return jsonify({'error': 'æœªç™»å½•'}), 401
    
    data = request.get_json()
    old_password = data.get('old_password', '').strip()
    new_password = data.get('new_password', '').strip()
    
    if not old_password:
        return jsonify({'error': 'è¯·è¾“å…¥æ—§å¯†ç '}), 400
    if not new_password or len(new_password) < 6:
        return jsonify({'error': 'æ–°å¯†ç è‡³å°‘6ä¸ªå­—ç¬¦'}), 400
    if old_password == new_password:
        return jsonify({'error': 'æ–°å¯†ç ä¸èƒ½ä¸æ—§å¯†ç ç›¸åŒ'}), 400
    
    # è·å–çœŸå®çš„ AdminUser å¯¹è±¡ï¼ˆget_current_admin å¯èƒ½è¿”å›è™šæ‹Ÿå¯¹è±¡ï¼‰
    admin_id = session.get('admin_user_id')
    if admin_id:
        admin_user = db.session.get(AdminUser, admin_id)
    else:
        # æ—§ session å…¼å®¹ï¼šé€šè¿‡ç”¨æˆ·åæŸ¥æ‰¾
        admin_user = AdminUser.query.filter_by(username=session.get('admin_username')).first()
    
    if not admin_user:
        return jsonify({'error': 'ç®¡ç†å‘˜è´¦å·ä¸å­˜åœ¨'}), 404
    
    # éªŒè¯æ—§å¯†ç 
    if admin_user.password_hash != hash_admin_password(old_password):
        # è¶…çº§ç®¡ç†å‘˜é¢å¤–æ£€æŸ¥ SystemConfig ä¸­çš„å¯†ç 
        if admin_user.is_super:
            admin_config = get_admin_config()
            if admin_config.get('password', '') != hash_admin_password(old_password):
                return jsonify({'error': 'æ—§å¯†ç é”™è¯¯'}), 400
        else:
            return jsonify({'error': 'æ—§å¯†ç é”™è¯¯'}), 400
    
    try:
        new_hash = hash_admin_password(new_password)
        admin_user.password_hash = new_hash
        
        # å­ç®¡ç†å‘˜åŒæ­¥æ›´æ–°æ˜æ–‡å¯†ç 
        if not admin_user.is_super:
            admin_user.password_plain = new_password
        
        # è¶…çº§ç®¡ç†å‘˜åŒæ­¥æ›´æ–° SystemConfig
        if admin_user.is_super:
            config = load_system_config()
            config['admin']['password'] = new_hash
            save_system_config(config)
        
        db.session.commit()
        
        app.logger.info(f'ç®¡ç†å‘˜ {admin_user.username} ä¿®æ”¹äº†è‡ªå·±çš„å¯†ç ')
        log_admin_audit('admin_change_password', detail=f'ç®¡ç†å‘˜ {admin_user.username} ä¿®æ”¹äº†å¯†ç ')
        
        # æ¸…é™¤å½“å‰ç®¡ç†å‘˜ sessionï¼Œå¼ºåˆ¶é‡æ–°ç™»å½•
        for _k in ['admin_logged_in', 'admin_username', 'admin_user_id', 'admin_is_super', 'admin_login_time']:
            session.pop(_k, None)
        
        return jsonify({'success': True, 'message': 'å¯†ç ä¿®æ”¹æˆåŠŸï¼Œè¯·é‡æ–°ç™»å½•', 'require_relogin': True})
    except Exception as e:
        db.session.rollback()
        app.logger.error(f'ç®¡ç†å‘˜ä¿®æ”¹å¯†ç å¤±è´¥: {e}')
        return jsonify({'error': 'ä¿®æ”¹å¯†ç å¤±è´¥'}), 500


@app.route('/api/admin/current-permissions', methods=['GET'])
@admin_required
def get_current_admin_permissions():
    """è·å–å½“å‰ç®¡ç†å‘˜çš„æƒé™ä¿¡æ¯"""
    current_admin = get_current_admin()
    if current_admin:
        return jsonify({
            'success': True,
            'username': current_admin.username,
            'is_super': current_admin.is_super,
            'permissions': current_admin.get_permissions(),
            'permission_groups': ADMIN_PERMISSION_GROUPS
        })
    return jsonify({
        'success': True,
        'username': session.get('admin_username', 'ç®¡ç†å‘˜'),
        'is_super': True,
        'permissions': list(ADMIN_PERMISSION_GROUPS.keys()),
        'permission_groups': ADMIN_PERMISSION_GROUPS
    })


@app.route('/admin')
@admin_required
def admin_panel():
    # è¿è¡Œæ—¶æˆæƒéªŒè¯
    if not is_license_valid():
        _v, _r = check_license()
        if not _v:
            return 'ç³»ç»Ÿæˆæƒå·²å¤±æ•ˆï¼Œè¯·è”ç³»å¼€å‘è€…', 503
    # ä¼˜åŒ–ï¼šä½¿ç”¨å•ä¸ªæŸ¥è¯¢è·å–ç»Ÿè®¡ä¿¡æ¯
    from sqlalchemy import func, case
    from sqlalchemy.orm import load_only
    
    stats_query = db.session.query(
        func.count(MovieRequest.id).label('total'),
        func.sum(case((MovieRequest.status == 'pending', 1), else_=0)).label('pending'),
        func.sum(case((MovieRequest.status == 'processing', 1), else_=0)).label('processing'),
        func.sum(case((MovieRequest.status == 'approved', 1), else_=0)).label('approved'),
        func.sum(case((MovieRequest.status == 'completed', 1), else_=0)).label('completed'),
        func.sum(case((MovieRequest.status == 'rejected', 1), else_=0)).label('rejected'),
        func.sum(case((MovieRequest.status == 'downloading', 1), else_=0)).label('downloading'),
        func.sum(case((MovieRequest.status == 'downloaded', 1), else_=0)).label('downloaded'),
        func.sum(case((MovieRequest.status == 'failed', 1), else_=0)).label('failed')
    ).first()
    
    # è®¡ç®—åˆå¹¶åçš„"å·²æ‰¹å‡†"æ•°é‡ï¼ˆåŒ…å« approved å’Œ processingï¼‰
    approved_total = (stats_query.approved or 0) + (stats_query.processing or 0)
    
    stats = {
        'total': stats_query.total or 0,
        'pending': stats_query.pending or 0,
        'processing': stats_query.processing or 0,
        'approved': approved_total,  # åˆå¹¶ approved å’Œ processing
        'completed': stats_query.completed or 0,
        'rejected': stats_query.rejected or 0,
        'downloading': stats_query.downloading or 0,
        'downloaded': stats_query.downloaded or 0,
        'failed': stats_query.failed or 0,
    }
    
    # åˆ†é¡µå‚æ•°
    page = request.args.get('page', 1, type=int)
    per_page = 5  # æ¯é¡µæ˜¾ç¤º5æ¡
    status_filter = request.args.get('status', 'all')  # çŠ¶æ€è¿‡æ»¤
    
    # æ„å»ºæŸ¥è¯¢
    query = MovieRequest.query.options(
        joinedload(MovieRequest.user),
        joinedload(MovieRequest.download_task)
    ).order_by(MovieRequest.created_at.desc())
    
    # æŒ‰çŠ¶æ€è¿‡æ»¤
    if status_filter and status_filter != 'all':
        # 'approved' å’Œ 'processing' éƒ½å±äº"å·²æ‰¹å‡†"èŒƒç•´ï¼Œåˆå¹¶ç­›é€‰
        if status_filter == 'approved':
            query = query.filter(MovieRequest.status.in_(['approved', 'processing']))
        else:
            query = query.filter(MovieRequest.status == status_filter)
    
    # è·å–åˆ†é¡µæ•°æ®
    pagination = query.paginate(page=page, per_page=per_page, error_out=False)
    
    # è·å–å¥—é¤é…ç½®ç”¨äºå…‘æ¢ç ç®¡ç†ï¼ˆä½¿ç”¨ç»Ÿä¸€çš„åŠ è½½å‡½æ•°ï¼Œä¼˜å…ˆä»æ•°æ®åº“è¯»å–ï¼‰
    plans_data = load_plans_config()
    
    # æ£€æŸ¥æ˜¯å¦é…ç½®äº† MoviePilotï¼ˆç”¨äºå‰ç«¯åˆ¤æ–­æ˜¯å¦æ˜¾ç¤º PT æœç´¢æŒ‰é’®ï¼‰
    mp_enabled = pt_manager.is_enabled()
    
    # æ ¹æ®é…ç½®å†³å®šæ˜¯å¦ä½¿ç”¨å›¾ç‰‡ä»£ç†
    site_config = get_site_config()
    if site_config.get('use_image_proxy', True):
        tmdb_image_base = '/api/tmdb-image/w500'
    else:
        tmdb_image_base = 'https://image.tmdb.org/t/p/w500'
    
    # è·å–å½“å‰ç®¡ç†å‘˜æƒé™ä¿¡æ¯
    current_admin = get_current_admin()
    admin_info = {
        'username': current_admin.username if current_admin else session.get('admin_username', 'ç®¡ç†å‘˜'),
        'is_super': current_admin.is_super if current_admin else True,
        'permissions': current_admin.get_permissions() if current_admin else list(ADMIN_PERMISSION_GROUPS.keys()),
    }
    
    return render_template('admin.html', 
                         requests=pagination.items,
                         pagination=pagination,
                         stats=stats,
                         current_status=status_filter,
                         tmdb_image_base=tmdb_image_base,
                         plans=plans_data,
                         mp_enabled=mp_enabled,
                         site_config=site_config,
                         admin_info=admin_info,
                         permission_groups=ADMIN_PERMISSION_GROUPS)


@app.route('/admin/update-request/<int:request_id>', methods=['POST'])
@admin_required
def update_request_status(request_id):
    movie_request = MovieRequest.query.get_or_404(request_id)
    data = request.get_json()
    
    status = data.get('status')
    admin_note = data.get('admin_note', '')
    auto_download = data.get('auto_download', True)  # æ‰¹å‡†æ—¶æ˜¯å¦è‡ªåŠ¨ä¸‹è½½ï¼Œé»˜è®¤å¼€å¯
    
    if status not in ['pending', 'approved', 'processing', 'rejected', 'completed', 'downloading', 'downloaded', 'failed']:
        return jsonify({'success': False, 'error': 'æ— æ•ˆçš„çŠ¶æ€'}), 400
    
    old_status = movie_request.status
    movie_request.status = status
    movie_request.admin_note = admin_note
    
    # ========== "processing" çŠ¶æ€ï¼šæ‰‹åŠ¨å¤„ç†æµç¨‹ï¼Œä¸è‡ªåŠ¨ä¸‹è½½ ==========
    if status == 'processing':
        db.session.commit()
        
        # é€šçŸ¥ç”¨æˆ·æ±‚ç‰‡å·²è¢«æ‰¹å‡†ï¼Œæ­£åœ¨å¤„ç†
        user = movie_request.user
        if user and user.tg:
            send_user_telegram_notification(
                user.tg,
                movie_request.title,
                'approved',
                admin_note or 'æ‚¨çš„æ±‚ç‰‡å·²è¢«æ‰¹å‡†ï¼Œæ­£åœ¨å¤„ç†ä¸­ï¼Œè¯·è€å¿ƒç­‰å¾…',
                movie_request.media_type,
                movie_request.tmdb_id,
                movie_request.poster_path
            )
        
        return jsonify({'success': True, 'message': 'å·²æ‰¹å‡†ï¼ŒçŠ¶æ€è®¾ä¸ºæ­£åœ¨å¤„ç†'}), 200
    
    # ========== æ‰¹å‡†æ—¶è‡ªåŠ¨æœç´¢å¹¶ä¸‹è½½æœ€å¤§çš„ç§å­ ==========
    download_started = False
    download_error = None
    
    if status == 'approved' and auto_download and pt_manager.is_enabled() and qbit_client.is_enabled():
        # å…ˆæ£€æŸ¥ Emby åº“ä¸­æ˜¯å¦å·²å­˜åœ¨
        if emby_client.is_enabled():
            emby_check = emby_client.check_exists(
                movie_request.tmdb_id, 
                movie_request.title, 
                movie_request.year, 
                movie_request.media_type
            )
            if emby_check['exists']:
                # å·²åœ¨åº“ä¸­ï¼Œç›´æ¥æ ‡è®°ä¸ºå®Œæˆ
                movie_request.status = 'completed'
                movie_request.admin_note = (admin_note + ' ' if admin_note else '') + '[å·²åœ¨ Emby åº“ä¸­]'
                db.session.commit()
                app.logger.info(f'æ±‚ç‰‡ {movie_request.title} å·²åœ¨ Emby åº“ä¸­ï¼Œç›´æ¥æ ‡è®°å®Œæˆ')
                
                # é€šçŸ¥ç”¨æˆ·
                user = movie_request.user
                if user and user.tg:
                    send_user_telegram_notification(
                        user.tg,
                        movie_request.title,
                        'completed',
                        'è¯¥å½±ç‰‡å·²åœ¨åª’ä½“åº“ä¸­ï¼Œå¯ç›´æ¥è§‚çœ‹ï¼',
                        movie_request.media_type,
                        movie_request.tmdb_id,
                        movie_request.poster_path
                    )
                
                return jsonify({
                    'success': True, 
                    'message': 'å½±ç‰‡å·²åœ¨åº“ä¸­ï¼Œå·²è‡ªåŠ¨æ ‡è®°ä¸ºå®Œæˆ',
                    'in_library': True
                }), 200
        
        # ä½¿ç”¨ PT ç®¡ç†å™¨æœç´¢æ‰€æœ‰ç«™ç‚¹
        try:
            keyword = f"{movie_request.title} {movie_request.year or ''}".strip()
            results = pt_manager.search(keyword, movie_request.media_type)
            
            if results:
                # æŒ‰æ–‡ä»¶å¤§å°é™åºæ’åºï¼Œé€‰æ‹©æœ€å¤§çš„ç§å­
                def parse_size(size_val):
                    """è§£ææ–‡ä»¶å¤§å°ä¸ºå­—èŠ‚æ•°"""
                    if not size_val:
                        return 0
                    if isinstance(size_val, (int, float)):
                        return size_val
                    size_str = str(size_val).upper().strip()
                    multipliers = {'B': 1, 'KB': 1024, 'MB': 1024**2, 'GB': 1024**3, 'TB': 1024**4}
                    for unit, mult in multipliers.items():
                        if unit in size_str:
                            try:
                                num = float(size_str.replace(unit, '').strip())
                                return num * mult
                            except ValueError:
                                return 0
                    return 0
                
                sorted_results = sorted(results, key=lambda x: parse_size(x.get('size', 0)), reverse=True)
                largest = sorted_results[0]
                
                # è·å–ä¸‹è½½é“¾æ¥ï¼ˆä¼˜å…ˆä½¿ç”¨ç»“æœä¸­çš„ download_urlï¼‰
                torrent_id = largest.get('id')
                source = largest.get('source', 'MoviePilot')
                download_url = largest.get('download_url')
                
                # å¦‚æœæ²¡æœ‰ç›´æ¥çš„ä¸‹è½½é“¾æ¥ï¼Œé€šè¿‡å®¢æˆ·ç«¯æ„å»º
                if not download_url:
                    client = pt_manager.get_client()
                    if client:
                        download_url = client.build_download_url(torrent_id)
                
                if download_url:
                    qb_tag = f"request-{movie_request.id}"
                    qbit_client.add_torrent(
                        download_url,
                        category=QBITTORRENT_CATEGORY or None,
                        save_path=QBITTORRENT_SAVE_PATH or None,
                        tags=[qb_tag]
                    )
                    
                    # ç­‰å¾…è·å–ç§å­ä¿¡æ¯
                    import time
                    time.sleep(1)
                    torrent_info = qbit_client.get_torrent_by_tag(qb_tag)
                    
                    # åˆ›å»ºä¸‹è½½ä»»åŠ¡
                    task = DownloadTask(
                        request_id=movie_request.id,
                        torrent_name=largest.get('name', movie_request.title),
                        torrent_hash=torrent_info.get('hash') if torrent_info else None,
                        status='queued',
                        progress=0,
                        qb_tag=qb_tag,
                        download_url=download_url,
                    )
                    db.session.add(task)
                    
                    movie_request.status = 'downloading'
                    download_started = True
                    app.logger.info(f'è‡ªåŠ¨ä¸‹è½½: {movie_request.title} -> {largest.get("name")} ({largest.get("size")})')
            else:
                download_error = 'PT æœç´¢æ— ç»“æœ'
                app.logger.warning(f'è‡ªåŠ¨ä¸‹è½½å¤±è´¥: {movie_request.title} - æœç´¢æ— ç»“æœ')
                
        except Exception as e:
            download_error = str(e)
            app.logger.error(f'è‡ªåŠ¨ä¸‹è½½å¼‚å¸¸: {movie_request.title} - {e}')
    
    db.session.commit()
    
    # å¦‚æœå¼€å§‹äº†ä¸‹è½½ï¼Œå¯åŠ¨è¯¥ä»»åŠ¡çš„ç‹¬ç«‹ç›‘æ§
    if download_started and movie_request.download_task:
        start_task_monitor(movie_request.download_task.id, DOWNLOAD_POLL_INTERVAL)
    
    app.logger.info(f'ç®¡ç†å‘˜ {session.get("username")} æ›´æ–°æ±‚ç‰‡çŠ¶æ€: ID={request_id}, {old_status} -> {movie_request.status}, å½±ç‰‡={movie_request.title}')
    
    # åªåœ¨æ‹’ç»å’Œå®Œæˆæ—¶å‘é€é€šçŸ¥ç»™ç”¨æˆ·
    if movie_request.status in ['rejected', 'completed'] and old_status != movie_request.status:
        user = movie_request.user
        if user and user.tg:
            # ç§èŠé€šçŸ¥ç”¨æˆ·
            send_user_telegram_notification(
                user.tg,
                movie_request.title,
                movie_request.status,
                admin_note if movie_request.status == 'rejected' else 'æ‚¨çš„æ±‚ç‰‡å·²å…¥åº“ï¼Œå¿«å»è§‚çœ‹å§ï¼ğŸ¬',
                movie_request.media_type,
                movie_request.tmdb_id,
                movie_request.poster_path
            )
            
            # å¦‚æœæ˜¯æ‰‹åŠ¨æ ‡è®°å…¥åº“ï¼Œä¹Ÿå‘é€ç¾¤ç»„é€šçŸ¥
            if movie_request.status == 'completed':
                send_group_completion_notification(
                    user_tg_id=user.telegram_id or user.tg,
                    username=user.name or user.username,
                    title=movie_request.title,
                    year=movie_request.year,
                    media_type=movie_request.media_type,
                    tmdb_id=movie_request.tmdb_id,
                    poster_path=movie_request.poster_path
                )
    
    response_data = {'success': True, 'message': 'çŠ¶æ€å·²æ›´æ–°'}
    if download_started:
        response_data['auto_download'] = True
        response_data['message'] = 'å·²æ‰¹å‡†å¹¶è‡ªåŠ¨å¼€å§‹ä¸‹è½½'
    elif download_error:
        response_data['auto_download_error'] = download_error
    
    return jsonify(response_data), 200


@app.route('/api/pt/status')
@admin_required
def pt_status():
    """æŸ¥çœ‹å·²æ³¨å†Œçš„ PT ç«™ç‚¹çŠ¶æ€ï¼ˆè°ƒè¯•ç”¨ï¼‰"""
    clients = pt_manager.get_enabled_clients()
    sites_info = []
    for c in clients:
        info = {
            'name': c.name,
            'type': c.__class__.__name__,
            'priority': c.priority,
            'enabled': c.is_enabled()
        }
        # å¦‚æœæ˜¯ RSS å®¢æˆ·ç«¯ï¼Œæ˜¾ç¤º RSS URL çš„å‰50å­—ç¬¦
        if hasattr(c, 'rss_url'):
            info['rss_url_preview'] = c.rss_url[:80] + '...' if len(c.rss_url) > 80 else c.rss_url
        sites_info.append(info)
    
    return jsonify({
        'success': True,
        'total_registered': len(pt_manager.clients),
        'total_enabled': len(clients),
        'sites': sites_info
    })


@app.route('/api/pt/search')
@admin_required
def pt_search():
    if not pt_manager.is_enabled():
        return jsonify({'success': False, 'error': 'æ‚¨æœªé…ç½® MoviePilotï¼Œè¯·åœ¨ç³»ç»Ÿè®¾ç½®ä¸­é…ç½®'}), 400

    request_id = request.args.get('request_id', type=int)
    keyword = (request.args.get('keyword') or '').strip()
    media_type = 'movie'

    if request_id:
        movie_request = MovieRequest.query.get_or_404(request_id)
        media_type = movie_request.media_type
        if not keyword:
            keyword = f"{movie_request.title} {movie_request.year or ''}".strip()

    if not keyword:
        return jsonify({'success': False, 'error': 'ç¼ºå°‘æœç´¢å…³é”®å­—'}), 400

    try:
        # ä½¿ç”¨ PT ç®¡ç†å™¨æœç´¢
        results = pt_manager.search(keyword, media_type)
        
        # è¿”å›å¯ç”¨ç«™ç‚¹åˆ—è¡¨ï¼ˆä¾¿äºå‰ç«¯å±•ç¤ºï¼‰
        enabled_sites = [c.name for c in pt_manager.get_enabled_clients()]
        
        return jsonify({
            'success': True, 
            'results': results, 
            'keyword': keyword,
            'sites': enabled_sites,
            'total_sites': len(enabled_sites)
        })
    except Exception as exc:  # noqa: BLE001
        error_msg = str(exc) if exc else 'æœªçŸ¥é”™è¯¯'
        app.logger.error(f'PTæœç´¢å¤±è´¥: {error_msg}', exc_info=True)
        return jsonify({'success': False, 'error': 'æœç´¢å¤±è´¥ï¼Œè¯·ç¨åå†è¯•'}), 500


@app.route('/api/pt/push', methods=['POST'])
@admin_required
def pt_push_to_qb():
    if not pt_manager.is_enabled():
        return jsonify({'success': False, 'error': 'PT ç«™æœªé…ç½®'}), 400
    if not qbit_client.is_enabled():
        return jsonify({'success': False, 'error': 'qBittorrent æœªé…ç½®'}), 400

    data = request.get_json() or {}
    request_id = data.get('request_id')
    if not request_id:
        return jsonify({'success': False, 'error': 'ç¼ºå°‘ request_id'}), 400

    movie_request = MovieRequest.query.get_or_404(request_id)

    if movie_request.download_task and movie_request.download_task.status in {'queued', 'downloading'}:
        return jsonify({'success': False, 'error': 'è¯¥è¯·æ±‚å·²å­˜åœ¨ä¸‹è½½ä»»åŠ¡'}), 400

    download_url = data.get('download_url')
    torrent_id = data.get('torrent_id')
    source = data.get('source', 'MoviePilot')  # æ¥æºç«™ç‚¹åç§°
    
    # é€šè¿‡å®¢æˆ·ç«¯è·å–ä¸‹è½½é“¾æ¥
    if not download_url and torrent_id:
        client = pt_manager.get_client()
        if client:
            download_url = client.build_download_url(torrent_id)

    if not download_url:
        return jsonify({'success': False, 'error': 'ç¼ºå°‘ç§å­ä¸‹è½½é“¾æ¥'}), 400

    torrent_title = data.get('title') or movie_request.title
    qb_tag = f"request-{movie_request.id}"

    app.logger.info(f'[PTæ¨é€] å¼€å§‹æ¨é€: request_id={request_id}, title={torrent_title}, source={source}')
    app.logger.info(f'[PTæ¨é€] ä¸‹è½½é“¾æ¥: {download_url[:100]}...' if len(download_url) > 100 else f'[PTæ¨é€] ä¸‹è½½é“¾æ¥: {download_url}')

    # ç»Ÿä¸€é€šè¿‡ MoviePilot ä¸‹è½½åˆ° qBittorrent
    moviepilot_client = pt_manager.get_client('MoviePilot')
    
    if not moviepilot_client or not moviepilot_client.is_enabled():
        return jsonify({'success': False, 'error': 'MoviePilot æœªé…ç½®'}), 400
    
    app.logger.info(f'[PTæ¨é€] ä½¿ç”¨ MoviePilot ä¸‹è½½ API')
    try:
        # ä¼ é€’ title ä»¥ä¾¿ MoviePilot è¯†åˆ«åª’ä½“ä¿¡æ¯
        mp_result = moviepilot_client.download_torrent(download_url, title=torrent_title)
        if not mp_result:
            return jsonify({'success': False, 'error': 'MoviePilot ä¸‹è½½å¤±è´¥: æ— å“åº”'}), 500
        if mp_result.get('success') != True:
            error_msg = mp_result.get('error', 'æœªçŸ¥é”™è¯¯')
            app.logger.error(f'[PTæ¨é€] MoviePilot API è¿”å›å¤±è´¥: {error_msg}')
            return jsonify({'success': False, 'error': f'MoviePilot ä¸‹è½½å¤±è´¥: {error_msg}'}), 500
        app.logger.info(f'[PTæ¨é€] MoviePilot ä¸‹è½½æˆåŠŸ')
    except Exception as exc:
        app.logger.error(f'[PTæ¨é€] MoviePilot ä¸‹è½½å¼‚å¸¸: {exc}', exc_info=True)
        return jsonify({'success': False, 'error': f'MoviePilot ä¸‹è½½å¤±è´¥: {exc}'}), 500

    # ç­‰å¾…ä¸€å°æ®µæ—¶é—´è®© qBittorrent å¤„ç†ç§å­
    import time
    time.sleep(2)
    
    torrent_info = None
    try:
        torrent_info = qbit_client.get_torrent_by_tag(qb_tag)
        if not torrent_info:
            # å¦‚æœæŒ‰ tag æ‰¾ä¸åˆ°ï¼Œå°è¯•è·å–æœ€è¿‘æ·»åŠ çš„ç§å­
            app.logger.warning(f'[PTæ¨é€] æŒ‰ tag æœªæ‰¾åˆ°ç§å­ï¼Œå°è¯•è·å–æœ€è¿‘æ·»åŠ çš„ç§å­')
            all_torrents = qbit_client.get_torrents_info()
            if all_torrents:
                # æŒ‰æ·»åŠ æ—¶é—´æ’åºï¼Œå–æœ€æ–°çš„
                all_torrents.sort(key=lambda x: x.get('added_on', 0), reverse=True)
                recent = all_torrents[0]
                # æ£€æŸ¥æ˜¯å¦æ˜¯åˆšæ·»åŠ çš„ï¼ˆ30ç§’å†…ï¼‰
                if time.time() - recent.get('added_on', 0) < 30:
                    torrent_info = recent
                    app.logger.info(f'[PTæ¨é€] æ‰¾åˆ°æœ€è¿‘æ·»åŠ çš„ç§å­: {recent.get("name", "")[:50]}')
    except Exception as e:
        app.logger.warning(f'[PTæ¨é€] è·å–ç§å­ä¿¡æ¯å¤±è´¥: {e}')
        torrent_info = None

    # åˆ›å»ºä»»åŠ¡æ—¶åˆå§‹è¿›åº¦è®¾ä¸º 0ï¼Œè®©åå°ç›‘æ§æ¥æ›´æ–°çœŸå®è¿›åº¦
    # é¿å… qBittorrent åœ¨ç§å­åˆšæ·»åŠ æ—¶è¿”å›é”™è¯¯çš„è¿›åº¦å€¼
    task = DownloadTask(
        request_id=movie_request.id,
        torrent_name=torrent_title,
        torrent_hash=torrent_info.get('hash') if torrent_info else None,
        status='queued',
        progress=0,  # åˆå§‹è¿›åº¦ä¸º 0
        qb_tag=qb_tag,
        download_url=download_url,
        source=source,  # è®°å½•æ¥æº
    )

    movie_request.status = 'downloading'
    db.session.add(task)
    db.session.commit()
    
    # ç«‹å³å¯åŠ¨è¯¥ä»»åŠ¡çš„ç‹¬ç«‹ç›‘æ§çº¿ç¨‹
    start_task_monitor(task.id, DOWNLOAD_POLL_INTERVAL)
    
    app.logger.info(f'[PTæ¨é€] ä»»åŠ¡åˆ›å»ºæˆåŠŸ: task_id={task.id}, hash={task.torrent_hash or "å¾…è·å–"}')

    return jsonify({'success': True, 'task': task.to_dict()})


# ==================== Emby Webhook è¾…åŠ©å‡½æ•° ====================
def _verify_emby_webhook_secret():
    """éªŒè¯ Emby Webhook å¯†é’¥ï¼ˆå¯é€‰ï¼‰ã€‚è¿”å› True è¡¨ç¤ºé€šè¿‡ï¼Œè¿”å› Response è¡¨ç¤ºæ‹’ç»ã€‚"""
    if not EMBY_WEBHOOK_SECRET or not EMBY_WEBHOOK_SECRET.strip():
        return True  # æœªé…ç½®å¯†é’¥ï¼Œè·³è¿‡éªŒè¯
    
    # ä»å¤šç§æ¥æºè·å–å¯†é’¥ï¼ˆå…¼å®¹ä¸åŒé…ç½®æ–¹å¼ï¼‰
    provided_secret = (
        request.headers.get('X-Emby-Secret', '')
        or request.headers.get('X-Webhook-Secret', '')
        or request.args.get('secret', '')  # URL å‚æ•°: ?secret=xxx
        or request.args.get('token', '')   # URL å‚æ•°: ?token=xxx
        or request.headers.get('Authorization', '').replace('Bearer ', '')
    )
    
    if not provided_secret:
        app.logger.warning(f'Emby Webhook æœªæä¾›å¯†é’¥ (headers: {dict(request.headers)})')
        return jsonify({'success': False, 'error': 'Webhook å¯†é’¥æœªæä¾›ã€‚è¯·åœ¨ Emby çš„ Webhook URL ä¸­æ·»åŠ  ?token=ä½ çš„å¯†é’¥ï¼Œæˆ–åœ¨ Header ä¸­æ·»åŠ  X-Emby-Secret'}), 401
    
    import hmac
    if not hmac.compare_digest(provided_secret.strip(), EMBY_WEBHOOK_SECRET.strip()):
        app.logger.warning(f'Emby Webhook å¯†é’¥ä¸åŒ¹é…')
        return jsonify({'success': False, 'error': 'å¯†é’¥éªŒè¯å¤±è´¥'}), 401
    
    return True


def _parse_emby_webhook_data():
    """è§£æ Emby Webhook æ•°æ®ï¼ˆå…¼å®¹ JSON / form-data / Webhooks æ’ä»¶æ ¼å¼ï¼‰"""
    data = {}
    try:
        content_type = request.content_type or ''
        
        if 'application/json' in content_type:
            # æ ‡å‡† JSON æ ¼å¼
            data = request.get_json(silent=True) or {}
        elif 'multipart/form-data' in content_type or 'application/x-www-form-urlencoded' in content_type:
            # Emby Webhooks æ’ä»¶ä½¿ç”¨ form-dataï¼Œæ•°æ®é€šå¸¸åœ¨ 'data' å­—æ®µä¸­
            raw_data = request.form.get('data', '')
            if raw_data:
                data = json.loads(raw_data)
            else:
                # å°è¯•ç›´æ¥ä» form å­—æ®µæ„å»º
                data = request.form.to_dict()
        else:
            # å°è¯•å¼ºåˆ¶æŒ‰ JSON è§£æ
            data = request.get_json(force=True, silent=True) or {}
        
        if not data:
            # æœ€åå°è¯•ä»åŸå§‹ body è§£æ
            raw_body = request.get_data(as_text=True)
            if raw_body:
                try:
                    data = json.loads(raw_body)
                except (json.JSONDecodeError, ValueError):
                    app.logger.debug(f'Webhook åŸå§‹æ•°æ®é JSON: {raw_body[:200]}')
    except Exception as e:
        app.logger.warning(f'è§£æ Webhook æ•°æ®å¼‚å¸¸: {e}')
    
    return data


# ==================== Emby Webhook æ¥å£ ====================
@app.route('/api/webhook/emby', methods=['POST'])
def emby_webhook():
    """
    æ¥æ”¶ Emby Webhook é€šçŸ¥ - åª’ä½“å…¥åº“
    
    Emby é…ç½®æ–¹æ³•ï¼š
    1. æ‰“å¼€ Emby æ§åˆ¶å° â†’ è®¾ç½® â†’ é€šçŸ¥
    2. æ·»åŠ  Webhook é€šçŸ¥
    3. URL: http://ä½ çš„æœåŠ¡å™¨åœ°å€:5002/api/webhook/emby
       å¦‚æœé…ç½®äº†å¯†é’¥: http://ä½ çš„æœåŠ¡å™¨åœ°å€:5002/api/webhook/emby?token=ä½ çš„å¯†é’¥
    4. äº‹ä»¶ç±»å‹é€‰æ‹©: library.new (æ–°åª’ä½“å…¥åº“)
    5. ä¹Ÿå¯åœ¨ Header ä¸­æ·»åŠ  X-Emby-Secret: ä½ çš„å¯†é’¥
    """
    # éªŒè¯å¯†é’¥ï¼ˆå¯é€‰ï¼Œä»…å½“é…ç½®äº†å¯†é’¥æ—¶æ‰éªŒè¯ï¼‰
    secret_check = _verify_emby_webhook_secret()
    if secret_check is not True:
        return secret_check
    
    data = _parse_emby_webhook_data()
    
    event_type = data.get('Event', '')
    app.logger.info(f'æ”¶åˆ° Emby å…¥åº“ Webhook: {event_type}')
    
    # åªå¤„ç†æ–°åª’ä½“å…¥åº“äº‹ä»¶
    if event_type not in ['library.new', 'item.added']:
        return jsonify({'success': True, 'message': 'éå…¥åº“äº‹ä»¶ï¼Œå·²å¿½ç•¥', 'event': event_type})
    
    item = data.get('Item', {})
    item_name = item.get('Name', '')
    item_type = item.get('Type', '')  # Movie, Series, Episode
    item_year = item.get('ProductionYear')
    provider_ids = item.get('ProviderIds', {})
    tmdb_id = provider_ids.get('Tmdb')
    imdb_id = provider_ids.get('Imdb')
    
    # å¯¹äº Episode ç±»å‹ï¼Œè·å–çˆ¶çº§ Series ä¿¡æ¯ç”¨äºæœç´¢æµ·æŠ¥
    series_name = None
    series_tmdb_id = None
    if item_type == 'Episode':
        series_name = item.get('SeriesName', '')
        # å°è¯•è·å– Series çš„ TMDB ID
        series_provider_ids = item.get('SeriesProviderIds', {}) or item.get('ProviderIds', {})
        series_tmdb_id = series_provider_ids.get('Tmdb') if series_provider_ids != provider_ids else None
        # å¦‚æœå•é›†æœ‰å¹´ä»½ä¿¡æ¯ï¼Œä¼˜å…ˆä½¿ç”¨ Series çš„å¹´ä»½
        if not item_year:
            item_year = item.get('PremiereDate', '')[:4] if item.get('PremiereDate') else None
        app.logger.info(f'Episode ç±»å‹: SeriesName={series_name}, SeriesTmdbId={series_tmdb_id}')
    
    # æå–é¢å¤–ä¿¡æ¯ç”¨äºé€šçŸ¥
    item_rating = item.get('CommunityRating')  # è¯„åˆ†
    media_streams = item.get('MediaStreams', [])
    # å°è¯•è·å–è§†é¢‘è´¨é‡
    video_quality = None
    for stream in media_streams:
        if stream.get('Type') == 'Video':
            height = stream.get('Height', 0)
            if height >= 2160:
                video_quality = '4K UHD'
            elif height >= 1080:
                video_quality = '1080p'
            elif height >= 720:
                video_quality = '720p'
            else:
                video_quality = f'{height}p'
            break
    
    # å°è¯•è·å–æ–‡ä»¶å¤§å°
    file_size = None
    if item.get('Size'):
        size_bytes = item.get('Size', 0)
        if size_bytes > 1024**3:
            file_size = f"{size_bytes / (1024**3):.2f}GB"
        elif size_bytes > 1024**2:
            file_size = f"{size_bytes / (1024**2):.2f}MB"
    
    app.logger.info(f'Emby æ–°å…¥åº“: {item_name} ({item_year}) - Type: {item_type}, TMDB: {tmdb_id}')
    
    # å°è¯•åŒ¹é…å·²ä¸‹è½½çš„æ±‚ç‰‡è¯·æ±‚
    matched_request = None
    
    # ä¼˜å…ˆé€šè¿‡ TMDB ID åŒ¹é…
    if tmdb_id:
        matched_request = MovieRequest.query.filter(
            MovieRequest.tmdb_id == str(tmdb_id),
            MovieRequest.status.in_(['downloading', 'downloaded'])
        ).first()
    
    # å¦‚æœæ²¡æœ‰åŒ¹é…åˆ°ï¼Œå°è¯•é€šè¿‡åç§°+å¹´ä»½åŒ¹é…
    if not matched_request and item_name:
        query = MovieRequest.query.filter(
            MovieRequest.status.in_(['downloading', 'downloaded'])
        )
        if item_year:
            matched_request = query.filter(
                MovieRequest.title.ilike(f'%{item_name}%'),
                MovieRequest.year == str(item_year)
            ).first()
        else:
            matched_request = query.filter(
                MovieRequest.title.ilike(f'%{item_name}%')
            ).first()
    
    if matched_request:
        app.logger.info(f'åŒ¹é…åˆ°æ±‚ç‰‡è¯·æ±‚: ID={matched_request.id}, æ ‡é¢˜={matched_request.title}')
        
        # æ›´æ–°çŠ¶æ€ä¸ºå·²å®Œæˆ
        previous_status = matched_request.status
        matched_request.status = 'completed'
        matched_request.admin_note = f'å·²å…¥åº“ Emby (è‡ªåŠ¨æ£€æµ‹)'
        
        # æ›´æ–°ä¸‹è½½ä»»åŠ¡çŠ¶æ€
        if matched_request.download_task:
            matched_request.download_task.status = 'completed'
            matched_request.download_task.finished_at = datetime.now()
        
        db.session.commit()
        
        # å‘é€ç¾¤ç»„å…¥åº“é€šçŸ¥ï¼ˆ@ç”¨æˆ·ï¼‰- ä»…å½“çŠ¶æ€æ”¹å˜æ—¶å‘é€
        if previous_status != 'completed':
            # è·å–ç”¨æˆ·ä¿¡æ¯ï¼ˆé€šè¿‡å…³ç³»æˆ–ç›´æ¥æŸ¥è¯¢ï¼‰
            user = matched_request.user  # ä½¿ç”¨ ORM å…³ç³»
            if not user:
                user = User.query.filter_by(tg=matched_request.user_tg).first()
            username = user.name if user else 'ç”¨æˆ·'
            
            # å‘é€ç¾¤ç»„é€šçŸ¥ï¼ˆä½¿ç”¨ä» Emby è·å–çš„ä¿¡æ¯ï¼‰
            # è·å–ç”¨æˆ·çœŸå® Telegram ID ç”¨äº @mention
            _notify_tg_id = user.telegram_id if user and user.telegram_id else matched_request.user_tg
            send_group_completion_notification(
                user_tg_id=_notify_tg_id,
                username=username,
                title=matched_request.title,
                year=matched_request.year,
                media_type=matched_request.media_type,
                tmdb_id=matched_request.tmdb_id,
                poster_path=matched_request.poster_path,
                rating=item_rating,
                quality=video_quality,
                size=file_size,
                file_count=None  # Emby å•æ¬¡ webhook ä¸æä¾›æ–‡ä»¶æ•°é‡
            )
            
            # åŒæ—¶ç§èŠé€šçŸ¥ç”¨æˆ·ï¼ˆå¯é€‰ï¼‰
            if matched_request.user_tg:
                send_user_telegram_notification(
                    user_tg_id=matched_request.user_tg,
                    title=matched_request.title,
                    status='completed',
                    admin_note='æ‚¨çš„æ±‚ç‰‡å·²å…¥åº“ Embyï¼Œå¿«å»è§‚çœ‹å§ï¼ğŸ¬',
                    media_type=matched_request.media_type,
                    tmdb_id=matched_request.tmdb_id,
                    poster_path=matched_request.poster_path
                )
        
        return_data = {
            'success': True,
            'matched': True,
            'request_id': matched_request.id,
            'title': matched_request.title
        }
    else:
        app.logger.info(f'æœªåŒ¹é…åˆ°æ±‚ç‰‡è¯·æ±‚: {item_name}')
        return_data = {'success': True, 'matched': False}
    
    # å‘é€é€šç”¨å…¥åº“é€šçŸ¥ï¼ˆæ‰€æœ‰åª’ä½“å…¥åº“éƒ½å‘é€ï¼Œä¸é™äºæ±‚ç‰‡ï¼‰
    try:
        # è·å–åª’ä½“ç±»åˆ«
        media_category = get_media_category(item_type, tmdb_id) if tmdb_id else 'æœªçŸ¥ç±»åˆ«'
        
        # æ„å»ºå­£é›†ä¿¡æ¯ï¼ˆå¦‚æœæ˜¯å‰§é›†ï¼‰
        season_episode = None
        if item_type in ['Episode', 'Series']:
            season_num = item.get('ParentIndexNumber')  # å­£
            episode_num = item.get('IndexNumber')  # é›†
            if season_num and episode_num:
                season_episode = f"ç¬¬{season_num}å­£ç¬¬{episode_num}é›†"
            elif season_num:
                season_episode = f"ç¬¬{season_num}å­£"
        
        # è·å–ç®€ä»‹
        overview = item.get('Overview', '')
        
        # è·å–å›¾ç‰‡è·¯å¾„ï¼ˆä¼˜å…ˆæ¨ªå‘èƒŒæ™¯å›¾ 16:9ï¼‰
        poster_path = None
        if matched_request and matched_request.tmdb_id:
            # æœ‰åŒ¹é…çš„æ±‚ç‰‡ä¸”æœ‰ TMDB IDï¼Œè·å–æ¨ªå‘èƒŒæ™¯å›¾
            try:
                req_media_type = 'tv' if matched_request.media_type == 'tv' else 'movie'
                details = get_tmdb_details(matched_request.tmdb_id, req_media_type)
                if details:
                    poster_path = details.get('backdrop_path') or details.get('poster_path')
                    app.logger.info(f'ä»æ±‚ç‰‡TMDB IDè·å–æ¨ªå‘å›¾ç‰‡: {poster_path}')
            except Exception:
                pass
            # å›é€€åˆ°æ±‚ç‰‡è®°å½•ä¸­çš„æµ·æŠ¥
            if not poster_path and matched_request.poster_path:
                poster_path = matched_request.poster_path
                app.logger.info(f'å›é€€ä½¿ç”¨æ±‚ç‰‡è®°å½•ä¸­çš„æµ·æŠ¥: {poster_path}')
        elif item_type == 'Episode' and series_tmdb_id:
            # Episode ç±»å‹ï¼šä½¿ç”¨ Series çš„ TMDB ID è·å–å‰§é›†æµ·æŠ¥
            try:
                details = get_tmdb_details(series_tmdb_id, 'tv')
                if details:
                    # ä¼˜å…ˆä½¿ç”¨æ¨ªå‘èƒŒæ™¯å›¾(16:9)ï¼Œå›é€€åˆ°ç«–å‘æµ·æŠ¥
                    poster_path = details.get('backdrop_path') or details.get('poster_path')
                    if not overview and details.get('overview'):
                        overview = details.get('overview')
                    if not item_rating and details.get('vote_average'):
                        item_rating = details.get('vote_average')
                    app.logger.info(f'ä» TMDB è·å–å‰§é›†ä¿¡æ¯ (SeriesTmdbId={series_tmdb_id}): image={poster_path}')
                else:
                    app.logger.warning(f'Series TMDB ID {series_tmdb_id} è·å–è¯¦æƒ…å¤±è´¥')
            except Exception as e:
                app.logger.warning(f'ä» TMDB è·å– Series ä¿¡æ¯å¤±è´¥: {e}')
        elif tmdb_id:
            # å¦‚æœæœ‰ TMDB IDï¼Œä» TMDB è·å–æµ·æŠ¥
            try:
                media_type = 'movie' if item_type == 'Movie' else 'tv'
                details = get_tmdb_details(tmdb_id, media_type)
                if details:
                    # ä¼˜å…ˆä½¿ç”¨æ¨ªå‘èƒŒæ™¯å›¾(16:9)ï¼Œå›é€€åˆ°ç«–å‘æµ·æŠ¥
                    poster_path = details.get('backdrop_path') or details.get('poster_path')
                    # å¦‚æœæ²¡æœ‰ overviewï¼Œä¹Ÿä» TMDB è·å–
                    if not overview and details.get('overview'):
                        overview = details.get('overview')
                    # å¦‚æœæ²¡æœ‰è¯„åˆ†ï¼Œä¹Ÿä» TMDB è·å–
                    if not item_rating and details.get('vote_average'):
                        item_rating = details.get('vote_average')
                    app.logger.info(f'ä» TMDB è·å–ä¿¡æ¯: image={poster_path}, rating={item_rating}')
                else:
                    app.logger.warning(f'TMDB ID {tmdb_id} è·å–è¯¦æƒ…å¤±è´¥ï¼Œè¿”å› None')
            except Exception as e:
                app.logger.warning(f'ä» TMDB è·å–ä¿¡æ¯å¤±è´¥: {e}')
        
        # å¦‚æœè¿˜æ˜¯æ²¡æœ‰æµ·æŠ¥ï¼Œå°è¯•é€šè¿‡åç§°æœç´¢ TMDBï¼ˆå…ˆä¸­æ–‡ï¼Œå†è‹±æ–‡ï¼‰
        # å¯¹äº Episode ç±»å‹ï¼Œä¼˜å…ˆä½¿ç”¨ SeriesName æœç´¢
        search_name = series_name if (item_type == 'Episode' and series_name) else item_name
        search_media_type = 'tv' if item_type in ['Episode', 'Series'] else 'movie'
        
        if not poster_path and search_name and TMDB_API_KEY:
            try:
                search_url = f'{TMDB_BASE_URL}/search/{search_media_type}'
                
                # å…ˆå°è¯•ä¸­æ–‡æœç´¢
                params = {
                    'api_key': TMDB_API_KEY,
                    'query': search_name,
                    'language': 'zh-CN'
                }
                if item_year:
                    params['year' if search_media_type == 'movie' else 'first_air_date_year'] = item_year
                
                response = http_session.get(search_url, params=params, timeout=10)
                results = []
                if response.status_code == 200:
                    results = response.json().get('results', [])
                
                # å¦‚æœä¸­æ–‡æœç´¢æ— ç»“æœï¼Œå°è¯•è‹±æ–‡æœç´¢
                if not results:
                    app.logger.info(f'ä¸­æ–‡æœç´¢æ— ç»“æœï¼Œå°è¯•è‹±æ–‡æœç´¢: {search_name}')
                    params['language'] = 'en-US'
                    response = http_session.get(search_url, params=params, timeout=10)
                    if response.status_code == 200:
                        results = response.json().get('results', [])
                
                # å¦‚æœè¿˜æ˜¯æ— ç»“æœï¼Œå°è¯•å»æ‰å¹´ä»½æœç´¢
                if not results and item_year:
                    app.logger.info(f'å¸¦å¹´ä»½æœç´¢æ— ç»“æœï¼Œå°è¯•ä¸å¸¦å¹´ä»½æœç´¢: {search_name}')
                    params.pop('year', None)
                    params.pop('first_air_date_year', None)
                    params['language'] = 'zh-CN'
                    response = http_session.get(search_url, params=params, timeout=10)
                    if response.status_code == 200:
                        results = response.json().get('results', [])
                
                if results:
                    best_match = results[0]
                    # ä¼˜å…ˆä½¿ç”¨æ¨ªå‘èƒŒæ™¯å›¾(16:9)ï¼Œå›é€€åˆ°ç«–å‘æµ·æŠ¥
                    poster_path = best_match.get('backdrop_path') or best_match.get('poster_path')
                    if not overview:
                        overview = best_match.get('overview', '')
                    if not item_rating:
                        item_rating = best_match.get('vote_average')
                    if not tmdb_id:
                        tmdb_id = best_match.get('id')
                    app.logger.info(f'é€šè¿‡æœç´¢è·å– TMDB ä¿¡æ¯ (æœç´¢è¯={search_name}): image={poster_path}, tmdb_id={tmdb_id}')
                else:
                    app.logger.warning(f'TMDB æœç´¢æ— ç»“æœ: {search_name} ({item_year})')
            except Exception as e:
                app.logger.warning(f'æœç´¢ TMDB å¤±è´¥: {e}')
        
        # å¦‚æœè¿˜æ˜¯æ²¡æœ‰æµ·æŠ¥ï¼Œå°è¯•ä½¿ç”¨ Emby è‡ªå·±çš„å›¾ç‰‡ï¼ˆä¼˜å…ˆæ¨ªå‘èƒŒæ™¯å›¾ï¼‰
        if not poster_path:
            emby_image_tags = item.get('ImageTags', {})
            emby_backdrop_tags = item.get('BackdropImageTags', [])
            emby_item_id = item.get('Id')
            # å¯¹äº Episodeï¼Œä¹Ÿå¯ä»¥å°è¯•è·å– Series çš„å›¾ç‰‡
            series_id = item.get('SeriesId') if item_type == 'Episode' else None
            
            # è·å– Emby é…ç½®
            config = load_system_config()
            emby_url = config.get('emby', {}).get('url', '').rstrip('/')
            emby_api_key = config.get('emby', {}).get('api_key', '')
            
            if emby_backdrop_tags and emby_item_id and emby_url and emby_api_key:
                # ä¼˜å…ˆä½¿ç”¨æ¨ªå‘èƒŒæ™¯å›¾(16:9)
                poster_path = f"{emby_url}/Items/{emby_item_id}/Images/Backdrop?api_key={emby_api_key}"
                app.logger.info(f'ä½¿ç”¨ Emby Backdrop å›¾ç‰‡: {poster_path[:50]}...')
            elif emby_image_tags.get('Primary') and emby_item_id and emby_url and emby_api_key:
                # å›é€€åˆ°ç«–å‘å°é¢å›¾
                poster_path = f"{emby_url}/Items/{emby_item_id}/Images/Primary?api_key={emby_api_key}"
                app.logger.info(f'ä½¿ç”¨ Emby Primary å›¾ç‰‡: {poster_path[:50]}...')
            elif series_id and emby_url and emby_api_key:
                # Episode æ²¡æœ‰è‡ªå·±çš„å›¾ç‰‡ï¼Œå°è¯•ä½¿ç”¨ Series çš„èƒŒæ™¯å›¾æˆ–å°é¢
                poster_path = f"{emby_url}/Items/{series_id}/Images/Backdrop?api_key={emby_api_key}"
                app.logger.info(f'ä½¿ç”¨ Emby Series Backdrop å›¾ç‰‡: {poster_path[:50]}...')
        
        if not poster_path:
            app.logger.warning(f'æ— æ³•è·å–æµ·æŠ¥: {item_name} - æ—  TMDB IDï¼Œæœç´¢å¤±è´¥ï¼ŒEmby ä¹Ÿæ— å›¾ç‰‡')
        
        # å¯¹äº Episodeï¼Œé€šçŸ¥æ ‡é¢˜ä½¿ç”¨ SeriesName + é›†ä¿¡æ¯
        notification_title = item_name
        if item_type == 'Episode' and series_name:
            notification_title = series_name
        
        # å‘é€å…¥åº“é€šçŸ¥ï¼ˆå‰§é›†èšåˆï¼Œç”µå½±ç›´æ¥å‘ï¼‰
        if item_type == 'Episode':
            # å‰§é›†ï¼šåŠ å…¥èšåˆé˜Ÿåˆ—ï¼Œç­‰å¾…åŒä¸€éƒ¨å‰§çš„å…¶ä»–é›†ä¸€èµ·é€šçŸ¥
            season_num = item.get('ParentIndexNumber') or 0
            episode_num = item.get('IndexNumber') or 0
            # è·å–å•é›†çš„é›†åï¼ˆå¦‚ "ç¬¬åä¸‰é›†"ã€"å‘½è¿ä¹‹å¤œ" ç­‰ï¼‰
            episode_name = item_name if item_name and item_name != series_name else None
            # èšåˆ keyï¼šå‰§å+å¹´ä»½ï¼ˆåŒä¸€éƒ¨å‰§å½’åˆ°ä¸€èµ·ï¼‰
            agg_key = f"{notification_title}|{item_year or ''}"
            app.logger.info(f'å‰§é›†å…¥åº“åŠ å…¥èšåˆ: {notification_title} S{season_num:02d}E{episode_num:02d} ({episode_name})')
            _queue_episode_notification(
                series_key=agg_key,
                title=notification_title,
                year=item_year,
                season_num=season_num,
                episode_num=episode_num,
                vote_average=item_rating,
                category=media_category,
                resource_quality=video_quality,
                total_size=file_size,
                tmdb_id=tmdb_id,
                overview=overview,
                poster_path=poster_path,
                episode_name=episode_name
            )
        else:
            # ç”µå½±ï¼šç›´æ¥å‘é€é€šçŸ¥
            app.logger.info(f'å‘é€å…¥åº“é€šçŸ¥: {notification_title}, poster={poster_path}, rating={item_rating}, quality={video_quality}')
            send_general_library_notification(
                title=notification_title,
                year=item_year,
                season_episode=season_episode,
                vote_average=item_rating,
                category=media_category,
                resource_quality=video_quality,
                file_count=1,
                total_size=file_size,
                tmdb_id=tmdb_id,
                release_group=None,
                time_usage=None,
                overview=overview,
                poster_path=poster_path
            )
    except Exception as e:
        app.logger.error(f'å‘é€é€šç”¨å…¥åº“é€šçŸ¥å¤±è´¥: {e}')
    
    return jsonify(return_data)


@app.route('/api/webhook/emby/playback', methods=['POST'])
def emby_playback_webhook():
    """
    æ¥æ”¶ Emby Webhook é€šçŸ¥ - æ’­æ”¾æ£€æµ‹ï¼ˆé»‘åå•ï¼‰
    
    è¿™æ˜¯ç‹¬ç«‹çš„æ’­æ”¾æ£€æµ‹ Webhookï¼Œç”¨äºé»‘åå•è®¾å¤‡æ£€æµ‹å’Œå°ç¦
    
    Emby é…ç½®æ–¹æ³•ï¼š
    1. æ‰“å¼€ Emby æ§åˆ¶å° â†’ è®¾ç½® â†’ é€šçŸ¥
    2. æ·»åŠ  Webhook é€šçŸ¥
    3. URL: http://ä½ çš„æœåŠ¡å™¨åœ°å€:5002/api/webhook/emby/playback
       å¦‚æœé…ç½®äº†å¯†é’¥: http://ä½ çš„æœåŠ¡å™¨åœ°å€:5002/api/webhook/emby/playback?token=ä½ çš„å¯†é’¥
    4. äº‹ä»¶ç±»å‹é€‰æ‹©: playback.start (æ’­æ”¾å¼€å§‹)
    5. ä¹Ÿå¯åœ¨ Header ä¸­æ·»åŠ  X-Emby-Secret: ä½ çš„å¯†é’¥
    """
    # éªŒè¯å¯†é’¥ï¼ˆå¯é€‰ï¼‰
    secret_check = _verify_emby_webhook_secret()
    if secret_check is not True:
        return secret_check
    
    data = _parse_emby_webhook_data()
    
    event_type = data.get('Event', '')
    app.logger.info(f'æ”¶åˆ° Emby æ’­æ”¾ Webhook: {event_type}')
    
    # æ”¯æŒå¤šç§äº‹ä»¶ï¼ˆæ’­æ”¾äº‹ä»¶ + è®¤è¯äº‹ä»¶ï¼‰
    valid_events = ['playback.start', 'PlaybackStart', 'playback.stop', 'PlaybackStop', 
                    'playback.progress', 'PlaybackProgress', 'playback.pause', 'playback.unpause',
                    'session.start', 'SessionStart', 'user.authenticated', 'AuthenticationSuccess']
    if event_type not in valid_events:
        return jsonify({'success': True, 'message': 'éç›‘å¬äº‹ä»¶ï¼Œå·²å¿½ç•¥', 'event': event_type})
    
    session_info = data.get('Session', {})
    user_info = data.get('User', {})
    item_info = data.get('Item', {})
    
    device_id = session_info.get('DeviceId', '')
    device_name = session_info.get('DeviceName', '')
    client = session_info.get('Client', '')
    emby_user_id = user_info.get('Id', '')
    emby_user_name = user_info.get('Name', '')
    remote_ip = session_info.get('RemoteEndPoint', '')
    session_id = session_info.get('Id', '')
    
    # åª’ä½“ä¿¡æ¯
    emby_item_id = item_info.get('Id', '')
    item_name = item_info.get('Name', '')
    item_type = item_info.get('Type', 'Movie')
    series_name = item_info.get('SeriesName', '')
    season_number = item_info.get('ParentIndexNumber')
    episode_number = item_info.get('IndexNumber')
    total_ticks = item_info.get('RunTimeTicks', 0)
    
    # æ’­æ”¾è¿›åº¦ä¿¡æ¯ - ä»å¤šä¸ªå¯èƒ½çš„ä½ç½®è·å– PositionTicks
    play_state = session_info.get('PlayState', {}) or {}
    playback_info = data.get('PlaybackInfo', {}) or {}
    
    # ä¼˜å…ˆçº§: PlaybackInfo > Session.PlayState > é¡¶å±‚PlayState > NowPlayingItem.UserData
    position_ticks = (
        playback_info.get('PositionTicks', 0) or
        play_state.get('PositionTicks', 0) or
        (data.get('PlayState', {}) or {}).get('PositionTicks', 0) or
        session_info.get('NowPlayingItem', {}).get('UserData', {}).get('PlaybackPositionTicks', 0) or
        item_info.get('UserData', {}).get('PlaybackPositionTicks', 0) or
        0
    )
    # RunTimeTicks ä¹Ÿå¯èƒ½åœ¨ NowPlayingItem ä¸­
    if not total_ticks:
        now_playing_item = session_info.get('NowPlayingItem', {})
        total_ticks = now_playing_item.get('RunTimeTicks', 0)
    
    play_method = play_state.get('PlayMethod', '') or playback_info.get('PlayMethod', '') or session_info.get('PlayMethod', '')
    
    app.logger.info(f'æ’­æ”¾æ£€æµ‹: ç”¨æˆ·={emby_user_name}, è®¾å¤‡={device_name}, å®¢æˆ·ç«¯={client}, äº‹ä»¶={event_type}')
    app.logger.info(f'æ’­æ”¾è¿›åº¦è°ƒè¯•: position_ticks={position_ticks}, total_ticks={total_ticks}, PlayState={play_state}, PlaybackInfo keys={list(playback_info.keys()) if playback_info else "æ— "}, dataé¡¶å±‚keys={[k for k in data.keys() if k not in ("Session","User","Item")]}')
    
    # æŸ¥æ‰¾ç”¨æˆ·
    emby_user = None
    if emby_user_id:
        emby_user = User.query.filter_by(embyid=emby_user_id).first()
    if not emby_user and emby_user_name:
        emby_user = User.query.filter_by(emby_name=emby_user_name).first()
    # å›é€€ï¼šç”¨ç½‘ç«™ç”¨æˆ·ååŒ¹é…ï¼ˆæœ‰äº›ç”¨æˆ·çš„ç½‘ç«™ç”¨æˆ·åä¸ Emby ç”¨æˆ·åä¸€è‡´ï¼‰
    if not emby_user and emby_user_name:
        emby_user = User.query.filter_by(name=emby_user_name).first()
    
    if not emby_user:
        app.logger.warning(f'æ’­æ”¾æ£€æµ‹: æœªæ‰¾åˆ°ç”¨æˆ· {emby_user_name} (emby_id={emby_user_id})')
        return jsonify({'success': True, 'message': 'ç”¨æˆ·æœªæ³¨å†Œ'})
    
    if not device_id:
        app.logger.warning(f'æ’­æ”¾æ£€æµ‹: ç¼ºå°‘è®¾å¤‡ID')
        return jsonify({'success': True, 'message': 'ç¼ºå°‘è®¾å¤‡ä¿¡æ¯'})
    
    try:
        # æŸ¥æ‰¾æˆ–åˆ›å»ºè®¾å¤‡è®°å½•
        device = UserDevice.query.filter_by(
            user_tg=emby_user.tg,
            device_id=device_id
        ).first()
        
        if not device:
            device = UserDevice(
                user_tg=emby_user.tg,
                device_id=device_id,
                device_name=device_name or 'æœªçŸ¥è®¾å¤‡',
                client=client or 'æœªçŸ¥',
                last_ip=remote_ip,
                last_active=datetime.now()
            )
            db.session.add(device)
            db.session.flush()
        else:
            device.device_name = device_name or device.device_name
            device.client = client or device.client
            device.last_ip = remote_ip or device.last_ip
            device.last_active = datetime.now()
        
        # è®°å½•æ’­æ”¾å†å²ï¼ˆæ‰€æœ‰æ’­æ”¾äº‹ä»¶éƒ½è®°å½•ï¼‰
        if emby_item_id:
            # è®¡ç®—æ’­æ”¾è¿›åº¦ï¼ˆå…ˆè®¡ç®—ç™¾åˆ†æ¯”å†å–æ•´ï¼Œé¿å…ç²¾åº¦ä¸¢å¤±ï¼‰
            total_duration = int(total_ticks / 10000000) if total_ticks else 0
            play_duration = int(position_ticks / 10000000) if position_ticks else 0
            # play_duration ä¸åº”è¶…è¿‡ total_durationï¼ˆé˜²æ­¢å¼‚å¸¸ ticksï¼‰
            if total_duration > 0 and play_duration > total_duration:
                play_duration = total_duration
            # ä½¿ç”¨ ticks ç›´æ¥è®¡ç®—ç™¾åˆ†æ¯”ï¼Œé¿å… int è½¬æ¢å¯¼è‡´çš„ç²¾åº¦ä¸¢å¤±
            play_percentage = min(100.0, (position_ticks / total_ticks * 100)) if total_ticks > 0 else 0
            
            # æŸ¥æ‰¾æœ€è¿‘10åˆ†é’Ÿå†…åŒä¸€åª’ä½“çš„è®°å½•ï¼ˆé¿å…é‡å¤ï¼‰
            ten_mins_ago = datetime.now() - timedelta(minutes=10)
            existing_record = PlaybackRecord.query.filter(
                PlaybackRecord.user_tg == emby_user.tg,
                PlaybackRecord.device_id == device.id,
                PlaybackRecord.emby_item_id == emby_item_id,
                PlaybackRecord.started_at > ten_mins_ago
            ).first()
            
            if existing_record:
                # æ›´æ–°ç°æœ‰è®°å½•
                existing_record.play_duration = play_duration
                existing_record.play_percentage = play_percentage
                existing_record.play_method = play_method or existing_record.play_method
                if event_type in ['playback.stop', 'PlaybackStop']:
                    existing_record.ended_at = datetime.now()
                app.logger.info(f'æ›´æ–°æ’­æ”¾è®°å½•: {item_name} ({play_percentage:.1f}%)')
            else:
                # åˆ›å»ºæ–°è®°å½•
                record = PlaybackRecord(
                    user_tg=emby_user.tg,
                    device_id=device.id,
                    emby_item_id=emby_item_id,
                    item_name=item_name,
                    item_type=item_type,
                    series_name=series_name,
                    season_number=season_number,
                    episode_number=episode_number,
                    play_duration=play_duration,
                    total_duration=total_duration,
                    play_percentage=play_percentage,
                    play_method=play_method,
                    client_ip=remote_ip,
                    started_at=datetime.now()
                )
                db.session.add(record)
                app.logger.info(f'æ–°å¢æ’­æ”¾è®°å½•: {item_name}')
        
        # ========== è®¢é˜…æœ‰æ•ˆæ€§æ£€æŸ¥ ==========
        # æ’­æ”¾å¼€å§‹æ—¶æ£€æŸ¥ç”¨æˆ·è®¢é˜…æ˜¯å¦æœ‰æ•ˆï¼Œè¿‡æœŸåˆ™ç«‹å³åœæ­¢æ’­æ”¾å¹¶ç¦ç”¨è´¦å·
        is_playback_start = event_type in ['playback.start', 'PlaybackStart']
        _emby_wl_sub = Subscription.query.filter_by(user_tg=emby_user.tg, plan_type='whitelist', status='active').first()
        if is_playback_start and not _emby_wl_sub:  # ç™½åå•ç”¨æˆ·è·³è¿‡æ£€æŸ¥
            has_valid_sub = emby_user.ex and emby_user.ex > datetime.now()
            if not has_valid_sub:
                app.logger.warning(f'[Webhook] è¿‡æœŸç”¨æˆ·å°è¯•æ’­æ”¾: {emby_user.name}, åˆ°æœŸæ—¶é—´={emby_user.ex}')
                # åœæ­¢æ’­æ”¾ä¼šè¯
                if session_id and emby_client.is_enabled():
                    emby_client.stop_session(session_id)
                    app.logger.info(f'[Webhook] å·²åœæ­¢è¿‡æœŸç”¨æˆ·æ’­æ”¾ä¼šè¯: {emby_user.name}')
                # ç¦ç”¨ Emby è´¦å·
                if emby_user.embyid and emby_client.is_enabled():
                    emby_client.disable_user(emby_user.embyid)
                    emby_client.kill_user_sessions(emby_user.embyid)
                    app.logger.info(f'[Webhook] å·²ç¦ç”¨è¿‡æœŸç”¨æˆ·Embyè´¦å·: {emby_user.name}')
                db.session.commit()
                return jsonify({'success': True, 'message': 'ç”¨æˆ·è®¢é˜…å·²è¿‡æœŸï¼Œæ’­æ”¾å·²åœæ­¢', 'action': 'expired_disabled'})
        
        # ========== åŒæ—¶æ’­æ”¾æµæ•°é™åˆ¶ï¼ˆä¸»åŠ¨é™æµï¼‰ ==========
        # Emby å†…ç½®çš„ SimultaneousStreamLimit åœ¨éƒ¨åˆ†ç‰ˆæœ¬ä¸ä¸¥æ ¼æ‰§è¡Œ
        # é€šè¿‡ Webhook + Sessions API ä¸»åŠ¨æ£€æµ‹å¹¶åœæ­¢è¶…é™ä¼šè¯
        # åœ¨ playback.start å’Œ playback.progress æ—¶éƒ½æ£€æŸ¥ï¼Œé˜²æ­¢ start äº‹ä»¶é—æ¼
        is_playing_event = event_type in ['playback.start', 'PlaybackStart', 'playback.progress', 'PlaybackProgress']
        if is_playing_event and emby_user.embyid and emby_client.is_enabled():
            # playback.progress é¢‘ç‡å¾ˆé«˜ï¼ŒèŠ‚æµï¼šæ¯ç”¨æˆ·30ç§’åªæ£€æŸ¥ä¸€æ¬¡
            _do_stream_check = True
            if not is_playback_start:
                _throttle_key = f'stream_check_{emby_user.embyid}'
                _last_check = getattr(app, '_stream_check_cache', {}).get(_throttle_key, 0)
                import time as _time
                if _time.time() - _last_check < 30:
                    _do_stream_check = False
                else:
                    if not hasattr(app, '_stream_check_cache'):
                        app._stream_check_cache = {}
                    app._stream_check_cache[_throttle_key] = _time.time()
            
            if _do_stream_check:
                config = load_system_config()
                max_streams = config.get('telegram', {}).get('max_streams', 0)
            
                if max_streams and max_streams > 0:
                    # æ‰€æœ‰ç”¨æˆ·ç»Ÿä¸€é™åˆ¶æœ€å¤§æ’­æ”¾è®¾å¤‡æ•°ï¼ˆåŒ…æ‹¬ç™½åå•ç”¨æˆ·ï¼‰
                    # playback.start æ—¶ Emby Sessions API æ›´æ–°æœ‰å»¶è¿Ÿï¼Œ
                    # æ–°ä¼šè¯å¯èƒ½è¿˜æ²¡æ³¨å†Œåˆ° Sessions åˆ—è¡¨ä¸­ï¼ŒçŸ­æš‚ç­‰å¾…æé«˜å‡†ç¡®åº¦
                    # playback.progress æ—¶ä¸éœ€è¦ç­‰å¾…
                    if is_playback_start:
                        import time as _time
                        _time.sleep(1.5)
                    
                    playing_count, playing_sessions = emby_client.get_user_playing_count(emby_user.embyid)
                    
                    app.logger.info(
                        f'[æ’­æ”¾é™æµ] ç”¨æˆ·={emby_user.name}, æ­£åœ¨æ’­æ”¾={playing_count}, é™åˆ¶={max_streams}, '
                        f'å½“å‰ä¼šè¯={session_id}, è®¾å¤‡={device_name}'
                    )
                    
                    if playing_count > max_streams:
                        app.logger.warning(
                            f'[Webhook] ç”¨æˆ· {emby_user.name} åŒæ—¶æ’­æ”¾ {playing_count} ä¸ªæµï¼Œ'
                            f'è¶…è¿‡é™åˆ¶ {max_streams}ï¼Œå°†åœæ­¢å½“å‰ä¼šè¯'
                        )
                        
                        # åœæ­¢å½“å‰è§¦å‘çš„ä¼šè¯ï¼ˆå³æœ€æ–°å¼€å§‹çš„è¿™ä¸ªï¼‰
                        if session_id:
                            emby_client.stop_session(
                                session_id,
                                reason=f'åŒæ—¶æ’­æ”¾è®¾å¤‡æ•°å·²è¾¾ä¸Šé™ï¼ˆ{max_streams}ï¼‰ï¼Œè¯·å…ˆå…³é—­å…¶ä»–è®¾å¤‡çš„æ’­æ”¾'
                            )
                        
                        # å¦‚æœåœäº†å½“å‰ä¼šè¯åä»ç„¶è¶…é™ï¼Œä¹Ÿåœæ‰å…¶ä»–æœ€æ–°çš„
                        if playing_count > max_streams + 1:
                            excess = playing_count - max_streams
                            sorted_sessions = sorted(playing_sessions, key=lambda x: x.get('last_activity', ''), reverse=True)
                            for i, ps in enumerate(sorted_sessions):
                                if i >= excess:
                                    break
                                ps_id = ps.get('session_id')
                                if ps_id and ps_id != session_id:
                                    emby_client.stop_session(
                                        ps_id,
                                        reason=f'åŒæ—¶æ’­æ”¾è®¾å¤‡æ•°å·²è¾¾ä¸Šé™ï¼ˆ{max_streams}ï¼‰ï¼Œè¯·å…ˆå…³é—­å…¶ä»–è®¾å¤‡çš„æ’­æ”¾'
                                    )
                        
                        # è®°å½•æ—¥å¿—
                        device_list = ', '.join([f"{s['device_name']}({s['client']})" for s in playing_sessions])
                        app.logger.info(
                            f'[Webhook] å·²åœæ­¢è¶…é™æ’­æ”¾: ç”¨æˆ·={emby_user.name}, '
                            f'æ­£åœ¨æ’­æ”¾={playing_count}/{max_streams}, '
                            f'è®¾å¤‡åˆ—è¡¨=[{device_list}]'
                        )
                        
                        db.session.commit()
                        return jsonify({
                            'success': True,
                            'message': f'åŒæ—¶æ’­æ”¾è¶…è¿‡é™åˆ¶({playing_count}/{max_streams})ï¼Œå·²åœæ­¢æ’­æ”¾',
                            'action': 'stream_limit_exceeded'
                        })
        
        # ========== é»‘åå•æ£€æµ‹é€»è¾‘ ==========
        # ç™»å½•/ä¼šè¯äº‹ä»¶ï¼šæ£€æµ‹ stop_and_ban è§„åˆ™ï¼Œç«‹å³ç¦ç”¨è´¦å·
        # æ’­æ”¾äº‹ä»¶ï¼šæ£€æµ‹æ‰€æœ‰è§„åˆ™ï¼Œåœæ­¢æ’­æ”¾
        
        is_auth_event = event_type in ['session.start', 'SessionStart', 'user.authenticated', 'AuthenticationSuccess']
        is_playback_event = event_type in ['playback.start', 'PlaybackStart']
        
        if is_auth_event or is_playback_event:
            blacklist_rules = DeviceBlacklist.query.filter_by(is_enabled=True).all()
            matched_rule = None
            
            for rule in blacklist_rules:
                if rule.matches(client, device_name):
                    matched_rule = rule
                    break
            
            # å¦‚æœåŒ¹é…é»‘åå•è§„åˆ™
            if matched_rule:
                # è®°å½•æ˜¯å¦æ˜¯é¦–æ¬¡é˜»æ­¢ï¼ˆç”¨äºå†³å®šæ˜¯å¦å‘é€é€šçŸ¥ï¼‰
                is_first_block = not device.is_blocked
                
                app.logger.warning(f'[Webhook] æ£€æµ‹åˆ°é»‘åå•å®¢æˆ·ç«¯: ç”¨æˆ·={emby_user.name}, è®¾å¤‡={device_name}, å®¢æˆ·ç«¯={client}, è§„åˆ™={matched_rule.rule_name}, äº‹ä»¶={event_type}, é¦–æ¬¡é˜»æ­¢={is_first_block}')
                
                # æ ‡è®°è®¾å¤‡ä¸ºå·²é˜»æ­¢
                if is_first_block:
                    device.is_blocked = True
                
                # ========== stop_and_ban æ¨¡å¼ï¼šç™»å½•æ—¶ç«‹å³ç¦ç”¨è´¦å· ==========
                if matched_rule.action == 'stop_and_ban':
                    # æ£€æŸ¥æ˜¯å¦å·²ç»å¤„ç†è¿‡ï¼ˆé€šè¿‡è®¢é˜…çŠ¶æ€åˆ¤æ–­ï¼‰
                    active_subs = Subscription.query.filter_by(user_tg=emby_user.tg, status='active').all()
                    has_active_sub = len(active_subs) > 0
                    
                    if has_active_sub or is_first_block:
                        # ä¿å­˜å°ç¦å‰çš„çŠ¶æ€ï¼ˆç”¨äºæ¢å¤ï¼‰
                        if is_first_block:
                            emby_user.ban_prev_lv = emby_user.lv
                            emby_user.ban_prev_ex = emby_user.ex
                            emby_user.ban_time = datetime.now()
                            emby_user.ban_reason = f'é»‘åå•è§„åˆ™è§¦å‘: {matched_rule.rule_name}'
                        
                        # æ³¨æ„ï¼šé»‘åå•å°ç¦åªç¦ç”¨ Emby è´¦å·ï¼Œä¸æ”¹ lv
                        # ç”¨æˆ·ä»å¯ç™»å½•é¢æ¿ï¼Œé¢æ¿é€šè¿‡ ban_reason æ˜¾ç¤º Emby è¢«ç¦ç”¨æç¤º
                        
                        # æš‚åœç”¨æˆ·è®¢é˜…
                        for sub in active_subs:
                            sub.status = 'suspended'
                        
                        # ç¦ç”¨ Emby è´¦å·å¹¶è¸¢å‡ºæ‰€æœ‰ä¼šè¯
                        if emby_user.embyid:
                            emby_client.disable_user(emby_user.embyid)
                            emby_client.kill_user_sessions(emby_user.embyid)
                        
                        db.session.commit()
                    else:
                        # å·²å¤„ç†è¿‡ï¼Œç¡®ä¿ Emby è´¦å·ä¿æŒç¦ç”¨
                        if emby_user.embyid:
                            emby_client.disable_user(emby_user.embyid)
                            emby_client.kill_user_sessions(emby_user.embyid)
                        db.session.commit()
                    
                    # æ¯æ¬¡æ£€æµ‹åˆ°éƒ½å‘é€é€šçŸ¥
                    trigger_type = "ç™»å½•" if is_auth_event else "æ’­æ”¾"
                    try:
                        message = f"""ğŸš¨ <b>é»‘åå•å®¢æˆ·ç«¯è­¦å‘Š</b>

ğŸ‘¤ <b>ç”¨æˆ·ï¼š</b>{emby_user.name}
ğŸ“± <b>è®¾å¤‡ï¼š</b>{device_name}
ğŸ’» <b>å®¢æˆ·ç«¯ï¼š</b>{client}
ğŸŒ <b>IPï¼š</b>{remote_ip}
ğŸš« <b>åŒ¹é…è§„åˆ™ï¼š</b>{matched_rule.rule_name}
ğŸ¯ <b>è§¦å‘äº‹ä»¶ï¼š</b>{trigger_type}
âš¡ <b>å¤„ç†æ–¹å¼ï¼š</b>ç¦ç”¨Embyè´¦å·
ğŸ”¢ <b>é¦–æ¬¡è§¦å‘ï¼š</b>{'æ˜¯' if is_first_block else 'å¦ï¼ˆé‡å¤å°è¯•ï¼‰'}

âœ… å·²æ‰§è¡Œï¼šEmbyè´¦å·å·²ç¦ç”¨ã€æ‰€æœ‰ä¼šè¯å·²è¸¢å‡º"""
                        send_admin_notification(message)
                    except Exception as e:
                        app.logger.error(f'å‘é€é»‘åå•é€šçŸ¥å¤±è´¥: {e}')
                    
                    return jsonify({'success': False, 'blocked': True, 'reason': 'Embyè´¦å·å·²è¢«ç¦ç”¨'}), 403
                
                # ========== stop_only æ¨¡å¼ï¼šä»…åœ¨æ’­æ”¾æ—¶åœæ­¢æ’­æ”¾ ==========
                elif matched_rule.action == 'stop_only' and is_playback_event:
                    # ç«‹å³åœæ­¢è¯¥ä¼šè¯çš„æ’­æ”¾
                    if session_id:
                        stop_result = emby_client.stop_session(session_id, reason=f'æ£€æµ‹åˆ°å¯ç–‘å®¢æˆ·ç«¯: {client}')
                        app.logger.info(f'åœæ­¢æ’­æ”¾ä¼šè¯: session_id={session_id}, result={stop_result}')
                    
                    db.session.commit()
                    
                    # æ¯æ¬¡æ£€æµ‹åˆ°éƒ½å‘é€é€šçŸ¥
                    try:
                        message = f"""âš ï¸ <b>é»‘åå•å®¢æˆ·ç«¯æ£€æµ‹</b>

ğŸ‘¤ <b>ç”¨æˆ·ï¼š</b>{emby_user.name}
ğŸ“± <b>è®¾å¤‡ï¼š</b>{device_name}
ğŸ’» <b>å®¢æˆ·ç«¯ï¼š</b>{client}
ğŸŒ <b>IPï¼š</b>{remote_ip}
ğŸš« <b>åŒ¹é…è§„åˆ™ï¼š</b>{matched_rule.rule_name}
âš¡ <b>å¤„ç†æ–¹å¼ï¼š</b>åœæ­¢æ’­æ”¾
ğŸ”¢ <b>é¦–æ¬¡è§¦å‘ï¼š</b>{'æ˜¯' if is_first_block else 'å¦ï¼ˆé‡å¤å°è¯•ï¼‰'}

âœ… å·²æ‰§è¡Œï¼šæ’­æ”¾å·²åœæ­¢"""
                        send_admin_notification(message)
                    except Exception as e:
                        app.logger.error(f'å‘é€é»‘åå•é€šçŸ¥å¤±è´¥: {e}')
                    
                    return jsonify({'success': True, 'blocked': True, 'reason': 'æ’­æ”¾å·²åœæ­¢'})
                
                else:
                    # stop_only æ¨¡å¼ä½†ä¸æ˜¯æ’­æ”¾äº‹ä»¶ï¼Œåªè®°å½•ä¸å¤„ç†
                    db.session.commit()
        
        db.session.commit()
        return jsonify({'success': True, 'message': 'äº‹ä»¶å·²å¤„ç†'})
        
    except Exception as e:
        db.session.rollback()
        app.logger.error(f'å¤„ç†æ’­æ”¾æ£€æµ‹å¤±è´¥: {e}')
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/webhook/emby/test', methods=['GET', 'POST'])
def test_emby_webhook():
    """æµ‹è¯• Emby Webhook é…ç½®ï¼ˆæ— éœ€ç™»å½•ï¼‰"""
    secret_configured = bool(EMBY_WEBHOOK_SECRET and EMBY_WEBHOOK_SECRET.strip())
    hint = ''
    if secret_configured:
        hint = 'å·²é…ç½®å¯†é’¥éªŒè¯ã€‚è¯·åœ¨ Emby Webhook URL ååŠ  ?token=ä½ çš„å¯†é’¥ï¼Œæˆ–åœ¨ Header ä¸­æ·»åŠ  X-Emby-Secret'
    else:
        hint = 'æœªé…ç½®å¯†é’¥ï¼Œæ‰€æœ‰è¯·æ±‚å‡å¯é€šè¿‡'
    
    return jsonify({
        'success': True,
        'message': 'Emby Webhook æ¥å£æ­£å¸¸',
        'secret_configured': secret_configured,
        'hint': hint,
        'endpoints': {
            'library': '/api/webhook/emby (å…¥åº“é€šçŸ¥)',
            'playback': '/api/webhook/emby/playback (æ’­æ”¾æ£€æµ‹/é»‘åå•)'
        }
    })


@app.route('/api/admin/debug/playback-reporting', methods=['GET'])
@admin_required
def debug_playback_reporting():
    """è°ƒè¯• Playback Reporting æ’ä»¶è¿”å›çš„åŸå§‹æ•°æ®"""
    if not emby_client.is_enabled():
        return jsonify({'success': False, 'error': 'Emby æœªé…ç½®'})
    
    days = request.args.get('days', 7, type=int)
    results = {}
    
    try:
        # æµ‹è¯• user_activity APIï¼ˆä¸»è¦ APIï¼ŒåŒ…å«è®¾å¤‡ä¿¡æ¯ï¼‰
        user_activity_url = f"{emby_client.base_url}/user_usage_stats/user_activity"
        user_activity_params = {
            'api_key': emby_client.api_key,
            'days': days,
            'end_date': datetime.now().strftime('%Y-%m-%d')
        }
        
        ua_response = emby_client.session.get(user_activity_url, params=user_activity_params, timeout=15)
        if ua_response.status_code == 200:
            ua_data = ua_response.json()
            results['user_activity'] = {
                'status': 'ok',
                'total_records': len(ua_data) if isinstance(ua_data, list) else 1,
                'field_names': list(ua_data[0].keys()) if ua_data and isinstance(ua_data, list) and ua_data[0] else [],
                'sample_data': ua_data[:3] if isinstance(ua_data, list) else ua_data
            }
        else:
            results['user_activity'] = {'status': 'error', 'code': ua_response.status_code}
        
        # æµ‹è¯• UserPlaylist API
        playlist_url = f"{emby_client.base_url}/user_usage_stats/UserPlaylist"
        playlist_params = {
            'api_key': emby_client.api_key,
            'days': days,
            'end_date': datetime.now().strftime('%Y-%m-%d'),
            'filter': ''
        }
        
        pl_response = emby_client.session.get(playlist_url, params=playlist_params, timeout=15)
        if pl_response.status_code == 200:
            pl_data = pl_response.json()
            results['user_playlist'] = {
                'status': 'ok',
                'total_records': len(pl_data) if isinstance(pl_data, list) else 1,
                'field_names': list(pl_data[0].keys()) if pl_data and isinstance(pl_data, list) and pl_data[0] else [],
                'sample_data': pl_data[:3] if isinstance(pl_data, list) else pl_data
            }
        else:
            results['user_playlist'] = {'status': 'error', 'code': pl_response.status_code}
        
        # æµ‹è¯• ClientName BreakdownReport API
        breakdown_url = f"{emby_client.base_url}/user_usage_stats/ClientName/BreakdownReport"
        breakdown_params = {
            'api_key': emby_client.api_key,
            'days': days,
            'end_date': datetime.now().strftime('%Y-%m-%d')
        }
        
        bd_response = emby_client.session.get(breakdown_url, params=breakdown_params, timeout=15)
        if bd_response.status_code == 200:
            bd_data = bd_response.json()
            results['client_breakdown'] = {
                'status': 'ok',
                'total_records': len(bd_data) if isinstance(bd_data, list) else 1,
                'data': bd_data
            }
        else:
            results['client_breakdown'] = {'status': 'error', 'code': bd_response.status_code}
        
        return jsonify({
            'success': True,
            'emby_url': emby_client.base_url,
            'results': results
        })
    except Exception as e:
        import traceback
        return jsonify({
            'success': False,
            'error': str(e),
            'traceback': traceback.format_exc()
        })


# ==================== Telegram Bot Webhook ====================
@app.route('/api/webhook/telegram', methods=['POST'])
def telegram_webhook():
    """
    æ¥æ”¶ Telegram Bot Webhook æ¶ˆæ¯
    
    â˜… é‡‡ç”¨"å…ˆè¿”å›200å†å¼‚æ­¥å¤„ç†"æ¨¡å¼ï¼Œé˜²æ­¢å¤„ç†è€—æ—¶è¿‡é•¿å¯¼è‡´ Telegram è¶…æ—¶é‡è¯•
    â˜… é€šè¿‡ secret_token éªŒè¯è¯·æ±‚ç¡®å®æ¥è‡ªå½“å‰é…ç½®çš„ Botï¼Œæ‹’ç»æ—§ Bot çš„æ¶ˆæ¯
    
    è®¾ç½® Webhook æ–¹æ³•:
    1. è·å–ä½ çš„åŸŸåï¼Œå¦‚: https://your-domain.com
    2. è°ƒç”¨: https://api.telegram.org/bot<TOKEN>/setWebhook?url=https://your-domain.com/api/webhook/telegram
    3. æˆ–è€…è®¿é—®æœ¬ç³»ç»Ÿçš„ /api/webhook/telegram/setup?url=https://your-domain.com è‡ªåŠ¨è®¾ç½®
    
    æ”¯æŒçš„å‘½ä»¤:
    - /start - å¼€å§‹ä½¿ç”¨
    - /bind <ç”¨æˆ·å> - ç»‘å®šç½‘ç«™è´¦å·
    - /unbind - è§£ç»‘è´¦å·
    - /status - æŸ¥çœ‹è´¦å·çŠ¶æ€
    """
    if not TELEGRAM_BOT_TOKEN:
        return jsonify({'ok': True})
    
    # â˜… éªŒè¯ secret_tokenï¼šæ‹’ç»éå½“å‰ Bot çš„ Webhook æ¨é€ï¼ˆé˜²æ­¢åˆ‡æ¢ Token åæ—§ Bot æ¶ˆæ¯ä»è¢«å¤„ç†ï¼‰
    if _TELEGRAM_WEBHOOK_SECRET:
        incoming_secret = request.headers.get('X-Telegram-Bot-Api-Secret-Token', '')
        if incoming_secret != _TELEGRAM_WEBHOOK_SECRET:
            app.logger.warning(f'[Webhook] secret_token ä¸åŒ¹é…ï¼Œæ‹’ç»å¤„ç†ï¼ˆå¯èƒ½æ˜¯æ—§ Bot çš„æ¨é€ï¼‰')
            return jsonify({'ok': True})
    
    try:
        data = request.get_json(force=True) or {}
        app.logger.info(f'[Webhook] æ¥æ”¶åˆ°æ•°æ®: {json.dumps(data, ensure_ascii=False)[:500]}')
    except Exception as e:
        app.logger.error(f'[Webhook] è§£æ JSON å¤±è´¥: {e}')
        return jsonify({'ok': True})
    
    # â˜… æ¶ˆæ¯å»é‡ï¼šç”¨ message_id + chat_id åšå”¯ä¸€æ ‡è¯†
    # æ—¥å¿—è¯å®åŒä¸€æ¡æ¶ˆæ¯ä¼šä»¥ä¸åŒ update_id è¢«æ¨é€å¤šæ¬¡ï¼Œæ‰€ä»¥ update_id å»é‡æ— æ•ˆ
    # å¿…é¡»ç”¨æ¶ˆæ¯æœ¬èº«çš„æ ‡è¯†æ¥å»é‡
    msg_key = None
    msg = data.get('message') or data.get('callback_query', {}).get('message')
    cb = data.get('callback_query')
    if cb:
        # callback_query ç”¨ callback_id å»é‡
        msg_key = f"cb_{cb.get('id')}"
    elif msg:
        # æ™®é€šæ¶ˆæ¯ç”¨ chat_id + message_id å»é‡
        chat_id = msg.get('chat', {}).get('id')
        message_id = msg.get('message_id')
        if chat_id and message_id:
            msg_key = f"{chat_id}_{message_id}"
    
    if msg_key:
        with _PROCESSED_MSG_KEYS_LOCK:
            if msg_key in _PROCESSED_MSG_KEYS:
                app.logger.info(f'[Webhook] è·³è¿‡é‡å¤æ¶ˆæ¯ key={msg_key}')
                return jsonify({'ok': True})
            _PROCESSED_MSG_KEYS.add(msg_key)
            # é˜²æ­¢å†…å­˜æ— é™å¢é•¿
            if len(_PROCESSED_MSG_KEYS) > _PROCESSED_MSG_KEYS_MAX:
                _PROCESSED_MSG_KEYS.clear()
    
    # â˜… å…ˆè¿”å› 200 ç»™ Telegramï¼Œå†åœ¨åå°çº¿ç¨‹å¤„ç†æ¶ˆæ¯
    # è¿™æ ·å³ä½¿å¤„ç†è€—æ—¶è¾ƒé•¿ï¼ˆå‘å›¾ç‰‡ã€æŸ¥æ•°æ®åº“ï¼‰ï¼ŒTelegram ä¹Ÿä¸ä¼šå› ä¸ºè¶…æ—¶è€Œé‡è¯•æ¨é€
    def _process_in_background(data_copy):
        with app.app_context():
            try:
                _do_process_telegram_update(data_copy)
            except Exception as e:
                app.logger.error(f'[Webhook] åå°å¤„ç†å¼‚å¸¸: {e}', exc_info=True)
    
    t = threading.Thread(target=_process_in_background, args=(data,), daemon=True)
    t.start()
    
    return jsonify({'ok': True})


def _do_process_telegram_update(data):
    """å®é™…å¤„ç† Telegram Webhook æ¨é€çš„æ¶ˆæ¯ï¼ˆåœ¨åå°çº¿ç¨‹ä¸­æ‰§è¡Œï¼‰"""
    
    # å¤„ç†å›è°ƒæŸ¥è¯¢ï¼ˆå†…è”æŒ‰é’®ç‚¹å‡»ï¼‰
    callback_query = data.get('callback_query')
    if callback_query:
        return handle_callback_query(callback_query)
    
    # å¤„ç† chat_member äº‹ä»¶ï¼ˆç”¨æˆ·é€€ç¾¤/è¢«è¸¢ â†’ ç¡¬åˆ é™¤è´¦å·ï¼‰
    chat_member_update = data.get('chat_member')
    if chat_member_update:
        return handle_chat_member_update(chat_member_update)
    
    # å¤„ç†æ¶ˆæ¯
    message = data.get('message', {})
    if not message:
        app.logger.info('[Webhook] æ¶ˆæ¯ä¸ºç©ºæˆ–éæ¶ˆæ¯ç±»å‹æ›´æ–°')
        return jsonify({'ok': True})
    
    chat_id = message.get('chat', {}).get('id')
    text = message.get('text', '').strip()
    message_id = message.get('message_id')  # è·å–æ¶ˆæ¯IDç”¨äºåˆ é™¤
    chat_type = message.get('chat', {}).get('type', '')  # private, group, supergroup
    from_user = message.get('from', {})
    telegram_user_id = from_user.get('id')
    telegram_username = from_user.get('username', '')
    telegram_first_name = from_user.get('first_name', '')
    
    if not chat_id or not text:
        app.logger.info(f'[Webhook] chat_id æˆ– text ä¸ºç©º: chat_id={chat_id}, text={text}')
        return jsonify({'ok': True})
    
    app.logger.info(f'[Webhook] å¤„ç†æ¶ˆæ¯ - chat_id={chat_id}, user_id={telegram_user_id}, username={telegram_username}, text={text[:100]}')
    
    # ç¾¤ç»„ä¸­å¦‚æœæœ‰@æœºå™¨äººï¼Œç§»é™¤@éƒ¨åˆ†
    if chat_type in ['group', 'supergroup']:
        bot_username = get_bot_username()
        if bot_username and f'@{bot_username}' in text:
            text = text.replace(f'@{bot_username}', '').strip()
    
    # å¦‚æœæ˜¯å‘½ä»¤ï¼Œå°è¯•åˆ é™¤ç”¨æˆ·å‘é€çš„å‘½ä»¤æ¶ˆæ¯ï¼ˆ/kk å‘½ä»¤é™¤å¤–ï¼Œå› ä¸ºå®ƒéœ€è¦å›å¤æ¶ˆæ¯æ¥è·å–ç›®æ ‡ç”¨æˆ·ï¼‰
    if text.startswith('/') and message_id and not text.startswith('/kk'):
        delete_telegram_message(chat_id, message_id)
    
    # æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å¤„äºæ³¨å†ŒçŠ¶æ€ï¼ˆç§èŠä¸­ï¼‰
    if chat_type == 'private' and not text.startswith('/'):
        # å…ˆæ£€æŸ¥æ˜¯å¦æ˜¯ç­¾åˆ°éªŒè¯ç ï¼ˆç®—æœ¯é¢˜ï¼‰
        if telegram_user_id in TELEGRAM_CHECKIN_CODES:
            checkin_data = TELEGRAM_CHECKIN_CODES[telegram_user_id]
            
            # æ£€æŸ¥éªŒè¯ç æ˜¯å¦è¿‡æœŸ
            if checkin_data.get('expires_at') and checkin_data['expires_at'] < datetime.now():
                del TELEGRAM_CHECKIN_CODES[telegram_user_id]
                send_telegram_reply(chat_id, "âŒ éªŒè¯ç å·²è¿‡æœŸï¼Œè¯·é‡æ–°å‘é€ /checkin")
                return jsonify({'ok': True})
            
            # éªŒè¯ç®—æœ¯ç­”æ¡ˆ
            try:
                user_answer = int(text.strip())
            except (ValueError, TypeError):
                send_telegram_reply(chat_id, "âŒ è¯·è¾“å…¥æ•°å­—ç­”æ¡ˆï¼Œæˆ–å‘é€ /checkin è·å–æ–°é¢˜ç›®")
                return jsonify({'ok': True})
            if user_answer == checkin_data.get('answer'):
                # éªŒè¯ç æ­£ç¡®ï¼Œæ‰§è¡Œç­¾åˆ°
                try:
                    user_tg = checkin_data.get('user_tg')
                    user = db.session.get(User, user_tg)
                    
                    if not user:
                        send_telegram_reply(chat_id, "âŒ ç”¨æˆ·ä¸å­˜åœ¨")
                        del TELEGRAM_CHECKIN_CODES[telegram_user_id]
                        return jsonify({'ok': True})
                    
                    # è·å–ç­¾åˆ°é…ç½®
                    checkin_config = get_db_config('checkin', {})
                    coin_name = checkin_config.get('coin_name', 'ç§¯åˆ†')
                    
                    # å†æ¬¡æ£€æŸ¥ä»Šå¤©æ˜¯å¦å·²ç­¾åˆ°ï¼ˆé˜²æ­¢å¹¶å‘ï¼‰
                    today = datetime.now().date()
                    existing = CheckInRecord.query.filter_by(
                        user_tg=user.tg,
                        checkin_date=today
                    ).first()
                    
                    if existing:
                        send_telegram_reply(chat_id, "âŒ ä»Šå¤©å·²ç»ç­¾åˆ°è¿‡äº†")
                        del TELEGRAM_CHECKIN_CODES[telegram_user_id]
                        return jsonify({'ok': True})
                    
                    # è®¡ç®—è¿ç»­ç­¾åˆ°å¤©æ•°
                    yesterday = today - timedelta(days=1)
                    yesterday_record = CheckInRecord.query.filter_by(
                        user_tg=user.tg,
                        checkin_date=yesterday
                    ).first()
                    
                    continuous_days = (yesterday_record.continuous_days + 1) if yesterday_record else 1
                    
                    # éšæœºç”Ÿæˆç­¾åˆ°ç§¯åˆ†
                    coin_min = checkin_config.get('coin_min', 1)
                    coin_max = checkin_config.get('coin_max', 10)
                    coins_earned = random.randint(coin_min, coin_max)
                    
                    # åˆ›å»ºç­¾åˆ°è®°å½•
                    checkin_record = CheckInRecord(
                        user_tg=user.tg,
                        checkin_date=today,
                        coins_earned=coins_earned,
                        continuous_days=continuous_days
                    )
                    db.session.add(checkin_record)
                    
                    # æ›´æ–°ç”¨æˆ·ç§¯åˆ†å’Œç­¾åˆ°æ—¶é—´
                    user.coins = (user.coins or 0) + coins_earned
                    user.ch = datetime.now()
                    
                    # åˆ›å»ºç§¯åˆ†äº¤æ˜“è®°å½•
                    coin_trans = CoinTransaction(
                        user_tg=user.tg,
                        amount=coins_earned,
                        balance_after=user.coins,
                        trans_type='checkin',
                        description=f'BOTç­¾åˆ°ï¼Œè¿ç»­{continuous_days}å¤©',
                        related_id=checkin_record.id
                    )
                    db.session.add(coin_trans)
                    
                    db.session.commit()
                    
                    # åˆ é™¤éªŒè¯ç 
                    del TELEGRAM_CHECKIN_CODES[telegram_user_id]
                    
                    app.logger.info(f'ç”¨æˆ·BOTç­¾åˆ°æˆåŠŸ: {user.name}, è·å¾—ç§¯åˆ†: {coins_earned}, è¿ç»­{continuous_days}å¤©')
                    
                    # embyboss é£æ ¼çš„ç­¾åˆ°æˆåŠŸæ–‡æ¡ˆ
                    today_str = datetime.now().strftime('%Y-%m-%d')
                    reply = f"""ğŸ‰ <b>ç­¾åˆ°æˆåŠŸ</b> | +{coins_earned} {coin_name}
ğŸ’´ <b>å½“å‰æŒæœ‰</b> | {user.coins} {coin_name}
ğŸ“… <b>è¿ç»­ç­¾åˆ°</b> | {continuous_days} å¤©
â³ <b>ç­¾åˆ°æ—¥æœŸ</b> | {today_str}"""
                    send_telegram_reply(chat_id, reply)
                    return jsonify({'ok': True})
                    
                except Exception as e:
                    app.logger.error(f'BOTç­¾åˆ°å¤±è´¥: {e}')
                    db.session.rollback()
                    send_telegram_reply(chat_id, f"âŒ ç­¾åˆ°å¤±è´¥: {str(e)}")
                    if telegram_user_id in TELEGRAM_CHECKIN_CODES:
                        del TELEGRAM_CHECKIN_CODES[telegram_user_id]
                    return jsonify({'ok': True})
            else:
                # éªŒè¯ç é”™è¯¯
                send_telegram_reply(chat_id, "âŒ ç­”æ¡ˆé”™è¯¯ï¼Œè¯·é‡æ–°è®¡ç®—æˆ–å‘é€ /checkin è·å–æ–°é¢˜ç›®")
                return jsonify({'ok': True})
        
        # æ£€æŸ¥æ˜¯å¦åœ¨ç­‰å¾…è¾“å…¥æ‹’ç»åŸå› ï¼ˆç®¡ç†å‘˜æ±‚ç‰‡å®¡æ ¸ï¼‰
        reject_state_key = f'mreq_reject_{telegram_user_id}'
        if get_db_config(reject_state_key, None):
            if handle_reject_reason_input(chat_id, telegram_user_id, text):
                return jsonify({'ok': True})
        
        # å†æ£€æŸ¥æ³¨å†ŒçŠ¶æ€
        reg_result = handle_registration_input(chat_id, telegram_user_id, text)
        if reg_result:
            return reg_result
    
    # å¤„ç† /cancel å‘½ä»¤ï¼ˆå–æ¶ˆæ³¨å†ŒçŠ¶æ€ æˆ– å–æ¶ˆæ‹’ç»åŸå› è¾“å…¥ï¼‰
    if text.startswith('/cancel') and chat_type == 'private':
        # æ£€æŸ¥æ˜¯å¦åœ¨ç­‰å¾…æ‹’ç»åŸå› 
        reject_state_key = f'mreq_reject_{telegram_user_id}'
        reject_state = get_db_config(reject_state_key, None)
        if reject_state:
            delete_db_config(reject_state_key)
            # æ¢å¤å®¡æ ¸æ¶ˆæ¯çš„æŒ‰é’®
            req = MovieRequest.query.get(reject_state.get('request_id'))
            if req and req.status == 'pending':
                reply_markup = {
                    'inline_keyboard': [[
                        {'text': 'âœ… æ‰¹å‡†', 'callback_data': f'mreq_approve_{req.id}'},
                        {'text': 'âŒ æ‹’ç»', 'callback_data': f'mreq_reject_{req.id}'}
                    ]]
                }
                # æ¢å¤åŸå§‹å®¡æ ¸æ¶ˆæ¯
                _update_review_message_with_buttons(
                    reject_state.get('chat_id'), reject_state.get('message_id'), req, reply_markup)
            send_telegram_reply(chat_id, "âœ… å·²å–æ¶ˆæ‹’ç»æ“ä½œ")
            return jsonify({'ok': True})
        
        reg_state_key = f'reg_state_{telegram_user_id}'
        reg_state = get_db_config(reg_state_key, None)
        if reg_state:
            delete_db_config(reg_state_key)
            send_telegram_reply(chat_id, "âœ… å·²é€€å‡ºæ³¨å†ŒçŠ¶æ€")
            return jsonify({'ok': True})
    
    # è§£æå‘½ä»¤
    if text.startswith('/start'):
        # æ£€æŸ¥æ˜¯å¦å¸¦æœ‰å‚æ•°ï¼ˆå¦‚ /start gift_xxxï¼‰
        parts = text.split(maxsplit=1)
        if len(parts) > 1 and parts[1].startswith('gift_'):
            # å¤„ç†èµ é€é¢†å–
            gift_code = parts[1][5:]  # ç§»é™¤ 'gift_' å‰ç¼€
            return handle_gift_claim(chat_id, telegram_user_id, telegram_username or telegram_first_name, gift_code)
        
        # åªåœ¨ç§èŠä¸­æ˜¾ç¤ºå›¾ç‰‡é¢æ¿
        if chat_type == 'private':
            caption, reply_markup, photo_url = build_start_panel(
                telegram_user_id, 
                telegram_first_name, 
                telegram_username
            )
            send_telegram_photo_url(chat_id, photo_url, caption, reply_markup)
        else:
            # ç¾¤ç»„ä¸­æç¤ºç§èŠ
            bot_username = get_bot_username()
            user_name = telegram_first_name or telegram_username or 'ç”¨æˆ·'
            reply = f"ğŸ¤– äº²çˆ±çš„ <a href=\"tg://user?id={telegram_user_id}\">{user_name}</a> è¿™æ˜¯ä¸€æ¡ç§èŠå‘½ä»¤"
            if bot_username:
                reply_markup = {
                    'inline_keyboard': [[
                        {'text': 'ğŸ‘‰ ç‚¹å‡»ç§èŠæˆ‘', 'url': f'https://t.me/{bot_username}'}
                    ]]
                }
                send_telegram_reply(chat_id, reply, reply_markup)
            else:
                send_telegram_reply(chat_id, reply)
        return jsonify({'ok': True})
        
    elif text.startswith('/bind'):
        # è§£æç»‘å®šç 
        parts = text.split(maxsplit=1)
        if len(parts) < 2:
            reply = """âŒ è¯·æä¾›ç»‘å®šç 

<b>ç»‘å®šæ­¥éª¤ï¼š</b>
1. ç™»å½•ç½‘ç«™ï¼Œç‚¹å‡»å·¦ä¸‹è§’"ç»‘å®š Telegram"æŒ‰é’®
2. å¤åˆ¶å¼¹çª—ä¸­æ˜¾ç¤ºçš„ç»‘å®šç 
3. å‘é€: <code>/bind ç»‘å®šç </code>"""
            send_telegram_reply(chat_id, reply)
            return jsonify({'ok': True})
        
        bind_input = parts[1].strip().upper()
        
        # æ¸…ç†è¿‡æœŸçš„ç»‘å®šç 
        cleanup_expired_bind_codes()
        
        # æ£€æŸ¥æ˜¯å¦æ˜¯ç»‘å®šç 
        if bind_input in TELEGRAM_BIND_CODES:
            bind_data = TELEGRAM_BIND_CODES[bind_input]
            user_tg = bind_data.get('user_tg')
            user_name = bind_data.get('user_name')
            
            # æŸ¥æ‰¾ç”¨æˆ·
            user = db.session.get(User, user_tg)
            if not user:
                reply = "âŒ ç»‘å®šç æ— æ•ˆæˆ–å·²è¿‡æœŸ"
                send_telegram_reply(chat_id, reply)
                return jsonify({'ok': True})
            
            # æ£€æŸ¥è¯¥ Telegram æ˜¯å¦å·²ç»‘å®šå…¶ä»–è´¦å·
            existing = User.query.filter_by(telegram_id=telegram_user_id).first()
            if existing and existing.tg != user.tg:
                reply = f"âš ï¸ æ‚¨çš„ Telegram å·²ç»‘å®šè´¦å· <b>{existing.name}</b>\n\nå¦‚éœ€æ›´æ¢ï¼Œè¯·å…ˆå‘é€ /unbind è§£ç»‘ã€‚"
                send_telegram_reply(chat_id, reply)
                return jsonify({'ok': True})
            
            # ç»‘å®š
            user.telegram_id = telegram_user_id
            db.session.commit()
            
            # åˆ é™¤å·²ä½¿ç”¨çš„ç»‘å®šç 
            del TELEGRAM_BIND_CODES[bind_input]
            
            # è·å–è®¢é˜…çŠ¶æ€
            status_text = "æœªè®¢é˜…"
            _bind_wl = Subscription.query.filter_by(user_tg=user.tg, plan_type='whitelist', status='active').first()
            if _bind_wl or user.lv == 'a':
                status_text = "âœ… ç™½åå• (æ°¸ä¹…æœ‰æ•ˆ)"
            elif user.ex and user.ex > datetime.now():
                status_text = f"âœ… å·²è®¢é˜… (åˆ°æœŸ: {user.ex.strftime('%Y-%m-%d')})"
            username = bind_input
            
            # æŸ¥æ‰¾ç”¨æˆ·
            user = User.query.filter_by(name=username).first()
            if not user:
                reply = f"""âŒ ç»‘å®šç  <b>{bind_input}</b> æ— æ•ˆæˆ–å·²è¿‡æœŸ

<b>ç»‘å®šæ­¥éª¤ï¼š</b>
1. ç™»å½•ç½‘ç«™ï¼Œç‚¹å‡»å·¦ä¸‹è§’"ç»‘å®š Telegram"æŒ‰é’®
2. å¤åˆ¶å¼¹çª—ä¸­æ˜¾ç¤ºçš„ç»‘å®šç 
3. å‘é€: <code>/bind ç»‘å®šç </code>

ç»‘å®šç æœ‰æ•ˆæœŸä¸º 5 åˆ†é’Ÿã€‚"""
                send_telegram_reply(chat_id, reply)
                return jsonify({'ok': True})
            
            # æ£€æŸ¥æ˜¯å¦å·²è¢«å…¶ä»– Telegram è´¦å·ç»‘å®š
            existing = User.query.filter_by(telegram_id=telegram_user_id).first()
            if existing and existing.tg != user.tg:
                reply = f"âš ï¸ æ‚¨çš„ Telegram å·²ç»‘å®šè´¦å· <b>{existing.name}</b>\n\nå¦‚éœ€æ›´æ¢ï¼Œè¯·å…ˆå‘é€ /unbind è§£ç»‘ã€‚"
                send_telegram_reply(chat_id, reply)
                return jsonify({'ok': True})
            
            # æ£€æŸ¥è¯¥è´¦å·æ˜¯å¦å·²è¢«å…¶ä»– Telegram ç»‘å®š
            if user.telegram_id and user.telegram_id != telegram_user_id:
                reply = f"âš ï¸ è´¦å· <b>{username}</b> å·²è¢«å…¶ä»– Telegram ç»‘å®š"
                send_telegram_reply(chat_id, reply)
                return jsonify({'ok': True})
            
            # ç»‘å®š
            user.telegram_id = telegram_user_id
            db.session.commit()
            
            # è·å–è®¢é˜…çŠ¶æ€
            status_text = "æœªè®¢é˜…"
            _bind2_wl = Subscription.query.filter_by(user_tg=user.tg, plan_type='whitelist', status='active').first()
            if _bind2_wl or user.lv == 'a':
                status_text = "âœ… ç™½åå• (æ°¸ä¹…æœ‰æ•ˆ)"
            elif user.ex and user.ex > datetime.now():
                status_text = f"âœ… å·²è®¢é˜… (åˆ°æœŸ: {user.ex.strftime('%Y-%m-%d')})"
            
            reply = f"""âœ… <b>ç»‘å®šæˆåŠŸï¼</b>

ğŸ‘¤ ç”¨æˆ·å: <b>{user.name}</b>
ğŸ“Š è®¢é˜…çŠ¶æ€: {status_text}

æ‚¨å°†æ”¶åˆ°ï¼š
â€¢ æ±‚ç‰‡è¿›åº¦é€šçŸ¥
â€¢ è®¢é˜…åˆ°æœŸæé†’
â€¢ ç³»ç»Ÿå…¬å‘Šæ¨é€"""
            send_telegram_reply(chat_id, reply)
        
    elif text.startswith('/unbind'):
        # æŸ¥æ‰¾ç»‘å®šçš„ç”¨æˆ·
        user = User.query.filter_by(telegram_id=telegram_user_id).first()
        if not user:
            reply = "âŒ æ‚¨å°šæœªç»‘å®šä»»ä½•è´¦å·"
            send_telegram_reply(chat_id, reply)
            return jsonify({'ok': True})
        
        username = user.name
        user.telegram_id = None
        db.session.commit()
        
        reply = f"âœ… å·²è§£ç»‘è´¦å· <b>{username}</b>\n\næ‚¨å°†ä¸å†æ”¶åˆ°é€šçŸ¥æ¶ˆæ¯ã€‚"
        send_telegram_reply(chat_id, reply)
        
    elif text.startswith('/status'):
        # æŸ¥æ‰¾ç»‘å®šçš„ç”¨æˆ·
        user = User.query.filter_by(telegram_id=telegram_user_id).first()
        if not user:
            reply = "âŒ æ‚¨å°šæœªç»‘å®šè´¦å·\n\nè¯·å…ˆå‘é€: <code>/bind ä½ çš„ç”¨æˆ·å</code>"
            send_telegram_reply(chat_id, reply)
            return jsonify({'ok': True})
        
        # è·å–è®¢é˜…çŠ¶æ€
        status_text = "âŒ æœªè®¢é˜…"
        _status_wl = Subscription.query.filter_by(user_tg=user.tg, plan_type='whitelist', status='active').first()
        if _status_wl or user.lv == 'a':
            status_text = "âœ… ç™½åå• (æ°¸ä¹…æœ‰æ•ˆ)"
        elif user.lv == 'c':
            status_text = "ğŸš« å·²ç¦ç”¨"
        elif user.ex and user.ex > datetime.now():
            days_left = (user.ex - datetime.now()).days
            status_text = f"âœ… å·²è®¢é˜… ({days_left} å¤©ååˆ°æœŸ)"
        
        # è·å–ä»Šæ—¥æ±‚ç‰‡æ¬¡æ•°
        today_count = user.get_today_request_count()
        daily_limit = user.get_daily_limit()
        
        # Emby ç»‘å®šçŠ¶æ€
        emby_status = "âœ… å·²ç»‘å®š" if user.embyid else "âŒ æœªç»‘å®š"
        
        reply = f"""ğŸ“Š <b>è´¦å·çŠ¶æ€</b>

ğŸ‘¤ ç”¨æˆ·å: <b>{user.name}</b>
ğŸ“± Telegram ID: <code>{telegram_user_id}</code>
ğŸ¬ Emby: {emby_status}

ğŸ“Š è®¢é˜…çŠ¶æ€: {status_text}
ğŸ¯ ä»Šæ—¥æ±‚ç‰‡: {today_count}/{daily_limit}"""
        send_telegram_reply(chat_id, reply)
    
    elif text.startswith('/count'):
        # æ£€æŸ¥æ˜¯å¦ä¸ºç§èŠ
        chat_type = message.get('chat', {}).get('type', '')
        if chat_type != 'private':
            # ç¾¤ç»„ä¸­æç¤ºå»ç§èŠï¼Œä½¿ç”¨ inline button
            user_name = telegram_first_name or telegram_username or 'ç”¨æˆ·'
            bot_username = get_bot_username()
            reply = f"ğŸ¤– äº²çˆ±çš„ <a href=\"tg://user?id={telegram_user_id}\">{user_name}</a> è¿™æ˜¯ä¸€æ¡ç§èŠå‘½ä»¤"
            if bot_username:
                reply_markup = {
                    'inline_keyboard': [[
                        {'text': 'ğŸ‘‰ ç‚¹å‡»æˆ‘(â€¢Ì€á´—â€¢Ì)Ùˆ', 'url': f'https://t.me/{bot_username}'}
                    ]]
                }
                send_telegram_reply(chat_id, reply, reply_markup)
            else:
                send_telegram_reply(chat_id, reply + "\n\nè¯·ç§èŠæœºå™¨äººå‘é€ /count")
            return jsonify({'ok': True})
        
        # è·å–åª’ä½“åº“ç»Ÿè®¡
        try:
            counts = emby_client.get_library_counts()
            reply = f"""ğŸ¬ ç”µå½±æ•°é‡ï¼š{counts.get('movies', 0)}
ğŸ“½ï¸ å‰§é›†æ•°é‡ï¼š{counts.get('series', 0)}
ğŸï¸ æ€»é›†æ•°ï¼š{counts.get('episodes', 0)}"""
        except Exception as e:
            app.logger.error(f'è·å–åª’ä½“åº“ç»Ÿè®¡å¤±è´¥: {e}')
            reply = "âŒ è·å–åª’ä½“åº“ç»Ÿè®¡å¤±è´¥ï¼Œè¯·ç¨åå†è¯•"
        send_telegram_reply(chat_id, reply)
    
    elif text.startswith('/myinfo'):
        # æŸ¥æ‰¾ç”¨æˆ·ä¿¡æ¯
        user_name = telegram_first_name or telegram_username or 'ç”¨æˆ·'
        user = User.query.filter_by(telegram_id=telegram_user_id).first()
        
        # è·å–è´§å¸åç§°é…ç½®
        checkin_config = get_db_config('checkin', {})
        coin_name = checkin_config.get('coin_name', 'ç§¯åˆ†')
        
        if user and user.lv in ['a', 'b', 'c']:
            # å·²æ³¨å†Œç”¨æˆ·
            # çŠ¶æ€åˆ¤æ–­
            _me_wl = Subscription.query.filter_by(user_tg=user.tg, plan_type='whitelist', status='active').first()
            if _me_wl or user.lv == 'a':
                status = "ç™½åå•"
            elif user.lv == 'c':
                status = "å·²å°ç¦"
            elif user.ex and user.ex > datetime.now():
                status = "æ­£å¸¸"
            else:
                status = "å·²è¿‡æœŸ"
            
            # åˆ°æœŸæ—¶é—´
            if _me_wl or user.lv == 'a':
                expire_time = "+ âˆ"
            elif user.ex:
                expire_time = user.ex.strftime('%Y-%m-%d %H:%M:%S')
            else:
                expire_time = "æœªè®¾ç½®"
            
            # è´¦å·åç§°
            account_name = user.name if user.name else "æ— è´¦æˆ·ä¿¡æ¯"
            
            # è·å–æœ€è¿‘30å¤©è§‚çœ‹æ—¶é—´
            watch_time_30days = get_user_watch_time_30days(user.tg)
            if watch_time_30days > 0:
                watch_time_text = f"{watch_time_30days} åˆ†é’Ÿ"
            else:
                watch_time_text = "æ— è®°å½•"
            
            reply = f"""Â· ğŸ‰ TG&åç§° | {user_name}
Â· ğŸ’ è¯†åˆ«ã®ID | {telegram_user_id}
Â· ğŸ“ å½“å‰çŠ¶æ€ | {status}
Â· ğŸ¥ æŒæœ‰{coin_name} | {user.coins or 0}
Â· ğŸ’  è´¦å·åç§° | {account_name}
Â· ğŸš¨ åˆ°æœŸæ—¶é—´ | {expire_time}
Â· ğŸ“… è¿‡å»30å¤© | {watch_time_text}"""
        else:
            # æœªæ³¨å†Œç”¨æˆ·
            reply = f"""Â· ğŸ‰ TG&åç§° | {user_name}
Â· ğŸ’ è¯†åˆ«ã®ID | {telegram_user_id}
Â· ğŸ“ å½“å‰çŠ¶æ€ | æœªæ³¨å†Œ
Â· ğŸ¥ æŒæœ‰{coin_name} | 0
Â· ğŸ’  è´¦å·åç§° | æ— è´¦æˆ·ä¿¡æ¯
Â· ğŸš¨ åˆ°æœŸæ—¶é—´ | æ— è´¦æˆ·ä¿¡æ¯"""
        
        send_telegram_reply(chat_id, reply)
    
    elif text.startswith('/checkin'):
        # æ£€æŸ¥æ˜¯å¦ä¸ºç§èŠ
        if chat_type != 'private':
            user_name = telegram_first_name or telegram_username or 'ç”¨æˆ·'
            bot_username = get_bot_username()
            reply = f"ğŸ¤– äº²çˆ±çš„ <a href=\"tg://user?id={telegram_user_id}\">{user_name}</a> è¿™æ˜¯ä¸€æ¡ç§èŠå‘½ä»¤"
            if bot_username:
                reply_markup = {
                    'inline_keyboard': [[
                        {'text': 'ğŸ‘‰ ç‚¹å‡»æˆ‘(â€¢Ì€á´—â€¢Ì)Ùˆ', 'url': f'https://t.me/{bot_username}'}
                    ]]
                }
                send_telegram_reply(chat_id, reply, reply_markup)
            else:
                send_telegram_reply(chat_id, reply + "\n\nè¯·ç§èŠæœºå™¨äººå‘é€ /checkin")
            return jsonify({'ok': True})
        
        # è·å–ç­¾åˆ°é…ç½®
        checkin_config = get_db_config('checkin', {})
        coin_name = checkin_config.get('coin_name', 'ç§¯åˆ†')
        
        # æ£€æŸ¥ç­¾åˆ°åŠŸèƒ½æ˜¯å¦å¯ç”¨
        if not checkin_config.get('enabled', False):
            send_telegram_reply(chat_id, "âŒ ç­¾åˆ°åŠŸèƒ½æœªå¼€å¯")
            return jsonify({'ok': True})
        
        # æ£€æŸ¥BOTç­¾åˆ°åŠŸèƒ½æ˜¯å¦å¯ç”¨
        if not checkin_config.get('bot_enabled', False):
            send_telegram_reply(chat_id, "âŒ ç®¡ç†å‘˜æœªå¼€å¯BOTç­¾åˆ°")
            return jsonify({'ok': True})
        
        # æŸ¥æ‰¾ç”¨æˆ·
        user = User.query.filter_by(telegram_id=telegram_user_id).first()
        if not user:
            send_telegram_reply(chat_id, "âŒ æ‚¨è¿˜æœªç»‘å®šè´¦å·\n\nè¯·å…ˆä½¿ç”¨ /bind å‘½ä»¤ç»‘å®šè´¦å·")
            return jsonify({'ok': True})
        
        # ç­¾åˆ°æƒé™æ£€æŸ¥
        checkin_perm = checkin_config.get('checkin_permission', 'all')
        if checkin_perm == 'none':
            send_telegram_reply(chat_id, "âŒ ç®¡ç†å‘˜å·²å…³é—­ç­¾åˆ°åŠŸèƒ½")
            return jsonify({'ok': True})
        if checkin_perm == 'subscribed':
            if not user.ex or user.ex < datetime.now():
                send_telegram_reply(chat_id, "âŒ ä»…é™æœ‰è®¢é˜…çš„ç”¨æˆ·ç­¾åˆ°ï¼Œè¯·å…ˆè®¢é˜…åå†æ¥ç­¾åˆ°")
                return jsonify({'ok': True})
        
        # æ£€æŸ¥ä»Šå¤©æ˜¯å¦å·²ç­¾åˆ°
        today = datetime.now().date()
        existing = CheckInRecord.query.filter_by(
            user_tg=user.tg,
            checkin_date=today
        ).first()
        
        if existing:
            # embyboss é£æ ¼æ–‡æ¡ˆ
            reply = f"""â­• <b>æ‚¨ä»Šå¤©å·²ç»ç­¾åˆ°è¿‡äº†ï¼</b>

ğŸ‰ <b>ä»Šæ—¥è·å¾—</b> | {existing.coins_earned} {coin_name}
ğŸ’´ <b>å½“å‰æŒæœ‰</b> | {user.coins or 0} {coin_name}
ğŸ“… <b>è¿ç»­ç­¾åˆ°</b> | {existing.continuous_days} å¤©

ç­¾åˆ°æ˜¯æ— èŠçš„æ´»åŠ¨å“¦ï¼Œæ˜å¤©å†æ¥å§~"""
            send_telegram_reply(chat_id, reply)
            return jsonify({'ok': True})
        
        # ç”Ÿæˆç®—æœ¯éªŒè¯ç 
        op = random.choice(['+', '-', 'Ã—'])
        if op == '+':
            a, b = random.randint(1, 50), random.randint(1, 50)
            math_answer = a + b
        elif op == '-':
            a = random.randint(10, 50)
            b = random.randint(1, a)
            math_answer = a - b
        else:
            a, b = random.randint(2, 12), random.randint(2, 12)
            math_answer = a * b
        question = f"{a} {op} {b}"
        
        # æ¸…ç†è¿‡æœŸçš„éªŒè¯ç 
        now = datetime.now()
        expired_keys = [uid for uid, data in TELEGRAM_CHECKIN_CODES.items() 
                       if data.get('expires_at') and data['expires_at'] < now]
        for key in expired_keys:
            del TELEGRAM_CHECKIN_CODES[key]
        
        # ä¿å­˜ç®—æœ¯ç­”æ¡ˆï¼ˆ1åˆ†é’Ÿæœ‰æ•ˆæœŸï¼‰
        TELEGRAM_CHECKIN_CODES[telegram_user_id] = {
            'answer': math_answer,
            'user_tg': user.tg,
            'created_at': now,
            'expires_at': now + timedelta(minutes=1)
        }
        
        reply = f"""ğŸ¯ <b>ç­¾åˆ°éªŒè¯</b>

è¯·è®¡ç®—ä»¥ä¸‹ç®—å¼å¹¶å›å¤ç»“æœï¼š

<code>{question} = ?</code>

â± æœ‰æ•ˆæœŸ: 1 åˆ†é’Ÿ"""
        send_telegram_reply(chat_id, reply)
    
    elif text.startswith('/create'):
        # /create å‘½ä»¤ï¼šç”¨æˆ·åå†²çªæ—¶åˆ›å»ºè‡ªå®šä¹‰ç”¨æˆ·åè´¦å·
        # åªåœ¨ç§èŠä¸­æœ‰æ•ˆ
        if chat_type != 'private':
            return jsonify({'ok': True})
        
        parts = text.split(maxsplit=1)
        if len(parts) < 2:
            send_telegram_reply(chat_id, "âŒ è¯·æä¾›ç”¨æˆ·å\n\nç”¨æ³•ï¼š<code>/create æ‚¨çš„ç”¨æˆ·å</code>")
            return jsonify({'ok': True})
        
        custom_username = parts[1].strip()
        
        # éªŒè¯ç”¨æˆ·åæ ¼å¼
        if len(custom_username) < 1:
            send_telegram_reply(chat_id, "âŒ ç”¨æˆ·åè‡³å°‘éœ€è¦ 1 ä¸ªå­—ç¬¦")
            return jsonify({'ok': True})
        
        if len(custom_username) > 20:
            send_telegram_reply(chat_id, "âŒ ç”¨æˆ·åä¸èƒ½è¶…è¿‡ 20 ä¸ªå­—ç¬¦")
            return jsonify({'ok': True})
        
        # æ£€æŸ¥ç”¨æˆ·åæ˜¯å¦åŒ…å«éæ³•å­—ç¬¦
        import re
        if not re.match(r'^[a-zA-Z0-9_\u4e00-\u9fff]+$', custom_username):
            send_telegram_reply(chat_id, "âŒ ç”¨æˆ·ååªèƒ½åŒ…å«å­—æ¯ã€æ•°å­—ã€ä¸‹åˆ’çº¿å’Œä¸­æ–‡")
            return jsonify({'ok': True})
        
        # æ£€æŸ¥æ˜¯å¦æœ‰åŒåEmbyè´¦å·
        name_conflict = User.query.filter_by(emby_name=custom_username).first()
        if name_conflict:
            send_telegram_reply(chat_id, f"âŒ ç”¨æˆ·å <b>{custom_username}</b> å·²è¢«å ç”¨ï¼Œè¯·æ¢ä¸€ä¸ª")
            return jsonify({'ok': True})
        
        # æŸ¥æ‰¾è¯¥ç”¨æˆ·çš„å¾…é¢†å–èµ é€ç 
        pending_gift = None
        pending_gift_key = None
        
        # éå†æŸ¥æ‰¾ï¼ˆç®€å•å®ç°ï¼Œå¯ä¼˜åŒ–ï¼‰
        all_configs = get_all_db_configs()
        for key, value in all_configs.items():
            if key.startswith('gift_') and isinstance(value, dict):
                if value.get('pending_create') and value.get('telegram_user_id') == telegram_user_id:
                    pending_gift = value
                    pending_gift_key = key
                    break
        
        if not pending_gift:
            send_telegram_reply(chat_id, "âŒ æ‚¨æ²¡æœ‰å¾…é¢†å–çš„èµ é€\n\nå¦‚æœ‰èµ é€é“¾æ¥ï¼Œè¯·å…ˆç‚¹å‡»é“¾æ¥é¢†å–ã€‚")
            return jsonify({'ok': True})
        
        # è·å–èµ é€ç 
        gift_code = pending_gift_key[5:]  # ç§»é™¤ 'gift_' å‰ç¼€
        
        # åˆ›å»ºè´¦å·
        return create_gift_account(chat_id, telegram_user_id, custom_username, gift_code, pending_gift)
    
    elif text.startswith('/kk'):
        # /kk å‘½ä»¤ï¼šç®¡ç†å‘˜ç”¨æˆ·ç®¡ç†å¿«æ·æ“ä½œ
        # ç”¨æ³•ï¼š
        # 1. å›å¤æ¶ˆæ¯ /kk
        # 2. /kk tgidï¼ˆtgid æ˜¯ Telegram ç”¨æˆ·IDï¼‰
        
        # åˆ é™¤ç”¨æˆ·å‘é€çš„ /kk å‘½ä»¤æ¶ˆæ¯
        if message_id:
            delete_telegram_message(chat_id, message_id)
        
        # æ£€æŸ¥æ˜¯å¦åœ¨ç®¡ç†å‘˜ç¾¤ç»„ä¸­å‘é€ï¼ˆTELEGRAM_CHAT_IDï¼‰
        if str(chat_id) != str(TELEGRAM_CHAT_ID):
            # éç®¡ç†ç¾¤ç»„ï¼Œé™é»˜å¿½ç•¥
            return jsonify({'ok': True})
        
        # æ£€æŸ¥æ˜¯å¦æ˜¯ BOT ç®¡ç†å‘˜ï¼ˆå¿…é¡»é…ç½®ä¸”åœ¨åˆ—è¡¨ä¸­æ‰èƒ½ä½¿ç”¨ï¼‰
        config = load_system_config()
        bot_admins_str = config.get('telegram', {}).get('bot_admins', '')
        bot_admin_ids = [x.strip() for x in bot_admins_str.split(',') if x.strip()]
        
        # å¦‚æœæœªé…ç½® bot_admins æˆ–è€…ç”¨æˆ·ä¸åœ¨åˆ—è¡¨ä¸­ï¼Œé™é»˜å¿½ç•¥ï¼ˆä¸å‘é€ä»»ä½•æ¶ˆæ¯ï¼‰
        if not bot_admin_ids or str(telegram_user_id) not in bot_admin_ids:
            app.logger.info(f'[/kk] æƒé™æ‹’ç» - ç”¨æˆ· {telegram_user_id} ä¸åœ¨ç®¡ç†å‘˜åˆ—è¡¨ {bot_admin_ids}')
            return jsonify({'ok': True})
        
        # è§£æå‘½ä»¤å‚æ•°
        parts = text.split()
        target_user_id = None
        target_username = None
        target_first_name = None
        
        # æ£€æŸ¥æ˜¯å¦æ˜¯å›å¤æ¶ˆæ¯
        reply_to_message = message.get('reply_to_message', {})
        if reply_to_message:
            # å›å¤æ¨¡å¼ï¼š/kk
            target_user = reply_to_message.get('from', {})
            target_user_id = target_user.get('id')
            target_username = target_user.get('username', '')
            target_first_name = target_user.get('first_name', '')
        else:
            # ç›´æ¥æŒ‡å®šæ¨¡å¼ï¼š/kk tgid
            if len(parts) < 2:
                send_telegram_reply(chat_id, """âŒ å‚æ•°ä¸è¶³

<b>ç”¨æ³•ï¼š</b>
1. å›å¤ç”¨æˆ·æ¶ˆæ¯ï¼š<code>/kk</code>
2. æŒ‡å®š Telegram IDï¼š<code>/kk tgid</code>

<b>ç¤ºä¾‹ï¼š</b>
<code>/kk 123456789</code> - ç®¡ç† TG ID 123456789 ç”¨æˆ·""")
                return jsonify({'ok': True})
            
            # è§£æ tgid
            tg_input = parts[1]
            if tg_input.startswith('@'):
                # @username æ ¼å¼
                target_username = tg_input[1:]  # ç§»é™¤ @
            else:
                # å°è¯•è§£æä¸ºæ•°å­— ID
                try:
                    target_user_id = int(tg_input)
                except ValueError:
                    # ä¸æ˜¯æ•°å­—ï¼Œå½“ä½œç”¨æˆ·å
                    target_username = tg_input
        
        if not target_user_id and not target_username:
            send_telegram_reply(chat_id, "âŒ æ— æ³•è¯†åˆ«ç›®æ ‡ç”¨æˆ·")
            return jsonify({'ok': True})
        
        # æ£€æŸ¥ç›®æ ‡ç”¨æˆ·æ˜¯å¦åœ¨æˆæƒç¾¤ç»„å†…
        if target_user_id:
            try:
                member_url = f'https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/getChatMember'
                member_resp = PROXY_SESSION.post(member_url, json={
                    'chat_id': TELEGRAM_CHAT_ID,
                    'user_id': target_user_id
                }, timeout=5)
                member_data = member_resp.json()
                if member_data.get('ok'):
                    member_status = member_data.get('result', {}).get('status', '')
                    if member_status in ('left', 'kicked'):
                        send_telegram_reply(chat_id, "âŒ è¯¥ç”¨æˆ·ä¸åœ¨ç¾¤ç»„å†…ï¼Œæ— æ³•æ“ä½œ")
                        return jsonify({'ok': True})
                else:
                    # API è°ƒç”¨å¤±è´¥ï¼ˆç”¨æˆ·ä»æœªåŠ å…¥è¿‡ç¾¤ç»„ç­‰æƒ…å†µï¼‰
                    app.logger.warning(f'[/kk] getChatMember å¤±è´¥: {member_data}')
                    send_telegram_reply(chat_id, "âŒ è¯¥ç”¨æˆ·ä¸åœ¨ç¾¤ç»„å†…ï¼Œæ— æ³•æ“ä½œ")
                    return jsonify({'ok': True})
            except Exception as e:
                app.logger.warning(f'[/kk] æ£€æŸ¥ç”¨æˆ·ç¾¤ç»„æˆå‘˜çŠ¶æ€å¤±è´¥: {e}')
                send_telegram_reply(chat_id, "âŒ æ£€æŸ¥ç”¨æˆ·ç¾¤ç»„çŠ¶æ€å¤±è´¥ï¼Œè¯·ç¨åå†è¯•")
                return jsonify({'ok': True})
        
        # è·å–ç³»ç»Ÿé…ç½®ä¸­çš„èµ é€å¤©æ•°
        config = load_system_config()
        gift_days = config.get('telegram', {}).get('gift_days', 30)
        
        # è·å–è´§å¸åç§°é…ç½®
        checkin_config = get_db_config('checkin', {})
        coin_name = checkin_config.get('coin_name', 'ç§¯åˆ†')
        
        # å¦‚æœæ²¡æœ‰ first_nameï¼ˆé€šè¿‡ tgid æŒ‡å®šç”¨æˆ·æ—¶ï¼‰ï¼Œå°è¯•é€šè¿‡ Telegram API è·å–
        if target_user_id and not target_first_name:
            try:
                chat_url = f'https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/getChat'
                chat_resp = PROXY_SESSION.post(chat_url, json={'chat_id': target_user_id}, timeout=5)
                chat_data = chat_resp.json()
                if chat_data.get('ok'):
                    result = chat_data.get('result', {})
                    target_first_name = result.get('first_name', '')
                    if not target_username:
                        target_username = result.get('username', '')
            except Exception as e:
                app.logger.warning(f'[/kk] è·å–ç”¨æˆ· {target_user_id} Telegramä¿¡æ¯å¤±è´¥: {e}')
        
        # æŸ¥è¯¢ç”¨æˆ·åœ¨æ•°æ®åº“ä¸­çš„ä¿¡æ¯
        existing_user = None
        if target_user_id:
            existing_user = User.query.filter_by(telegram_id=target_user_id).first()
        
        # æ„å»ºç”¨æˆ·ä¿¡æ¯æ˜¾ç¤º - æŒ‰ç…§æ–°æ ¼å¼
        from html import escape as html_escape
        display_name = html_escape(target_username or target_first_name or str(target_user_id))
        
        # TGåç§°å¸¦é“¾æ¥
        if target_user_id:
            tg_name_link = f'<a href="tg://user?id={target_user_id}">{display_name}</a>'
        else:
            tg_name_link = display_name
        
        if existing_user:
            # ç”¨æˆ·å·²æœ‰ç½‘ç«™è´¦å·
            # çŠ¶æ€åˆ¤æ–­
            _exist_wl = Subscription.query.filter_by(user_tg=existing_user.tg, plan_type='whitelist', status='active').first()
            if _exist_wl or existing_user.lv == 'a':
                status = "ç™½åå•"
            elif existing_user.lv == 'c':
                status = "å·²å°ç¦"
            elif existing_user.ex and existing_user.ex > datetime.now():
                status = "æ­£å¸¸"
            else:
                status = "å·²è¿‡æœŸ"
            
            # åˆ°æœŸæ—¶é—´
            if _exist_wl or existing_user.lv == 'a':
                expire_time = "+ âˆ"
            elif existing_user.ex:
                expire_time = existing_user.ex.strftime('%Y-%m-%d %H:%M:%S')
            else:
                expire_time = "å·²è¿‡æœŸ"
            
            # è´¦å·åç§°ï¼ˆEmby è´¦å·ï¼‰
            account_name = html_escape(existing_user.emby_name) if existing_user.emby_name else "æ— è´¦æˆ·ä¿¡æ¯"
            
            user_info = f"""Â· ğŸ‰ TG&åç§° | {tg_name_link}
Â· ğŸ’ è¯†åˆ«ã®ID | {target_user_id}
Â· ğŸ“ å½“å‰çŠ¶æ€ | {status}
Â· ğŸ¥ æŒæœ‰{coin_name} | {existing_user.coins or 0}
Â· ğŸ’  è´¦å·åç§° | {account_name}
Â· ğŸš¨ åˆ°æœŸæ—¶é—´ | {expire_time}"""
        else:
            # æœªæ³¨å†Œç”¨æˆ·
            user_info = f"""Â· ğŸ‰ TG&åç§° | {tg_name_link}
Â· ğŸ’ è¯†åˆ«ã®ID | {target_user_id}
Â· ğŸ“ å½“å‰çŠ¶æ€ | æ— è´¦æˆ·ä¿¡æ¯
Â· ğŸ¥ æŒæœ‰{coin_name} | 0
Â· ğŸ’  è´¦å·åç§° | æ— è´¦æˆ·ä¿¡æ¯
Â· ğŸš¨ åˆ°æœŸæ—¶é—´ | å·²è¿‡æœŸ"""
        
        # åˆ›å»ºå†…è”æŒ‰é’® - æ°´å¹³æ’åˆ—èµ é€å’Œè¸¢å‡ºï¼Œåˆ é™¤æ¶ˆæ¯å•ç‹¬ä¸€è¡Œ
        # callback_data åªä¼  user_idï¼Œé¿å…è¶…è¿‡ Telegram 64å­—èŠ‚é™åˆ¶
        # å°†ç›®æ ‡ç”¨æˆ·ä¿¡æ¯å­˜å…¥ç¼“å­˜ï¼Œå›è°ƒæ—¶æŸ¥è¯¢
        kk_cache_key = f'kk_target_{target_user_id}'
        set_db_config(kk_cache_key, {
            'username': target_username or '',
            'first_name': target_first_name or '',
            'cached_at': datetime.now().isoformat()
        })
        reply_markup = {
            'inline_keyboard': [
                [
                    {'text': 'ğŸ èµ é€èµ„æ ¼', 'callback_data': f'kk_gift_{target_user_id}'},
                    {'text': 'ğŸš« è¸¢å‡ºå¹¶åˆ é™¤', 'callback_data': f'kk_kick_{target_user_id}'}
                ],
                [
                    {'text': 'ğŸ—‘ï¸ åˆ é™¤æ¶ˆæ¯', 'callback_data': 'kk_delete_0'}
                ]
            ]
        }
        
        send_telegram_reply(chat_id, user_info, reply_markup)
        app.logger.info(f'[/kk] ç®¡ç†å‘˜ {telegram_user_id} æ˜¾ç¤ºç”¨æˆ·æ“ä½œèœå•: {target_username or target_user_id}')
    
    # ä¸å›å¤æœªçŸ¥å‘½ä»¤ï¼Œåªå¤„ç†å·²å®šä¹‰çš„å‘½ä»¤
    
    return jsonify({'ok': True})


def handle_callback_query(callback_query):
    """å¤„ç†å†…è”æŒ‰é’®å›è°ƒ"""
    callback_id = None
    try:
        callback_id = callback_query.get('id')
        callback_data = callback_query.get('data', '')
        from_user = callback_query.get('from', {})
        user_id = from_user.get('id')
        user_username = from_user.get('username', '')  # TG ç”¨æˆ·åï¼ˆå¯èƒ½ä¸ºç©ºï¼‰
        user_first_name = from_user.get('first_name', '')  # æ˜¾ç¤ºåç§°
        username = user_username or user_first_name  # å…¼å®¹æ—§ä»£ç 
        message = callback_query.get('message', {})
        chat_id = message.get('chat', {}).get('id')
        message_id = message.get('message_id')
        
        app.logger.info(f'[Callback] æ”¶åˆ°å›è°ƒ: data={callback_data}, user_id={user_id}, chat_id={chat_id}')
        
        # å¤„ç† /kk å‘½ä»¤çš„å›è°ƒ
        if callback_data.startswith('kk_'):
            # æ£€æŸ¥æ˜¯å¦åœ¨ç®¡ç†å‘˜ç¾¤ç»„
            if str(chat_id) != str(TELEGRAM_CHAT_ID):
                answer_callback_query(callback_id, "âŒ åªèƒ½åœ¨ç®¡ç†ç¾¤ç»„ä¸­æ“ä½œ", show_alert=True)
                return jsonify({'ok': True})
            
            # æ£€æŸ¥æ“ä½œè€…æ˜¯å¦æ˜¯ BOT ç®¡ç†å‘˜
            config = load_system_config()
            bot_admins_str = config.get('telegram', {}).get('bot_admins', '')
            bot_admin_ids = [x.strip() for x in bot_admins_str.split(',') if x.strip()]
            
            if not bot_admin_ids or str(user_id) not in bot_admin_ids:
                app.logger.info(f'[kkå›è°ƒ] æƒé™æ‹’ç» - ç”¨æˆ· {user_id} ä¸åœ¨ç®¡ç†å‘˜åˆ—è¡¨ {bot_admin_ids}')
                answer_callback_query(callback_id, "âŒ è¯·ä¸è¦ä»¥ä¸‹çŠ¯ä¸Š okï¼Ÿ", show_alert=True)
                return jsonify({'ok': True})
            
            parts = callback_data.split('_')  # kk_action_targetUserId
            if len(parts) < 3:
                answer_callback_query(callback_id, "âŒ å‚æ•°é”™è¯¯", show_alert=True)
                return jsonify({'ok': True})
            
            action = parts[1]
            target_user_id = parts[2] if parts[2] else None
            
            # ä»ç¼“å­˜è·å–ç›®æ ‡ç”¨æˆ·ä¿¡æ¯
            target_username = None
            target_first_name = None
            if target_user_id and target_user_id != 'None':
                try:
                    target_user_id = int(target_user_id)
                    kk_cache = get_db_config(f'kk_target_{target_user_id}', {})
                    target_username = kk_cache.get('username') or None
                    target_first_name = kk_cache.get('first_name') or None
                except ValueError:
                    target_user_id = None
            else:
                target_user_id = None
            
            if action == 'gift':
                # èµ é€èµ„æ ¼ - ä¼ é€’ç›®æ ‡ç”¨æˆ·ä¿¡æ¯å’Œç®¡ç†å‘˜ä¿¡æ¯
                return handle_kk_gift(callback_id, chat_id, message_id, target_user_id, target_username, target_first_name, user_id, user_username, user_first_name)
            
            elif action == 'kick':
                # è¸¢å‡ºå¹¶å°ç¦
                return handle_kk_kick(callback_id, chat_id, message_id, target_user_id, target_username, username)
            
            elif action == 'delete':
                # åˆ é™¤æ¶ˆæ¯
                delete_telegram_message(chat_id, message_id)
                answer_callback_query(callback_id, "âœ… æ¶ˆæ¯å·²åˆ é™¤")
                return jsonify({'ok': True})
        
        # å¤„ç†æ³¨å†Œç›¸å…³çš„å›è°ƒ
        if callback_data.startswith('reg_'):
            parts = callback_data.split('_', 2)  # reg_action_giftCode
            if len(parts) < 3:
                answer_callback_query(callback_id, "âŒ å‚æ•°é”™è¯¯", show_alert=True)
                return jsonify({'ok': True})
            
            action = parts[1]
            gift_code = parts[2]
            
            if action == 'start':
                # å¼€å§‹æ³¨å†Œ
                return handle_reg_start(callback_id, chat_id, message_id, user_id, gift_code)
            
            elif action == 'cancel':
                # å–æ¶ˆæ³¨å†Œ
                return handle_reg_cancel(callback_id, chat_id, message_id, user_id, gift_code)
        
        # å¤„ç† /start é¢æ¿æŒ‰é’®å›è°ƒ
        if callback_data.startswith('cmd_'):
            return handle_start_panel_callback(callback_id, callback_data, chat_id, message_id, user_id, username)
        
        # å¤„ç†æ±‚ç‰‡å®¡æ ¸å›è°ƒ (mreq_approve_ID / mreq_reject_ID)
        if callback_data.startswith('mreq_'):
            return handle_movie_request_review(callback_id, callback_data, chat_id, message_id, user_id, user_first_name or user_username)
        
        # åº”ç­”å›è°ƒï¼ˆé˜²æ­¢æŒ‰é’®ä¸€ç›´è½¬åœˆï¼‰
        answer_callback_query(callback_id)
        return jsonify({'ok': True})
        
    except Exception as e:
        app.logger.error(f'[Callback] å¤„ç†å›è°ƒå¼‚å¸¸: {e}', exc_info=True)
        if callback_id:
            answer_callback_query(callback_id, "âŒ å¤„ç†å¤±è´¥ï¼Œè¯·é‡è¯•", show_alert=True)
        return jsonify({'ok': True})


def answer_callback_query(callback_id, text=None, show_alert=False):
    """åº”ç­” Telegram å›è°ƒæŸ¥è¯¢"""
    try:
        answer_url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/answerCallbackQuery"
        payload = {'callback_query_id': callback_id}
        if text:
            payload['text'] = text
        if show_alert:
            payload['show_alert'] = True
        PROXY_SESSION.post(answer_url, json=payload, timeout=5)
    except:
        pass


def send_telegram_alert(user_id, text):
    """å‘ç”¨æˆ·å‘é€ç§èŠæç¤ºæ¶ˆæ¯ï¼ˆç”¨äºæƒé™ä¸è¶³ç­‰æç¤ºï¼‰
    
    é€šè¿‡ç§èŠå‘é€æ¶ˆæ¯ï¼Œç”¨æˆ·ä¼šæ”¶åˆ° Telegram é€šçŸ¥å¼¹çª—
    """
    if not TELEGRAM_BOT_TOKEN:
        return False
    
    try:
        url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendMessage"
        payload = {
            'chat_id': user_id,
            'text': text,
            'parse_mode': 'HTML'
        }
        response = PROXY_SESSION.post(url, json=payload, timeout=5)
        data = response.json()
        return data.get('ok', False)
    except Exception as e:
        app.logger.debug(f'[å‘é€æç¤º] å‘é€å¤±è´¥: {e}')
        return False


def handle_start_panel_callback(callback_id, callback_data, chat_id, message_id, user_id, username):
    """å¤„ç† /start é¢æ¿æŒ‰é’®å›è°ƒ"""
    try:
        app.logger.info(f'[é¢æ¿å›è°ƒ] å¤„ç†å›è°ƒ: data={callback_data}, user_id={user_id}, chat_id={chat_id}')
        
        if callback_data == 'cmd_close':
            # å…³é—­é¢æ¿ - åˆ é™¤æ¶ˆæ¯
            delete_telegram_message(chat_id, message_id)
            answer_callback_query(callback_id, "âœ… å·²å…³é—­")
            return jsonify({'ok': True})
        
        elif callback_data == 'cmd_status':
            # æŸ¥çœ‹çŠ¶æ€ - å…ˆåˆ é™¤åŸæ¶ˆæ¯
            delete_telegram_message(chat_id, message_id)
            answer_callback_query(callback_id, "æ­£åœ¨æŸ¥è¯¢...")
            user = User.query.filter_by(telegram_id=user_id).first()
            if user:
                now = datetime.now()
                
                # è®¢é˜…çŠ¶æ€ï¼ˆå«å‰©ä½™å¤©æ•°ï¼‰
                _cb_wl = Subscription.query.filter_by(user_tg=user.tg, plan_type='whitelist', status='active').first()
                if _cb_wl or user.lv == 'a':
                    status_text = 'âœ… ç™½åå• (æ°¸ä¹…æœ‰æ•ˆ)'
                elif user.lv == 'c':
                    status_text = 'ğŸš« å·²ç¦ç”¨'
                elif user.ex and user.ex > now:
                    days_left = (user.ex - now).days
                    status_text = f'âœ… å·²è®¢é˜… ({days_left} å¤©ååˆ°æœŸ)'
                else:
                    status_text = 'âŒ æœªè®¢é˜…'
                
                ex_display = 'æ°¸ä¹…' if (_cb_wl or user.lv == 'a') else (user.ex.strftime('%Y-%m-%d %H:%M') if user.ex else 'æœªè®¾ç½®')
                emby_status = 'âœ… å·²ç»‘å®š' if user.embyid else 'âŒ æœªç»‘å®š'
                
                # ä»Šæ—¥æ±‚ç‰‡
                today_count = user.get_today_request_count()
                daily_limit = user.get_daily_limit()
                
                checkin_config = get_db_config('checkin', {})
                coin_name = checkin_config.get('coin_name', 'ç§¯åˆ†')
                
                reply = f"""ğŸ“Š <b>è´¦å·çŠ¶æ€</b>

<b>Â· ğŸ’  è´¦å·åç§°</b> | {user.name or 'æœªè®¾ç½®'}
<b>Â· ğŸ“Š è®¢é˜…çŠ¶æ€</b> | {status_text}
<b>Â· ğŸ¬ Emby</b> | {emby_status}
<b>Â· ğŸ’ æŒæœ‰{coin_name}</b> | {user.coins or 0}
<b>Â· ğŸš¨ åˆ°æœŸæ—¶é—´</b> | {ex_display}
<b>Â· ğŸ¯ ä»Šæ—¥æ±‚ç‰‡</b> | {today_count}/{daily_limit}"""
                send_telegram_reply(chat_id, reply)
            else:
                send_telegram_reply(chat_id, "âŒ æ‚¨è¿˜æœªç»‘å®šè´¦å·")
            return jsonify({'ok': True})
        
        elif callback_data == 'cmd_count':
            # åª’ä½“ç»Ÿè®¡ - å…ˆåˆ é™¤åŸæ¶ˆæ¯
            delete_telegram_message(chat_id, message_id)
            answer_callback_query(callback_id, "æ­£åœ¨ç»Ÿè®¡...")
            try:
                counts = emby_client.get_library_counts()
                if counts:
                    reply = f"""ğŸ¬ <b>åª’ä½“åº“ç»Ÿè®¡</b>

ğŸ“½ï¸ ç”µå½±: {counts.get('movies', 0)} éƒ¨
ğŸ“º ç”µè§†å‰§: {counts.get('series', 0)} éƒ¨
ğŸï¸ å‰§é›†: {counts.get('episodes', 0)} é›†"""
                    send_telegram_reply(chat_id, reply)
                else:
                    send_telegram_reply(chat_id, "âŒ è·å–åª’ä½“ç»Ÿè®¡å¤±è´¥")
            except Exception as e:
                app.logger.error(f'è·å–åª’ä½“ç»Ÿè®¡å¤±è´¥: {e}')
                send_telegram_reply(chat_id, "âŒ è·å–åª’ä½“ç»Ÿè®¡å¤±è´¥")
            return jsonify({'ok': True})
        
        elif callback_data == 'cmd_checkin':
            # ç­¾åˆ° - å…ˆåˆ é™¤åŸæ¶ˆæ¯
            delete_telegram_message(chat_id, message_id)
            answer_callback_query(callback_id, "æ­£åœ¨ç­¾åˆ°...")
            
            checkin_config = get_db_config('checkin', {})
            coin_name = checkin_config.get('coin_name', 'ç§¯åˆ†')
            
            if not checkin_config.get('enabled', False) or not checkin_config.get('bot_enabled', False):
                send_telegram_reply(chat_id, "âŒ ç­¾åˆ°åŠŸèƒ½æœªå¼€å¯")
                return jsonify({'ok': True})
            
            user = User.query.filter_by(telegram_id=user_id).first()
            if not user:
                send_telegram_reply(chat_id, "âŒ è¯·å…ˆç»‘å®šè´¦å·")
                return jsonify({'ok': True})
            
            # æ£€æŸ¥ä»Šå¤©æ˜¯å¦å·²ç­¾åˆ°
            today = datetime.now().date()
            existing = CheckInRecord.query.filter_by(user_tg=user.tg, checkin_date=today).first()
            
            if existing:
                # å’Œ /checkin å‘½ä»¤ä¸€æ ·ï¼Œå‘é€å®Œæ•´çš„å·²ç­¾åˆ°ä¿¡æ¯
                answer_callback_query(callback_id, "â­• ä»Šå¤©å·²ç»ç­¾åˆ°è¿‡äº†")
                reply = f"""â­• <b>æ‚¨ä»Šå¤©å·²ç»ç­¾åˆ°è¿‡äº†ï¼</b>

ğŸ‰ <b>ä»Šæ—¥è·å¾—</b> | {existing.coins_earned} {coin_name}
ğŸ’´ <b>å½“å‰æŒæœ‰</b> | {user.coins or 0} {coin_name}
ğŸ“… <b>è¿ç»­ç­¾åˆ°</b> | {existing.continuous_days} å¤©

ç­¾åˆ°æ˜¯æ— èŠçš„æ´»åŠ¨å“¦ï¼Œæ˜å¤©å†æ¥å§~"""
                send_telegram_reply(chat_id, reply)
                return jsonify({'ok': True})
            
            # ç”Ÿæˆç®—æœ¯éªŒè¯ç 
            op = random.choice(['+', '-', 'Ã—'])
            if op == '+':
                a, b = random.randint(1, 50), random.randint(1, 50)
                math_answer = a + b
            elif op == '-':
                a = random.randint(10, 50)
                b = random.randint(1, a)
                math_answer = a - b
            else:
                a, b = random.randint(2, 12), random.randint(2, 12)
                math_answer = a * b
            question = f"{a} {op} {b}"
            
            # æ¸…ç†è¿‡æœŸçš„éªŒè¯ç 
            now = datetime.now()
            expired_keys = [uid for uid, data in TELEGRAM_CHECKIN_CODES.items()
                           if data.get('expires_at') and data['expires_at'] < now]
            for key in expired_keys:
                del TELEGRAM_CHECKIN_CODES[key]
            
            # ä¿å­˜ç®—æœ¯ç­”æ¡ˆï¼ˆ1åˆ†é’Ÿæœ‰æ•ˆæœŸï¼‰
            TELEGRAM_CHECKIN_CODES[user_id] = {
                'answer': math_answer,
                'user_tg': user.tg,
                'created_at': now,
                'expires_at': now + timedelta(minutes=1)
            }
            
            reply = f"""ğŸ¯ <b>æ¯æ—¥ç­¾åˆ°</b>

è¯·è®¡ç®—ä»¥ä¸‹ç®—å¼å¹¶å›å¤ç»“æœï¼š

<code>{question} = ?</code>

â± æœ‰æ•ˆæœŸ: 1 åˆ†é’Ÿ"""
            send_telegram_reply(chat_id, reply)
            return jsonify({'ok': True})
        
        elif callback_data == 'cmd_checkin_need_bind':
            answer_callback_query(callback_id, "âŒ è¯·å…ˆç»‘å®šè´¦å·åå†ç­¾åˆ°", show_alert=True)
            return jsonify({'ok': True})
        
        elif callback_data == 'cmd_unbind':
            # è§£ç»‘ - æ˜¾ç¤ºç¡®è®¤æ¶ˆæ¯
            delete_telegram_message(chat_id, message_id)
            answer_callback_query(callback_id)
            user = User.query.filter_by(telegram_id=user_id).first()
            if user:
                reply = f"""âš ï¸ <b>ç¡®è®¤è§£ç»‘</b>

æ‚¨ç¡®å®šè¦è§£ç»‘è´¦å· <b>{user.name}</b> å—ï¼Ÿ

è§£ç»‘åå°†æ— æ³•æ¥æ”¶é€šçŸ¥æ¶ˆæ¯ã€‚"""
                buttons = [
                    [{'text': 'âœ… ç¡®è®¤è§£ç»‘', 'callback_data': 'cmd_unbind_confirm'}],
                    [{'text': 'âŒ å–æ¶ˆ', 'callback_data': 'cmd_unbind_cancel'}]
                ]
                reply_markup = {'inline_keyboard': buttons}
                send_telegram_reply(chat_id, reply, reply_markup)
            else:
                send_telegram_reply(chat_id, "âŒ æ‚¨è¿˜æœªç»‘å®šè´¦å·")
            return jsonify({'ok': True})
        
        elif callback_data == 'cmd_unbind_confirm':
            # ç¡®è®¤è§£ç»‘
            delete_telegram_message(chat_id, message_id)
            answer_callback_query(callback_id, "æ­£åœ¨è§£ç»‘...")
            user = User.query.filter_by(telegram_id=user_id).first()
            if user:
                user.telegram_id = None
                db.session.commit()
                send_telegram_reply(chat_id, "âœ… å·²æˆåŠŸè§£ç»‘è´¦å·")
            else:
                send_telegram_reply(chat_id, "âŒ æ‚¨è¿˜æœªç»‘å®šè´¦å·")
            return jsonify({'ok': True})
        
        elif callback_data == 'cmd_unbind_cancel':
            # å–æ¶ˆè§£ç»‘
            delete_telegram_message(chat_id, message_id)
            answer_callback_query(callback_id, "å·²å–æ¶ˆ")
            send_telegram_reply(chat_id, "âŒ å·²å–æ¶ˆè§£ç»‘æ“ä½œ")
            return jsonify({'ok': True})
        
        elif callback_data == 'cmd_bind_help':
            # ç»‘å®šå¸®åŠ© - å…ˆåˆ é™¤åŸæ¶ˆæ¯
            delete_telegram_message(chat_id, message_id)
            answer_callback_query(callback_id)
            reply = """ğŸ”— <b>å¦‚ä½•ç»‘å®šè´¦å·</b>

1ï¸âƒ£ ç™»å½•ç½‘ç«™ Dashboard
2ï¸âƒ£ ç‚¹å‡»å·¦ä¸‹è§’"ç»‘å®š Telegram"æŒ‰é’®
3ï¸âƒ£ å¤åˆ¶å¼¹çª—ä¸­æ˜¾ç¤ºçš„ç»‘å®šç 
4ï¸âƒ£ å›åˆ°è¿™é‡Œå‘é€: <code>/bind ç»‘å®šç </code>

ç»‘å®šåå¯æ”¶åˆ°ï¼š
â€¢ ğŸ¬ æ±‚ç‰‡è¿›åº¦é€šçŸ¥
â€¢ â° è®¢é˜…åˆ°æœŸæé†’
â€¢ ğŸ¯ ç­¾åˆ°é¢†ç§¯åˆ†"""
            send_telegram_reply(chat_id, reply)
            return jsonify({'ok': True})
        
        # æœªçŸ¥å›è°ƒ
        answer_callback_query(callback_id)
        return jsonify({'ok': True})
        
    except Exception as e:
        app.logger.error(f'[é¢æ¿å›è°ƒ] å¤„ç†å›è°ƒå¼‚å¸¸: {e}', exc_info=True)
        answer_callback_query(callback_id, "âŒ å¤„ç†å¤±è´¥ï¼Œè¯·é‡è¯•", show_alert=True)
        return jsonify({'ok': True})


def handle_reg_start(callback_id, chat_id, message_id, user_id, gift_code):
    """å¤„ç†ç‚¹å‡»æ³¨å†ŒæŒ‰é’® - è¿›å…¥æ³¨å†ŒçŠ¶æ€"""
    
    # éªŒè¯èµ é€ç 
    gift_key = f'gift_{gift_code}'
    gift_data = get_db_config(gift_key, None)
    
    if not gift_data:
        answer_callback_query(callback_id, "âŒ èµ é€ç å·²è¿‡æœŸ", show_alert=True)
        return jsonify({'ok': True})
    
    # æ£€æŸ¥æ˜¯å¦å·²è¢«ä½¿ç”¨
    if gift_data.get('used'):
        used_by = gift_data.get('used_by_id', 'æœªçŸ¥')
        answer_callback_query(callback_id, f"âŒ è¯¥æ³¨å†Œç å·²è¢« {used_by} ä½¿ç”¨", show_alert=True)
        return jsonify({'ok': True})
    
    # éªŒè¯ç”¨æˆ·èº«ä»½
    target_user_id = gift_data.get('target_user_id')
    if target_user_id and int(target_user_id) != int(user_id):
        answer_callback_query(callback_id, "âŒ è¿™ä¸æ˜¯ç»™ä½ çš„é‚€è¯·", show_alert=True)
        return jsonify({'ok': True})
    
    # è®¾ç½®ç”¨æˆ·ä¸ºæ³¨å†ŒçŠ¶æ€
    reg_state_key = f'reg_state_{user_id}'
    reg_state = {
        'gift_code': gift_code,
        'state': 'waiting_credentials',
        'created_at': datetime.now().isoformat(),
        'expires_at': (datetime.now() + timedelta(minutes=2)).isoformat()
    }
    set_db_config(reg_state_key, reg_state)
    
    # æ›´æ–°æ¶ˆæ¯ä¸ºæ³¨å†Œæç¤º
    register_prompt = """ğŸ¤–æ³¨æ„ï¼šæ‚¨å·²è¿›å…¥æ³¨å†ŒçŠ¶æ€:

â€¢ è¯·åœ¨2minå†…è¾“å…¥ [ç”¨æˆ·å][ç©ºæ ¼][å¯†ç ]
â€¢ ä¸¾ä¸ªä¾‹å­ğŸŒ°ï¼šè‹è‹ 1234

â€¢ ç”¨æˆ·åä¸­ä¸é™åˆ¶ä¸­/è‹±æ–‡/emojiï¼ŒğŸš«ç‰¹æ®Šå­—ç¬¦
â€¢ è¯·å¡«å…¥æœ€ç†Ÿæ‚‰çš„æ•°å­—4~6ä½ï¼›é€€å‡ºè¯·ç‚¹ /cancel"""
    
    edit_telegram_message(chat_id, message_id, register_prompt, None)
    answer_callback_query(callback_id, "âœ… å·²è¿›å…¥æ³¨å†ŒçŠ¶æ€ï¼Œè¯·åœ¨2åˆ†é’Ÿå†…è¾“å…¥ç”¨æˆ·åå’Œå¯†ç ")
    
    app.logger.info(f'[Reg] ç”¨æˆ· {user_id} è¿›å…¥æ³¨å†ŒçŠ¶æ€ï¼Œgift_code={gift_code}')
    return jsonify({'ok': True})


def handle_reg_cancel(callback_id, chat_id, message_id, user_id, gift_code):
    """å¤„ç†å–æ¶ˆæ³¨å†Œ"""
    
    # åˆ é™¤æ³¨å†ŒçŠ¶æ€
    reg_state_key = f'reg_state_{user_id}'
    delete_db_config(reg_state_key)
    
    # æ›´æ–°æ¶ˆæ¯
    edit_telegram_message(chat_id, message_id, "âŒ å·²å–æ¶ˆæ³¨å†Œã€‚å¦‚éœ€é‡æ–°é¢†å–ï¼Œè¯·è¿”å›ç¾¤ç»„ç‚¹å‡»é¢†å–æŒ‰é’®ã€‚", None)
    answer_callback_query(callback_id, "å·²å–æ¶ˆ")
    
    app.logger.info(f'[Reg] ç”¨æˆ· {user_id} å–æ¶ˆæ³¨å†Œ')
    return jsonify({'ok': True})


def handle_registration_input(chat_id, telegram_user_id, text):
    """å¤„ç†ç”¨æˆ·åœ¨æ³¨å†ŒçŠ¶æ€ä¸‹çš„è¾“å…¥"""
    import re
    
    # æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å¤„äºæ³¨å†ŒçŠ¶æ€
    reg_state_key = f'reg_state_{telegram_user_id}'
    reg_state = get_db_config(reg_state_key, None)
    
    if not reg_state:
        return None  # ä¸åœ¨æ³¨å†ŒçŠ¶æ€ï¼Œä¸å¤„ç†
    
    # æ£€æŸ¥æ˜¯å¦è¶…æ—¶
    expires_at = reg_state.get('expires_at')
    if expires_at:
        try:
            expire_time = datetime.fromisoformat(expires_at)
            if datetime.now() > expire_time:
                delete_db_config(reg_state_key)
                send_telegram_reply(chat_id, "â° æ³¨å†Œè¶…æ—¶ï¼Œè¯·é‡æ–°ç‚¹å‡»é¢†å–æŒ‰é’®")
                return jsonify({'ok': True})
        except:
            pass
    
    gift_code = reg_state.get('gift_code')
    if not gift_code:
        delete_db_config(reg_state_key)
        send_telegram_reply(chat_id, "âŒ æ³¨å†Œä¿¡æ¯å¼‚å¸¸ï¼Œè¯·é‡æ–°é¢†å–")
        return jsonify({'ok': True})
    
    # è·å–èµ é€ä¿¡æ¯
    gift_key = f'gift_{gift_code}'
    gift_data = get_db_config(gift_key, None)
    
    if not gift_data:
        delete_db_config(reg_state_key)
        send_telegram_reply(chat_id, "âŒ èµ é€ç å·²è¿‡æœŸï¼Œè¯·è”ç³»ç®¡ç†å‘˜é‡æ–°èµ é€")
        return jsonify({'ok': True})
    
    # è§£æç”¨æˆ·åå’Œå¯†ç 
    parts = text.split(maxsplit=1)
    if len(parts) < 2:
        send_telegram_reply(chat_id, """âŒ æ ¼å¼é”™è¯¯

è¯·è¾“å…¥ï¼š[ç”¨æˆ·å][ç©ºæ ¼][å¯†ç ]
ä¾‹å¦‚ï¼šè‹è‹ 1234

é€€å‡ºè¯·ç‚¹ /cancel""")
        return jsonify({'ok': True})
    
    username = parts[0].strip()
    password = parts[1].strip()
    
    # éªŒè¯ç”¨æˆ·å: 1-20ä¸ªå­—ç¬¦ï¼Œæ”¯æŒä¸­æ–‡ã€å­—æ¯ã€æ•°å­—ã€ä¸‹åˆ’çº¿
    if not re.match(r'^[a-zA-Z0-9_\u4e00-\u9fff]+$', username):
        send_telegram_reply(chat_id, """âŒ ç”¨æˆ·åæ ¼å¼é”™è¯¯

ç”¨æˆ·åæ”¯æŒä¸­æ–‡ã€å­—æ¯ã€æ•°å­—ã€ä¸‹åˆ’çº¿
è¯·é‡æ–°è¾“å…¥ï¼š[ç”¨æˆ·å][ç©ºæ ¼][å¯†ç ]""")
        return jsonify({'ok': True})
    
    if len(username) < 1 or len(username) > 20:
        send_telegram_reply(chat_id, "âŒ ç”¨æˆ·åé•¿åº¦åº”åœ¨1-20ä¸ªå­—ç¬¦ä¹‹é—´")
        return jsonify({'ok': True})
    
    # éªŒè¯å¯†ç : ä¸è¶…è¿‡32ä¸ªå­—ç¬¦ï¼ˆå…è®¸çŸ­å¯†ç ï¼‰
    if len(password) > 32:
        send_telegram_reply(chat_id, """âŒ å¯†ç è¿‡é•¿

å¯†ç ä¸èƒ½è¶…è¿‡32ä¸ªå­—ç¬¦
è¯·é‡æ–°è¾“å…¥ï¼š[ç”¨æˆ·å][ç©ºæ ¼][å¯†ç ]""")
        return jsonify({'ok': True})
    
    # æ£€æŸ¥Embyç”¨æˆ·åæ˜¯å¦å·²å­˜åœ¨
    existing_user = User.query.filter_by(emby_name=username).first()
    if existing_user:
        send_telegram_reply(chat_id, f"""âŒ ç”¨æˆ·å "{username}" å·²è¢«å ç”¨

è¯·é€‰æ‹©å…¶ä»–ç”¨æˆ·å
è¯·é‡æ–°è¾“å…¥ï¼š[ç”¨æˆ·å][ç©ºæ ¼][å¯†ç ]""")
        return jsonify({'ok': True})
    
    # åˆ›å»ºè´¦å·
    days = gift_data.get('days', 0)
    from_user_id = gift_data.get('from_user_id')
    from_username = gift_data.get('from_username', 'ç®¡ç†å‘˜')
    
    # æ„å»ºé‚€è¯·äººé“¾æ¥
    if from_user_id:
        inviter_text = f'<a href="tg://user?id={from_user_id}">{from_username}</a>'
    else:
        inviter_text = f'<b>{from_username}</b>'
    
    try:
        new_tg = generate_next_user_id()
        new_user = User(
            tg=new_tg,
            telegram_id=telegram_user_id,
            name=username,
            pwd=password,
            lv='b',
            cr=datetime.now(),
            ex=datetime.now() + timedelta(days=days),
            us=1,
            coins=0,
        )
        
        db.session.add(new_user)
        db.session.commit()
        
        # åˆ é™¤èµ é€ç å’Œæ³¨å†ŒçŠ¶æ€
        delete_db_config(gift_key)
        delete_db_config(reg_state_key)
        
        # æ›´æ–°ç¾¤ç»„ä¸­çš„èµ é€æ¶ˆæ¯ä¸ºå·²é¢†å–çŠ¶æ€ï¼ˆæ–°æ³¨å†Œï¼‰
        _update_gift_message_claimed(gift_data, telegram_user_id, username, is_renew=False)
        
        # è·å–é¢æ¿ç™»å½•é“¾æ¥
        site_config = load_site_config()
        panel_url = site_config.get('panel_url', '')
        
        # æ„å»ºç™»å½•é“¾æ¥æ–‡æœ¬
        if panel_url:
            login_link = f'\n\nğŸ”— <b>é¢æ¿ç™»å½•:</b> {panel_url}'
        else:
            login_link = ''
        
        # å‘é€æˆåŠŸæ¶ˆæ¯
        send_telegram_reply(chat_id, f"""ğŸ‰ <b>æ³¨å†ŒæˆåŠŸï¼</b>

æ„Ÿè°¢ {inviter_text} çš„é‚€è¯·ï¼

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ‘¤ <b>è´¦å·ä¿¡æ¯</b>
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ç”¨æˆ·å: <code>{username}</code>
å¯†ç : <code>{password}</code>
è®¢é˜…å¤©æ•°: <b>{days}</b> å¤©
åˆ°æœŸæ—¶é—´: <b>{new_user.ex.strftime('%Y-%m-%d %H:%M')}</b>

âš ï¸ <b>è¯·å¦¥å–„ä¿å­˜è´¦å·ä¿¡æ¯ï¼</b>
ä½¿ç”¨æ­¤è´¦å·å¯†ç ç™»å½•ç½‘ç«™å³å¯ä½¿ç”¨ã€‚{login_link}""")
        
        app.logger.info(f'[Reg] ç”¨æˆ· {telegram_user_id} æˆåŠŸæ³¨å†Œè´¦å·: {username}, èµ é€ {days} å¤©')
        return jsonify({'ok': True})
        
    except Exception as e:
        db.session.rollback()
        app.logger.error(f'[Reg] åˆ›å»ºè´¦å·å¤±è´¥: {e}')
        send_telegram_reply(chat_id, f"âŒ åˆ›å»ºè´¦å·å¤±è´¥: {str(e)}")
        return jsonify({'ok': True})


def handle_kk_gift(callback_id, chat_id, message_id, target_user_id, target_username, target_first_name, operator_id, operator_username, operator_first_name):
    """å¤„ç†èµ é€èµ„æ ¼å›è°ƒ
    
    Args:
        target_username: ç›®æ ‡ç”¨æˆ·çš„ TG ç”¨æˆ·åï¼ˆå¯èƒ½ä¸ºç©ºï¼‰
        target_first_name: ç›®æ ‡ç”¨æˆ·çš„æ˜¾ç¤ºåç§°
        operator_username: ç®¡ç†å‘˜çš„ TG ç”¨æˆ·åï¼ˆå¯èƒ½ä¸ºç©ºï¼‰
        operator_first_name: ç®¡ç†å‘˜çš„æ˜¾ç¤ºåç§°
    """
    import secrets
    
    if not target_user_id:
        answer_callback_query(callback_id, "âŒ æ— æ³•è¯†åˆ«ç›®æ ‡ç”¨æˆ·", show_alert=True)
        return jsonify({'ok': True})
    
    # è·å–ç³»ç»Ÿé…ç½®ä¸­çš„èµ é€å¤©æ•°
    config = load_system_config()
    gift_days = config.get('telegram', {}).get('gift_days', 30)
    
    # ç”Ÿæˆèµ é€ç 
    gift_code = secrets.token_urlsafe(16)
    
    # å­˜å‚¨èµ é€ä¿¡æ¯
    gift_data = {
        'target_user_id': target_user_id,
        'target_username': target_username,
        'days': gift_days,
        'from_user_id': operator_id,
        'from_username': operator_username or operator_first_name,
        'created_at': datetime.now().isoformat(),
        'group_chat_id': chat_id,
        'group_message_id': message_id,
    }
    
    gift_key = f'gift_{gift_code}'
    set_db_config(gift_key, gift_data)
    
    # è·å– Bot ç”¨æˆ·å
    bot_username = get_bot_username()
    
    # æ„å»ºèµ é€æ¶ˆæ¯
    from html import escape as html_escape
    # ç›®æ ‡ç”¨æˆ·æ˜¾ç¤ºï¼šæ˜¾ç¤ºåç§°ï¼Œä½¿ç”¨ tg://user?id é“¾æ¥ï¼ˆä¸ä¼šäº§ç”Ÿé¢„è§ˆï¼‰
    target_display_name = html_escape(target_first_name or target_username or str(target_user_id))
    target_display = f'<a href="tg://user?id={target_user_id}">{target_display_name}</a>'
    
    # ç®¡ç†å‘˜æ˜¾ç¤ºï¼šæ˜¾ç¤ºåç§°ï¼Œä½¿ç”¨ tg://user?id é“¾æ¥ï¼ˆä¸ä¼šäº§ç”Ÿé¢„è§ˆï¼‰
    operator_display_name = html_escape(operator_first_name or operator_username or str(operator_id))
    operator_link = f'<a href="tg://user?id={operator_id}">{operator_display_name}</a>'
    
    gift_message = f"""ğŸŒŸ å¥½çš„ï¼Œç®¡ç†å‘˜ {operator_link}
å·²ä¸º {target_display} èµ äºˆèµ„æ ¼ã€‚å‰å¾€botè¿›è¡Œä¸‹ä¸€æ­¥æ“ä½œï¼š"""
    
    # åˆ›å»ºé¢†å–æŒ‰é’®
    start_param = f"gift_{gift_code}"
    reply_markup = {
        'inline_keyboard': [[
            {
                'text': 'ğŸ ç‚¹å‡»é¢†å–',
                'url': f'https://t.me/{bot_username}?start={start_param}'
            }
        ]]
    }
    
    # æ›´æ–°åŸæ¶ˆæ¯ä¸ºèµ é€æ¶ˆæ¯ï¼ˆèµ é€æ¶ˆæ¯ä¸è‡ªåŠ¨æ’¤å›ï¼Œéœ€è¦ç”¨æˆ·ç‚¹å‡»é¢†å–ï¼‰
    edit_telegram_message(chat_id, message_id, gift_message, reply_markup, auto_delete=0)
    
    # æ—¥å¿—è®°å½•
    operator_log_name = operator_username or operator_first_name or operator_id
    target_log_name = target_username or target_first_name or target_user_id
    answer_callback_query(callback_id, f"âœ… å·²å‘é€èµ é€é“¾æ¥ ({gift_days}å¤©)")
    app.logger.info(f'[/kk gift] ç®¡ç†å‘˜ {operator_log_name} èµ é€ {target_log_name} {gift_days} å¤©è®¢é˜…ï¼Œç : {gift_code}')
    
    return jsonify({'ok': True})


    answer_callback_query(callback_id, f"âœ… å·²å‘é€èµ é€é“¾æ¥ ({gift_days}å¤©)")
    app.logger.info(f'[/kk gift] ç®¡ç†å‘˜ {operator_log_name} èµ é€ {target_log_name} {gift_days} å¤©è®¢é˜…ï¼Œç : {gift_code}')
    
    return jsonify({'ok': True})


def handle_movie_request_review(callback_id, callback_data, chat_id, message_id, admin_id, admin_name):
    """å¤„ç†æ±‚ç‰‡å®¡æ ¸å›è°ƒï¼ˆç®¡ç†å‘˜ç§èŠä¸­çš„æ‰¹å‡†/æ‹’ç»æŒ‰é’®ï¼‰"""
    
    # æ£€æŸ¥æ˜¯å¦æ˜¯ BOT ç®¡ç†å‘˜
    config = load_system_config()
    bot_admins_str = config.get('telegram', {}).get('bot_admins', '')
    bot_admin_ids = [x.strip() for x in bot_admins_str.split(',') if x.strip()]
    
    if str(admin_id) not in bot_admin_ids:
        answer_callback_query(callback_id, "âŒ æ— æƒæ“ä½œ", show_alert=True)
        return jsonify({'ok': True})
    
    # è§£æ callback_data: mreq_approve_123 / mreq_reject_123
    parts = callback_data.split('_', 2)  # ['mreq', 'approve', '123']
    if len(parts) < 3:
        answer_callback_query(callback_id, "âŒ å‚æ•°é”™è¯¯", show_alert=True)
        return jsonify({'ok': True})
    
    action = parts[1]  # approve / reject
    try:
        request_id = int(parts[2])
    except ValueError:
        answer_callback_query(callback_id, "âŒ æ— æ•ˆçš„æ±‚ç‰‡ID", show_alert=True)
        return jsonify({'ok': True})
    
    # æŸ¥è¯¢æ±‚ç‰‡è®°å½•
    movie_request = MovieRequest.query.get(request_id)
    if not movie_request:
        answer_callback_query(callback_id, "âŒ æ±‚ç‰‡è®°å½•ä¸å­˜åœ¨", show_alert=True)
        return jsonify({'ok': True})
    
    if movie_request.status != 'pending':
        status_text = {'approved': 'å·²æ‰¹å‡†', 'rejected': 'å·²æ‹’ç»', 'completed': 'å·²å…¥åº“',
                       'downloading': 'ä¸‹è½½ä¸­', 'processing': 'å¤„ç†ä¸­'}.get(movie_request.status, movie_request.status)
        answer_callback_query(callback_id, f"âš ï¸ è¯¥æ±‚ç‰‡å·²ç»æ˜¯ã€Œ{status_text}ã€çŠ¶æ€", show_alert=True)
        return jsonify({'ok': True})
    
    if action == 'approve':
        # ===== æ‰¹å‡†æ±‚ç‰‡ =====
        movie_request.status = 'approved'
        movie_request.admin_note = f'ç”±ç®¡ç†å‘˜ {admin_name} é€šè¿‡Botæ‰¹å‡†'
        db.session.commit()
        
        # é€šçŸ¥ç”¨æˆ·
        user = movie_request.user
        if user and user.tg:
            send_user_telegram_notification(
                user.telegram_id or user.tg,
                movie_request.title,
                'approved',
                'æ‚¨çš„æ±‚ç‰‡å·²è¢«æ‰¹å‡†ï¼Œæ­£åœ¨å¤„ç†ä¸­ï¼Œè¯·è€å¿ƒç­‰å¾… ğŸ¬',
                movie_request.media_type,
                movie_request.tmdb_id,
                movie_request.poster_path
            )
        
        # æ›´æ–°ç®¡ç†å‘˜æ¶ˆæ¯ï¼ˆç§»é™¤æŒ‰é’®ï¼Œæ˜¾ç¤ºç»“æœï¼‰
        from html import escape as html_escape
        safe_admin = html_escape(str(admin_name))
        now_str = datetime.now(timezone(timedelta(hours=8))).strftime('%Y-%m-%d %H:%M:%S')
        
        # ç”±äºåŸæ¶ˆæ¯å¯èƒ½æ˜¯å¸¦å›¾ç‰‡çš„ï¼Œä½¿ç”¨ editMessageCaption æˆ– editMessageText
        _update_review_message(chat_id, message_id, movie_request,
                               f"\n\nâœ… <b>å·²æ‰¹å‡†</b> â€” {safe_admin} Â· {now_str}")
        
        answer_callback_query(callback_id, f"âœ… å·²æ‰¹å‡†ã€Œ{movie_request.title}ã€")
        app.logger.info(f'[Botå®¡æ ¸] ç®¡ç†å‘˜ {admin_id}({admin_name}) æ‰¹å‡†æ±‚ç‰‡: ID={request_id}, {movie_request.title}')
        
    elif action == 'reject':
        # ===== æ‹’ç»æ±‚ç‰‡ - è¿›å…¥ç­‰å¾…è¾“å…¥æ‹’ç»åŸå› çŠ¶æ€ =====
        reject_state_key = f'mreq_reject_{admin_id}'
        set_db_config(reject_state_key, {
            'request_id': request_id,
            'chat_id': chat_id,
            'message_id': message_id,
            'admin_name': admin_name,
            'created_at': datetime.now().isoformat()
        })
        
        # æ›´æ–°æ¶ˆæ¯æç¤ºè¾“å…¥åŸå› 
        _update_review_message(chat_id, message_id, movie_request,
                               f"\n\nâ³ <b>è¯·è¾“å…¥æ‹’ç»åŸå› </b>ï¼ˆç›´æ¥å›å¤æ–‡å­—å³å¯ï¼Œå‘é€ /cancel å–æ¶ˆï¼‰")
        
        answer_callback_query(callback_id, "è¯·è¾“å…¥æ‹’ç»åŸå› ")
        app.logger.info(f'[Botå®¡æ ¸] ç®¡ç†å‘˜ {admin_id}({admin_name}) å‡†å¤‡æ‹’ç»æ±‚ç‰‡: ID={request_id}, ç­‰å¾…è¾“å…¥åŸå› ')
    
    return jsonify({'ok': True})


def _update_review_message(chat_id, message_id, movie_request, append_text):
    """æ›´æ–°å®¡æ ¸é€šçŸ¥æ¶ˆæ¯ï¼ˆåŒæ—¶å…¼å®¹å›¾ç‰‡æ¶ˆæ¯å’Œæ–‡æœ¬æ¶ˆæ¯ï¼‰"""
    if not TELEGRAM_BOT_TOKEN:
        return
    
    # é‡å»ºæ¶ˆæ¯å†…å®¹
    media_type_cn = 'ğŸ¬ ç”µå½±' if movie_request.media_type == 'movie' else 'ğŸ“º å‰§é›†'
    scope_info = movie_request.get_request_scope() if movie_request.media_type == 'tv' else ''
    user = movie_request.user
    user_display = user.name if user else 'æœªçŸ¥'
    tg_id = user.telegram_id or user.tg if user else ''
    user_mention = f'<a href="tg://user?id={tg_id}">{user_display}</a>' if tg_id else f'<b>{user_display}</b>'
    tmdb_url = f"https://www.themoviedb.org/{movie_request.media_type}/{movie_request.tmdb_id}"
    
    message_lines = [
        f"ğŸ“‹ <b>æ±‚ç‰‡å®¡æ ¸</b>",
        f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”",
        f"ğŸ‘¤ <b>ç”¨æˆ·ï¼š</b>{user_mention}",
        f"ğŸ <b>å½±ç‰‡ï¼š</b><b>{movie_request.title}</b> ({movie_request.year or 'æœªçŸ¥'})",
        f"ğŸ“ <b>ç±»å‹ï¼š</b>{media_type_cn}",
    ]
    if scope_info:
        message_lines.append(f"ğŸ“‘ <b>èŒƒå›´ï¼š</b>{scope_info}")
    message_lines.append(f"ğŸ”— <a href='{tmdb_url}'>TMDB</a>")
    
    new_text = '\n'.join(message_lines) + append_text
    
    try:
        # å…ˆå°è¯• editMessageCaptionï¼ˆå›¾ç‰‡æ¶ˆæ¯ï¼‰
        url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/editMessageCaption"
        payload = {
            'chat_id': chat_id,
            'message_id': message_id,
            'caption': new_text,
            'parse_mode': 'HTML'
        }
        resp = PROXY_SESSION.post(url, json=payload, timeout=10)
        data = resp.json()
        
        if not data.get('ok'):
            # å¯èƒ½æ˜¯æ–‡æœ¬æ¶ˆæ¯ï¼Œç”¨ editMessageText
            url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/editMessageText"
            payload = {
                'chat_id': chat_id,
                'message_id': message_id,
                'text': new_text,
                'parse_mode': 'HTML'
            }
            PROXY_SESSION.post(url, json=payload, timeout=10)
    except Exception as e:
        app.logger.warning(f'[Botå®¡æ ¸] æ›´æ–°å®¡æ ¸æ¶ˆæ¯å¤±è´¥: {e}')


def _update_review_message_with_buttons(chat_id, message_id, movie_request, reply_markup):
    """æ›´æ–°å®¡æ ¸æ¶ˆæ¯å¹¶æ¢å¤æŒ‰é’®ï¼ˆç”¨äºå–æ¶ˆæ‹’ç»æ—¶æ¢å¤åŸå§‹çŠ¶æ€ï¼‰"""
    if not TELEGRAM_BOT_TOKEN:
        return
    
    media_type_cn = 'ğŸ¬ ç”µå½±' if movie_request.media_type == 'movie' else 'ğŸ“º å‰§é›†'
    scope_info = movie_request.get_request_scope() if movie_request.media_type == 'tv' else ''
    user = movie_request.user
    user_display = user.name if user else 'æœªçŸ¥'
    tg_id = user.telegram_id or user.tg if user else ''
    user_mention = f'<a href="tg://user?id={tg_id}">{user_display}</a>' if tg_id else f'<b>{user_display}</b>'
    tmdb_url = f"https://www.themoviedb.org/{movie_request.media_type}/{movie_request.tmdb_id}"
    
    message_lines = [
        f"ğŸ“‹ <b>æ–°æ±‚ç‰‡å¾…å®¡æ ¸</b>",
        f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”",
        f"ğŸ‘¤ <b>ç”¨æˆ·ï¼š</b>{user_mention}",
        f"ğŸ <b>å½±ç‰‡ï¼š</b><b>{movie_request.title}</b> ({movie_request.year or 'æœªçŸ¥'})",
        f"ğŸ“ <b>ç±»å‹ï¼š</b>{media_type_cn}",
    ]
    if scope_info:
        message_lines.append(f"ğŸ“‘ <b>èŒƒå›´ï¼š</b>{scope_info}")
    message_lines.append(f"ğŸ”— <a href='{tmdb_url}'>TMDB</a>")
    new_text = '\n'.join(message_lines)
    
    try:
        url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/editMessageCaption"
        payload = {
            'chat_id': chat_id, 'message_id': message_id,
            'caption': new_text, 'parse_mode': 'HTML', 'reply_markup': reply_markup
        }
        resp = PROXY_SESSION.post(url, json=payload, timeout=10)
        if not resp.json().get('ok'):
            url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/editMessageText"
            payload = {
                'chat_id': chat_id, 'message_id': message_id,
                'text': new_text, 'parse_mode': 'HTML', 'reply_markup': reply_markup
            }
            PROXY_SESSION.post(url, json=payload, timeout=10)
    except Exception as e:
        app.logger.warning(f'[Botå®¡æ ¸] æ¢å¤å®¡æ ¸æ¶ˆæ¯å¤±è´¥: {e}')


def handle_reject_reason_input(chat_id, admin_id, text):
    """å¤„ç†ç®¡ç†å‘˜è¾“å…¥çš„æ‹’ç»åŸå› 
    
    Returns:
        True if handled (consumed the message), False otherwise
    """
    reject_state_key = f'mreq_reject_{admin_id}'
    reject_state = get_db_config(reject_state_key, None)
    
    if not reject_state:
        return False
    
    request_id = reject_state.get('request_id')
    original_chat_id = reject_state.get('chat_id')
    original_message_id = reject_state.get('message_id')
    admin_name = reject_state.get('admin_name', 'ç®¡ç†å‘˜')
    
    # æ¸…é™¤ç­‰å¾…çŠ¶æ€
    delete_db_config(reject_state_key)
    
    # æŸ¥è¯¢æ±‚ç‰‡è®°å½•
    movie_request = MovieRequest.query.get(request_id)
    if not movie_request:
        send_telegram_reply(chat_id, "âŒ æ±‚ç‰‡è®°å½•ä¸å­˜åœ¨ï¼Œå¯èƒ½å·²è¢«åˆ é™¤")
        return True
    
    if movie_request.status != 'pending':
        send_telegram_reply(chat_id, f"âš ï¸ è¯¥æ±‚ç‰‡çŠ¶æ€å·²å˜æ›´ä¸ºã€Œ{movie_request.status}ã€ï¼Œæ— æ³•æ‹’ç»")
        return True
    
    # æ‰§è¡Œæ‹’ç»
    reject_reason = text.strip()
    movie_request.status = 'rejected'
    movie_request.admin_note = reject_reason
    db.session.commit()
    
    # é€šçŸ¥ç”¨æˆ·
    user = movie_request.user
    if user and user.tg:
        send_user_telegram_notification(
            user.telegram_id or user.tg,
            movie_request.title,
            'rejected',
            reject_reason,
            movie_request.media_type,
            movie_request.tmdb_id,
            movie_request.poster_path
        )
    
    # æ›´æ–°ç®¡ç†å‘˜çš„å®¡æ ¸æ¶ˆæ¯
    from html import escape as html_escape
    safe_admin = html_escape(str(admin_name))
    safe_reason = html_escape(reject_reason)
    now_str = datetime.now(timezone(timedelta(hours=8))).strftime('%Y-%m-%d %H:%M:%S')
    
    _update_review_message(original_chat_id, original_message_id, movie_request,
                           f"\n\nâŒ <b>å·²æ‹’ç»</b> â€” {safe_admin} Â· {now_str}\nğŸ’¬ åŸå› ï¼š{safe_reason}")
    
    send_telegram_reply(chat_id, f"âœ… å·²æ‹’ç»ã€Œ{movie_request.title}ã€\nğŸ’¬ åŸå› ï¼š{reject_reason}")
    app.logger.info(f'[Botå®¡æ ¸] ç®¡ç†å‘˜ {admin_id}({admin_name}) æ‹’ç»æ±‚ç‰‡: ID={request_id}, {movie_request.title}, åŸå› : {reject_reason}')
    
    return True


def handle_kk_kick(callback_id, chat_id, message_id, target_user_id, target_username, operator_name):
    """å¤„ç†è¸¢å‡ºå¹¶ç¡¬åˆ é™¤å›è°ƒï¼šåˆ é™¤è´¦å· + è¸¢å‡ºç¾¤ç»„
    
    æ³¨æ„ï¼šå¿…é¡»å…ˆç¡¬åˆ é™¤å†è¸¢å‡ºï¼Œå› ä¸ºè¸¢å‡º(banChatMember)ä¼šè§¦å‘ chat_member äº‹ä»¶ï¼Œ
    å¦‚æœå…ˆè¸¢å†åˆ ï¼Œchat_member äº‹ä»¶å¤„ç†å™¨å¯èƒ½æŠ¢å…ˆæ‰§è¡Œå¯¼è‡´é‡å¤æ“ä½œã€‚
    å…ˆåˆ é™¤åï¼Œchat_member äº‹ä»¶è§¦å‘æ—¶ç”¨æˆ·å·²ä¸å­˜åœ¨ï¼Œä¼šè‡ªç„¶è·³è¿‡ã€‚
    """
    
    if not target_user_id:
        answer_callback_query(callback_id, "âŒ æ— æ³•è¯†åˆ«ç›®æ ‡ç”¨æˆ·ï¼ˆéœ€è¦ç”¨æˆ· IDï¼‰", show_alert=True)
        return jsonify({'ok': True})
    
    from html import escape as html_escape
    display_name = f"@{html_escape(target_username)}" if target_username else str(target_user_id)
    safe_operator_name = html_escape(str(operator_name)) if operator_name else 'æœªçŸ¥'
    
    # 1. å…ˆç¡¬åˆ é™¤ï¼šåˆ é™¤ Emby è´¦å· + åˆ é™¤ç½‘ç«™è´¦å·åŠæ‰€æœ‰å…³è”æ•°æ®
    delete_result = hard_delete_user_data(target_user_id, reason=f'è¢«ç®¡ç†å‘˜ {operator_name} é€šè¿‡ /kk è¸¢å‡ºåˆ é™¤')
    
    # 2. å†ä»ç¾¤ç»„è¸¢å‡ºç”¨æˆ·ï¼ˆè¸¢å‡ºä¼šè§¦å‘ chat_member äº‹ä»¶ï¼Œä½†æ­¤æ—¶ç”¨æˆ·å·²è¢«åˆ é™¤ï¼Œäº‹ä»¶å¤„ç†å™¨ä¼šè‡ªç„¶è·³è¿‡ï¼‰
    kick_result = kick_chat_member(TELEGRAM_CHAT_ID, target_user_id)
    
    # 3. æ›´æ–°æ¶ˆæ¯æ˜¾ç¤ºç»“æœ
    if delete_result['found']:
        safe_user_name = html_escape(delete_result['user_name'])
        emby_status = 'âœ… å·²åˆ é™¤' if delete_result['emby_deleted'] else 'âš ï¸ æ—  Emby è´¦å·æˆ–åˆ é™¤å¤±è´¥'
        account_line = f"âœ… å·²åˆ é™¤ï¼ˆç”¨æˆ·: {safe_user_name}ï¼‰"
        emby_line = f"\nâ€¢ Emby è´¦å·: {emby_status}"
    else:
        account_line = 'âš ï¸ è¯¥ç”¨æˆ·æ— ç½‘ç«™è´¦å·'
        emby_line = ''
    
    result_message = f"""ğŸš« <b>ç”¨æˆ·å·²è¢«è¸¢å‡ºå¹¶åˆ é™¤</b>

ç”¨æˆ·: {display_name}
TG ID: <code>{target_user_id}</code>
æ“ä½œè€…: {safe_operator_name}

çŠ¶æ€:
â€¢ ç¾¤ç»„è¸¢å‡º: {'âœ… æˆåŠŸ' if kick_result else 'âŒ å¤±è´¥ï¼ˆå¯èƒ½å·²ä¸åœ¨ç¾¤ä¸­æˆ–æƒé™ä¸è¶³ï¼‰'}
â€¢ ç½‘ç«™è´¦å·: {account_line}{emby_line}"""
    
    edit_telegram_message(chat_id, message_id, result_message, None)
    
    answer_callback_query(callback_id, "âœ… ç”¨æˆ·å·²è¢«è¸¢å‡ºå¹¶åˆ é™¤")
    app.logger.info(f'[/kk kick] ç®¡ç†å‘˜ {operator_name} è¸¢å‡ºå¹¶åˆ é™¤ {display_name}, ç»“æœ: {delete_result}')
    
    return jsonify({'ok': True})


def hard_delete_user_data(user_tg_id, reason='æœªçŸ¥'):
    """ç¡¬åˆ é™¤ç”¨æˆ·ï¼šåˆ é™¤ Emby è´¦å· + åˆ é™¤ç½‘ç«™è´¦å·åŠæ‰€æœ‰å…³è”æ•°æ®
    
    Args:
        user_tg_id: ç”¨æˆ·çš„ Telegram IDï¼ˆä¹Ÿæ˜¯æ•°æ®åº“ä¸»é”® tgï¼‰
        reason: åˆ é™¤åŸå› ï¼ˆç”¨äºæ—¥å¿—ï¼‰
        
    Returns:
        dict: {'found': bool, 'user_name': str, 'emby_deleted': bool, 'db_deleted': bool}
    """
    result = {'found': False, 'user_name': '', 'emby_deleted': False, 'db_deleted': False}
    
    try:
        # æŸ¥æ‰¾ç”¨æˆ·
        user = User.query.filter_by(telegram_id=user_tg_id).first()
        if not user:
            user = db.session.get(User, user_tg_id)
        if not user:
            app.logger.info(f'[ç¡¬åˆ é™¤] æœªæ‰¾åˆ°ç”¨æˆ· tg_id={user_tg_id}ï¼Œè·³è¿‡')
            return result
        
        result['found'] = True
        result['user_name'] = user.emby_name or user.name or str(user_tg_id)
        user_tg = user.tg  # æ•°æ®åº“ä¸»é”®
        emby_id = user.embyid
        
        # é˜²æ­¢åˆ é™¤ç®¡ç†å‘˜
        if user.is_admin:
            app.logger.warning(f'[ç¡¬åˆ é™¤] æ‹’ç»åˆ é™¤ç®¡ç†å‘˜ {result["user_name"]} (tg={user_tg})')
            result['found'] = False  # æ ‡è®°ä¸ºä¸å¤„ç†
            return result
        
        # 1. åˆ é™¤ Emby æœåŠ¡å™¨ä¸Šçš„è´¦å·
        if emby_id and emby_client.is_enabled():
            try:
                result['emby_deleted'] = emby_client.delete_user(emby_id)
                if result['emby_deleted']:
                    app.logger.info(f'[ç¡¬åˆ é™¤] Emby è´¦å·å·²åˆ é™¤: {emby_id}')
                else:
                    app.logger.warning(f'[ç¡¬åˆ é™¤] Emby è´¦å·åˆ é™¤å¤±è´¥: {emby_id}')
            except Exception as e:
                app.logger.error(f'[ç¡¬åˆ é™¤] åˆ é™¤ Emby è´¦å·å¼‚å¸¸: {e}')
        
        # 2. åˆ é™¤æ‰€æœ‰å…³è”æ•°æ®
        try:
            PlaybackRecord.query.filter_by(user_tg=user_tg).delete(synchronize_session=False)
            UserDevice.query.filter_by(user_tg=user_tg).delete(synchronize_session=False)
            Subscription.query.filter_by(user_tg=user_tg).delete(synchronize_session=False)
            Order.query.filter_by(user_tg=user_tg).delete(synchronize_session=False)
            # ä¸‹è½½ä»»åŠ¡ï¼ˆæœ‰å¤–é”®å¼•ç”¨ movie_requestsï¼‰
            request_ids = [r.id for r in MovieRequest.query.filter_by(user_tg=user_tg).all()]
            if request_ids:
                DownloadTask.query.filter(DownloadTask.request_id.in_(request_ids)).delete(synchronize_session=False)
            MovieRequest.query.filter_by(user_tg=user_tg).delete(synchronize_session=False)
            # å·¥å•ï¼ˆå…ˆåˆ æ¶ˆæ¯ï¼‰
            ticket_ids = [t.id for t in SupportTicket.query.filter_by(user_tg=user_tg).all()]
            if ticket_ids:
                TicketMessage.query.filter(TicketMessage.ticket_id.in_(ticket_ids)).delete(synchronize_session=False)
            SupportTicket.query.filter_by(user_tg=user_tg).delete(synchronize_session=False)
            InviteRecord.query.filter((InviteRecord.inviter_tg == user_tg) | (InviteRecord.invitee_tg == user_tg)).delete(synchronize_session=False)
            UserActivityLog.query.filter_by(user_tg=user_tg).delete(synchronize_session=False)
            CheckInRecord.query.filter_by(user_tg=user_tg).delete(synchronize_session=False)
            CoinTransaction.query.filter_by(user_tg=user_tg).delete(synchronize_session=False)
            ExchangeRecord.query.filter_by(user_tg=user_tg).delete(synchronize_session=False)
            RedeemCode.query.filter_by(used_by=user_tg).update({'used_by': None}, synchronize_session=False)
            
            # åˆ é™¤ç”¨æˆ·æœ¬èº«
            db.session.delete(user)
            db.session.commit()
            result['db_deleted'] = True
            app.logger.info(f'[ç¡¬åˆ é™¤] ç”¨æˆ·æ•°æ®å·²åˆ é™¤: {result["user_name"]} (tg={user_tg}), åŸå› : {reason}')
        except Exception as e:
            db.session.rollback()
            app.logger.error(f'[ç¡¬åˆ é™¤] åˆ é™¤ç”¨æˆ·æ•°æ®å¤±è´¥: {e}')
    except Exception as e:
        app.logger.error(f'[ç¡¬åˆ é™¤] å¤„ç†å¼‚å¸¸: user_tg_id={user_tg_id}, error={e}')
    
    return result


def handle_chat_member_update(chat_member_update):
    """å¤„ç† chat_member äº‹ä»¶ï¼šç”¨æˆ·é€€ç¾¤æˆ–è¢«è¸¢æ—¶è‡ªåŠ¨ç¡¬åˆ é™¤è´¦å·
    
    Telegram æ¨é€æ ¼å¼:
    {
        "chat": {"id": ..., "type": "supergroup"},
        "from": {"id": ...},  // æ“ä½œè€…ï¼ˆé€€ç¾¤æ—¶æ˜¯ç”¨æˆ·è‡ªå·±ï¼Œè¢«è¸¢æ—¶æ˜¯ç®¡ç†å‘˜ï¼‰
        "date": ...,
        "old_chat_member": {"user": {"id": ...}, "status": "member"},
        "new_chat_member": {"user": {"id": ...}, "status": "left"/"kicked"}
    }
    """
    try:
        chat = chat_member_update.get('chat', {})
        chat_id = chat.get('id')
        
        # åªå¤„ç†æˆæƒç¾¤ç»„çš„äº‹ä»¶
        if TELEGRAM_CHAT_ID and str(chat_id) != str(TELEGRAM_CHAT_ID):
            return jsonify({'ok': True})
        
        old_member = chat_member_update.get('old_chat_member', {})
        new_member = chat_member_update.get('new_chat_member', {})
        
        old_status = old_member.get('status', '')
        new_status = new_member.get('status', '')
        
        target_user = new_member.get('user', {})
        target_user_id = target_user.get('id')
        target_first_name = target_user.get('first_name', '')
        target_username = target_user.get('username', '')
        
        from_user = chat_member_update.get('from', {})
        from_user_id = from_user.get('id')
        from_first_name = from_user.get('first_name', '')
        
        if not target_user_id:
            return jsonify({'ok': True})
        
        # åˆ¤æ–­æ˜¯å¦æ˜¯ç¦»å¼€/è¢«è¸¢äº‹ä»¶
        # old_status ä¸º member/administrator/restricted ä¸” new_status ä¸º left/kicked
        is_leaving = (old_status in ('member', 'administrator', 'restricted', 'creator') 
                      and new_status in ('left', 'kicked'))
        
        if not is_leaving:
            return jsonify({'ok': True})
        
        # åˆ¤æ–­æ˜¯ä¸»åŠ¨é€€ç¾¤è¿˜æ˜¯è¢«è¸¢
        is_self_leave = (from_user_id == target_user_id)
        
        if is_self_leave:
            reason = 'ç”¨æˆ·ä¸»åŠ¨é€€ç¾¤'
            app.logger.info(f'[é€€ç¾¤åˆ å·] ç”¨æˆ· {target_first_name}({target_user_id}) ä¸»åŠ¨é€€å‡ºç¾¤ç»„ï¼Œå¼€å§‹ç¡¬åˆ é™¤...')
        else:
            reason = f'è¢«ç®¡ç†å‘˜ {from_first_name}({from_user_id}) è¸¢å‡ºç¾¤ç»„'
            app.logger.info(f'[é€€ç¾¤åˆ å·] ç”¨æˆ· {target_first_name}({target_user_id}) è¢«è¸¢å‡ºç¾¤ç»„ï¼Œå¼€å§‹ç¡¬åˆ é™¤...')
        
        # æ‰§è¡Œç¡¬åˆ é™¤
        delete_result = hard_delete_user_data(target_user_id, reason=reason)
        
        from html import escape as html_escape
        safe_first_name = html_escape(target_first_name) if target_first_name else ''
        safe_username = html_escape(target_username) if target_username else ''
        display_name = f"@{safe_username}" if safe_username else safe_first_name or str(target_user_id)
        
        # åœ¨ç¾¤ç»„ä¸­å‘é€é€šçŸ¥
        if delete_result['found'] and delete_result['db_deleted']:
            emby_info = 'ï¼ŒEmby è´¦å·å·²åˆ é™¤' if delete_result['emby_deleted'] else ''
            notice = f"âœ… <b>{display_name}</b> å·²ç¦»å¼€ç¾¤ç»„ï¼Œå…¶ç½‘ç«™è´¦å·å·²åˆ é™¤{emby_info}"
            send_telegram_reply(chat_id, notice)
            app.logger.info(f'[é€€ç¾¤åˆ å·] å·²å¤„ç†: {display_name}, ç»“æœ: {delete_result}')
        elif delete_result['found'] and not delete_result['db_deleted']:
            notice = f"âš ï¸ <b>{display_name}</b> å·²ç¦»å¼€ç¾¤ç»„ï¼Œä½†è´¦å·åˆ é™¤å¤±è´¥ï¼Œè¯·ç®¡ç†å‘˜æ‰‹åŠ¨æ£€æŸ¥"
            send_telegram_reply(chat_id, notice)
            app.logger.warning(f'[é€€ç¾¤åˆ å·] åˆ é™¤å¤±è´¥: {display_name}, ç»“æœ: {delete_result}')
        else:
            app.logger.info(f'[é€€ç¾¤åˆ å·] ç”¨æˆ· {display_name} ç¦»å¼€ç¾¤ç»„ï¼Œä½†æ— ç½‘ç«™è´¦å·ï¼Œæ— éœ€å¤„ç†')
        
    except Exception as e:
        app.logger.error(f'[é€€ç¾¤åˆ å·] å¤„ç† chat_member äº‹ä»¶å¼‚å¸¸: {e}')
    
    return jsonify({'ok': True})


def kick_chat_member(chat_id, user_id):
    """è¸¢å‡ºç¾¤ç»„æˆå‘˜å¹¶å°ç¦"""
    if not TELEGRAM_BOT_TOKEN:
        return False
    
    try:
        # ä½¿ç”¨ banChatMember è¸¢å‡ºå¹¶å°ç¦ç”¨æˆ·
        url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/banChatMember"
        payload = {
            'chat_id': chat_id,
            'user_id': user_id,
        }
        response = PROXY_SESSION.post(url, json=payload, timeout=10)
        data = response.json()
        
        if data.get('ok'):
            app.logger.info(f'[è¸¢å‡ºç”¨æˆ·] æˆåŠŸè¸¢å‡º user_id={user_id} ä» chat_id={chat_id}')
            return True
        else:
            app.logger.warning(f'[è¸¢å‡ºç”¨æˆ·] è¸¢å‡ºå¤±è´¥: {data.get("description", "æœªçŸ¥é”™è¯¯")}')
            return False
    except Exception as e:
        app.logger.error(f'[è¸¢å‡ºç”¨æˆ·] è¸¢å‡ºå¼‚å¸¸: {e}')
        return False


def edit_telegram_message(chat_id, message_id, text, reply_markup=None, auto_delete=None):
    """ç¼–è¾‘ Telegram æ¶ˆæ¯
    
    Args:
        auto_delete: ç¼–è¾‘åè‡ªåŠ¨æ’¤å›å»¶è¿Ÿç§’æ•°ã€‚None=ç¾¤ç»„è‡ªåŠ¨æ’¤å›, 0=ä¸æ’¤å›, >0=æŒ‡å®šå»¶è¿Ÿ
    """
    if not TELEGRAM_BOT_TOKEN:
        return False
    
    try:
        url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/editMessageText"
        payload = {
            'chat_id': chat_id,
            'message_id': message_id,
            'text': text,
            'parse_mode': 'HTML'
        }
        if reply_markup:
            payload['reply_markup'] = reply_markup
        
        response = PROXY_SESSION.post(url, json=payload, timeout=10)
        data = response.json()
        
        if data.get('ok'):
            # ç¼–è¾‘åä¹Ÿæ”¯æŒè‡ªåŠ¨æ’¤å›
            if auto_delete is None and _is_group_chat(chat_id) and BOT_AUTO_DELETE_SECONDS > 0:
                schedule_delete_message(chat_id, message_id)
            elif auto_delete and auto_delete > 0:
                schedule_delete_message(chat_id, message_id, delay=auto_delete)
            return True
        else:
            app.logger.warning(f'[ç¼–è¾‘æ¶ˆæ¯] ç¼–è¾‘å¤±è´¥: {data.get("description", "æœªçŸ¥é”™è¯¯")}')
            return False
    except Exception as e:
        app.logger.error(f'[ç¼–è¾‘æ¶ˆæ¯] ç¼–è¾‘å¼‚å¸¸: {e}')
        return False


def _update_gift_message_claimed(gift_data, claimed_user_id, claimed_username, is_renew=False):
    """é¢†å–èµ é€ååˆ é™¤ç¾¤ç»„ä¸­çš„èµ é€æ¶ˆæ¯ï¼ˆè‡ªåŠ¨æ’¤å›ï¼‰"""
    group_chat_id = gift_data.get('group_chat_id')
    group_message_id = gift_data.get('group_message_id')
    if not group_chat_id or not group_message_id:
        return
    
    claim_type = 'ç»­æœŸ' if is_renew else 'æ–°æ³¨å†Œ'
    delete_telegram_message(group_chat_id, group_message_id)
    app.logger.info(f'[Gift] å·²åˆ é™¤ç¾¤ç»„èµ é€æ¶ˆæ¯({claim_type}): chat={group_chat_id}, msg={group_message_id}, claimed_by={claimed_user_id}')


def handle_gift_claim(chat_id, telegram_user_id, telegram_username, gift_code):
    """å¤„ç†èµ é€é¢†å– - éªŒè¯ç”¨æˆ·èº«ä»½å¹¶æ˜¾ç¤ºæ³¨å†Œé€‰é¡¹"""
    
    app.logger.info(f'[Gift] ç”¨æˆ· {telegram_user_id} ({telegram_username}) å°è¯•é¢†å–èµ é€ç : {gift_code}')
    
    # è·å–èµ é€ä¿¡æ¯
    gift_key = f'gift_{gift_code}'
    gift_data = get_db_config(gift_key, None)
    
    if not gift_data:
        send_telegram_reply(chat_id, "âŒ èµ é€ç æ— æ•ˆæˆ–å·²è¿‡æœŸ")
        return jsonify({'ok': True})
    
    # æ£€æŸ¥æ˜¯å¦å·²è¢«ä½¿ç”¨
    if gift_data.get('used'):
        used_by = gift_data.get('used_by_id', 'æœªçŸ¥')
        used_by_name = gift_data.get('used_by_name', '')
        used_at = gift_data.get('used_at', '')
        if used_by_name:
            send_telegram_reply(chat_id, f"âŒ è¯¥æ³¨å†Œç å·²è¢« <code>{used_by}</code>ï¼ˆ{used_by_name}ï¼‰ä½¿ç”¨")
        else:
            send_telegram_reply(chat_id, f"âŒ è¯¥æ³¨å†Œç å·²è¢« <code>{used_by}</code> ä½¿ç”¨")
        return jsonify({'ok': True})
    
    days = gift_data.get('days', 0)
    from_user_id = gift_data.get('from_user_id')
    from_username = gift_data.get('from_username', 'ç®¡ç†å‘˜')
    target_user_id = gift_data.get('target_user_id')
    
    # æ„å»ºé‚€è¯·äººé“¾æ¥
    if from_user_id:
        inviter_text = f'<a href="tg://user?id={from_user_id}">{from_username}</a>'
    else:
        inviter_text = f'<b>{from_username}</b>'
    
    if days <= 0:
        send_telegram_reply(chat_id, "âŒ èµ é€ä¿¡æ¯å¼‚å¸¸")
        return jsonify({'ok': True})
    
    # éªŒè¯æ˜¯å¦æ˜¯è¢«èµ é€çš„ç”¨æˆ·
    if target_user_id and int(target_user_id) != int(telegram_user_id):
        # ä¸æ˜¯è¢«èµ é€çš„ç”¨æˆ·
        send_telegram_reply(chat_id, "ä½ ä¹Ÿæƒ³å’ŒBOTå‡»å‰‘å—ï¼Ÿ")
        return jsonify({'ok': True})
    
    # æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å·²æœ‰è´¦å·
    existing_user = User.query.filter_by(telegram_id=telegram_user_id).first()
    if not existing_user:
        # å…¼å®¹ï¼štelegram_id æœªç»‘å®šçš„ç”¨æˆ·ï¼Œå°è¯•ç”¨ tg ä¸»é”®æŸ¥æ‰¾
        existing_user = db.session.get(User, telegram_user_id)
    
    if existing_user and existing_user.lv in ['a', 'b', 'c', 'd']:
        # ç”¨æˆ·å·²æœ‰è´¦å·
        was_banned = (existing_user.lv == 'c')  # è®°å½•æ˜¯å¦æ˜¯è¢«ç¦ç”¨ç”¨æˆ·
        
        _gift_wl = Subscription.query.filter_by(user_tg=existing_user.tg, plan_type='whitelist', status='active').first()
        if _gift_wl or existing_user.lv == 'a':
            # ç™½åå•ç”¨æˆ·
            send_telegram_reply(chat_id, f"""âœ… <b>é¢†å–æˆåŠŸï¼</b>

æ‚¨æ˜¯ç™½åå•ç”¨æˆ·ï¼Œå·²æ‹¥æœ‰æ°¸ä¹…è®¢é˜…ï¼
æ„Ÿè°¢ {inviter_text} çš„èµ é€ ğŸ‰

ğŸ‘¤ è´¦å·: <b>{existing_user.emby_name or existing_user.name}</b>""")
        else:
            # æ™®é€šç”¨æˆ· / è¢«ç¦ç”¨ç”¨æˆ· / æ— è´¦å·ç”¨æˆ·ï¼Œå…ˆèµ é€å¤©æ•°
            if existing_user.lv == 'd':
                existing_user.lv = 'b'  # æ¿€æ´»æ— è´¦å·ç”¨æˆ·
            
            start_date = datetime.now()
            
            if was_banned:
                # è¢«ç¦ç”¨ç”¨æˆ·ï¼šåŸºäºå°ç¦å‰çš„åˆ°æœŸæ—¶é—´åˆ¤æ–­
                prev_ex = existing_user.ban_prev_ex
                if prev_ex and prev_ex > start_date:
                    # å°ç¦å‰è®¢é˜…è¿˜æ²¡è¿‡æœŸï¼Œåœ¨åŸåˆ°æœŸæ—¶é—´ä¸Šå åŠ 
                    existing_user.ex = prev_ex + timedelta(days=days)
                else:
                    # å°ç¦å‰è®¢é˜…å·²è¿‡æœŸï¼Œä»é¢†å–æ—¶é—´å¼€å§‹æ¨ç®—
                    existing_user.ex = start_date + timedelta(days=days)
            else:
                # æ™®é€šç”¨æˆ·ï¼šå¦‚æœè¿˜æœ‰å‰©ä½™è®¢é˜…å°±åœ¨æ­¤åŸºç¡€ä¸Šå åŠ 
                if existing_user.ex and existing_user.ex > start_date:
                    existing_user.ex = existing_user.ex + timedelta(days=days)
                else:
                    existing_user.ex = start_date + timedelta(days=days)
            
            # åˆ›å»ºè®¢é˜…è®°å½•
            subscription = Subscription(
                user_tg=existing_user.tg,
                plan_type='gift',
                plan_name=f'ç®¡ç†å‘˜èµ é€ {days}å¤©',
                duration_months=0,  # æŒ‰å¤©èµ é€ï¼Œä¸æŒ‰æœˆè®¡
                price=0,
                start_date=start_date,
                end_date=existing_user.ex,
                status='active',
                source='gift'
            )
            db.session.add(subscription)
            
            # èµ é€å®Œæˆåå†è§£ç¦
            if was_banned:
                existing_user.lv = 'b'
                existing_user.ban_prev_lv = None
                existing_user.ban_prev_ex = None
                existing_user.ban_time = None
                existing_user.ban_reason = None
                # æ¢å¤Embyè´¦å·
                if existing_user.embyid and emby_client.is_enabled():
                    emby_client.enable_user(existing_user.embyid)
                app.logger.info(f'[Gift] è¢«ç¦ç”¨ç”¨æˆ· {existing_user.emby_name or existing_user.name} (tg={existing_user.tg}) é¢†å–èµ é€åè‡ªåŠ¨è§£ç¦')
            else:
                # éç¦ç”¨ç”¨æˆ·é¢†å–èµ é€åï¼Œä¹Ÿéœ€è¦æ¢å¤Embyè´¦å·
                # ï¼ˆç”¨æˆ·å¯èƒ½ä¹‹å‰å› è¿‡æœŸè¢«è‡ªåŠ¨ç¦ç”¨äº†Embyï¼Œä½†è´¦å·ç­‰çº§ä»æ˜¯'b'ï¼‰
                # é»‘åå•ç¦ç”¨çš„ç”¨æˆ·ä¸è‡ªåŠ¨æ¢å¤
                if not existing_user.ban_reason and existing_user.embyid and emby_client.is_enabled():
                    if emby_client.enable_user(existing_user.embyid):
                        app.logger.info(f'[Gift] ç”¨æˆ· {existing_user.emby_name or existing_user.name} é¢†å–èµ é€åæ¢å¤Embyè´¦å·')
            
            db.session.commit()
            
            ban_note = '\nğŸ”“ æ‚¨çš„è´¦å·å·²è‡ªåŠ¨è§£é™¤ç¦ç”¨ï¼' if was_banned else ''
            app.logger.info(f'[Gift] ä¸ºå·²æœ‰ç”¨æˆ· {existing_user.emby_name or existing_user.name} (tg={existing_user.tg}) åˆ›å»ºèµ é€è®¢é˜…è®°å½•: {days}å¤©{" (åŸè¢«ç¦ç”¨)" if was_banned else ""}')
            
            send_telegram_reply(chat_id, f"""âœ… <b>é¢†å–æˆåŠŸï¼</b>

å·²ä¸ºæ‚¨çš„è´¦å·å¢åŠ  <b>{days}</b> å¤©è®¢é˜…ï¼
æ„Ÿè°¢ {inviter_text} çš„èµ é€ ğŸ‰

ğŸ‘¤ è´¦å·: <b>{existing_user.emby_name or existing_user.name}</b>
ğŸ“… æ–°åˆ°æœŸæ—¶é—´: <b>{existing_user.ex.strftime('%Y-%m-%d %H:%M')}</b>{ban_note}""")
        
        # æ ‡è®°èµ é€ç ä¸ºå·²ä½¿ç”¨
        gift_data['used'] = True
        gift_data['used_by_id'] = telegram_user_id
        gift_data['used_by_name'] = telegram_username or ''
        gift_data['used_at'] = datetime.now().isoformat()
        set_db_config(gift_key, gift_data)
        
        # æ›´æ–°ç¾¤ç»„ä¸­çš„èµ é€æ¶ˆæ¯ä¸ºå·²é¢†å–çŠ¶æ€ï¼ˆå·²æœ‰è´¦å·=ç»­æœŸï¼‰
        _update_gift_message_claimed(gift_data, telegram_user_id, telegram_username, is_renew=True)
        
        return jsonify({'ok': True})
    
    # ç”¨æˆ·æ²¡æœ‰è´¦å·ï¼Œæ˜¾ç¤ºæ³¨å†Œé€‰é¡¹
    display_name = telegram_username or str(telegram_user_id)
    
    # å‘é€æ³¨å†Œæç¤ºæ¶ˆæ¯ï¼Œå¸¦æ³¨å†Œå’Œå–æ¶ˆæŒ‰é’®
    register_message = f"""ğŸŠ å°‘å¹´éƒï¼Œæ­å–œä½ ï¼Œå·²ç»æ”¶åˆ°äº† {inviter_text} å‘é€çš„é‚€è¯·æ³¨å†Œèµ„æ ¼

è¯·é€‰æ‹©ä½ çš„é€‰é¡¹~"""
    
    reply_markup = {
        'inline_keyboard': [[
            {'text': 'ğŸ“ æ³¨å†Œ', 'callback_data': f'reg_start_{gift_code}'},
            {'text': 'â­• å–æ¶ˆ', 'callback_data': f'reg_cancel_{gift_code}'}
        ]]
    }
    
    send_telegram_reply(chat_id, register_message, reply_markup)
    return jsonify({'ok': True})


def create_gift_account(chat_id, telegram_user_id, username, gift_code, gift_data):
    """åˆ›å»ºèµ é€è´¦å·"""
    import secrets
    
    days = gift_data.get('days', 0)
    from_user_id = gift_data.get('from_user_id')
    from_username = gift_data.get('from_username', 'ç®¡ç†å‘˜')
    
    # æ„å»ºé‚€è¯·äººé“¾æ¥
    if from_user_id:
        inviter_text = f'<a href="tg://user?id={from_user_id}">{from_username}</a>'
    else:
        inviter_text = f'<b>{from_username}</b>'
    
    # ç”Ÿæˆéšæœºå¯†ç 
    password = secrets.token_urlsafe(8)
    
    try:
        # åˆ›å»ºæ–°ç”¨æˆ·
        new_tg = generate_next_user_id()
        new_user = User(
            tg=new_tg,  # ç³»ç»Ÿè‡ªå¢æ­£æ•´æ•° ID
            telegram_id=telegram_user_id,
            name=username,
            pwd=password,
            lv='b',  # æ™®é€šç”¨æˆ·
            cr=datetime.now(),
            ex=datetime.now() + timedelta(days=days),
            us=1,
            coins=0,
        )
        
        db.session.add(new_user)
        db.session.flush()  # å…ˆflushä»¥è·å–ç”¨æˆ·ID
        
        # åˆ›å»ºè®¢é˜…è®°å½•
        subscription = Subscription(
            user_tg=new_user.tg,
            plan_type='gift',
            plan_name=f'ç®¡ç†å‘˜èµ é€ {days}å¤©',
            duration_months=0,  # æŒ‰å¤©èµ é€ï¼Œä¸æŒ‰æœˆè®¡
            price=0,
            start_date=new_user.cr,
            end_date=new_user.ex,
            status='active',
            source='gift'
        )
        db.session.add(subscription)
        db.session.commit()
        
        app.logger.info(f'[Gift] æˆåŠŸåˆ›å»ºè´¦å·: {username}, èµ é€ {days} å¤©ï¼Œå·²åˆ›å»ºè®¢é˜…è®°å½•')
        
        # æ ‡è®°èµ é€ç ä¸ºå·²ä½¿ç”¨
        gift_key = f'gift_{gift_code}'
        gift_data['used'] = True
        gift_data['used_by_id'] = telegram_user_id
        gift_data['used_by_name'] = username
        gift_data['used_at'] = datetime.now().isoformat()
        set_db_config(gift_key, gift_data)
        
        # æ›´æ–°ç¾¤ç»„ä¸­çš„èµ é€æ¶ˆæ¯ä¸ºå·²é¢†å–çŠ¶æ€ï¼ˆæ–°æ³¨å†Œï¼‰
        _update_gift_message_claimed(gift_data, telegram_user_id, username, is_renew=False)
        
        # è·å–é¢æ¿ç™»å½•é“¾æ¥
        site_config = load_site_config()
        panel_url = site_config.get('panel_url', '')
        
        # æ„å»ºç™»å½•é“¾æ¥æ–‡æœ¬
        if panel_url:
            login_link = f'\n\nğŸ”— <b>é¢æ¿ç™»å½•:</b> {panel_url}'
        else:
            login_link = ''
        
        send_telegram_reply(chat_id, f"""ğŸ‰ <b>è´¦å·åˆ›å»ºæˆåŠŸï¼</b>

æ„Ÿè°¢ {inviter_text} çš„èµ é€ï¼

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ‘¤ <b>è´¦å·ä¿¡æ¯</b>
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ç”¨æˆ·å: <code>{username}</code>
å¯†ç : <code>{password}</code>
è®¢é˜…å¤©æ•°: <b>{days}</b> å¤©
åˆ°æœŸæ—¶é—´: <b>{new_user.ex.strftime('%Y-%m-%d %H:%M')}</b>

âš ï¸ <b>è¯·å¦¥å–„ä¿å­˜è´¦å·ä¿¡æ¯ï¼</b>
ä½¿ç”¨æ­¤è´¦å·å¯†ç ç™»å½•ç½‘ç«™å³å¯ä½¿ç”¨ã€‚{login_link}

ğŸ’¡ å¦‚éœ€ä¿®æ”¹å¯†ç ï¼Œè¯·ç™»å½•ç½‘ç«™ååœ¨ä¸ªäººä¸­å¿ƒä¿®æ”¹ã€‚""")
        
        return jsonify({'ok': True})
        
    except Exception as e:
        db.session.rollback()
        app.logger.error(f'[Gift] åˆ›å»ºè´¦å·å¤±è´¥: {e}')
        send_telegram_reply(chat_id, f"âŒ åˆ›å»ºè´¦å·å¤±è´¥: {str(e)}")
        return jsonify({'ok': True})


def send_telegram_reply(chat_id, text, reply_markup=None, auto_delete=None):
    """å‘é€ Telegram æ¶ˆæ¯ï¼ˆæ”¯æŒ inline buttonï¼‰
    
    Args:
        chat_id: èŠå¤© ID
        text: æ¶ˆæ¯æ–‡æœ¬
        reply_markup: å†…è”é”®ç›˜
        auto_delete: è‡ªåŠ¨æ’¤å›å»¶è¿Ÿç§’æ•°ã€‚None=ç¾¤ç»„è‡ªåŠ¨æ’¤å›/ç§èŠä¸æ’¤å›, 0=ä¸æ’¤å›, >0=æŒ‡å®šå»¶è¿Ÿ
    
    Returns:
        æˆåŠŸè¿”å› message_id (int)ï¼Œå¤±è´¥è¿”å› False
    """
    if not TELEGRAM_BOT_TOKEN:
        app.logger.warning(f'[å‘é€æ¶ˆæ¯] Bot Token æœªé…ç½®ï¼Œæ— æ³•å‘é€åˆ° chat_id={chat_id}')
        return False
    
    try:
        url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendMessage"
        payload = {
            'chat_id': chat_id,
            'text': text,
            'parse_mode': 'HTML'
        }
        if reply_markup:
            payload['reply_markup'] = reply_markup
        app.logger.info(f'[å‘é€æ¶ˆæ¯] å‘é€åˆ° chat_id={chat_id}, æ–‡æœ¬é•¿åº¦={len(text)}, ä½¿ç”¨ä»£ç†: {PROXY_SESSION.proxies if hasattr(PROXY_SESSION, "proxies") else "æ— "}')
        
        response = PROXY_SESSION.post(url, json=payload, timeout=10)
        data = response.json()
        
        if data.get('ok'):
            sent_msg_id = data.get('result', {}).get('message_id')
            app.logger.info(f'[å‘é€æ¶ˆæ¯] å‘é€æˆåŠŸåˆ° chat_id={chat_id}, message_id={sent_msg_id}')
            
            # è‡ªåŠ¨æ’¤å›é€»è¾‘ï¼šç¾¤ç»„æ¶ˆæ¯é»˜è®¤è‡ªåŠ¨æ’¤å›
            if auto_delete is None and _is_group_chat(chat_id) and BOT_AUTO_DELETE_SECONDS > 0:
                schedule_delete_message(chat_id, sent_msg_id)
            elif auto_delete and auto_delete > 0:
                schedule_delete_message(chat_id, sent_msg_id, delay=auto_delete)
            
            return sent_msg_id or True
        else:
            error_desc = data.get('description', 'æœªçŸ¥é”™è¯¯')
            app.logger.error(f'[å‘é€æ¶ˆæ¯] å‘é€å¤±è´¥åˆ° chat_id={chat_id}: {error_desc}')
            return False
    except requests.exceptions.Timeout:
        app.logger.error(f'[å‘é€æ¶ˆæ¯] è¯·æ±‚è¶…æ—¶ï¼Œæ— æ³•å‘é€åˆ° chat_id={chat_id}ï¼Œè¯·æ£€æŸ¥ç½‘ç»œå’Œä»£ç†è®¾ç½®')
        return False
    except requests.exceptions.ConnectionError as e:
        app.logger.error(f'[å‘é€æ¶ˆæ¯] è¿æ¥é”™è¯¯ï¼Œæ— æ³•å‘é€åˆ° chat_id={chat_id}: {e}ï¼Œè¯·æ£€æŸ¥ç½‘ç»œå’Œä»£ç†è®¾ç½®')
        return False
    except Exception as e:
        app.logger.error(f'[å‘é€æ¶ˆæ¯] å‘é€ Telegram æ¶ˆæ¯å¤±è´¥åˆ° chat_id={chat_id}: {e}', exc_info=True)
        return False


def generate_captcha_image(code):
    """ç”ŸæˆéªŒè¯ç å›¾ç‰‡"""
    try:
        # åˆ›å»ºå›¾ç‰‡ (å®½300, é«˜100)
        width, height = 300, 100
        image = Image.new('RGB', (width, height), color=(255, 255, 255))
        draw = ImageDraw.Draw(image)
        
        # ç»˜åˆ¶èƒŒæ™¯å¹²æ‰°çº¿
        for _ in range(5):
            x1 = random.randint(0, width)
            y1 = random.randint(0, height)
            x2 = random.randint(0, width)
            y2 = random.randint(0, height)
            draw.line([(x1, y1), (x2, y2)], fill=(200, 200, 200), width=2)
        
        # ç»˜åˆ¶å¹²æ‰°ç‚¹
        for _ in range(100):
            x = random.randint(0, width)
            y = random.randint(0, height)
            draw.point((x, y), fill=(random.randint(150, 200), random.randint(150, 200), random.randint(150, 200)))
        
        # å°è¯•åŠ è½½å­—ä½“ï¼Œå¦‚æœå¤±è´¥ä½¿ç”¨é»˜è®¤å­—ä½“
        try:
            # å°è¯•ä½¿ç”¨ç³»ç»Ÿå­—ä½“
            font = ImageFont.truetype("arial.ttf", 50)
        except:
            try:
                # Windowsç³»ç»Ÿå­—ä½“
                font = ImageFont.truetype("C:/Windows/Fonts/arial.ttf", 50)
            except:
                try:
                    # å…¶ä»–å¯èƒ½çš„å­—ä½“è·¯å¾„
                    font = ImageFont.truetype("/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf", 50)
                except:
                    # ä½¿ç”¨é»˜è®¤å­—ä½“
                    font = ImageFont.load_default()
        
        # è®¡ç®—æ–‡æœ¬ä½ç½®ï¼ˆå±…ä¸­ï¼‰
        text = str(code)
        try:
            # æ–°ç‰ˆæœ¬PIL
            bbox = draw.textbbox((0, 0), text, font=font)
            text_width = bbox[2] - bbox[0]
            text_height = bbox[3] - bbox[1]
        except:
            # æ—§ç‰ˆæœ¬PIL
            text_width, text_height = draw.textsize(text, font=font)
        
        x = (width - text_width) // 2
        y = (height - text_height) // 2
        
        # ç»˜åˆ¶éªŒè¯ç æ–‡å­—ï¼ˆæ·»åŠ é¢œè‰²å˜åŒ–ï¼‰
        for i, char in enumerate(text):
            char_x = x + i * (text_width // len(text))
            char_y = y + random.randint(-5, 5)  # éšæœºä¸Šä¸‹åç§»
            color = (
                random.randint(0, 100),
                random.randint(0, 100),
                random.randint(0, 100)
            )
            draw.text((char_x, char_y), char, font=font, fill=color)
        
        # ä¿å­˜åˆ°BytesIO
        bio = BytesIO()
        image.save(bio, format='PNG')
        bio.seek(0)
        return bio
    except Exception as e:
        app.logger.error(f'ç”ŸæˆéªŒè¯ç å›¾ç‰‡å¤±è´¥: {e}')
        return None


def send_telegram_photo(chat_id, photo_bytes, caption=None, auto_delete=None):
    """å‘é€ Telegram å›¾ç‰‡
    
    Returns:
        æˆåŠŸè¿”å› message_id (int)ï¼Œå¤±è´¥è¿”å› False
    """
    if not TELEGRAM_BOT_TOKEN:
        app.logger.warning(f'[å‘é€å›¾ç‰‡] Bot Token æœªé…ç½®ï¼Œæ— æ³•å‘é€åˆ° chat_id={chat_id}')
        return False
    
    try:
        url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendPhoto"
        
        files = {
            'photo': ('captcha.png', photo_bytes, 'image/png')
        }
        
        data = {
            'chat_id': chat_id
        }
        
        if caption:
            data['caption'] = caption
            data['parse_mode'] = 'HTML'
        
        app.logger.info(f'[å‘é€å›¾ç‰‡] å‘é€åˆ° chat_id={chat_id}')
        
        response = PROXY_SESSION.post(url, data=data, files=files, timeout=15)
        result = response.json()
        
        if result.get('ok'):
            sent_msg_id = result.get('result', {}).get('message_id')
            app.logger.info(f'[å‘é€å›¾ç‰‡] å‘é€æˆåŠŸåˆ° chat_id={chat_id}, message_id={sent_msg_id}')
            
            # è‡ªåŠ¨æ’¤å›é€»è¾‘
            if auto_delete is None and _is_group_chat(chat_id) and BOT_AUTO_DELETE_SECONDS > 0:
                schedule_delete_message(chat_id, sent_msg_id)
            elif auto_delete and auto_delete > 0:
                schedule_delete_message(chat_id, sent_msg_id, delay=auto_delete)
            
            return sent_msg_id or True
        else:
            error_desc = result.get('description', 'æœªçŸ¥é”™è¯¯')
            app.logger.error(f'[å‘é€å›¾ç‰‡] å‘é€å¤±è´¥åˆ° chat_id={chat_id}: {error_desc}')
            return False
    except requests.exceptions.Timeout:
        app.logger.error(f'[å‘é€å›¾ç‰‡] è¯·æ±‚è¶…æ—¶ï¼Œæ— æ³•å‘é€åˆ° chat_id={chat_id}')
        return False
    except Exception as e:
        app.logger.error(f'[å‘é€å›¾ç‰‡] å‘é€å¤±è´¥åˆ° chat_id={chat_id}: {e}', exc_info=True)
        return False


def send_telegram_photo_url(chat_id, photo_url, caption=None, reply_markup=None, auto_delete=None):
    """é€šè¿‡ URL å‘é€ Telegram å›¾ç‰‡
    
    Args:
        chat_id: èŠå¤©ID
        photo_url: å›¾ç‰‡URL
        caption: å›¾ç‰‡è¯´æ˜æ–‡å­—
        reply_markup: å†…è”é”®ç›˜æŒ‰é’®
        auto_delete: è‡ªåŠ¨æ’¤å›å»¶è¿Ÿç§’æ•°ã€‚None=ç¾¤ç»„è‡ªåŠ¨æ’¤å›, 0=ä¸æ’¤å›, >0=æŒ‡å®šå»¶è¿Ÿ
    
    Returns:
        æˆåŠŸè¿”å› message_id (int)ï¼Œå¤±è´¥è¿”å› False
    """
    if not TELEGRAM_BOT_TOKEN:
        app.logger.warning(f'[å‘é€å›¾ç‰‡URL] Bot Token æœªé…ç½®ï¼Œæ— æ³•å‘é€åˆ° chat_id={chat_id}')
        return False
    
    try:
        url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendPhoto"
        
        payload = {
            'chat_id': chat_id,
            'photo': photo_url
        }
        
        if caption:
            payload['caption'] = caption
            payload['parse_mode'] = 'HTML'
        
        if reply_markup:
            payload['reply_markup'] = reply_markup
        
        app.logger.info(f'[å‘é€å›¾ç‰‡URL] å‘é€åˆ° chat_id={chat_id}, photo_url={photo_url[:50]}...')
        
        response = PROXY_SESSION.post(url, json=payload, timeout=15)
        result = response.json()
        
        if result.get('ok'):
            sent_msg_id = result.get('result', {}).get('message_id')
            app.logger.info(f'[å‘é€å›¾ç‰‡URL] å‘é€æˆåŠŸåˆ° chat_id={chat_id}, message_id={sent_msg_id}')
            
            # è‡ªåŠ¨æ’¤å›é€»è¾‘
            if auto_delete is None and _is_group_chat(chat_id) and BOT_AUTO_DELETE_SECONDS > 0:
                schedule_delete_message(chat_id, sent_msg_id)
            elif auto_delete and auto_delete > 0:
                schedule_delete_message(chat_id, sent_msg_id, delay=auto_delete)
            
            return sent_msg_id or True
        else:
            error_desc = result.get('description', 'æœªçŸ¥é”™è¯¯')
            app.logger.error(f'[å‘é€å›¾ç‰‡URL] å‘é€å¤±è´¥åˆ° chat_id={chat_id}: {error_desc}')
            return False
    except requests.exceptions.Timeout:
        app.logger.error(f'[å‘é€å›¾ç‰‡URL] è¯·æ±‚è¶…æ—¶ï¼Œæ— æ³•å‘é€åˆ° chat_id={chat_id}')
        return False
    except Exception as e:
        app.logger.error(f'[å‘é€å›¾ç‰‡URL] å‘é€å¤±è´¥åˆ° chat_id={chat_id}: {e}', exc_info=True)
        return False


def build_start_panel(telegram_user_id, telegram_first_name, telegram_username):
    """æ„å»º /start é¢æ¿å†…å®¹
    
    è¿”å›: (caption, reply_markup, photo_url)
    """
    # è·å–é…ç½®
    checkin_config = get_db_config('checkin', {})
    coin_name = checkin_config.get('coin_name', 'ç§¯åˆ†')
    checkin_enabled = checkin_config.get('enabled', False) and checkin_config.get('bot_enabled', False)
    
    # è·å–ç³»ç»Ÿé…ç½®ä¸­çš„ bot_photo
    system_config = load_system_config()
    bot_photo = system_config.get('telegram', {}).get('bot_photo', '')
    
    # é»˜è®¤å›¾ç‰‡
    if not bot_photo:
        bot_photo = 'https://telegra.ph/file/3b6cd2a89b652e72e0d3b.png'
    
    # æŸ¥è¯¢ç”¨æˆ·ä¿¡æ¯
    user = User.query.filter_by(telegram_id=telegram_user_id).first()
    user_name = telegram_first_name or telegram_username or 'ç”¨æˆ·'
    
    if user:
        # å·²ç»‘å®šç”¨æˆ·
        now = datetime.now()
        
        # è·å–ç”¨æˆ·ç­‰çº§æ˜¾ç¤º
        _start_wl = Subscription.query.filter_by(user_tg=user.tg, plan_type='whitelist', status='active').first()
        if _start_wl or user.lv == 'a':
            lv_display = 'ğŸ‘‘ ç™½åå•'
        else:
            lv_display = {
                'b': 'â­ è®¢é˜…ç”¨æˆ·' if user.ex and user.ex > now else 'æ™®é€šç”¨æˆ·',
                'c': 'ğŸš« å·²ç¦ç”¨',
                'd': 'ğŸ“­ æ— è´¦å·'
            }.get(user.lv, 'æœªçŸ¥')
        
        # åˆ°æœŸæ—¶é—´æ˜¾ç¤º
        if _start_wl or user.lv == 'a':
            ex_display = 'æ°¸ä¹…'
        elif user.ex:
            ex_display = user.ex.strftime('%Y-%m-%d %H:%M')
        else:
            ex_display = 'æœªè®¾ç½®'
        
        caption = f"""<b>âœ¨ æ¬¢è¿å›æ¥ï¼Œ{user_name}ï¼</b>

<b>Â· ğŸ†” ç”¨æˆ·ID</b> | <code>{telegram_user_id}</code>
<b>Â· ğŸ“Š å½“å‰çŠ¶æ€</b> | {lv_display}
<b>Â· ğŸ’ æŒæœ‰{coin_name}</b> | {user.coins or 0}
<b>Â· ğŸ’  è´¦å·åç§°</b> | {user.name or 'æœªè®¾ç½®'}
<b>Â· ğŸš¨ åˆ°æœŸæ—¶é—´</b> | {ex_display}

<i>ğŸ‘‡ è¯·é€‰æ‹©åŠŸèƒ½</i>"""
    else:
        # æœªç»‘å®šç”¨æˆ·
        caption = f"""<b>â–æ¬¢è¿è¿›å…¥ç”¨æˆ·é¢æ¿ï¼{user_name}</b>

<b>Â· ğŸ†” ç”¨æˆ·ID</b> | <code>{telegram_user_id}</code>
<b>Â· ğŸ“Š å½“å‰çŠ¶æ€</b> | æœªç»‘å®š
<b>Â· ğŸ’ æŒæœ‰{coin_name}</b> | 0
<b>Â· ğŸ’  è´¦å·åç§°</b> | æ— è´¦æˆ·ä¿¡æ¯
<b>Â· ğŸš¨ åˆ°æœŸæ—¶é—´</b> | æ— è´¦æˆ·ä¿¡æ¯

<i>ğŸ‘‡ è¯·å…ˆç»‘å®šè´¦å·æˆ–æ³¨å†Œ</i>"""
    
    # æ„å»ºæŒ‰é’®
    buttons = []
    
    if user:
        # å·²ç»‘å®šç”¨æˆ·çš„æŒ‰é’®
        # ç¬¬ä¸€æ’ï¼šæˆ‘çš„çŠ¶æ€ + æ¯æ—¥ç­¾åˆ°
        row1 = [{'text': 'ğŸ“Š æˆ‘çš„çŠ¶æ€', 'callback_data': 'cmd_status'}]
        if checkin_enabled:
            row1.append({'text': 'ğŸ¯ æ¯æ—¥ç­¾åˆ°', 'callback_data': 'cmd_checkin'})
        buttons.append(row1)
        
        # ç¬¬äºŒæ’ï¼šè§£ç»‘è´¦å·
        row2 = [{'text': 'ğŸ”“ è§£ç»‘è´¦å·', 'callback_data': 'cmd_unbind'}]
        buttons.append(row2)
    else:
        # æœªç»‘å®šç”¨æˆ·çš„æŒ‰é’®
        row1 = [{'text': 'ğŸ”— å¦‚ä½•ç»‘å®š', 'callback_data': 'cmd_bind_help'}]
        buttons.append(row1)
    
    # ç¬¬ä¸‰æ’ï¼šåˆ é™¤æ¶ˆæ¯
    buttons.append([{'text': 'ğŸ—‘ï¸ åˆ é™¤æ¶ˆæ¯', 'callback_data': 'cmd_close'}])
    
    reply_markup = {'inline_keyboard': buttons}
    
    return caption, reply_markup, bot_photo


# ===== Bot æ¶ˆæ¯è‡ªåŠ¨æ’¤å›ï¼ˆç¾¤ç»„æ¶ˆæ¯30ç§’åè‡ªåŠ¨åˆ é™¤ï¼‰ =====
BOT_AUTO_DELETE_SECONDS = 30  # ç¾¤ç»„æ¶ˆæ¯è‡ªåŠ¨æ’¤å›å»¶è¿Ÿï¼ˆç§’ï¼‰ï¼Œè®¾ä¸º 0 ç¦ç”¨

def schedule_delete_message(chat_id, message_id, delay=None):
    """å»¶è¿Ÿåˆ é™¤ Telegram æ¶ˆæ¯ï¼ˆç”¨äºç¾¤ç»„æ¶ˆæ¯è‡ªåŠ¨æ’¤å›ï¼‰
    
    Args:
        chat_id: èŠå¤© ID
        message_id: æ¶ˆæ¯ ID
        delay: å»¶è¿Ÿç§’æ•°ï¼Œé»˜è®¤ä½¿ç”¨ BOT_AUTO_DELETE_SECONDS
    """
    if delay is None:
        delay = BOT_AUTO_DELETE_SECONDS
    if not message_id or delay <= 0:
        return
    
    def _do_delete():
        try:
            delete_telegram_message(chat_id, message_id)
            app.logger.debug(f'[è‡ªåŠ¨æ’¤å›] å·²åˆ é™¤æ¶ˆæ¯ chat_id={chat_id}, message_id={message_id}')
        except Exception as e:
            app.logger.debug(f'[è‡ªåŠ¨æ’¤å›] åˆ é™¤å¤±è´¥: {e}')
    
    timer = threading.Timer(delay, _do_delete)
    timer.daemon = True
    timer.start()


def _is_group_chat(chat_id):
    """åˆ¤æ–­æ˜¯å¦ä¸ºç¾¤ç»„èŠå¤©ï¼ˆç¾¤ç»„ chat_id ä¸ºè´Ÿæ•°ï¼‰"""
    try:
        return int(chat_id) < 0
    except (TypeError, ValueError):
        return False


def delete_telegram_message(chat_id, message_id):
    """åˆ é™¤ Telegram æ¶ˆæ¯"""
    if not TELEGRAM_BOT_TOKEN:
        return False
    
    try:
        url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/deleteMessage"
        payload = {
            'chat_id': chat_id,
            'message_id': message_id
        }
        response = PROXY_SESSION.post(url, json=payload, timeout=5)
        data = response.json()
        
        if data.get('ok'):
            app.logger.info(f'[åˆ é™¤æ¶ˆæ¯] æˆåŠŸåˆ é™¤æ¶ˆæ¯ chat_id={chat_id}, message_id={message_id}')
            return True
        else:
            # åˆ é™¤å¤±è´¥ä¸æ‰“å°é”™è¯¯ï¼Œå¯èƒ½æ˜¯æƒé™ä¸è¶³æˆ–æ¶ˆæ¯å·²è¢«åˆ é™¤
            app.logger.debug(f'[åˆ é™¤æ¶ˆæ¯] åˆ é™¤å¤±è´¥: {data.get("description", "æœªçŸ¥é”™è¯¯")}')
            return False
    except Exception as e:
        app.logger.debug(f'[åˆ é™¤æ¶ˆæ¯] åˆ é™¤å¼‚å¸¸: {e}')
        return False


# ç¼“å­˜æœºå™¨äººç”¨æˆ·å
_bot_username_cache = None
_bot_username_cache_time = 0

def get_bot_username():
    """è·å–æœºå™¨äººç”¨æˆ·åï¼ˆå¸¦ç¼“å­˜ï¼‰"""
    global _bot_username_cache, _bot_username_cache_time
    
    if not TELEGRAM_BOT_TOKEN:
        return None
    
    # ç¼“å­˜æœ‰æ•ˆæœŸ 1 å°æ—¶
    if _bot_username_cache and (time.time() - _bot_username_cache_time) < 3600:
        return _bot_username_cache
    
    try:
        url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/getMe"
        response = PROXY_SESSION.get(url, timeout=10)
        data = response.json()
        
        if data.get('ok'):
            _bot_username_cache = data.get('result', {}).get('username')
            _bot_username_cache_time = time.time()
            return _bot_username_cache
    except Exception as e:
        app.logger.error(f'è·å–æœºå™¨äººç”¨æˆ·åå¤±è´¥: {e}')
    
    return None


def get_user_watch_time_30days(user_tg):
    """è·å–ç”¨æˆ·æœ€è¿‘30å¤©çš„è§‚çœ‹æ—¶é—´ï¼ˆåˆ†é’Ÿï¼‰
    
    ä¼˜å…ˆä» Emby Playback Reporting æ’ä»¶è·å–ï¼Œå¦‚æœå¤±è´¥åˆ™ä»æœ¬åœ°æ•°æ®åº“è·å–
    
    Args:
        user_tg: ç”¨æˆ·çš„ tg ID
        
    Returns:
        int: è§‚çœ‹æ—¶é—´ï¼ˆåˆ†é’Ÿï¼‰ï¼Œå¦‚æœæ²¡æœ‰è®°å½•è¿”å› 0
    """
    try:
        # å…ˆè·å–ç”¨æˆ·çš„ Emby ID
        user = User.query.filter_by(tg=user_tg).first()
        if not user:
            user = User.query.filter_by(telegram_id=user_tg).first()
        
        if user and user.embyid and emby_client.is_enabled():
            # å°è¯•ä» Emby Playback Reporting æ’ä»¶è·å–
            watch_time = get_emby_user_watch_time(user.embyid, 30)
            if watch_time is not None:
                return watch_time
        
        # å›é€€ï¼šä»æœ¬åœ° PlaybackRecord è¡¨æŸ¥è¯¢
        # play_duration å­˜çš„æ˜¯æ’­æ”¾ä½ç½®ï¼ˆpositionï¼‰ï¼ŒåŒä¸€åª’ä½“å¤šæ¡è®°å½•ä¼šé‡å¤
        # å¯¹æ¯ä¸ª emby_item_id å– MAX(play_duration)ï¼Œå†æ±‚å’Œ
        thirty_days_ago = datetime.now() - timedelta(days=30)
        from sqlalchemy import func as sa_func
        duration_by_item = db.session.query(
            sa_func.max(PlaybackRecord.play_duration)
        ).filter(
            PlaybackRecord.user_tg == user_tg,
            PlaybackRecord.started_at >= thirty_days_ago
        ).group_by(
            PlaybackRecord.emby_item_id
        ).all()
        total_sec = sum(r[0] or 0 for r in duration_by_item)
        
        if total_sec:
            return int(total_sec / 60)
        return 0
    except Exception as e:
        app.logger.error(f'è·å–ç”¨æˆ·è§‚çœ‹æ—¶é—´å¤±è´¥: {e}')
        return 0


def get_emby_user_watch_time(emby_user_id, days=30):
    """ä» Emby è·å–ç”¨æˆ·è§‚çœ‹æ—¶é—´
    
    å°è¯•å¤šç§æ–¹å¼è·å–ï¼š
    1. Playback Reporting æ’ä»¶ API
    2. Emby æ ‡å‡† PlaybackInfo API
    
    Args:
        emby_user_id: Emby ç”¨æˆ· ID
        days: ç»Ÿè®¡å¤©æ•°
        
    Returns:
        int: è§‚çœ‹æ—¶é—´ï¼ˆåˆ†é’Ÿï¼‰ï¼Œå¤±è´¥è¿”å› None
    """
    if not emby_client.is_enabled():
        return None
    
    try:
        # è®¡ç®—æ—¥æœŸèŒƒå›´
        end_date = datetime.now()
        start_date = end_date - timedelta(days=days)
        
        # æ–¹å¼1: Playback Reporting æ’ä»¶ API: /user_usage_stats/UserPlaylist
        try:
            url = f"{emby_client.base_url}/user_usage_stats/UserPlaylist"
            params = {
                'api_key': emby_client.api_key,
                'user_id': emby_user_id,
                'days': days,
                'end_date': end_date.strftime('%Y-%m-%d'),
                'filter': ''
            }
            
            response = emby_client.session.get(url, params=params, timeout=10)
            
            if response.status_code == 200:
                data = response.json()
                total_seconds = 0
                for item in data:
                    duration = item.get('PlayDuration', 0)
                    if duration:
                        total_seconds += duration
                
                if total_seconds > 0:
                    app.logger.debug(f'ä» Playback Reporting è·å–è§‚çœ‹æ—¶é—´: user={emby_user_id}, {total_seconds}ç§’')
                    return int(total_seconds / 60)
        except Exception as e:
            app.logger.debug(f'Playback Reporting API å¤±è´¥: {e}')
        
        # æ–¹å¼2: user_usage_stats/user_activity API
        try:
            url2 = f"{emby_client.base_url}/user_usage_stats/user_activity"
            params2 = {
                'api_key': emby_client.api_key,
                'user_id': emby_user_id,
                'days': days
            }
            
            response2 = emby_client.session.get(url2, params=params2, timeout=10)
            if response2.status_code == 200:
                data2 = response2.json()
                total_minutes = 0
                for day_data in data2:
                    time_val = day_data.get('Time', 0) or day_data.get('PlayDuration', 0)
                    if time_val:
                        total_minutes += time_val
                
                if total_minutes > days * 24 * 60:
                    total_minutes = int(total_minutes / 60)
                
                if total_minutes > 0:
                    app.logger.debug(f'ä» user_activity API è·å–è§‚çœ‹æ—¶é—´: user={emby_user_id}, {total_minutes}åˆ†é’Ÿ')
                    return int(total_minutes)
        except Exception as e:
            app.logger.debug(f'user_activity API å¤±è´¥: {e}')
        
        # æ–¹å¼3: ä» Items/PlayedItems è·å–å·²æ’­æ”¾é¡¹ç›®å¹¶è®¡ç®—
        try:
            url3 = f"{emby_client.base_url}/Users/{emby_user_id}/Items"
            params3 = {
                'api_key': emby_client.api_key,
                'Filters': 'IsPlayed',
                'Recursive': 'true',
                'Fields': 'RunTimeTicks,UserData',
                'Limit': 500,
                'SortBy': 'DatePlayed',
                'SortOrder': 'Descending'
            }
            
            response3 = emby_client.session.get(url3, params=params3, timeout=15)
            if response3.status_code == 200:
                data3 = response3.json()
                items = data3.get('Items', [])
                
                total_ticks = 0
                for item in items:
                    user_data = item.get('UserData', {})
                    last_played = user_data.get('LastPlayedDate')
                    
                    if last_played:
                        try:
                            # è§£ææ’­æ”¾æ—¥æœŸ
                            played_date = datetime.fromisoformat(last_played.replace('Z', '+00:00'))
                            if played_date.replace(tzinfo=None) >= start_date:
                                # åœ¨30å¤©å†…æ’­æ”¾è¿‡
                                play_count = user_data.get('PlayCount', 1) or 1
                                runtime = item.get('RunTimeTicks', 0)
                                if runtime:
                                    total_ticks += runtime * play_count
                        except:
                            pass
                
                if total_ticks > 0:
                    total_minutes = int(total_ticks / 10000000 / 60)
                    app.logger.debug(f'ä» PlayedItems è®¡ç®—è§‚çœ‹æ—¶é—´: user={emby_user_id}, {total_minutes}åˆ†é’Ÿ')
                    return total_minutes
        except Exception as e:
            app.logger.debug(f'PlayedItems API å¤±è´¥: {e}')
        
        return None
    except Exception as e:
        app.logger.debug(f'ä» Emby è·å–è§‚çœ‹æ—¶é—´å¤±è´¥: {e}')
        return None


def register_telegram_commands():
    """æ³¨å†Œ Telegram Bot å‘½ä»¤èœå•"""
    if not TELEGRAM_BOT_TOKEN:
        return False
    return register_telegram_commands_with_token(TELEGRAM_BOT_TOKEN)


def register_telegram_commands_with_token(bot_token):
    """ä½¿ç”¨æŒ‡å®šçš„ token æ³¨å†Œ Telegram Bot å‘½ä»¤èœå•"""
    if not bot_token:
        app.logger.warning('[Telegram] æ³¨å†Œå‘½ä»¤å¤±è´¥: bot_token ä¸ºç©º')
        return False
    
    commands = [
        {"command": "start", "description": "å¼€å§‹ä½¿ç”¨"},
        {"command": "bind", "description": "ç»‘å®šç½‘ç«™è´¦å·"},
        {"command": "unbind", "description": "è§£ç»‘è´¦å·"},
        {"command": "status", "description": "æŸ¥çœ‹è´¦å·çŠ¶æ€"},
        {"command": "myinfo", "description": "æŸ¥çœ‹æˆ‘çš„ä¿¡æ¯"},
        {"command": "count", "description": "æŸ¥çœ‹åª’ä½“åº“ç»Ÿè®¡"},
        {"command": "checkin", "description": "æ¯æ—¥ç­¾åˆ°"},
        {"command": "kk", "description": "ç®¡ç†å‘˜å¿«æ·æ“ä½œ"},
        {"command": "cancel", "description": "å–æ¶ˆå½“å‰æ“ä½œ"}
    ]
    
    try:
        app.logger.info(f'[Telegram] å¼€å§‹æ³¨å†Œå‘½ä»¤èœå•ï¼Œå…± {len(commands)} ä¸ªå‘½ä»¤')
        
        # å…ˆåˆ é™¤æ—§çš„å‘½ä»¤
        delete_url = f"https://api.telegram.org/bot{bot_token}/deleteMyCommands"
        try:
            delete_resp = PROXY_SESSION.post(delete_url, timeout=10)
            app.logger.info(f'[Telegram] æ¸…é™¤æ—§å‘½ä»¤ç»“æœ: {delete_resp.json()}')
        except Exception as e:
            app.logger.warning(f'[Telegram] æ¸…é™¤æ—§å‘½ä»¤å¤±è´¥ï¼ˆå¯å¿½ç•¥ï¼‰: {e}')
        
        # æ³¨å†Œæ–°å‘½ä»¤
        url = f"https://api.telegram.org/bot{bot_token}/setMyCommands"
        payload = {"commands": commands}
        app.logger.info(f'[Telegram] æ³¨å†Œå‘½ä»¤è¯·æ±‚: {payload}')
        
        response = PROXY_SESSION.post(url, json=payload, timeout=10)
        data = response.json()
        app.logger.info(f'[Telegram] æ³¨å†Œå‘½ä»¤å“åº”: {data}')
        
        if data.get('ok'):
            app.logger.info('[Telegram] å‘½ä»¤èœå•æ³¨å†ŒæˆåŠŸ')
            
            # éªŒè¯æ³¨å†Œç»“æœ
            try:
                verify_url = f"https://api.telegram.org/bot{bot_token}/getMyCommands"
                verify_resp = PROXY_SESSION.get(verify_url, timeout=10)
                verify_data = verify_resp.json()
                if verify_data.get('ok'):
                    registered_commands = verify_data.get('result', [])
                    app.logger.info(f'[Telegram] éªŒè¯å·²æ³¨å†Œå‘½ä»¤: {registered_commands}')
                else:
                    app.logger.warning(f'[Telegram] éªŒè¯å‘½ä»¤å¤±è´¥: {verify_data}')
            except Exception as e:
                app.logger.warning(f'[Telegram] éªŒè¯å‘½ä»¤å¼‚å¸¸: {e}')
            
            return True
        else:
            app.logger.warning(f'[Telegram] å‘½ä»¤èœå•æ³¨å†Œå¤±è´¥: {data.get("description")}')
            return False
    except Exception as e:
        app.logger.error(f'[Telegram] æ³¨å†Œå‘½ä»¤å¤±è´¥: {e}')
        return False


@app.route('/api/webhook/telegram/setup', methods=['GET', 'POST'])
@admin_required
def setup_telegram_webhook():
    """
    è®¾ç½® Telegram Bot Webhook (ç®¡ç†å‘˜)
    
    GET: æŸ¥çœ‹å½“å‰ Webhook çŠ¶æ€
    POST: è®¾ç½®æ–°çš„ Webhook URL
        å‚æ•°: { "url": "https://your-domain.com" }
        æˆ– ?url=https://your-domain.com
    """
    global TELEGRAM_CONFIGURED_URL
    
    if not TELEGRAM_BOT_TOKEN:
        return jsonify({
            'success': False,
            'error': 'Telegram Bot Token æœªé…ç½®'
        }), 400
    
    if request.method == 'GET':
        # è·å–å½“å‰ Webhook ä¿¡æ¯
        try:
            url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/getWebhookInfo"
            response = PROXY_SESSION.get(url, timeout=10)
            data = response.json()
            return jsonify({
                'success': True,
                'webhook_info': data.get('result', {}),
                'setup_url': '/api/webhook/telegram/setup?url=https://your-domain.com'
            })
        except Exception as e:
            return jsonify({'success': False, 'error': str(e)}), 500
    
    else:  # POST
        # è®¾ç½® Webhook
        base_url = request.args.get('url') or (request.json or {}).get('url', '')
        app.logger.info(f'[Telegramè®¾ç½®] æ”¶åˆ°è®¾ç½®è¯·æ±‚ - base_url={base_url}')
        
        if not base_url:
            app.logger.warning('[Telegramè®¾ç½®] URL å‚æ•°ä¸ºç©º')
            return jsonify({
                'success': False,
                'error': 'è¯·æä¾› url å‚æ•°',
                'example': '/api/webhook/telegram/setup?url=https://your-domain.com'
            }), 400
        
        # Webhook æ¨¡å¼éœ€è¦ HTTPS åŸŸå
        if not base_url.startswith('https://'):
            app.logger.warning(f'[Telegramè®¾ç½®] URL æ ¼å¼ä¸æ­£ç¡®: {base_url}')
            return jsonify({
                'success': False,
                'error': 'Webhook æ¨¡å¼éœ€è¦ HTTPS åŸŸå',
                'tip': 'è¯·ä½¿ç”¨ https:// å¼€å¤´çš„åŸŸå',
                'example': 'https://your-domain.com'
            }), 400
        
        # æ„å»ºå®Œæ•´çš„ webhook URL
        webhook_url = base_url.rstrip('/') + '/api/webhook/telegram'
        app.logger.info(f'[Webhookæ¨¡å¼] æ„å»º Webhook URL: {webhook_url}')
        
        try:
            # â˜… å…ˆåˆ é™¤æ—§ Webhookï¼Œç¡®ä¿ drop_pending_updates ç”Ÿæ•ˆ
            # Telegram åœ¨ URL ä¸å˜æ—¶å¯èƒ½ä¸ä¼šé‡æ–° drop pending updates
            # å…ˆ delete å† set ä¿è¯æ¯æ¬¡éƒ½æ˜¯å¹²å‡€çŠ¶æ€ï¼Œä¸ä¼šé‡å¤æ¨é€
            delete_url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/deleteWebhook"
            try:
                del_resp = PROXY_SESSION.post(delete_url, json={'drop_pending_updates': True}, timeout=10)
                app.logger.info(f'[Webhookæ¨¡å¼] åˆ é™¤æ—§ Webhook: {del_resp.json()}')
            except Exception as e:
                app.logger.warning(f'[Webhookæ¨¡å¼] åˆ é™¤æ—§ Webhook å¤±è´¥ï¼ˆå¯å¿½ç•¥ï¼‰: {e}')
            
            # ç”Ÿæˆéšæœº secret_tokenï¼Œç”¨äºéªŒè¯ Webhook è¯·æ±‚ç¡®å®æ¥è‡ªæ­¤ Bot
            import secrets as _secrets
            webhook_secret = _secrets.token_hex(32)
            
            url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/setWebhook"
            payload = {
                'url': webhook_url,
                'allowed_updates': ['message', 'callback_query', 'chat_member'],
                'drop_pending_updates': True,
                'secret_token': webhook_secret
            }
            app.logger.info(f'[Webhookæ¨¡å¼] å‘é€è®¾ç½®è¯·æ±‚ - url={webhook_url}, secret_tokenå·²ç”Ÿæˆ')
            
            response = PROXY_SESSION.post(url, json=payload, timeout=10)
            data = response.json()
            
            app.logger.info(f'[Webhookæ¨¡å¼] Telegram å“åº”: {json.dumps(data, ensure_ascii=False)}')
            
            if data.get('ok'):
                app.logger.info(f'[Webhookæ¨¡å¼] è®¾ç½®æˆåŠŸ: {webhook_url}')
                
                # ä¿å­˜ secret_token åˆ°å…¨å±€å˜é‡å’Œé…ç½®
                global _TELEGRAM_WEBHOOK_SECRET
                _TELEGRAM_WEBHOOK_SECRET = webhook_secret
                
                # ä¿å­˜åˆ°æ•°æ®åº“
                TELEGRAM_CONFIGURED_URL = base_url
                current_config = get_db_config(CONFIG_KEY_TELEGRAM) or {}
                current_config['configured_url'] = base_url
                current_config['webhook_secret_token'] = webhook_secret
                set_db_config(CONFIG_KEY_TELEGRAM, current_config, 'Telegram BOTé…ç½®')
                
                # åŒæ—¶ä¿å­˜åˆ°ç³»ç»Ÿé…ç½®æ–‡ä»¶
                sys_config = load_system_config()
                sys_config['telegram']['configured_url'] = base_url
                sys_config['telegram']['webhook_secret_token'] = webhook_secret
                save_system_config(sys_config)
                
                # æ³¨å†Œå‘½ä»¤èœå•
                register_telegram_commands()
                
                return jsonify({
                    'success': True,
                    'configured_url': base_url,
                    'message': 'âœ… Webhook è®¾ç½®æˆåŠŸ',
                    'webhook_url': webhook_url,
                    'tip': 'Webhook æ¨¡å¼ä¸‹ï¼ŒTelegram å°†æ¨é€æ¶ˆæ¯åˆ°æ‚¨çš„æœåŠ¡å™¨'
                })
            else:
                error_msg = data.get('description', 'è®¾ç½®å¤±è´¥')
                app.logger.error(f'[Webhookæ¨¡å¼] è®¾ç½®å¤±è´¥: {error_msg}')
                return jsonify({
                    'success': False,
                    'error': error_msg
                }), 400
        except requests.exceptions.Timeout:
            app.logger.error('[Webhookæ¨¡å¼] è¯·æ±‚è¶…æ—¶')
            return jsonify({'success': False, 'error': 'è¯·æ±‚è¶…æ—¶ï¼Œè¯·æ£€æŸ¥ç½‘ç»œå’Œä»£ç†è®¾ç½®'}), 500
        except requests.exceptions.ConnectionError as e:
            app.logger.error(f'[Webhookæ¨¡å¼] è¿æ¥é”™è¯¯: {e}')
            return jsonify({'success': False, 'error': f'è¿æ¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œå’Œä»£ç†è®¾ç½®: {str(e)}'}), 500
        except Exception as e:
            app.logger.error(f'[Webhookæ¨¡å¼] è®¾ç½®å¤±è´¥: {e}', exc_info=True)
            return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/webhook/telegram/mode', methods=['GET'])
@admin_required
def get_telegram_mode():
    """è·å–å½“å‰ Telegram Webhook çŠ¶æ€"""
    return jsonify({
        'success': True,
        'configured_url': TELEGRAM_CONFIGURED_URL
    })


@app.route('/api/webhook/telegram/delete', methods=['POST'])
@admin_required
def delete_telegram_webhook():
    """åˆ é™¤ Telegram Bot Webhook (ç®¡ç†å‘˜)"""
    if not TELEGRAM_BOT_TOKEN:
        return jsonify({
            'success': False,
            'error': 'Telegram Bot Token æœªé…ç½®'
        }), 400
    
    try:
        url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/deleteWebhook"
        response = PROXY_SESSION.post(url, timeout=10)
        data = response.json()
        
        if data.get('ok'):
            return jsonify({
                'success': True,
                'message': 'Webhook å·²åˆ é™¤'
            })
        else:
            return jsonify({
                'success': False,
                'error': data.get('description', 'åˆ é™¤å¤±è´¥')
            }), 400
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/downloads/<int:request_id>')
def get_download_status(request_id):
    movie_request = db.session.get(MovieRequest, request_id)
    
    # å¦‚æœè®°å½•ä¸å­˜åœ¨ï¼Œè¿”å› 200 ä½†æ ‡è®°ä¸ºæ— ä»»åŠ¡ï¼ˆé¿å…è§¦å‘ toast é”™è¯¯ï¼‰
    if not movie_request:
        return jsonify({'success': False, 'error': 'è®°å½•ä¸å­˜åœ¨', 'not_found': True}), 200

    if 'user_id' not in session:
        return jsonify({'success': False, 'error': 'æœªç™»å½•'}), 401

    user = db.session.get(User, session['user_id'])
    if not user:
        return jsonify({'success': False, 'error': 'æœªç™»å½•'}), 401
    
    # éªŒè¯session_token
    if user.session_token and session.get('session_token') != user.session_token:
        return jsonify({'success': False, 'error': 'ä¼šè¯å·²å¤±æ•ˆï¼Œè¯·é‡æ–°ç™»å½•'}), 401

    if not user.is_admin and movie_request.user_tg != user.tg:
        return jsonify({'success': False, 'error': 'æ— æƒæŸ¥çœ‹è¯¥ä¸‹è½½ä»»åŠ¡'}), 403

    if not movie_request.download_task:
        return jsonify({'success': False, 'error': 'æš‚æ— ä¸‹è½½ä»»åŠ¡', 'no_task': True}), 200

    task = movie_request.download_task
    
    # å®æ—¶åŒæ­¥ qBittorrent çŠ¶æ€ï¼ˆæ‰©å±•æ¡ä»¶ï¼šåªè¦ä»»åŠ¡æœªå®Œæˆ/å¤±è´¥å°±æŸ¥è¯¢ qBï¼‰
    # æ³¨æ„ï¼šå³ä½¿åç«¯çŠ¶æ€æ˜¾ç¤º completedï¼Œä¹ŸæŸ¥ä¸€ä¸‹ qB ç¡®ä¿è¿›åº¦å‡†ç¡®
    should_sync = (
        task.torrent_hash and 
        qbit_client.is_enabled() and
        task.status not in ['failed', 'cancelled']
    )
    
    if should_sync:
        try:
            infos = qbit_client.get_torrents_info(hashes=[task.torrent_hash])
            if infos:
                info = infos[0]
                qb_state = info.get('state', '').lower()
                qb_progress = info.get('progress') or 0
                progress = round(qb_progress * 100, 2)
                
                # è®°å½•è¿›åº¦å·®å¼‚ä»¥ä¾¿è°ƒè¯•
                old_progress = task.progress or 0
                if abs(progress - old_progress) > 1:
                    app.logger.info(f'ä»»åŠ¡ {task.id} è¿›åº¦åŒæ­¥: {old_progress:.1f}% -> {progress:.1f}% (qBçŠ¶æ€: {qb_state})')
                
                # æ›´æ–°è¿›åº¦ä¿¡æ¯
                task.progress = progress
                task.download_speed = info.get('dlspeed', 0)
                task.eta = info.get('eta', -1)
                
                # æ£€æŸ¥æ˜¯å¦å·²å®Œæˆï¼ˆåšç§çŠ¶æ€ï¼‰
                if qb_state in {'uploading', 'stalledup', 'queuedup', 'checkingup', 'pausedup', 'completed', 'forcedup', 'seeding'}:
                    if task.status != 'completed':
                        task.status = 'completed'
                        task.progress = 100.0
                        task.finished_at = task.finished_at or datetime.now()
                        movie_request.status = 'downloaded'
                        app.logger.info(f'API æŸ¥è¯¢æ—¶åŒæ­¥: ä»»åŠ¡ {task.id} å·²å®Œæˆ')
                elif qb_state in {'downloading', 'stalleddl', 'forceddl', 'metadl', 'checkingdl', 'allocating', 'moving'}:
                    if task.status != 'downloading':
                        task.status = 'downloading'
                        movie_request.status = 'downloading'
                
                db.session.commit()
            else:
                # qB ä¸­ä»»åŠ¡ä¸å­˜åœ¨
                if task.progress >= 100 or task.status == 'completed':
                    if task.status != 'completed':
                        task.status = 'completed'
                        task.finished_at = task.finished_at or datetime.now()
                        movie_request.status = 'downloaded'
                        db.session.commit()
                        app.logger.info(f'API æŸ¥è¯¢æ—¶åŒæ­¥: ä»»åŠ¡ {task.id} qBå·²åˆ é™¤ä½†è¿›åº¦100%ï¼Œæ ‡è®°å®Œæˆ')
        except Exception as e:
            app.logger.warning(f'å®æ—¶åŒæ­¥ qB çŠ¶æ€å¤±è´¥ (ä»»åŠ¡ {task.id}): {e}')
            db.session.rollback()  # ç¡®ä¿å›æ»šä»¥é˜²æ­¢äº‹åŠ¡é—®é¢˜

    # å¦‚æœæ±‚ç‰‡çŠ¶æ€å·²å®Œæˆï¼ˆå·²å…¥åº“ï¼‰ï¼Œç¡®ä¿ä¸‹è½½ä»»åŠ¡è¿›åº¦ä¹Ÿæ˜¾ç¤ºä¸º 100%
    if movie_request.status == 'completed' and task.status != 'completed':
        task.status = 'completed'
        task.progress = 100.0
        task.finished_at = task.finished_at or datetime.now()
        try:
            db.session.commit()
        except:
            db.session.rollback()

    return jsonify({
        'success': True, 
        'task': task.to_dict(),
        'request_status': movie_request.status  # æ·»åŠ æ±‚ç‰‡çŠ¶æ€
    })


@app.route('/api/admin/sync-downloads', methods=['POST'])
@admin_required
def sync_all_downloads():
    """æ‰‹åŠ¨åŒæ­¥æ‰€æœ‰ä¸‹è½½ä»»åŠ¡çŠ¶æ€ï¼ˆç®¡ç†å‘˜ï¼‰"""
    if not qbit_client.is_enabled():
        return jsonify({'success': False, 'error': 'qBittorrent æœªé…ç½®'}), 400
    
    # è·å–æ‰€æœ‰æœªå®Œæˆçš„ä¸‹è½½ä»»åŠ¡
    tasks = DownloadTask.query.filter(
        DownloadTask.status.in_(['queued', 'downloading'])
    ).all()
    
    synced = 0
    completed = 0
    failed = 0
    
    for task in tasks:
        if not task.torrent_hash:
            continue
        
        try:
            infos = qbit_client.get_torrents_info(hashes=[task.torrent_hash])
            if infos:
                info = infos[0]
                qb_state = info.get('state', '').lower()
                progress = round((info.get('progress') or 0) * 100, 2)
                
                task.progress = progress
                task.download_speed = info.get('dlspeed', 0)
                task.eta = info.get('eta', -1)
                
                if qb_state in {'uploading', 'stalledup', 'queuedup', 'checkingup', 'pausedup', 'completed', 'forcedup'}:
                    task.status = 'completed'
                    task.progress = 100.0
                    task.finished_at = task.finished_at or datetime.now()
                    if task.request:
                        task.request.status = 'downloaded'
                    completed += 1
                else:
                    synced += 1
            else:
                # qB ä¸­ä¸å­˜åœ¨
                if task.progress >= 100:
                    task.status = 'completed'
                    if task.request:
                        task.request.status = 'downloaded'
                    completed += 1
                else:
                    task.status = 'failed'
                    task.error_message = 'qBittorrent ä¸­ä»»åŠ¡ä¸å­˜åœ¨'
                    if task.request:
                        task.request.status = 'failed'
                    failed += 1
        except Exception as e:
            app.logger.error(f'åŒæ­¥ä»»åŠ¡ {task.id} å¤±è´¥: {e}')
    
    db.session.commit()
    
    return jsonify({
        'success': True,
        'message': f'åŒæ­¥å®Œæˆ: {synced} ä¸ªä»»åŠ¡æ›´æ–°è¿›åº¦, {completed} ä¸ªå·²å®Œæˆ, {failed} ä¸ªå¤±è´¥'
    })


@app.route('/api/downloads/<int:request_id>/retry', methods=['POST'])
@login_required
def retry_download(request_id):
    """é‡è¯•å¤±è´¥çš„ä¸‹è½½ä»»åŠ¡"""
    movie_request = db.session.get(MovieRequest, request_id)
    
    if not movie_request:
        return jsonify({'success': False, 'error': 'æ±‚ç‰‡è®°å½•ä¸å­˜åœ¨'}), 404
    
    user = db.session.get(User, session['user_id'])
    if not user:
        return jsonify({'success': False, 'error': 'æœªç™»å½•'}), 401
    
    # æ£€æŸ¥æƒé™: ç®¡ç†å‘˜æˆ–æ±‚ç‰‡ç”¨æˆ·æœ¬äºº
    if not user.is_admin and movie_request.user_tg != user.tg:
        return jsonify({'success': False, 'error': 'æ— æƒæ“ä½œè¯¥ä»»åŠ¡'}), 403
    
    task = movie_request.download_task
    if not task:
        return jsonify({'success': False, 'error': 'è¯¥æ±‚ç‰‡æ²¡æœ‰ä¸‹è½½ä»»åŠ¡'}), 400
    
    # æ£€æŸ¥æ˜¯å¦å¯ä»¥é‡è¯•
    if not task.can_retry():
        if task.retry_count >= task.max_retries:
            return jsonify({
                'success': False, 
                'error': f'å·²è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•° ({task.max_retries}æ¬¡)'
            }), 400
        else:
            return jsonify({
                'success': False, 
                'error': 'åªæœ‰å¤±è´¥çš„ä»»åŠ¡æ‰èƒ½é‡è¯•'
            }), 400
    
    # è®°å½•é‡è¯•
    task.retry_count += 1
    task.last_retry_at = datetime.now()
    task.error_message = f'ç¬¬ {task.retry_count} æ¬¡é‡è¯•ä¸­...'
    
    # é‡ç½®ä»»åŠ¡çŠ¶æ€
    task.status = 'queued'
    task.progress = 0.0
    task.download_speed = 0
    task.eta = -1
    
    # é‡ç½®æ±‚ç‰‡çŠ¶æ€
    movie_request.status = 'approved'
    
    try:
        db.session.commit()
        app.logger.info(f'ç”¨æˆ· {user.name} é‡è¯•ä¸‹è½½ä»»åŠ¡ {task.id} (ç¬¬{task.retry_count}æ¬¡)')
        
        # TODO: è¿™é‡Œåº”è¯¥è§¦å‘é‡æ–°ä¸‹è½½é€»è¾‘
        # å¯ä»¥é€šè¿‡ MoviePilot API æˆ– qBittorrent é‡æ–°æ·»åŠ ç§å­
        # æš‚æ—¶åªæ˜¯é‡ç½®çŠ¶æ€ï¼Œå®é™…ä¸‹è½½é€»è¾‘éœ€è¦æ ¹æ®ä½ çš„ç³»ç»Ÿå®ç°
        
        return jsonify({
            'success': True,
            'message': f'å·²æäº¤é‡è¯• (ç¬¬{task.retry_count}/{task.max_retries}æ¬¡)',
            'retry_count': task.retry_count,
            'max_retries': task.max_retries
        })
    except Exception as e:
        db.session.rollback()
        app.logger.error(f'é‡è¯•ä¸‹è½½å¤±è´¥: {e}')
        return jsonify({'success': False, 'error': str(e)}), 500


# ==================== æ‰¹é‡æ“ä½œ API ====================
@app.route('/admin/batch-update', methods=['POST'])
@admin_required
def batch_update_status():
    """æ‰¹é‡æ›´æ–°æ±‚ç‰‡çŠ¶æ€"""
    data = request.get_json()
    
    request_ids = data.get('ids', [])
    status = data.get('status')
    admin_note = data.get('admin_note', '')
    
    if not request_ids:
        return jsonify({'success': False, 'error': 'æœªé€‰æ‹©ä»»ä½•è¯·æ±‚'}), 400
    
    if status not in ['approved', 'rejected', 'completed']:
        return jsonify({'success': False, 'error': 'æ— æ•ˆçš„çŠ¶æ€'}), 400
    
    success_count = 0
    fail_count = 0
    
    for req_id in request_ids:
        try:
            movie_request = db.session.get(MovieRequest, req_id)
            if movie_request:
                old_status = movie_request.status
                movie_request.status = status
                if admin_note:
                    movie_request.admin_note = admin_note
                success_count += 1
                
                # å‘é€é€šçŸ¥ï¼ˆåªåœ¨æ‹’ç»å’Œå®Œæˆæ—¶ï¼‰
                if status in ['rejected', 'completed'] and old_status != status:
                    # è·å–ç”¨æˆ·ä¿¡æ¯
                    user = movie_request.user
                    if not user:
                        user = User.query.filter_by(tg=movie_request.user_tg).first()
                    
                    user_tg = user.tg if user else movie_request.user_tg
                    username = user.name if user else 'ç”¨æˆ·'
                    
                    if user_tg:
                        # å‘é€ç§èŠé€šçŸ¥
                        send_user_telegram_notification(
                            user_tg,
                            movie_request.title,
                            status,
                            admin_note,
                            movie_request.media_type,
                            movie_request.tmdb_id,
                            movie_request.poster_path
                        )
                        
                        # å…¥åº“å®Œæˆæ—¶é¢å¤–å‘é€ç¾¤ç»„é€šçŸ¥
                        if status == 'completed':
                            # è·å–ç”¨æˆ·çœŸå® Telegram ID
                            _batch_user = User.query.filter_by(tg=user_tg).first()
                            _batch_tg_id = _batch_user.telegram_id if _batch_user and _batch_user.telegram_id else user_tg
                            send_group_completion_notification(
                                user_tg_id=_batch_tg_id,
                                username=username,
                                title=movie_request.title,
                                year=movie_request.year,
                                media_type=movie_request.media_type,
                                tmdb_id=movie_request.tmdb_id,
                                poster_path=movie_request.poster_path
                            )
            else:
                fail_count += 1
        except Exception as e:
            app.logger.error(f'æ‰¹é‡æ›´æ–°å¤±è´¥: ID={req_id}, error={e}')
            fail_count += 1
    
    db.session.commit()
    app.logger.info(f'ç®¡ç†å‘˜ {session.get("username")} æ‰¹é‡æ›´æ–°çŠ¶æ€: æˆåŠŸ={success_count}, å¤±è´¥={fail_count}, çŠ¶æ€={status}')
    
    return jsonify({
        'success': True,
        'message': f'å·²æ›´æ–° {success_count} æ¡è®°å½•',
        'success_count': success_count,
        'fail_count': fail_count
    }), 200


@app.route('/admin/batch-delete', methods=['POST'])
@admin_required
def batch_delete_requests():
    """æ‰¹é‡åˆ é™¤æ±‚ç‰‡è®°å½•"""
    data = request.get_json()
    
    request_ids = data.get('ids', [])
    
    if not request_ids:
        return jsonify({'success': False, 'error': 'æœªé€‰æ‹©ä»»ä½•è¯·æ±‚'}), 400
    
    success_count = 0
    fail_count = 0
    
    for req_id in request_ids:
        try:
            movie_request = db.session.get(MovieRequest, req_id)
            if movie_request:
                # åŒæ—¶åˆ é™¤å…³è”çš„ä¸‹è½½ä»»åŠ¡
                if movie_request.download_task:
                    db.session.delete(movie_request.download_task)
                db.session.delete(movie_request)
                success_count += 1
            else:
                fail_count += 1
        except Exception as e:
            app.logger.error(f'æ‰¹é‡åˆ é™¤å¤±è´¥: ID={req_id}, error={e}')
            fail_count += 1
    
    db.session.commit()
    app.logger.info(f'ç®¡ç†å‘˜ {session.get("username")} æ‰¹é‡åˆ é™¤è®°å½•: æˆåŠŸ={success_count}, å¤±è´¥={fail_count}')
    
    return jsonify({
        'success': True,
        'message': f'å·²åˆ é™¤ {success_count} æ¡è®°å½•',
        'success_count': success_count,
        'fail_count': fail_count
    }), 200


# ==================== æ‰¹é‡æ“ä½œ API ====================

@app.route('/api/admin/users/import-emby', methods=['POST'])
@admin_required
def import_users_to_emby():
    """ä¸€é”®å°†é¢æ¿ç”¨æˆ·å¯¼å…¥ Emby æœåŠ¡å™¨
    
    é€»è¾‘ï¼šéå†é¢æ¿ä¸­æ‰€æœ‰ç»‘å®šäº† emby_name çš„ç”¨æˆ·ï¼Œæ£€æŸ¥ Emby æœåŠ¡å™¨ä¸­æ˜¯å¦å­˜åœ¨è¯¥è´¦å·ï¼Œ
    ä¸å­˜åœ¨åˆ™åˆ›å»ºã€‚åˆ›å»ºåæ ¹æ®ç”¨æˆ·çŠ¶æ€ï¼ˆlv='c' ä¸ºç¦ç”¨ï¼‰è®¾ç½® Emby è´¦å·çŠ¶æ€ã€‚
    """
    try:
        if not emby_client.is_enabled():
            return jsonify({'success': False, 'error': 'Emby æœåŠ¡å™¨æœªé…ç½®æˆ–æœªå¯ç”¨'}), 400
        
        # å…ˆæµ‹è¯• Emby è¿æ¥
        try:
            test_url = f"{emby_client.base_url}/System/Info"
            test_resp = emby_client.session.get(test_url, params={'api_key': emby_client.api_key}, timeout=10)
            if test_resp.status_code != 200:
                return jsonify({'success': False, 'error': f'Emby æœåŠ¡å™¨è¿æ¥å¤±è´¥ (HTTP {test_resp.status_code})'}), 500
        except Exception as e:
            return jsonify({'success': False, 'error': f'æ— æ³•è¿æ¥ Emby æœåŠ¡å™¨: {str(e)}'}), 500
        
        # è·å– Emby æœåŠ¡å™¨ä¸Šå·²æœ‰çš„æ‰€æœ‰ç”¨æˆ·ï¼ˆç”¨äºå¿«é€Ÿæ¯”å¯¹ï¼‰
        emby_users = emby_client.get_all_users()
        
        # æ„å»º Emby å·²æœ‰ç”¨æˆ·åæ˜ å°„ï¼ˆå°å†™æ¯”å¯¹ï¼‰å’Œ ID é›†åˆ
        emby_name_map = {u.get('Name', '').lower(): u for u in emby_users}
        emby_id_set = {u.get('Id', '') for u in emby_users}
        
        # è·å–é¢æ¿ä¸­æ‰€æœ‰ç»‘å®šäº† emby ç”¨æˆ·åçš„ç”¨æˆ·
        panel_users = User.query.filter(
            User.emby_name.isnot(None),
            User.emby_name != ''
        ).all()
        
        if not panel_users:
            return jsonify({'success': True, 'message': 'æ²¡æœ‰éœ€è¦å¯¼å…¥çš„ç”¨æˆ·', 
                           'total': 0, 'created': 0, 'skipped': 0, 'failed': 0, 'disabled': 0, 'updated': 0})
        
        total = len(panel_users)
        created = 0
        skipped = 0
        failed = 0
        disabled = 0
        updated = 0
        details = []
        
        for user in panel_users:
            emby_name = user.emby_name.strip()
            emby_id = user.embyid
            is_banned = user.lv == 'c'
            
            try:
                # æƒ…å†µ1ï¼šç”¨æˆ·æœ‰ embyid ä¸” Emby æœåŠ¡å™¨ä¸Šå­˜åœ¨è¯¥ ID â†’ å·²å­˜åœ¨ï¼Œè·³è¿‡
                if emby_id and emby_id in emby_id_set:
                    skipped += 1
                    continue
                
                # æ£€æŸ¥ Emby ä¸­æ˜¯å¦å·²æœ‰åŒåç”¨æˆ·
                existing_emby = emby_name_map.get(emby_name.lower())
                
                if existing_emby:
                    # æƒ…å†µ2ï¼šEmby ä¸­å·²æœ‰åŒåç”¨æˆ· â†’ æ›´æ–°é¢æ¿çš„ embyid æ˜ å°„
                    new_emby_id = existing_emby.get('Id')
                    if user.embyid != new_emby_id:
                        user.embyid = new_emby_id
                        updated += 1
                        details.append(f'âœï¸ {emby_name}: å·²å…³è”åˆ°å·²æœ‰Embyè´¦å· (ID: {new_emby_id[:8]}...)')
                    else:
                        skipped += 1
                    
                    # å¦‚æœé¢æ¿ä¸­æ˜¯ç¦ç”¨çŠ¶æ€ï¼ŒåŒæ­¥ç¦ç”¨ Emby è´¦å·
                    if is_banned:
                        emby_client.disable_user(new_emby_id)
                        disabled += 1
                    continue
                
                # æƒ…å†µ3ï¼šEmby ä¸­ä¸å­˜åœ¨ï¼Œéœ€è¦åˆ›å»ºæ–°è´¦å·
                # pwd2 å­˜å‚¨çš„æ˜¯æ˜æ–‡ Emby å¯†ç ï¼›ä¸ºç©ºåˆ™ä¸è®¾ç½®å¯†ç ï¼ˆEmby å…è®¸ç©ºå¯†ç ç™»å½•ï¼‰
                password = user.pwd2 if user.pwd2 else ''
                
                # ç›´æ¥è°ƒç”¨ Emby API åˆ›å»ºç”¨æˆ·ï¼ˆè·³è¿‡ create_user å†…éƒ¨çš„é‡å¤æ£€æŸ¥ï¼Œå› ä¸ºæˆ‘ä»¬å·²ç»åšè¿‡äº†ï¼‰
                try:
                    create_url = f"{emby_client.base_url}/Users/New"
                    create_params = {'api_key': emby_client.api_key}
                    create_data = {'Name': emby_name}
                    
                    resp = emby_client.session.post(create_url, params=create_params, json=create_data, timeout=15)
                    
                    if resp.status_code not in [200, 201]:
                        failed += 1
                        details.append(f'âŒ {emby_name}: Embyåˆ›å»ºå¤±è´¥ (HTTP {resp.status_code})')
                        app.logger.warning(f'å¯¼å…¥Embyåˆ›å»ºç”¨æˆ·å¤±è´¥: {emby_name}, status={resp.status_code}, body={resp.text[:200]}')
                        continue
                    
                    new_user_data = resp.json()
                    new_emby_id = new_user_data.get('Id')
                    
                    if not new_emby_id:
                        failed += 1
                        details.append(f'âŒ {emby_name}: åˆ›å»ºæˆåŠŸä½†æœªè¿”å›ID')
                        continue
                    
                    # è®¾ç½®å¯†ç ï¼ˆä»…å½“é¢æ¿ä¸­æœ‰ä¿å­˜å¯†ç æ—¶ï¼‰
                    pwd_status = 'æ— å¯†ç '
                    if password:
                        try:
                            pwd_url = f"{emby_client.base_url}/Users/{new_emby_id}/Password"
                            pwd_data = {'CurrentPw': '', 'NewPw': password}
                            pwd_resp = emby_client.session.post(pwd_url, params=create_params, json=pwd_data, timeout=10)
                            if pwd_resp.status_code in [200, 204]:
                                pwd_status = 'å·²è®¾ç½®'
                            else:
                                pwd_status = 'è®¾ç½®å¤±è´¥'
                                app.logger.warning(f'å¯¼å…¥Embyè®¾ç½®å¯†ç å¤±è´¥: {emby_name}, status={pwd_resp.status_code}')
                        except Exception as pwd_e:
                            pwd_status = 'è®¾ç½®å¼‚å¸¸'
                            app.logger.warning(f'å¯¼å…¥Embyè®¾ç½®å¯†ç å¼‚å¸¸: {emby_name}, error={pwd_e}')
                    
                    # è®¾ç½®ç”¨æˆ·ç­–ç•¥ï¼ˆæƒé™æ§åˆ¶ï¼‰
                    emby_client._set_user_policy(new_emby_id)
                    
                    # æ›´æ–°é¢æ¿ç”¨æˆ·çš„ embyid
                    user.embyid = new_emby_id
                    
                    # å°†æ–°åˆ›å»ºçš„ç”¨æˆ·åŠ å…¥æ¯”å¯¹é›†åˆï¼ˆé˜²æ­¢åŒåé‡å¤åˆ›å»ºï¼‰
                    emby_name_map[emby_name.lower()] = {'Id': new_emby_id, 'Name': emby_name}
                    emby_id_set.add(new_emby_id)
                    
                    # å¦‚æœæ˜¯ç¦ç”¨ç”¨æˆ·ï¼Œåˆ›å»ºåç«‹å³ç¦ç”¨
                    if is_banned:
                        emby_client.disable_user(new_emby_id)
                        disabled += 1
                        details.append(f'ğŸ”’ {emby_name}: å·²åˆ›å»ºå¹¶ç¦ç”¨ (å¯†ç : {pwd_status})')
                    else:
                        details.append(f'âœ… {emby_name}: åˆ›å»ºæˆåŠŸ (å¯†ç : {pwd_status})')
                    
                    created += 1
                    
                except Exception as create_e:
                    failed += 1
                    details.append(f'âŒ {emby_name}: {str(create_e)}')
                    app.logger.error(f'å¯¼å…¥Embyåˆ›å»ºç”¨æˆ·å¼‚å¸¸: {emby_name}, error={create_e}')
                
            except Exception as e:
                failed += 1
                details.append(f'âŒ {emby_name}: {str(e)}')
                app.logger.error(f'å¯¼å…¥ç”¨æˆ·åˆ° Emby å¤±è´¥: {emby_name}, error={e}')
        
        db.session.commit()
        
        app.logger.info(f'ä¸€é”®å¯¼å…¥ Emby å®Œæˆ: æ€»è®¡={total}, æ–°å»º={created}, å·²å­˜åœ¨={skipped}, æ›´æ–°æ˜ å°„={updated}, ç¦ç”¨={disabled}, å¤±è´¥={failed}')
        
        return jsonify({
            'success': True,
            'message': f'å¯¼å…¥å®Œæˆï¼æ–°å»º {created} ä¸ªï¼Œå·²å­˜åœ¨ {skipped} ä¸ªï¼Œæ›´æ–° {updated} ä¸ªï¼Œå¤±è´¥ {failed} ä¸ª',
            'total': total,
            'created': created,
            'skipped': skipped,
            'failed': failed,
            'disabled': disabled,
            'updated': updated,
            'details': details[-50:]  # æœ€å¤šè¿”å›50æ¡è¯¦æƒ…
        })
        
    except Exception as e:
        db.session.rollback()
        app.logger.error(f'ä¸€é”®å¯¼å…¥ Emby å¤±è´¥: {e}', exc_info=True)
        return jsonify({'success': False, 'error': f'å¯¼å…¥å¤±è´¥: {str(e)}'}), 500


@app.route('/api/admin/users/batch', methods=['POST'])
@admin_required
def batch_users():
    """æ‰¹é‡ç”¨æˆ·æ“ä½œï¼šç¦ç”¨/è§£ç¦/åˆ é™¤/èµ é€è®¢é˜…/è®¾ç™½åå•"""
    data = request.get_json()
    ids = data.get('ids', [])
    action = data.get('action', '')
    days = data.get('days', 30)  # èµ é€å¤©æ•°
    
    if not ids:
        return jsonify({'success': False, 'error': 'æœªé€‰æ‹©ä»»ä½•ç”¨æˆ·'}), 400
    
    success_count = 0
    fail_count = 0
    now = datetime.now()
    
    for uid in ids:
        try:
            user = db.session.get(User, uid)
            if not user:
                fail_count += 1
                continue
            
            if action == 'ban':
                user.ban_prev_lv = user.lv
                user.ban_prev_ex = user.ex
                user.ban_time = now
                user.lv = 'c'
                # ç¦ç”¨Embyè´¦å·
                if user.embyid and emby_client.is_enabled():
                    emby_client.disable_user(user.embyid)
                success_count += 1
            elif action == 'unban':
                # æ¢å¤å°ç¦å‰çŠ¶æ€
                if user.ban_prev_lv:
                    user.lv = user.ban_prev_lv
                    user.ex = user.ban_prev_ex
                else:
                    user.lv = 'b'
                user.ban_prev_lv = None
                user.ban_prev_ex = None
                user.ban_time = None
                user.ban_reason = None
                # æ¢å¤Embyè´¦å·
                if user.embyid and emby_client.is_enabled():
                    emby_client.enable_user(user.embyid)
                success_count += 1
            elif action == 'delete':
                # å¤ç”¨é€šç”¨ç¡¬åˆ é™¤å‡½æ•°
                del_result = hard_delete_user_data(uid, reason='ç®¡ç†å‘˜æ‰¹é‡åˆ é™¤')
                if del_result['db_deleted']:
                    success_count += 1
                else:
                    fail_count += 1
            elif action == 'gift':
                # æ‰¹é‡èµ é€è®¢é˜…
                gift_days = int(days) if days else 30
                if user.ex and user.ex > now:
                    user.ex = user.ex + timedelta(days=gift_days)
                else:
                    user.ex = now + timedelta(days=gift_days)
                if user.lv not in ['a', 'c']:  # ç™½åå•ä¸å˜ï¼Œå°ç¦ç”¨æˆ·ä¿æŒå°ç¦çŠ¶æ€
                    user.lv = 'b'
                # åˆ›å»ºè®¢é˜…è®°å½•
                sub = Subscription(
                    user_tg=user.tg,
                    plan_type='gift',
                    plan_name=f'ç®¡ç†å‘˜èµ é€ {gift_days}å¤©',
                    duration_months=max(1, -(-gift_days // 30)),
                    price=0,
                    start_date=now,
                    end_date=user.ex,
                    status='active',
                    source='gift'
                )
                db.session.add(sub)
                # æ¢å¤Embyè´¦å·ï¼ˆå°ç¦ç”¨æˆ·å’Œé»‘åå•ç¦ç”¨ç”¨æˆ·ä¸è‡ªåŠ¨æ¢å¤ï¼‰
                if user.lv != 'c' and not user.ban_reason and user.embyid and emby_client.is_enabled():
                    emby_client.enable_user(user.embyid)
                success_count += 1
            elif action == 'whitelist':
                # æ‰¹é‡è®¾ä¸ºç™½åå•ï¼ˆlv='a' + æ°¸ä¹…åˆ°æœŸ + plan_type='whitelist'è®¢é˜…è®°å½•ï¼‰
                user.lv = 'a'
                user.ex = datetime(9999, 12, 31)
                # æ¸…é™¤é»‘åå•å°ç¦ä¿¡æ¯
                user.ban_reason = None
                user.ban_time = None
                user.ban_prev_lv = None
                user.ban_prev_ex = None
                # åˆ›å»ºæˆ–æ›´æ–°ç™½åå• Subscription
                existing_sub = Subscription.query.filter_by(
                    user_tg=user.tg, status='active'
                ).order_by(Subscription.end_date.desc()).first()
                if existing_sub:
                    existing_sub.plan_type = 'whitelist'
                    existing_sub.plan_name = 'ç™½åå•ç”¨æˆ·'
                    existing_sub.end_date = datetime(9999, 12, 31)
                    existing_sub.updated_at = datetime.now()
                else:
                    new_sub = Subscription(
                        user_tg=user.tg,
                        plan_type='whitelist',
                        plan_name='ç™½åå•ç”¨æˆ·',
                        duration_months=-1,
                        price=0,
                        start_date=datetime.now(),
                        end_date=datetime(9999, 12, 31),
                        status='active',
                        source='manual'
                    )
                    db.session.add(new_sub)
                # æ¢å¤Embyè´¦å·
                if user.embyid and emby_client.is_enabled():
                    emby_client.enable_user(user.embyid)
                success_count += 1
            elif action == 'clear_coins':
                # æ‰¹é‡æ¸…é™¤ç§¯åˆ†
                old_coins = user.coins or 0
                if old_coins > 0:
                    user.coins = 0
                    # è®°å½•ç§¯åˆ†äº¤æ˜“
                    try:
                        coin_tx = CoinTransaction(
                            user_tg=user.tg,
                            amount=-old_coins,
                            balance_after=0,
                            trans_type='admin_deduct',
                            description='ç®¡ç†å‘˜æ‰¹é‡æ¸…é™¤ç§¯åˆ†',
                            created_at=now
                        )
                        db.session.add(coin_tx)
                    except Exception:
                        pass
                success_count += 1
            elif action == 'set_plan_type':
                # æ‰¹é‡è®¾ç½®å¥—é¤ç±»å‹ï¼ˆæŒ‰å¥—é¤IDåŒ¹é…ï¼‰
                plan_type_value = data.get('plan_type', '')
                if not plan_type_value:
                    fail_count += 1
                    continue
                type_labels = {}
                try:
                    _plans = load_plans_config()
                    for _p in _plans:
                        pid = _p.get('id')
                        if pid and pid not in type_labels:
                            type_labels[pid] = _p.get('name', pid)
                        # å…¼å®¹æ—§type
                        pt = _p.get('type')
                        if pt and pt not in type_labels:
                            type_labels[pt] = _p.get('name', pt)
                except:
                    pass
                plan_name = type_labels.get(plan_type_value, plan_type_value) + 'å¥—é¤'
                # æ£€æŸ¥è¯¥å¥—é¤æ˜¯å¦æ ‡è®°ä¸ºç™½åå•å¥—é¤
                _is_wl_plan = False
                for _p in _plans:
                    if _p.get('id') == plan_type_value and _p.get('is_whitelist'):
                        _is_wl_plan = True
                        break
                if _is_wl_plan:
                    # ç™½åå•å¥—é¤ï¼šè®¾ä¸ºç™½åå•ç”¨æˆ·
                    user.lv = 'a'
                    user.ex = datetime(9999, 12, 31)
                    plan_type_value = 'whitelist'
                    plan_name = 'ç™½åå•ç”¨æˆ·'
                else:
                    # æ™®é€šå¥—é¤ï¼šç¡®ä¿ç”¨æˆ·æ˜¯è®¢é˜…ç”¨æˆ·
                    if user.lv == 'a':
                        user.lv = 'b'
                    elif user.lv not in ['a', 'b', 'c']:
                        user.lv = 'b'
                # æ›´æ–°æˆ–åˆ›å»º Subscription è®°å½•
                existing_sub = Subscription.query.filter_by(
                    user_tg=user.tg, status='active'
                ).order_by(Subscription.end_date.desc()).first()
                if existing_sub:
                    existing_sub.plan_type = plan_type_value
                    existing_sub.plan_name = plan_name
                    existing_sub.updated_at = now
                else:
                    new_sub = Subscription(
                        user_tg=user.tg,
                        plan_type=plan_type_value,
                        plan_name=plan_name,
                        duration_months=1,
                        price=0,
                        start_date=now,
                        end_date=user.ex if user.ex and user.ex > now else now,
                        status='active',
                        source='manual'
                    )
                    db.session.add(new_sub)
                # æ¸…é™¤é»‘åå•å°ç¦ä¿¡æ¯
                user.ban_reason = None
                user.ban_time = None
                user.ban_prev_lv = None
                user.ban_prev_ex = None
                # æ¢å¤Embyè´¦å·
                if user.embyid and emby_client.is_enabled():
                    emby_client.enable_user(user.embyid)
                success_count += 1
            else:
                fail_count += 1
        except Exception as e:
            db.session.rollback()
            app.logger.error(f'æ‰¹é‡ç”¨æˆ·æ“ä½œå¤±è´¥: ID={uid}, action={action}, error={e}', exc_info=True)
            fail_count += 1
    
    try:
        db.session.commit()
    except Exception as e:
        db.session.rollback()
        app.logger.error(f'æ‰¹é‡æ“ä½œæäº¤å¤±è´¥: action={action}, error={e}', exc_info=True)
        return jsonify({'success': False, 'error': f'æ“ä½œæäº¤å¤±è´¥: {str(e)}'}), 500
    
    app.logger.info(f'ç®¡ç†å‘˜æ‰¹é‡{action}ç”¨æˆ·: æˆåŠŸ={success_count}, å¤±è´¥={fail_count}')
    return jsonify({'success': True, 'message': f'å·²å¤„ç† {success_count} ä¸ªç”¨æˆ·', 'success_count': success_count, 'fail_count': fail_count})


@app.route('/api/admin/orders/batch', methods=['POST'])
@admin_required
def batch_orders():
    """æ‰¹é‡è®¢å•æ“ä½œï¼šå–æ¶ˆ/åˆ é™¤"""
    data = request.get_json()
    order_nos = data.get('order_nos', [])
    action = data.get('action', '')
    
    if not order_nos:
        return jsonify({'success': False, 'error': 'æœªé€‰æ‹©ä»»ä½•è®¢å•'}), 400
    
    success_count = 0
    fail_count = 0
    
    for order_no in order_nos:
        try:
            order = Order.query.filter_by(order_no=order_no).first()
            if not order:
                fail_count += 1
                continue
            
            if action == 'cancel':
                if order.payment_status == 'pending':
                    order.payment_status = 'cancelled'
                    success_count += 1
                else:
                    fail_count += 1
            elif action == 'delete':
                db.session.delete(order)
                success_count += 1
            else:
                fail_count += 1
        except Exception as e:
            app.logger.error(f'æ‰¹é‡è®¢å•æ“ä½œå¤±è´¥: {order_no}, error={e}')
            fail_count += 1
    
    db.session.commit()
    app.logger.info(f'ç®¡ç†å‘˜æ‰¹é‡{action}è®¢å•: æˆåŠŸ={success_count}, å¤±è´¥={fail_count}')
    return jsonify({'success': True, 'message': f'å·²å¤„ç† {success_count} ä¸ªè®¢å•', 'success_count': success_count})


@app.route('/api/admin/tickets/batch', methods=['POST'])
@admin_required
def batch_tickets():
    """æ‰¹é‡å·¥å•æ“ä½œï¼šå…³é—­/åˆ é™¤"""
    data = request.get_json()
    ids = data.get('ids', [])
    action = data.get('action', '')
    
    if not ids:
        return jsonify({'success': False, 'error': 'æœªé€‰æ‹©ä»»ä½•å·¥å•'}), 400
    
    success_count = 0
    fail_count = 0
    
    for tid in ids:
        try:
            ticket = db.session.get(SupportTicket, tid)
            if not ticket:
                fail_count += 1
                continue
            
            if action == 'close':
                ticket.status = 'closed'
                ticket.resolved_at = datetime.now()
                success_count += 1
            elif action == 'delete':
                TicketMessage.query.filter_by(ticket_id=ticket.id).delete()
                db.session.delete(ticket)
                success_count += 1
            else:
                fail_count += 1
        except Exception as e:
            app.logger.error(f'æ‰¹é‡å·¥å•æ“ä½œå¤±è´¥: ID={tid}, error={e}')
            fail_count += 1
    
    db.session.commit()
    app.logger.info(f'ç®¡ç†å‘˜æ‰¹é‡{action}å·¥å•: æˆåŠŸ={success_count}, å¤±è´¥={fail_count}')
    return jsonify({'success': True, 'message': f'å·²å¤„ç† {success_count} ä¸ªå·¥å•', 'success_count': success_count})


@app.route('/api/admin/subscriptions/batch', methods=['POST'])
@admin_required
def batch_subscriptions():
    """æ‰¹é‡è®¢é˜…æ“ä½œï¼šåˆ é™¤/å»¶æœŸï¼ˆåŸºäºç”¨æˆ·tg IDï¼‰"""
    data = request.get_json()
    ids = data.get('ids', [])
    action = data.get('action', '')
    days = data.get('days', 30)
    
    if not ids:
        return jsonify({'success': False, 'error': 'æœªé€‰æ‹©ä»»ä½•è®¢é˜…'}), 400
    
    success_count = 0
    fail_count = 0
    now = datetime.now()
    
    for uid in ids:
        try:
            uid_int = int(uid)
            if action == 'delete':
                # åˆ é™¤è¯¥ç”¨æˆ·çš„æ‰€æœ‰è®¢é˜…è®°å½•
                deleted = Subscription.query.filter_by(user_tg=uid_int).delete()
                if deleted > 0:
                    success_count += 1
                else:
                    # æ²¡æœ‰è®¢é˜…è®°å½•ä¹Ÿç®—æˆåŠŸï¼ˆå› ä¸ºè®¢é˜…é¡µé¢æ˜¾ç¤ºçš„æ˜¯ç”¨æˆ·ä¿¡æ¯ï¼‰
                    success_count += 1
            elif action == 'extend':
                # æ‰¹é‡å»¶æœŸè®¢é˜…
                user = db.session.get(User, uid_int)
                if user:
                    extend_days = int(days) if days else 30
                    if user.ex and user.ex > now:
                        user.ex = user.ex + timedelta(days=extend_days)
                    else:
                        user.ex = now + timedelta(days=extend_days)
                    if user.lv not in ['a', 'c']:  # ç™½åå•ä¸å˜ï¼Œå°ç¦ç”¨æˆ·ä¿æŒå°ç¦çŠ¶æ€
                        user.lv = 'b'
                    # åˆ›å»ºè®¢é˜…è®°å½•
                    sub = Subscription(
                        user_tg=user.tg,
                        plan_type='extend',
                        plan_name=f'ç®¡ç†å‘˜å»¶æœŸ {extend_days}å¤©',
                        duration_months=max(1, -(-extend_days // 30)),
                        price=0,
                        start_date=now,
                        end_date=user.ex,
                        status='active',
                        source='gift'
                    )
                    db.session.add(sub)
                    # æ¢å¤Embyè´¦å·ï¼ˆå°ç¦ç”¨æˆ·å’Œé»‘åå•ç¦ç”¨ç”¨æˆ·ä¸è‡ªåŠ¨æ¢å¤ï¼‰
                    if user.lv != 'c' and not user.ban_reason and user.embyid and emby_client.is_enabled():
                        emby_client.enable_user(user.embyid)
                    success_count += 1
                else:
                    fail_count += 1
            else:
                fail_count += 1
        except Exception as e:
            app.logger.error(f'æ‰¹é‡è®¢é˜…æ“ä½œå¤±è´¥: ID={uid}, error={e}')
            fail_count += 1
    
    db.session.commit()
    app.logger.info(f'ç®¡ç†å‘˜æ‰¹é‡{action}è®¢é˜…: æˆåŠŸ={success_count}, å¤±è´¥={fail_count}')
    return jsonify({'success': True, 'message': f'å·²å¤„ç† {success_count} æ¡è®¢é˜…', 'success_count': success_count})


@app.route('/api/admin/playback/devices/batch', methods=['POST'])
@admin_required
def batch_devices():
    """æ‰¹é‡è®¾å¤‡æ“ä½œï¼šåˆ é™¤/ç¦ç”¨/è§£ç¦"""
    data = request.get_json()
    ids = data.get('ids', [])
    action = data.get('action', '')
    
    if not ids:
        return jsonify({'success': False, 'error': 'æœªé€‰æ‹©ä»»ä½•è®¾å¤‡'}), 400
    
    success_count = 0
    fail_count = 0
    
    for did in ids:
        try:
            device = db.session.get(UserDevice, did)
            if not device:
                fail_count += 1
                continue
            
            if action == 'delete':
                PlaybackRecord.query.filter_by(device_id=device.id).delete()
                db.session.delete(device)
                success_count += 1
            elif action == 'block':
                device.is_blocked = True
                success_count += 1
            elif action == 'unblock':
                device.is_blocked = False
                success_count += 1
            else:
                fail_count += 1
        except Exception as e:
            app.logger.error(f'æ‰¹é‡è®¾å¤‡æ“ä½œå¤±è´¥: ID={did}, error={e}')
            fail_count += 1
    
    db.session.commit()
    app.logger.info(f'ç®¡ç†å‘˜æ‰¹é‡{action}è®¾å¤‡: æˆåŠŸ={success_count}, å¤±è´¥={fail_count}')
    return jsonify({'success': True, 'message': f'å·²å¤„ç† {success_count} ä¸ªè®¾å¤‡', 'success_count': success_count})


@app.route('/api/admin/playback/history/batch', methods=['POST'])
@admin_required
def batch_history():
    """æ‰¹é‡æ’­æ”¾è®°å½•æ“ä½œï¼šåˆ é™¤"""
    data = request.get_json()
    ids = data.get('ids', [])
    action = data.get('action', '')
    
    if not ids:
        return jsonify({'success': False, 'error': 'æœªé€‰æ‹©ä»»ä½•è®°å½•'}), 400
    
    success_count = 0
    fail_count = 0
    
    for rid in ids:
        try:
            record = db.session.get(PlaybackRecord, rid)
            if not record:
                fail_count += 1
                continue
            
            if action == 'delete':
                db.session.delete(record)
                success_count += 1
            else:
                fail_count += 1
        except Exception as e:
            app.logger.error(f'æ‰¹é‡æ’­æ”¾è®°å½•æ“ä½œå¤±è´¥: ID={rid}, error={e}')
            fail_count += 1
    
    db.session.commit()
    app.logger.info(f'ç®¡ç†å‘˜æ‰¹é‡{action}æ’­æ”¾è®°å½•: æˆåŠŸ={success_count}, å¤±è´¥={fail_count}')
    return jsonify({'success': True, 'message': f'å·²å¤„ç† {success_count} æ¡è®°å½•', 'success_count': success_count})


@app.route('/api/admin/device-blacklist/batch', methods=['POST'])
@admin_required
def batch_blacklist():
    """æ‰¹é‡é»‘åå•æ“ä½œï¼šåˆ é™¤"""
    data = request.get_json()
    ids = data.get('ids', [])
    action = data.get('action', '')
    
    if not ids:
        return jsonify({'success': False, 'error': 'æœªé€‰æ‹©ä»»ä½•è§„åˆ™'}), 400
    
    success_count = 0
    fail_count = 0
    
    for bid in ids:
        try:
            rule = db.session.get(DeviceBlacklist, bid)
            if not rule:
                fail_count += 1
                continue
            
            if action == 'delete':
                db.session.delete(rule)
                success_count += 1
            else:
                fail_count += 1
        except Exception as e:
            app.logger.error(f'æ‰¹é‡é»‘åå•æ“ä½œå¤±è´¥: ID={bid}, error={e}')
            fail_count += 1
    
    db.session.commit()
    app.logger.info(f'ç®¡ç†å‘˜æ‰¹é‡{action}é»‘åå•: æˆåŠŸ={success_count}, å¤±è´¥={fail_count}')
    return jsonify({'success': True, 'message': f'å·²å¤„ç† {success_count} æ¡è§„åˆ™', 'success_count': success_count})


# ==================== ç»Ÿè®¡å›¾è¡¨ API ====================
@app.route('/admin/stats/daily')
@admin_required
def get_daily_stats():
    """è·å–æ¯æ—¥æ±‚ç‰‡è¶‹åŠ¿æ•°æ®ï¼ˆæœ€è¿‘30å¤©ï¼‰"""
    from sqlalchemy import func
    
    # è·å–æœ€è¿‘30å¤©çš„æ—¥æœŸèŒƒå›´
    end_date = datetime.now().date()
    start_date = end_date - timedelta(days=29)
    
    # æŸ¥è¯¢æ¯æ—¥æ±‚ç‰‡æ•°é‡
    daily_stats = db.session.query(
        func.date(MovieRequest.created_at).label('date'),
        func.count(MovieRequest.id).label('count')
    ).filter(
        func.date(MovieRequest.created_at) >= start_date
    ).group_by(
        func.date(MovieRequest.created_at)
    ).order_by(
        func.date(MovieRequest.created_at)
    ).all()
    
    # æ„å»ºå®Œæ•´çš„æ—¥æœŸæ•°æ®ï¼ˆå¡«å……ç©ºç¼ºæ—¥æœŸï¼‰
    stats_dict = {str(stat.date): stat.count for stat in daily_stats}
    
    result = []
    current_date = start_date
    while current_date <= end_date:
        date_str = str(current_date)
        result.append({
            'date': date_str,
            'count': stats_dict.get(date_str, 0)
        })
        current_date += timedelta(days=1)
    
    return jsonify({
        'success': True,
        'data': result
    }), 200


@app.route('/admin/stats/type')
@admin_required
def get_type_stats():
    """è·å–æ±‚ç‰‡ç±»å‹åˆ†å¸ƒç»Ÿè®¡"""
    from sqlalchemy import func
    
    type_stats = db.session.query(
        MovieRequest.media_type,
        func.count(MovieRequest.id).label('count')
    ).group_by(MovieRequest.media_type).all()
    
    result = {stat.media_type: stat.count for stat in type_stats}
    
    return jsonify({
        'success': True,
        'data': {
            'movie': result.get('movie', 0),
            'tv': result.get('tv', 0)
        }
    }), 200


@app.route('/api/admin/dashboard-stats')
@admin_required
def get_dashboard_stats():
    """è·å–ç®¡ç†å‘˜ä»ªè¡¨ç›˜æ€»è§ˆç»Ÿè®¡æ•°æ®"""
    try:
        from datetime import date, timedelta
        today = date.today()
        now = datetime.now()
        last_month_start = (today.replace(day=1) - timedelta(days=1)).replace(day=1)
        this_month_start = today.replace(day=1)

        # ç”¨æˆ·ç»Ÿè®¡
        total_users = User.query.count()
        active_users = User.query.filter(User.lv.in_(['a', 'b']), User.ex > now).count()
        whitelist_users = Subscription.query.filter_by(plan_type='whitelist', status='active').count()
        subscriber_users = User.query.filter(User.lv == 'b').count()
        expired_users = User.query.filter(User.lv.in_(['a', 'b']), User.ex <= now).count()
        banned_users = User.query.filter(User.lv == 'c').count()

        # æœ¬æœˆå’Œä¸Šæœˆæ–°å¢ç”¨æˆ·ï¼ˆç”¨äºç¯æ¯”ï¼‰
        this_month_users = User.query.filter(db.func.date(User.cr) >= this_month_start).count()
        last_month_users = User.query.filter(
            db.func.date(User.cr) >= last_month_start,
            db.func.date(User.cr) < this_month_start
        ).count()

        # æ±‚ç‰‡
        total_requests = MovieRequest.query.count()
        pending_requests = MovieRequest.query.filter_by(status='pending').count()
        downloading_requests = MovieRequest.query.filter_by(status='downloading').count()
        completed_requests = MovieRequest.query.filter_by(status='completed').count()
        rejected_requests = MovieRequest.query.filter_by(status='rejected').count()

        # è®¢å• & æ”¶å…¥ â€” æœ¬æœˆ/ä¸Šæœˆ
        this_month_revenue_r = db.session.query(db.func.sum(Order.final_price)).filter(
            Order.payment_status == 'paid', db.func.date(Order.payment_time) >= this_month_start
        ).scalar()
        this_month_revenue = float(this_month_revenue_r) if this_month_revenue_r else 0.0
        last_month_revenue_r = db.session.query(db.func.sum(Order.final_price)).filter(
            Order.payment_status == 'paid',
            db.func.date(Order.payment_time) >= last_month_start,
            db.func.date(Order.payment_time) < this_month_start
        ).scalar()
        last_month_revenue = float(last_month_revenue_r) if last_month_revenue_r else 0.0

        # å·¥å•
        open_tickets = SupportTicket.query.filter_by(status='open').count()
        total_tickets = SupportTicket.query.count()

        # ä»Šæ—¥æ’­æ”¾è¯¦ç»†ç»Ÿè®¡
        today_plays = PlaybackRecord.query.filter(db.func.date(PlaybackRecord.started_at) == today)
        # æ’­æ”¾æ¬¡æ•°ï¼šåŒä¸€ç”¨æˆ·çœ‹åŒä¸€åª’ä½“ç®— 1 æ¬¡ï¼ˆå»é‡ï¼Œé¿å…æ¯10åˆ†é’Ÿè¿›åº¦è®°å½•å¯¼è‡´è™šé«˜ï¼‰
        play_count = db.session.query(
            db.func.count(db.func.distinct(
                db.func.concat(PlaybackRecord.user_tg, '-', PlaybackRecord.emby_item_id)
            ))
        ).filter(
            db.func.date(PlaybackRecord.started_at) == today
        ).scalar() or 0
        play_users = db.session.query(db.func.count(db.func.distinct(PlaybackRecord.user_tg))).filter(
            db.func.date(PlaybackRecord.started_at) == today
        ).scalar() or 0

        # è®¡ç®—ä»Šæ—¥æ€»æ’­æ”¾æ—¶é•¿
        # play_duration å­—æ®µå­˜çš„æ˜¯æ’­æ”¾ä½ç½®ï¼ˆpositionï¼‰ï¼Œä¸æ˜¯å®é™…æ¶ˆè€—çš„æ—¶é—´
        # åŒä¸€ç”¨æˆ·å¯¹åŒä¸€åª’ä½“å¯èƒ½æœ‰å¤šæ¡è®°å½•ï¼ˆæ¯10åˆ†é’Ÿåˆ›å»ºæ–°è®°å½•ï¼‰ï¼Œposition ä¼šé‡å¤ç´¯ç§¯
        # æ–¹æ¡ˆï¼šå¯¹æ¯ä¸ª (user_tg, emby_item_id) ç»„åˆï¼Œåªå–æœ€å¤§ play_durationï¼ˆå³æœ€ç»ˆä½ç½®ï¼‰ï¼Œé¿å…é‡å¤
        # åŒæ—¶å– total_duration åšä¸Šé™ä¿æŠ¤ï¼Œé˜²æ­¢å¼‚å¸¸ ticks å¯¼è‡´å¤©æ–‡æ•°å­—
        duration_by_item = db.session.query(
            db.func.max(PlaybackRecord.play_duration),
            db.func.max(PlaybackRecord.total_duration)
        ).filter(
            db.func.date(PlaybackRecord.started_at) == today
        ).group_by(
            PlaybackRecord.user_tg, PlaybackRecord.emby_item_id
        ).all()
        MAX_SINGLE_DURATION = 86400  # å•æ¡è®°å½•æœ€å¤§24å°æ—¶ï¼ˆç§’ï¼‰
        play_duration_sec = 0
        for r in duration_by_item:
            dur = r[0] or 0
            total = r[1] or 0
            # play_duration ä¸åº”è¶…è¿‡ total_durationï¼ˆå¦‚æœæœ‰ï¼‰ï¼Œä¸”ä¸è¶…è¿‡24å°æ—¶
            if total > 0:
                dur = min(dur, total)
            dur = min(dur, MAX_SINGLE_DURATION)
            play_duration_sec += dur
        # ç”µå½±/å‰§é›†æ¬¡æ•°åŒæ ·æŒ‰ (user_tg, emby_item_id) å»é‡
        play_movies = db.session.query(
            db.func.count(db.func.distinct(
                db.func.concat(PlaybackRecord.user_tg, '-', PlaybackRecord.emby_item_id)
            ))
        ).filter(
            db.func.date(PlaybackRecord.started_at) == today,
            PlaybackRecord.item_type == 'Movie'
        ).scalar() or 0
        play_episodes = db.session.query(
            db.func.count(db.func.distinct(
                db.func.concat(PlaybackRecord.user_tg, '-', PlaybackRecord.emby_item_id)
            ))
        ).filter(
            db.func.date(PlaybackRecord.started_at) == today,
            PlaybackRecord.item_type == 'Episode'
        ).scalar() or 0
        play_transcode = today_plays.filter(PlaybackRecord.play_method == 'Transcode').count()

        # ä»Šæ—¥çƒ­æ’­ Top 5
        # ç”¨ CASE è¡¨è¾¾å¼ï¼šå‰§é›†æŒ‰ series_name èšåˆï¼Œç”µå½±æŒ‰ item_name èšåˆ
        # é¿å…åŒä¸€éƒ¨å‰§çš„ä¸åŒé›†æ•°è¢«æ‹†æˆå¤šæ¡ï¼ˆå¦‚"å¹´å°‘æœ‰ä¸º"å‡ºç°ä¸¤æ¬¡ï¼‰
        display_name_col = db.case(
            (db.and_(PlaybackRecord.item_type == 'Episode', PlaybackRecord.series_name.isnot(None), PlaybackRecord.series_name != ''),
             PlaybackRecord.series_name),
            else_=PlaybackRecord.item_name
        ).label('display_name')
        
        top_items = db.session.query(
            display_name_col,
            PlaybackRecord.item_type,
            db.func.count(PlaybackRecord.id).label('cnt')
        ).filter(
            db.func.date(PlaybackRecord.started_at) == today
        ).group_by(
            'display_name', PlaybackRecord.item_type
        ).order_by(db.desc('cnt')).limit(5).all()

        top_list = []
        for item in top_items:
            top_list.append({'name': item.display_name, 'count': item.cnt, 'type': item.item_type or 'Unknown'})

        # æœ€è¿‘æ´»åŠ¨ï¼ˆæœ€æ–°10æ¡æ´»åŠ¨æ—¥å¿—ï¼‰
        recent_activities = []
        try:
            logs = UserActivityLog.query.order_by(UserActivityLog.created_at.desc()).limit(10).all()
            for log in logs:
                recent_activities.append({
                    'action': log.action_type,
                    'details': f"{log.user_name or 'æœªçŸ¥'} - {log.action_detail or ''}",
                    'time': log.created_at.isoformat() if log.created_at else None
                })
        except Exception:
            pass

        # æ ¼å¼åŒ–æ’­æ”¾æ—¶é•¿
        hours = play_duration_sec // 3600
        minutes = (play_duration_sec % 3600) // 60
        duration_str = f"{hours}h {minutes}m" if hours > 0 else f"{minutes}m"

        return jsonify({
            'success': True,
            'data': {
                'users': {
                    'total': total_users, 'active': active_users,
                    'whitelist': whitelist_users, 'subscriber': subscriber_users,
                    'expired': expired_users, 'banned': banned_users,
                    'this_month': this_month_users, 'last_month': last_month_users
                },
                'requests': {
                    'total': total_requests, 'pending': pending_requests,
                    'downloading': downloading_requests, 'completed': completed_requests,
                    'rejected': rejected_requests
                },
                'revenue': {
                    'this_month': this_month_revenue,
                    'last_month': last_month_revenue
                },
                'tickets': { 'open': open_tickets, 'total': total_tickets },
                'playback': {
                    'count': play_count, 'users': play_users,
                    'duration': duration_str, 'movies': play_movies,
                    'episodes': play_episodes, 'transcode': play_transcode,
                    'top': top_list
                },
                'recent_activities': recent_activities
            }
        }), 200
    except Exception as e:
        app.logger.error(f'è·å–ä»ªè¡¨ç›˜ç»Ÿè®¡æ•°æ®å¤±è´¥: {str(e)}')
        import traceback
        app.logger.error(traceback.format_exc())
        return jsonify({ 'success': False, 'error': 'è·å–ä»ªè¡¨ç›˜ç»Ÿè®¡æ•°æ®å¤±è´¥' }), 500


@app.route('/api/admin/dashboard-revenue-chart')
@admin_required
def get_dashboard_revenue_chart():
    """è·å–æ”¶å…¥æ›²çº¿å›¾æ•°æ®ï¼Œæ”¯æŒè‡ªå®šä¹‰æ—¶é—´èŒƒå›´"""
    try:
        from datetime import date, timedelta
        days = request.args.get('days', 30, type=int)
        start_date = request.args.get('start')
        end_date = request.args.get('end')

        if start_date and end_date:
            start = date.fromisoformat(start_date)
            end = date.fromisoformat(end_date)
            # æœ€é•¿ä¸€å¹´
            if (end - start).days > 366:
                start = end - timedelta(days=365)
        else:
            end = date.today()
            start = end - timedelta(days=days - 1)

        total_days = (end - start).days + 1
        chart_data = []
        total_revenue = 0.0
        total_orders = 0

        for i in range(total_days):
            d = start + timedelta(days=i)
            day_revenue_r = db.session.query(db.func.sum(Order.final_price)).filter(
                Order.payment_status == 'paid', db.func.date(Order.payment_time) == d
            ).scalar()
            day_revenue = float(day_revenue_r) if day_revenue_r else 0.0
            day_orders = Order.query.filter(
                Order.payment_status == 'paid', db.func.date(Order.payment_time) == d
            ).count()
            total_revenue += day_revenue
            total_orders += day_orders
            chart_data.append({
                'date': d.strftime('%m-%d') if total_days <= 90 else d.strftime('%Y-%m-%d'),
                'revenue': round(day_revenue, 2),
                'orders': day_orders
            })

        avg_revenue = round(total_revenue / max(total_days, 1), 2)

        return jsonify({
            'success': True,
            'data': {
                'chart': chart_data,
                'summary': {
                    'total_revenue': round(total_revenue, 2),
                    'total_orders': total_orders,
                    'avg_revenue': avg_revenue
                }
            }
        }), 200
    except Exception as e:
        app.logger.error(f'è·å–æ”¶å…¥å›¾è¡¨æ•°æ®å¤±è´¥: {str(e)}')
        return jsonify({ 'success': False, 'error': 'è·å–æ”¶å…¥å›¾è¡¨æ•°æ®å¤±è´¥' }), 500


@app.route('/api/admin/dashboard-system')
@admin_required
def get_dashboard_system():
    """è·å–ç³»ç»Ÿèµ„æºçŠ¶æ€"""
    try:
        import psutil
        cpu = psutil.cpu_percent(interval=0.5)
        mem = psutil.virtual_memory()
        disk = psutil.disk_usage('/')
        return jsonify({
            'success': True,
            'data': {
                'cpu': round(cpu, 1),
                'memory': round(mem.percent, 1),
                'disk': round(disk.percent, 1),
                'time': datetime.now().strftime('%H:%M:%S')
            }
        }), 200
    except ImportError:
        return jsonify({
            'success': True,
            'data': { 'cpu': 0, 'memory': 0, 'disk': 0, 'time': datetime.now().strftime('%H:%M:%S'), 'unavailable': True }
        }), 200
    except Exception as e:
        return jsonify({ 'success': False, 'error': str(e) }), 500


@app.route('/api/admin/dashboard-analytics')
@admin_required
def get_dashboard_analytics():
    """è·å–ä»ªè¡¨ç›˜ç»Ÿè®¡åˆ†ææ•°æ®ï¼šç”¨æˆ·æ’­æ”¾åˆ†å¸ƒã€å®¢æˆ·ç«¯åˆ†å¸ƒã€è®¾å¤‡åˆ†å¸ƒã€çƒ­é—¨ç”µå½±/å‰§é›†"""
    try:
        from datetime import date, timedelta
        days = request.args.get('days', 30, type=int)
        days = min(days, 90)
        since = datetime.now() - timedelta(days=days)

        # --- ç”¨æˆ·æ’­æ”¾ç»Ÿè®¡ï¼ˆæŒ‰æ’­æ”¾æ¬¡æ•° Top 10ï¼‰ ---
        user_play_stats = db.session.query(
            PlaybackRecord.user_tg,
            db.func.count(PlaybackRecord.id).label('cnt')
        ).filter(
            PlaybackRecord.started_at >= since
        ).group_by(PlaybackRecord.user_tg).order_by(db.desc('cnt')).limit(10).all()

        user_stats = []
        for row in user_play_stats:
            user = User.query.filter_by(tg=row[0]).first()
            name = (user.emby_name or user.name or str(row[0])) if user else str(row[0])
            user_stats.append({'name': name, 'value': row.cnt})

        # --- å®¢æˆ·ç«¯åˆ†å¸ƒ ---
        # ä¼˜å…ˆä» PlaybackRecord å…³è”çš„ UserDevice è·å–
        client_stats_raw = db.session.query(
            UserDevice.client,
            db.func.count(PlaybackRecord.id).label('cnt')
        ).join(
            UserDevice, PlaybackRecord.device_id == UserDevice.id
        ).filter(
            PlaybackRecord.started_at >= since,
            UserDevice.client.isnot(None),
            UserDevice.client != ''
        ).group_by(UserDevice.client).order_by(db.desc('cnt')).limit(10).all()

        client_stats = [{'name': row.client or 'æœªçŸ¥', 'value': row.cnt} for row in client_stats_raw]

        # å¦‚æœæ²¡æœ‰å…³è”æ•°æ®ï¼Œä» play_method åšå¤‡ç”¨ç»Ÿè®¡
        if not client_stats:
            method_stats = db.session.query(
                PlaybackRecord.play_method,
                db.func.count(PlaybackRecord.id).label('cnt')
            ).filter(
                PlaybackRecord.started_at >= since,
                PlaybackRecord.play_method.isnot(None),
                PlaybackRecord.play_method != ''
            ).group_by(PlaybackRecord.play_method).order_by(db.desc('cnt')).all()
            client_stats = [{'name': row.play_method or 'æœªçŸ¥', 'value': row.cnt} for row in method_stats]

        # --- è®¾å¤‡åˆ†å¸ƒ ---
        device_stats_raw = db.session.query(
            UserDevice.device_name,
            db.func.count(PlaybackRecord.id).label('cnt')
        ).join(
            UserDevice, PlaybackRecord.device_id == UserDevice.id
        ).filter(
            PlaybackRecord.started_at >= since,
            UserDevice.device_name.isnot(None),
            UserDevice.device_name != ''
        ).group_by(UserDevice.device_name).order_by(db.desc('cnt')).limit(10).all()

        device_stats = [{'name': row.device_name or 'æœªçŸ¥', 'value': row.cnt} for row in device_stats_raw]

        # --- çƒ­é—¨ç”µå½± Top 10 ---
        movie_stats_raw = db.session.query(
            PlaybackRecord.item_name,
            db.func.count(PlaybackRecord.id).label('cnt'),
            db.func.sum(PlaybackRecord.play_duration).label('total_dur')
        ).filter(
            PlaybackRecord.started_at >= since,
            PlaybackRecord.item_type == 'Movie'
        ).group_by(PlaybackRecord.item_name).order_by(db.desc('cnt')).limit(10).all()

        movie_stats = [{'name': row.item_name or 'æœªçŸ¥', 'value': row.cnt,
                        'duration': row.total_dur or 0} for row in movie_stats_raw]

        # --- çƒ­é—¨å‰§é›† Top 10ï¼ˆæŒ‰ series_name èšåˆï¼‰ ---
        series_stats_raw = db.session.query(
            PlaybackRecord.series_name,
            db.func.count(PlaybackRecord.id).label('cnt'),
            db.func.sum(PlaybackRecord.play_duration).label('total_dur')
        ).filter(
            PlaybackRecord.started_at >= since,
            PlaybackRecord.item_type == 'Episode',
            PlaybackRecord.series_name.isnot(None),
            PlaybackRecord.series_name != ''
        ).group_by(PlaybackRecord.series_name).order_by(db.desc('cnt')).limit(10).all()

        series_stats = [{'name': row.series_name or 'æœªçŸ¥', 'value': row.cnt,
                         'duration': row.total_dur or 0} for row in series_stats_raw]

        return jsonify({
            'success': True,
            'data': {
                'days': days,
                'users': user_stats,
                'clients': client_stats,
                'devices': device_stats,
                'movies': movie_stats,
                'series': series_stats
            }
        }), 200
    except Exception as e:
        app.logger.error(f'è·å–ä»ªè¡¨ç›˜ç»Ÿè®¡åˆ†ææ•°æ®å¤±è´¥: {str(e)}')
        import traceback
        app.logger.error(traceback.format_exc())
        return jsonify({'success': False, 'error': 'è·å–ç»Ÿè®¡åˆ†ææ•°æ®å¤±è´¥'}), 500


@app.route('/admin/stats/summary')
@admin_required
def get_stats_summary():
    """è·å–ç»Ÿè®¡æ•°æ®æ‘˜è¦ï¼ˆç”¨äºåˆ·æ–°åŠŸèƒ½ï¼‰"""
    try:
        total = MovieRequest.query.count()
        pending = MovieRequest.query.filter_by(status='pending').count()
        approved = MovieRequest.query.filter_by(status='approved').count()
        completed = MovieRequest.query.filter_by(status='completed').count()
        rejected = MovieRequest.query.filter_by(status='rejected').count()
        downloading = MovieRequest.query.filter_by(status='downloading').count()
        downloaded = MovieRequest.query.filter_by(status='downloaded').count()
        failed = MovieRequest.query.filter_by(status='failed').count()
        
        return jsonify({
            'success': True,
            'data': {
                'total': total,
                'pending': pending,
                'approved': approved,
                'completed': completed,
                'rejected': rejected,
                'downloading': downloading,
                'downloaded': downloaded,
                'failed': failed
            }
        }), 200
    except Exception as e:
        app.logger.error(f'è·å–ç»Ÿè®¡æ•°æ®å¤±è´¥: {str(e)}')
        return jsonify({
            'success': False,
            'error': 'è·å–ç»Ÿè®¡æ•°æ®å¤±è´¥'
        }), 500


@app.route('/my-requests')
@login_required
def my_requests():
    user = db.session.get(User, session['user_id'])
    requests = MovieRequest.query.options(joinedload(MovieRequest.download_task)).filter_by(user_tg=user.tg).order_by(MovieRequest.created_at.desc()).all()
    
    return render_template('my_requests.html',
                         requests=requests,
                         tmdb_image_base=TMDB_IMAGE_BASE_URL)


@app.route('/api/my-requests')
@login_required
def api_my_requests():
    """è·å–å½“å‰ç”¨æˆ·çš„æ±‚ç‰‡è®°å½•ï¼ˆAPIï¼‰"""
    user = db.session.get(User, session['user_id'])
    if not user:
        return jsonify({'success': False, 'error': 'ç”¨æˆ·ä¸å­˜åœ¨'}), 401
    
    requests_list = MovieRequest.query.options(
        joinedload(MovieRequest.download_task)
    ).filter_by(user_tg=user.tg).order_by(MovieRequest.created_at.desc()).limit(100).all()
    
    # æ ¹æ®é…ç½®å†³å®šæ˜¯å¦ä½¿ç”¨å›¾ç‰‡ä»£ç†
    site_config = get_site_config()
    if site_config.get('use_image_proxy', True):
        tmdb_image_base = '/api/tmdb-image/w500'
    else:
        tmdb_image_base = 'https://image.tmdb.org/t/p/w500'
    
    results = []
    for req in requests_list:
        item = {
            'id': req.id,
            'tmdb_id': req.tmdb_id,
            'title': req.title,
            'year': req.year,
            'poster_path': req.poster_path,
            'poster_url': f"{tmdb_image_base}{req.poster_path}" if req.poster_path else None,
            'overview': req.overview,
            'media_type': req.media_type,
            'request_type': req.request_type,
            'season_number': req.season_number,
            'episode_number': req.episode_number,
            'total_seasons': req.total_seasons,
            'status': req.status,
            'created_at': req.created_at.strftime('%Y-%m-%d %H:%M') if req.created_at else None,
            'admin_note': req.admin_note,
            'user_note': req.user_note,
            'request_scope': req.get_request_scope()
        }
        
        # ä¸‹è½½ä»»åŠ¡ä¿¡æ¯
        if req.download_task:
            item['download_task'] = {
                'progress': req.download_task.progress,
                'download_speed': req.download_task.download_speed,
                'eta': req.download_task.eta,
                'error_message': req.download_task.error_message if hasattr(req.download_task, 'error_message') else None,
                'retry_count': req.download_task.retry_count if hasattr(req.download_task, 'retry_count') else 0,
                'max_retries': req.download_task.max_retries if hasattr(req.download_task, 'max_retries') else 3
            }
        
        results.append(item)
    
    return jsonify({
        'success': True,
        'requests': results,
        'total': len(results)
    })


# ==================== è®¢é˜…ç®¡ç† API ====================

@app.route('/api/subscription/benefits', methods=['GET'])
@login_required
def get_subscription_benefits():
    user = User.query.filter_by(tg=session.get('user_id')).first()
    config = load_system_config()
    benefits = {
        'request_limit': config.get('request_limit', {}),
        'plans': load_plans_config(),
        'subscription_expire': {
            'auto_disable': config.get('subscription_expire', {}).get('auto_disable', True),
            'delete_days': config.get('subscription_expire', {}).get('delete_days', 0),
            'delete_web_account': config.get('subscription_expire', {}).get('delete_web_account', False),
            'retention_mode': config.get('subscription_expire', {}).get('retention_mode', 'off')
        }
    }
    return jsonify({'success': True, 'benefits': benefits})
    """æ ¹æ®ç”¨æˆ·è®¢é˜…çŠ¶æ€è·å–å¯¹åº”çš„æƒç›Šé…ç½®"""
    try:
        user = db.session.get(User, session.get('user_id'))
        config = load_system_config()
        default_benefits = config.get('default_benefits', {})
        
        # ç™½åå•ç”¨æˆ·ï¼šé€šè¿‡ Subscription plan_type='whitelist' åˆ¤æ–­ï¼ˆå…¼å®¹æ—§ lv='a'ï¼‰
        whitelist_sub = Subscription.query.filter_by(
            user_tg=user.tg, status='active', plan_type='whitelist'
        ).first()
        
        if whitelist_sub or user.lv == 'a':
            benefits = default_benefits.get('whitelist', [
                {'icon': 'ğŸ¬', 'text': 'æ— é™æ±‚ç‰‡'},
                {'icon': 'âš¡', 'text': 'æœ€é«˜ä¼˜å…ˆçº§'},
                {'icon': 'ğŸ“º', 'text': '4Kè¶…æ¸…èµ„æº'},
                {'icon': 'ğŸ’¬', 'text': 'VIPä¸“å±å®¢æœ'}
            ])
            return jsonify({
                'success': True,
                'benefits': benefits,
                'plan_type': 'whitelist'
            }), 200
        
        # æ£€æŸ¥ç”¨æˆ·æ˜¯å¦æœ‰æœ‰æ•ˆè®¢é˜…
        if user.ex and user.ex > datetime.now():
            # è·å–ç”¨æˆ·å½“å‰è®¢é˜…çš„å¥—é¤ç±»å‹
            subscription = Subscription.query.filter_by(
                user_tg=user.tg,
                status='active'
            ).order_by(Subscription.end_date.desc()).first()
            
            if subscription:
                # ä»å¥—é¤é…ç½®ä¸­è·å–å¯¹åº”çš„æƒç›Š
                plans = load_plans_config()
                for plan in plans:
                    if plan.get('id') == subscription.plan_type or plan.get('type') == subscription.plan_type:
                        benefits = plan.get('benefits', plan.get('features', []))
                        # å¦‚æœæ˜¯å­—ç¬¦ä¸²æ•°ç»„ï¼Œè½¬æ¢ä¸ºå¯¹è±¡æ•°ç»„
                        if benefits and isinstance(benefits[0], str):
                            benefits = [{'icon': 'âœ¨', 'text': b} for b in benefits]
                        return jsonify({
                            'success': True,
                            'benefits': benefits,
                            'plan_type': subscription.plan_type,
                            'plan_name': plan.get('name', '')
                        }), 200
            
            # æœ‰è®¢é˜…ä½†æ‰¾ä¸åˆ°å¥—é¤é…ç½®ï¼Œä½¿ç”¨é»˜è®¤è®¢é˜…æƒç›Š
            benefits = default_benefits.get('subscribed', [
                {'icon': 'ğŸ¬', 'text': 'æ¯æ—¥æ±‚ç‰‡'},
                {'icon': 'âš¡', 'text': 'ä¼˜å…ˆå¤„ç†'},
                {'icon': 'ğŸ“º', 'text': 'é«˜æ¸…èµ„æº'},
                {'icon': 'ğŸ’¬', 'text': 'ä¸“å±å®¢æœ'}
            ])
            return jsonify({
                'success': True,
                'benefits': benefits,
                'plan_type': 'subscribed'
            }), 200
        
        # æœªè®¢é˜…ç”¨æˆ·
        benefits = default_benefits.get('unsubscribed', [
            {'icon': 'ğŸš«', 'text': 'æ— æ±‚ç‰‡æƒé™'},
            {'icon': 'â³', 'text': 'æ™®é€šå¤„ç†'},
            {'icon': 'ğŸ“º', 'text': 'æ ‡æ¸…èµ„æº'},
            {'icon': 'ğŸ’¬', 'text': 'ç¤¾åŒºæ”¯æŒ'}
        ])
        return jsonify({
            'success': True,
            'benefits': benefits,
            'plan_type': 'unsubscribed'
        }), 200
        
    except Exception as e:
        app.logger.error(f'è·å–è®¢é˜…æƒç›Šé…ç½®å¤±è´¥: {e}')
        return jsonify({'error': str(e)}), 500


@app.route('/api/admin/default-benefits', methods=['GET', 'POST'])
@admin_required
def admin_default_benefits():
    """ç®¡ç†é»˜è®¤æƒç›Šé…ç½®ï¼ˆæœªè®¢é˜…ç”¨æˆ·å’Œç™½åå•ç”¨æˆ·ï¼‰"""
    config = load_system_config()
    
    if request.method == 'GET':
        default_benefits = config.get('default_benefits', {
            'unsubscribed': [
                {'icon': 'ğŸš«', 'text': 'æ— æ±‚ç‰‡æƒé™'},
                {'icon': 'â³', 'text': 'æ™®é€šå¤„ç†'},
                {'icon': 'ğŸ“º', 'text': 'æ ‡æ¸…èµ„æº'},
                {'icon': 'ğŸ’¬', 'text': 'ç¤¾åŒºæ”¯æŒ'}
            ],
            'whitelist': [
                {'icon': 'ğŸ¬', 'text': 'æ— é™æ±‚ç‰‡'},
                {'icon': 'âš¡', 'text': 'æœ€é«˜ä¼˜å…ˆçº§'},
                {'icon': 'ğŸ“º', 'text': '4Kè¶…æ¸…èµ„æº'},
                {'icon': 'ğŸ’¬', 'text': 'VIPä¸“å±å®¢æœ'}
            ]
        })
        return jsonify({
            'success': True,
            'default_benefits': default_benefits
        }), 200
    
    elif request.method == 'POST':
        try:
            data = request.json
            default_benefits = data.get('default_benefits', {})
            
            # éªŒè¯æ•°æ®æ ¼å¼
            for key in ['unsubscribed', 'whitelist']:
                benefits = default_benefits.get(key, [])
                if len(benefits) > 8:
                    return jsonify({'success': False, 'error': f'{key}æœ€å¤šåªèƒ½é…ç½®8ä¸ªæƒç›Š'}), 400
            
            config['default_benefits'] = default_benefits
            
            if save_system_config(config):
                return jsonify({
                    'success': True,
                    'message': 'é»˜è®¤æƒç›Šé…ç½®å·²ä¿å­˜'
                }), 200
            else:
                return jsonify({'success': False, 'error': 'ä¿å­˜é…ç½®å¤±è´¥'}), 500
                
        except Exception as e:
            app.logger.error(f'ä¿å­˜é»˜è®¤æƒç›Šé…ç½®å¤±è´¥: {e}')
            return jsonify({'error': str(e)}), 500


@app.route('/api/subscription/current', methods=['GET'])
@login_required
def get_current_subscription():
    """è·å–å½“å‰ç”¨æˆ·çš„è®¢é˜…ä¿¡æ¯"""
    try:
        user = db.session.get(User, session.get('user_id'))
        if not user:
            return jsonify({'error': 'ç”¨æˆ·ä¸å­˜åœ¨'}), 404
        
        # ===== æ„å»ºä¿å·é…ç½®ä¿¡æ¯ =====
        config = load_system_config()
        expire_config = config.get('subscription_expire', {})
        checkin_config = config.get('checkin', {})
        retention_mode = expire_config.get('retention_mode', 'off')
        retention_info = None
        if retention_mode != 'off':
            retention_info = {
                'mode': retention_mode,
                'renew_days': expire_config.get('retention_renew_days', 30),
                'coin_name': checkin_config.get('coin_name', 'ç§¯åˆ†'),
                'user_coins': user.coins or 0,
            }
            if retention_mode in ('checkin', 'both'):
                retention_info['checkin_cost'] = expire_config.get('retention_checkin_cost', 10)
            if retention_mode in ('watch', 'both'):
                retention_info['watch_days'] = expire_config.get('retention_watch_days', 30)
                retention_info['watch_minutes'] = expire_config.get('retention_watch_minutes', 30)
        
        # ç™½åå•ç”¨æˆ·ç‰¹æ®Šå¤„ç†ï¼šé€šè¿‡ Subscription plan_type='whitelist' åˆ¤æ–­ï¼ˆå…¼å®¹æ—§ lv='a'ï¼‰
        # æ£€æŸ¥ Subscription è¡¨æ˜¯å¦æœ‰ç™½åå•è®°å½•
        whitelist_sub = Subscription.query.filter_by(
            user_tg=user.tg, status='active', plan_type='whitelist'
        ).first()
        
        if whitelist_sub or user.lv == 'a':
            return jsonify({
                'success': True,
                'subscription': {
                    'id': whitelist_sub.id if whitelist_sub else 0,
                    'user_tg_id': user.tg,
                    'user_name': user.name,
                    'plan_type': 'whitelist',
                    'plan_name': 'ç™½åå•ç”¨æˆ·',
                    'duration_months': -1,  # -1 è¡¨ç¤ºæ°¸ä¹…
                    'price': 0,
                    'start_date': (whitelist_sub.start_date.isoformat() if whitelist_sub else user.cr.isoformat()) if (whitelist_sub or user.cr) else None,
                    'end_date': None,  # æ°¸ä¸è¿‡æœŸ
                    'status': 'active',
                    'days_remaining': 'æ°¸ä¹…',
                    'is_whitelist': True
                },
                'retention': retention_info
            }), 200
        
        # ä¼˜å…ˆæ£€æŸ¥ç”¨æˆ·çš„ exï¼ˆåˆ°æœŸæ—¶é—´ï¼‰å­—æ®µ - è¿™æ˜¯è®¢é˜…çŠ¶æ€çš„ä¸»è¦æ¥æº
        if user.ex and user.ex > datetime.now():
            # ç”¨æˆ·æœ‰æœ‰æ•ˆçš„åˆ°æœŸæ—¶é—´
            days_remaining = (user.ex - datetime.now()).days
            
            # å°è¯•ä» Subscription è¡¨è·å–æ›´å¤šä¿¡æ¯
            subscription = Subscription.query.filter_by(
                user_tg=user.tg,
                status='active'
            ).order_by(Subscription.end_date.desc()).first()
            
            if subscription:
                return jsonify({
                    'success': True,
                    'subscription': subscription.to_dict(),
                    'retention': retention_info
                }), 200
            else:
                # æ²¡æœ‰ Subscription è®°å½•ä½†æœ‰ user.exï¼Œè¯´æ˜æ˜¯é€šè¿‡å…¶ä»–æ–¹å¼è®¾ç½®çš„ï¼ˆå¦‚ç®¡ç†å‘˜æ‰‹åŠ¨è®¾ç½®ï¼‰
                return jsonify({
                    'success': True,
                    'subscription': {
                        'id': 0,
                        'user_tg_id': user.tg,
                        'user_name': user.name,
                        'plan_type': 'manual',
                        'plan_name': 'è®¢é˜…ç”¨æˆ·',
                        'duration_months': 0,
                        'price': 0,
                        'start_date': user.cr.isoformat() if user.cr else None,
                        'end_date': user.ex.isoformat() if user.ex else None,
                        'status': 'active',
                        'days_remaining': days_remaining,
                        'is_whitelist': False
                    },
                    'retention': retention_info
                }), 200
        
        # ç”¨æˆ·æ²¡æœ‰æœ‰æ•ˆçš„åˆ°æœŸæ—¶é—´
        return jsonify({
            'success': True,
            'subscription': None,
            'retention': retention_info,
            'message': 'æš‚æ— æœ‰æ•ˆè®¢é˜…'
        }), 200
    except Exception as e:
        app.logger.error(f'è·å–è®¢é˜…ä¿¡æ¯å¤±è´¥: {e}')
        return jsonify({'error': str(e)}), 500


@app.route('/api/subscription/history', methods=['GET'])
@login_required
def get_subscription_history():
    """è·å–è®¢é˜…å†å²"""
    try:
        user = db.session.get(User, session.get('user_id'))
        now = datetime.now()
        
        # è‡ªåŠ¨æ›´æ–°è®¢é˜…çŠ¶æ€ï¼š
        # 1. å°†å·²è¿‡æœŸçš„ active è®¢é˜…æ ‡è®°ä¸º expired
        # 2. å°†å·²åˆ°å¼€å§‹æ—¶é—´çš„ pending è®¢é˜…æ¿€æ´»ä¸º active
        expired_subs = Subscription.query.filter_by(
            user_tg=user.tg,
            status='active'
        ).filter(Subscription.end_date <= now).all()
        
        for sub in expired_subs:
            sub.status = 'expired'
        
        pending_subs = Subscription.query.filter_by(
            user_tg=user.tg,
            status='pending'
        ).filter(Subscription.start_date <= now).all()
        
        for sub in pending_subs:
            sub.status = 'active'
        
        if expired_subs or pending_subs:
            db.session.commit()
        
        subscriptions = Subscription.query.filter_by(user_tg=user.tg).order_by(
            Subscription.start_date.desc()
        ).all()
        
        # å¦‚æœæ²¡æœ‰ Subscription è®°å½•ï¼Œä½†ç”¨æˆ·æœ‰æœ‰æ•ˆçš„åˆ°æœŸæ—¶é—´(user.ex)ï¼Œè¡¥å……åˆ›å»ºä¸€æ¡è®°å½•
        if not subscriptions and user.ex and user.ex > datetime.now():
            # å°è¯•ä»è®¢å•è¡¨æ‰¾åˆ°æœ€è¿‘çš„å·²æ”¯ä»˜è®¢å•æ¥ç¡®å®šå¥—é¤ä¿¡æ¯
            recent_order = Order.query.filter_by(
                user_tg=user.tg,
                payment_status='paid'
            ).order_by(Order.payment_time.desc()).first()
            
            if recent_order:
                # æ ¹æ®è®¢å•åˆ›å»ºè®¢é˜…è®°å½•
                subscription = Subscription(
                    user_tg=user.tg,
                    plan_type=recent_order.plan_type,
                    plan_name=recent_order.plan_name,
                    duration_months=recent_order.duration_months,
                    price=recent_order.final_price,
                    start_date=recent_order.payment_time or datetime.now(),
                    end_date=user.ex,
                    status='active',
                    source='purchase'
                )
                db.session.add(subscription)
                db.session.commit()
                app.logger.info(f'è‡ªåŠ¨è¡¥å……åˆ›å»ºè®¢é˜…è®°å½•: ç”¨æˆ·={user.name}, å¥—é¤={recent_order.plan_name}')
                subscriptions = [subscription]
            else:
                # æ²¡æœ‰è®¢å•è®°å½•ï¼Œå¯èƒ½æ˜¯ç®¡ç†å‘˜æ‰‹åŠ¨è®¾ç½®çš„ï¼Œåˆ›å»ºä¸€ä¸ªé€šç”¨è®°å½•
                subscription = Subscription(
                    user_tg=user.tg,
                    plan_type='manual',
                    plan_name='è®¢é˜…ä¼šå‘˜',
                    duration_months=max(1, (user.ex - datetime.now()).days // 30),
                    price=0,
                    start_date=user.cr or datetime.now(),
                    end_date=user.ex,
                    status='active',
                    source='manual'
                )
                db.session.add(subscription)
                db.session.commit()
                app.logger.info(f'è‡ªåŠ¨è¡¥å……åˆ›å»ºè®¢é˜…è®°å½•(æ‰‹åŠ¨è®¾ç½®): ç”¨æˆ·={user.name}')
                subscriptions = [subscription]
        
        return jsonify({
            'success': True,
            'subscriptions': [sub.to_dict() for sub in subscriptions]
        }), 200
    except Exception as e:
        app.logger.error(f'è·å–è®¢é˜…å†å²å¤±è´¥: {e}')
        return jsonify({'error': str(e)}), 500


# ==================== è´­ä¹°/è®¢å• API ====================
@app.route('/api/plans', methods=['GET'])
@login_required
def get_plans():
    """è·å–å¯è´­ä¹°çš„å¥—é¤åˆ—è¡¨"""
    plans = load_plans_config()
    
    return jsonify({
        'success': True,
        'plans': plans
    }), 200


@app.route('/api/orders/create', methods=['POST'])
@login_required
def create_order():
    """åˆ›å»ºè®¢å•"""
    try:
        data = request.json
        app.logger.info(f'æ”¶åˆ°åˆ›å»ºè®¢å•è¯·æ±‚: {data}')
        
        user = db.session.get(User, session.get('user_id'))
        if not user:
            app.logger.error('åˆ›å»ºè®¢å•å¤±è´¥: ç”¨æˆ·æœªæ‰¾åˆ°')
            return jsonify({'error': 'ç”¨æˆ·æœªæ‰¾åˆ°'}), 401
        
        # æ£€æŸ¥ orders è¡¨æ˜¯å¦å­˜åœ¨
        from sqlalchemy import inspect
        inspector = inspect(db.engine)
        if 'orders' not in inspector.get_table_names():
            app.logger.warning('orders è¡¨ä¸å­˜åœ¨ï¼Œæ­£åœ¨åˆ›å»º...')
            db.create_all()
            app.logger.info('orders è¡¨å·²åˆ›å»º')
        
        plan_type = data.get('plan_type')  # å¥—é¤ç±»å‹
        duration = int(data.get('duration', 1))  # è®¢é˜…æ—¶é•¿ï¼ˆ0=ä¸€æ¬¡æ€§ï¼Œ1=æœˆä»˜ï¼Œ3=å­£ä»˜ç­‰ï¼‰
        payment_method = data.get('payment_method', 'alipay')
        
        app.logger.info(f'åˆ›å»ºè®¢å•å‚æ•°: plan_type={plan_type}, duration={duration}, payment_method={payment_method}, user={user.name}')
        
        # ä»é…ç½®æ–‡ä»¶åŠ è½½å¥—é¤
        plans_config = load_plans_config()
        
        # æŸ¥æ‰¾å¯¹åº”IDçš„å¥—é¤ï¼ˆä¼˜å…ˆæŒ‰IDåŒ¹é…ï¼Œå…¼å®¹æ—§æ•°æ®æŒ‰typeåŒ¹é…ï¼‰
        plan_config = None
        for plan in plans_config:
            if plan.get('id') == plan_type:
                plan_config = plan
                break
        if not plan_config:
            # å…¼å®¹æ—§æ•°æ®ï¼šæŒ‰ type å­—æ®µå›é€€åŒ¹é…
            for plan in plans_config:
                if plan.get('type') == plan_type:
                    plan_config = plan
                    break
        
        if not plan_config:
            return jsonify({'error': 'æ— æ•ˆçš„å¥—é¤'}), 400
        
        # ä»å¥—é¤é…ç½®è·å–åŸºç¡€å¤©æ•°ï¼ˆduration_days å­—æ®µï¼‰
        base_duration_days = int(plan_config.get('duration_days', 30))
        # æ°¸ä¹…å¥—é¤ï¼š999å¤©åŠä»¥ä¸Šè§†ä¸ºæ°¸ä¹…
        is_permanent = base_duration_days >= 999
        
        # äº’æ–¥æ ¡éªŒï¼šä¸€æ¬¡æ€§ä»·æ ¼å’Œæœˆä»˜ä»·æ ¼åªèƒ½ç”¨ä¸€ç§æ¨¡å¼
        has_once_price = float(plan_config.get('price_once', 0) or 0) > 0
        has_monthly_price = float(plan_config.get('price_1m', 0) or plan_config.get('price', 0) or 0) > 0
        
        if duration == 0 and not has_once_price:
            return jsonify({'error': 'è¯¥å¥—é¤æœªé…ç½®ä¸€æ¬¡æ€§ä»·æ ¼'}), 400
        if duration > 0 and has_once_price:
            return jsonify({'error': 'è¯¥å¥—é¤ä¸ºä¸€æ¬¡æ€§è´­ä¹°æ¨¡å¼ï¼Œä¸æ”¯æŒå‘¨æœŸè®¢é˜…'}), 400
        if duration > 0 and not has_monthly_price:
            return jsonify({'error': 'è¯¥å¥—é¤æœªé…ç½®å‘¨æœŸä»·æ ¼'}), 400
        
        # ä¸€æ¬¡æ€§è´­ä¹°ï¼ˆduration=0ï¼‰ï¼šä½¿ç”¨å¥—é¤çš„åŸºç¡€å¤©æ•°ï¼Œä»·æ ¼ç”¨ price_once
        if duration == 0:
            actual_duration_days = base_duration_days
            final_price = float(plan_config.get('price_once', 0))
            if final_price <= 0:
                return jsonify({'error': 'è¯¥å¥—é¤æœªé…ç½®ä¸€æ¬¡æ€§ä»·æ ¼'}), 400
            original_price = final_price
            discount = 0
        else:
            # æ ¹æ®è´­ä¹°å‘¨æœŸè®¡ç®—å®é™…å¤©æ•°
            # duration=1 â†’ åŸºç¡€å¤©æ•°, duration=3 â†’ åŸºç¡€å¤©æ•°*3, ä»¥æ­¤ç±»æ¨
            actual_duration_days = base_duration_days * duration
            
            # è·å–å¯¹åº”å‘¨æœŸçš„ä»·æ ¼
            duration_price_map = {
                1: plan_config.get('price_1m') or plan_config.get('price', 0),
                3: plan_config.get('price_3m', 0),
                6: plan_config.get('price_6m', 0),
                12: plan_config.get('price_12m', 0)
            }
            
            if duration not in duration_price_map:
                return jsonify({'error': 'æ— æ•ˆçš„è®¢é˜…æ—¶é•¿'}), 400
            
            final_price = float(duration_price_map[duration])
            if final_price <= 0:
                # å¦‚æœè¯¥å‘¨æœŸæ²¡æœ‰è®¾ç½®ä»·æ ¼ï¼Œä½¿ç”¨æœˆä»˜ä»·æ ¼è®¡ç®—
                monthly_price = float(plan_config.get('price_1m') or plan_config.get('price', 0))
                if monthly_price <= 0:
                    return jsonify({'error': 'å¥—é¤ä»·æ ¼æœªé…ç½®'}), 400
                # ä½¿ç”¨é»˜è®¤æŠ˜æ‰£è®¡ç®—
                multipliers = {1: 1.0, 3: 2.8, 6: 5.0, 12: 9.0}
                final_price = round(monthly_price * multipliers.get(duration, duration), 2)
        
        # è®¡ç®—åŸä»·å’ŒæŠ˜æ‰£ï¼ˆä¸€æ¬¡æ€§è´­ä¹°å·²åœ¨ä¸Šé¢å¤„ç†ï¼‰
        if duration != 0:
            monthly_price = float(plan_config.get('price_1m') or plan_config.get('price', 0))
            original_price = round(monthly_price * duration, 2)
            discount = round(original_price - final_price, 2)
            if discount < 0:
                discount = 0
        
        # æ„å»ºå¥—é¤åç§°
        plan_name = plan_config.get('name', 'å¥—é¤')
        if duration == 0:
            # ä¸€æ¬¡æ€§è´­ä¹°
            if is_permanent:
                plan_name = f"{plan_name}(æ°¸ä¹…)"
            else:
                plan_name = f"{plan_name}({actual_duration_days}å¤©)"
        elif base_duration_days < 30:
            # çŸ­æœŸå¥—é¤ï¼ˆè¯•ç”¨ç­‰ï¼‰ï¼Œç›´æ¥æ˜¾ç¤ºå¤©æ•°
            if duration > 1:
                plan_name = f"{plan_name}({actual_duration_days}å¤©)"
        elif duration > 1:
            duration_names = {3: '(å­£ä»˜)', 6: '(åŠå¹´ä»˜)', 12: '(å¹´ä»˜)'}
            plan_name = f"{plan_name}{duration_names.get(duration, f'({duration}æœŸ)')}"
        
        # è‡ªåŠ¨å–æ¶ˆè¯¥ç”¨æˆ·åŒä¸€å¥—é¤çš„æ—§å¾…æ”¯ä»˜è®¢å•ï¼ˆé˜²æ­¢è®¢å•å †ç§¯ï¼‰
        stale_orders = Order.query.filter_by(
            user_tg=user.tg,
            plan_type=plan_type,
            payment_status='pending'
        ).all()
        for stale in stale_orders:
            stale.payment_status = 'cancelled'
            app.logger.info(f'è‡ªåŠ¨å–æ¶ˆæ—§å¾…æ”¯ä»˜è®¢å•: {stale.order_no}')
        
        # ç”Ÿæˆè®¢å•å·ï¼ˆæ—¶é—´æˆ³ + ç”¨æˆ·IDå4ä½ + 4ä½éšæœºæ•°ï¼Œé˜²æ­¢å¯é¢„æµ‹ï¼‰
        import random
        order_no = f'ORD{int(time.time())}{user.tg % 10000:04d}{random.randint(1000, 9999)}'
        
        # åˆ›å»ºè®¢å•
        order = Order(
            order_no=order_no,
            user_tg=user.tg,
            plan_type=plan_type,
            plan_name=plan_name,
            duration_months=duration,
            duration_days=actual_duration_days,
            original_price=original_price,
            discount=discount,
            final_price=final_price,
            payment_method=payment_method,
            payment_status='pending'
        )
        
        db.session.add(order)
        db.session.commit()
        
        # éªŒè¯è®¢å•æ˜¯å¦çœŸçš„ä¿å­˜äº†
        saved_order = Order.query.filter_by(order_no=order_no).first()
        if saved_order:
            app.logger.info(f'åˆ›å»ºè®¢å•æˆåŠŸ: {order_no}, ID={saved_order.id}, ç”¨æˆ·: {user.name}, å¥—é¤: {plan_name}, é‡‘é¢: {final_price}')
        else:
            app.logger.error(f'è®¢å•ä¿å­˜å¤±è´¥ï¼order_no={order_no} æ— æ³•æŸ¥è¯¢åˆ°')
            # å°è¯•ç›´æ¥ç”¨SQLæŸ¥è¯¢
            from sqlalchemy import text
            result = db.session.execute(text(f"SELECT COUNT(*) FROM orders WHERE order_no='{order_no}'"))
            count = result.scalar()
            app.logger.error(f'ç›´æ¥SQLæŸ¥è¯¢ç»“æœ: {count}')
        
        # è®°å½•åˆ›å»ºè®¢å•æ—¥å¿—
        log_user_activity(UserActivityLog.ACTION_CREATE_ORDER, user=user,
                         detail={'order_no': order_no, 'plan_type': plan_type, 'plan_name': plan_name,
                                'duration_months': duration, 'final_price': final_price, 'payment_method': payment_method})
        
        return jsonify({
            'success': True,
            'order': order.to_dict()
        }), 200
        
    except Exception as e:
        app.logger.error(f'åˆ›å»ºè®¢å•å¤±è´¥: {e}', exc_info=True)
        db.session.rollback()
        return jsonify({'error': str(e)}), 500


@app.route('/api/orders/my', methods=['GET'])
@login_required
def get_my_orders():
    """è·å–æˆ‘çš„è®¢å•"""
    try:
        user = db.session.get(User, session.get('user_id'))
        orders = Order.query.filter_by(user_tg=user.tg).order_by(
            Order.created_at.desc()
        ).limit(20).all()  # é™åˆ¶æœ€å¤šè¿”å›20æ¡
        
        return jsonify({
            'success': True,
            'orders': [order.to_dict() for order in orders]
        }), 200
    except Exception as e:
        app.logger.error(f'è·å–è®¢å•å¤±è´¥: {e}')
        return jsonify({'error': str(e)}), 500


@app.route('/api/orders/cancel', methods=['POST'])
@login_required
def cancel_order():
    """å–æ¶ˆè®¢å•"""
    try:
        data = request.json
        order_no = data.get('order_no')
        
        if not order_no:
            return jsonify({'error': 'è®¢å•å·ä¸èƒ½ä¸ºç©º'}), 400
        
        user = db.session.get(User, session.get('user_id'))
        order = Order.query.filter_by(order_no=order_no, user_tg=user.tg).first()
        
        if not order:
            return jsonify({'error': 'è®¢å•ä¸å­˜åœ¨'}), 404
        
        if order.payment_status != 'pending':
            return jsonify({'error': 'åªèƒ½å–æ¶ˆå¾…æ”¯ä»˜è®¢å•'}), 400
        
        order.payment_status = 'cancelled'
        db.session.commit()
        
        app.logger.info(f'å–æ¶ˆè®¢å•: {order_no}, ç”¨æˆ·: {user.name}')
        
        return jsonify({
            'success': True,
            'message': 'è®¢å•å·²å–æ¶ˆ'
        }), 200
        
    except Exception as e:
        app.logger.error(f'å–æ¶ˆè®¢å•å¤±è´¥: {e}')
        db.session.rollback()
        return jsonify({'error': str(e)}), 500


# ==================== å…‘æ¢ç  API ====================

@app.route('/api/redeem/use', methods=['POST'])
@login_required
def use_redeem_code():
    """ä½¿ç”¨å…‘æ¢ç """
    try:
        # â€”â€” åç«¯éªŒè¯ç æ ¡éªŒï¼ˆé˜²è„šæœ¬åˆ·å…‘æ¢ç ï¼‰ â€”â€”
        data = request.get_json(silent=True) or {}
        captcha_answer = data.get('captcha_answer')
        ok, err = _verify_captcha(captcha_answer)
        if not ok:
            return jsonify({'success': False, 'error': err}), 400

        code = data.get('code', '').strip().upper()
        
        if not code:
            app.logger.warning(f'å…‘æ¢ç ä½¿ç”¨å¤±è´¥ - åŸå› : æœªè¾“å…¥å…‘æ¢ç ')
            return jsonify({'success': False, 'error': 'è¯·è¾“å…¥å…‘æ¢ç '}), 400
        
        user = db.session.get(User, session.get('user_id'))
        if not user:
            app.logger.warning(f'å…‘æ¢ç ä½¿ç”¨å¤±è´¥ - åŸå› : ç”¨æˆ·ä¸å­˜åœ¨ (session user_id={session.get("user_id")})')
            return jsonify({'success': False, 'error': 'ç”¨æˆ·ä¸å­˜åœ¨ï¼Œè¯·é‡æ–°ç™»å½•'}), 401
        
        if not user.tg:
            app.logger.warning(f'å…‘æ¢ç ä½¿ç”¨å¤±è´¥ - ç”¨æˆ·: {user.name}, åŸå› : ç¼ºå°‘TGæ ‡è¯†')
            return jsonify({'success': False, 'error': 'ç”¨æˆ·è´¦æˆ·å¼‚å¸¸ï¼Œç¼ºå°‘TGæ ‡è¯†'}), 400
        
        app.logger.info(f'ç”¨æˆ· {user.name}(tg={user.tg}) å°è¯•ä½¿ç”¨å…‘æ¢ç : {code}')
        
        # æŸ¥æ‰¾å…‘æ¢ç ï¼ˆMySQL åŠ è¡Œçº§é”é˜²å¹¶å‘ç«æ€ï¼›SQLite å•å†™è€…æ¨¡å‹å¤©ç„¶å®‰å…¨ï¼‰
        is_mysql = 'mysql' in app.config.get('SQLALCHEMY_DATABASE_URI', '')
        query = RedeemCode.query.filter_by(code=code)
        if is_mysql:
            query = query.with_for_update()
        redeem = query.first()
        
        if not redeem:
            app.logger.warning(f'å…‘æ¢ç ä½¿ç”¨å¤±è´¥ - ç”¨æˆ·: {user.name}(tg={user.tg}), å…‘æ¢ç : {code}, åŸå› : å…‘æ¢ç ä¸å­˜åœ¨')
            return jsonify({'success': False, 'error': 'å…‘æ¢ç ä¸å­˜åœ¨ï¼Œè¯·æ£€æŸ¥è¾“å…¥æ˜¯å¦æ­£ç¡®'}), 404
        
        if redeem.is_used:
            app.logger.warning(f'å…‘æ¢ç ä½¿ç”¨å¤±è´¥ - ç”¨æˆ·: {user.name}(tg={user.tg}), å…‘æ¢ç : {code}, åŸå› : å…‘æ¢ç å·²è¢«ä½¿ç”¨ (used_by={redeem.used_by}, used_at={redeem.used_at})')
            return jsonify({'success': False, 'error': 'å…‘æ¢ç å·²è¢«ä½¿ç”¨ï¼Œæ¯ä¸ªå…‘æ¢ç åªèƒ½ä½¿ç”¨ä¸€æ¬¡'}), 400
        
        if not redeem.is_active:
            app.logger.warning(f'å…‘æ¢ç ä½¿ç”¨å¤±è´¥ - ç”¨æˆ·: {user.name}(tg={user.tg}), å…‘æ¢ç : {code}, åŸå› : å…‘æ¢ç å·²è¢«ç¦ç”¨')
            return jsonify({'success': False, 'error': 'å…‘æ¢ç å·²è¢«ç¦ç”¨ï¼Œè¯·è”ç³»ç®¡ç†å‘˜'}), 400
        
        # æ£€æŸ¥æ˜¯å¦è¿‡æœŸ
        if redeem.expires_at and redeem.expires_at < datetime.now():
            app.logger.warning(f'å…‘æ¢ç ä½¿ç”¨å¤±è´¥ - ç”¨æˆ·: {user.name}(tg={user.tg}), å…‘æ¢ç : {code}, åŸå› : å…‘æ¢ç å·²è¿‡æœŸ (expires_at={redeem.expires_at})')
            return jsonify({'success': False, 'error': 'å…‘æ¢ç å·²è¿‡æœŸï¼Œè¯·ä½¿ç”¨æœ‰æ•ˆçš„å…‘æ¢ç '}), 400
        
        # æ ¡éªŒå…‘æ¢ç ç±»å‹ä¸ç”¨æˆ·çŠ¶æ€æ˜¯å¦åŒ¹é…
        has_emby = bool(user.embyid)
        if redeem.code_type == 'new' and has_emby:
            app.logger.warning(f'å…‘æ¢ç ä½¿ç”¨å¤±è´¥ - ç”¨æˆ·: {user.name}(tg={user.tg}), å…‘æ¢ç : {code}, åŸå› : ç±»å‹ä¸åŒ¹é…(æ³¨å†Œç ä½†ç”¨æˆ·å·²æœ‰Embyè´¦å·)')
            return jsonify({'success': False, 'error': 'æ‚¨å·²æœ‰ Emby è´¦å·ï¼Œæ­¤ä¸ºæ³¨å†Œç ï¼Œä»…é™æœªå¼€é€šè´¦å·çš„ç”¨æˆ·ä½¿ç”¨ã€‚è¯·ä½¿ç”¨ç»­æœŸç å»¶é•¿è®¢é˜…ã€‚'}), 400
        
        if redeem.code_type == 'renew' and not has_emby:
            app.logger.warning(f'å…‘æ¢ç ä½¿ç”¨å¤±è´¥ - ç”¨æˆ·: {user.name}(tg={user.tg}), å…‘æ¢ç : {code}, åŸå› : ç±»å‹ä¸åŒ¹é…(ç»­æœŸç ä½†ç”¨æˆ·æ— Embyè´¦å·)')
            return jsonify({'success': False, 'error': 'æ‚¨è¿˜æ²¡æœ‰ Emby è´¦å·ï¼Œæ­¤ä¸ºç»­æœŸç ï¼Œä»…é™å·²æœ‰è´¦å·çš„ç”¨æˆ·ä½¿ç”¨ã€‚è¯·å…ˆä½¿ç”¨æ³¨å†Œç å¼€é€šè´¦å·ã€‚'}), 400
        
        # è·å–å¥—é¤é…ç½®
        plans_config = []
        try:
            plans_config_path = os.path.join(app.instance_path, 'plans_config.json')
            if os.path.exists(plans_config_path):
                with open(plans_config_path, 'r', encoding='utf-8') as f:
                    plans_config = json.load(f)
        except Exception as e:
            app.logger.error(f'åŠ è½½å¥—é¤é…ç½®å¤±è´¥: {e}')
        
        # ä»é…ç½®ä¸­è·å–å¥—é¤åç§°
        plan_name = redeem.plan_type
        if redeem.plan_type == 'custom':
            plan_name = 'è‡ªå®šä¹‰æ—¶é•¿'
        else:
            for plan in plans_config:
                if plan.get('id') == redeem.plan_type:
                    plan_name = plan.get('name', redeem.plan_type)
                    break
        
        # è®¡ç®—æœˆæ•°ï¼ˆå‘ä¸Šå–æ•´ï¼Œä¿è¯ Subscription.duration_months ä¸ä¸º 0ï¼‰
        duration_months = max(1, -(-redeem.duration_days // 30))  # ceil division
        
        # æ£€æŸ¥è¯¥å¥—é¤æ˜¯å¦æ ‡è®°ä¸ºç™½åå•å¥—é¤
        _redeem_plan_type = redeem.plan_type
        _redeem_plan_name = plan_name
        _redeem_is_wl = False
        try:
            for _rp in load_plans_config():
                if _rp.get('id') == redeem.plan_type and _rp.get('is_whitelist'):
                    _redeem_is_wl = True
                    break
        except Exception:
            pass
        
        # è®¡ç®—è®¢é˜…æ—¶é—´ - æ‰€æœ‰ç±»å‹éƒ½ç«‹å³ç”Ÿæ•ˆï¼Œåœ¨ç°æœ‰åˆ°æœŸæ—¶é—´åŸºç¡€ä¸Šå åŠ 
        now = datetime.now()
        start_date = now
        
        if _redeem_is_wl:
            # ç™½åå•å¥—é¤ï¼šæ°¸ä¹…æœ‰æ•ˆ
            end_date = datetime(9999, 12, 31)
            _redeem_plan_type = 'whitelist'
            _redeem_plan_name = 'ç™½åå•ç”¨æˆ·'
        else:
            # æ™®é€šå¥—é¤ï¼šå¦‚æœç”¨æˆ·å·²æœ‰æœªè¿‡æœŸçš„åˆ°æœŸæ—¶é—´ï¼Œåœ¨æ­¤åŸºç¡€ä¸Šå åŠ 
            if user.ex and user.ex > now:
                end_date = user.ex + timedelta(days=redeem.duration_days)
            else:
                end_date = now + timedelta(days=redeem.duration_days)
        
        # åˆ›å»ºè®¢é˜…è®°å½•
        subscription = Subscription(
            user_tg=user.tg,
            plan_type=_redeem_plan_type,
            plan_name=_redeem_plan_name,
            duration_months=duration_months,
            price=0,  # å…‘æ¢ç å…è´¹
            start_date=start_date,
            end_date=end_date,
            status='active',
            source='redeem'
        )
        db.session.add(subscription)
        
        # æ ‡è®°å…‘æ¢ç å·²ä½¿ç”¨
        redeem.is_used = True
        redeem.used_by = user.tg
        redeem.used_at = datetime.now()
        
        # åŒæ­¥æ›´æ–°ç”¨æˆ·è¡¨çš„è®¢é˜…çŠ¶æ€
        if _redeem_is_wl:
            user.lv = 'a'  # ç™½åå•å¥—é¤è®¾ä¸ºç™½åå•ç­‰çº§
        elif user.lv not in ['a', 'c']:
            # æ™®é€šå¥—é¤ï¼šç™½åå•ä¸å˜ï¼Œå°ç¦ç”¨æˆ·ä¿æŒå°ç¦çŠ¶æ€
            user.lv = 'b'
        
        # æ›´æ–°è¿‡æœŸæ—¶é—´ - ç›´æ¥ä½¿ç”¨ä¸Šé¢å·²ç»æ­£ç¡®è®¡ç®—ï¼ˆå«å åŠ ï¼‰çš„ end_date
        user.ex = end_date
        
        app.logger.info(f'æ›´æ–°ç”¨æˆ·è®¢é˜…çŠ¶æ€: lv={user.lv}, ex={user.ex}')
        
        # é‚€è¯·è¿”åˆ©ï¼šæ£€æŸ¥æ˜¯å¦æœ‰é‚€è¯·äººï¼Œç»™é‚€è¯·äººè¿”åˆ©
        process_invite_reward(user, redeem.duration_days, source='å…‘æ¢ç ')
        
        db.session.commit()
        
        app.logger.info(f'å…‘æ¢ç ä½¿ç”¨æˆåŠŸ: {code}, ç”¨æˆ·: {user.name}(tg={user.tg}), ç±»å‹: {redeem.code_type}, å¥—é¤: {plan_name}, å¤©æ•°: {redeem.duration_days}')
        
        # æ£€æŸ¥ç”¨æˆ·æ˜¯å¦æœ‰ Emby è´¦å·ï¼ˆcommit åç«‹å³å–å€¼ï¼Œä¾›è¿”å›å’Œåå°çº¿ç¨‹ä½¿ç”¨ï¼‰
        has_emby_account = bool(user.embyid)
        _emby_id = user.embyid
        _emby_name = user.emby_name
        _user_name = user.name
        _user_tg = user.tg
        _user_lv = user.lv
        _user_ban_reason = user.ban_reason
        _display_name = user.emby_name or user.name or str(user.tg)
        _code_type = redeem.code_type
        _plan_type = redeem.plan_type
        _duration_days = redeem.duration_days
        
        # â€”â€” è€—æ—¶ IO æ“ä½œæ”¾å…¥åå°çº¿ç¨‹ï¼Œä¸»çº¿ç¨‹ç«‹å³è¿”å›ç»™ç”¨æˆ· â€”â€”
        def _post_redeem_tasks():
            with app.app_context():
                # æ¢å¤ Emby è´¦å·ï¼ˆå°ç¦ç”¨æˆ·å’Œé»‘åå•ç¦ç”¨ç”¨æˆ·ä¸è‡ªåŠ¨æ¢å¤ï¼‰
                if _user_lv != 'c' and not _user_ban_reason and _emby_id and emby_client.is_enabled():
                    if emby_client.enable_user(_emby_id):
                        app.logger.info(f'ç”¨æˆ· {_user_name} å…‘æ¢æˆåŠŸï¼Œå·²æ¢å¤Embyè´¦å· {_emby_name}')
                
                # è®°å½•æ´»åŠ¨æ—¥å¿—
                try:
                    log_user_activity(UserActivityLog.ACTION_REDEEM_CODE, user_tg=_user_tg, user_name=_user_name,
                                     detail={'code': code, 'plan_type': _plan_type, 'plan_name': plan_name,
                                            'duration_days': _duration_days, 'code_type': _code_type})
                except Exception as e:
                    app.logger.warning(f'è®°å½•å…‘æ¢ç æ´»åŠ¨æ—¥å¿—å¤±è´¥: {e}')
                
                # å‘é€ Telegram é€šçŸ¥
                try:
                    code_type_name = 'æ³¨å†Œç ' if _code_type == 'new' else 'ç»­æœŸç '
                    masked_code = code[:4] + 'â–‘' * max(len(code) - 4, 0) if len(code) > 4 else code
                    notify_msg = (
                        f"Â· ğŸŸï¸ <b>{code_type_name}ä½¿ç”¨</b> - "
                        f"<a href=\"tg://user?id={_user_tg}\">{_display_name}</a> "
                        f"[<code>{_user_tg}</code>] "
                        f"ä½¿ç”¨äº† <code>{masked_code}</code>\n"
                        f"Â· ğŸ“… åˆ°æœŸ: {end_date.strftime('%Y-%m-%d')}"
                    )
                    send_admin_notification(notify_msg)
                except Exception as e:
                    app.logger.warning(f'å‘é€å…‘æ¢ç ä½¿ç”¨ç¾¤ç»„é€šçŸ¥å¤±è´¥: {e}')
        
        Thread(target=_post_redeem_tasks, daemon=True).start()
        
        return jsonify({
            'success': True,
            'message': f'ğŸ‰ å…‘æ¢æˆåŠŸï¼å·²è·å¾— {plan_name} {redeem.duration_days} å¤©',
            'plan_type': _plan_type,
            'plan_name': plan_name,
            'duration_days': _duration_days,
            'code_type': _code_type,
            'has_emby_account': has_emby_account
        }), 200
        
    except Exception as e:
        app.logger.error(f'ä½¿ç”¨å…‘æ¢ç å¤±è´¥: {e}')
        db.session.rollback()
        return jsonify({'error': str(e)}), 500


# ==================== æ”¯ä»˜ API ====================

def epay_sign(params, key):
    """æ˜“æ”¯ä»˜ç­¾åç”Ÿæˆ"""
    # 1. è¿‡æ»¤ç©ºå€¼å’Œsignã€sign_typeå‚æ•°
    filtered = {k: v for k, v in params.items() if v and k not in ['sign', 'sign_type']}
    # 2. æŒ‰å‚æ•°åASCIIç æ’åº
    sorted_params = sorted(filtered.items(), key=lambda x: x[0])
    # 3. æ‹¼æ¥ä¸º key=value& æ ¼å¼
    sign_str = '&'.join([f'{k}={v}' for k, v in sorted_params])
    # 4. æ‹¼æ¥å•†æˆ·å¯†é’¥
    sign_str += key
    # 5. MD5åŠ å¯†
    return hashlib.md5(sign_str.encode('utf-8')).hexdigest()


def epay_verify_sign(params, key):
    """æ˜“æ”¯ä»˜ç­¾åéªŒè¯"""
    sign = params.get('sign', '')
    if not sign:
        return False
    return epay_sign(params, key) == sign


@app.route('/api/payment/create', methods=['POST'])
@login_required
def create_payment():
    """åˆ›å»ºæ”¯ä»˜ï¼ˆå¯¹æ¥æ˜“æ”¯ä»˜ï¼‰"""
    try:
        data = request.json
        order_no = data.get('order_no')
        payment_method = data.get('payment_method', 'alipay')
        
        order = Order.query.filter_by(order_no=order_no).first()
        if not order:
            return jsonify({'error': 'è®¢å•ä¸å­˜åœ¨'}), 404
        
        # éªŒè¯è®¢å•å½’å±ï¼ˆé˜²æ­¢ç”¨æˆ·æ”¯ä»˜åˆ«äººçš„è®¢å•ï¼‰
        user = db.session.get(User, session.get('user_id'))
        if not user or order.user_tg != user.tg:
            return jsonify({'error': 'æ— æƒæ“ä½œæ­¤è®¢å•'}), 403
        
        if order.payment_status == 'paid':
            return jsonify({'error': 'è®¢å•å·²æ”¯ä»˜'}), 400
        
        if order.payment_status == 'cancelled':
            return jsonify({'error': 'è®¢å•å·²å–æ¶ˆï¼Œè¯·é‡æ–°ä¸‹å•'}), 400
        
        # åŠ¨æ€è·å–æ˜“æ”¯ä»˜é…ç½®
        epay_config = get_epay_config()
        epay_url = epay_config['epay_url'].rstrip('/') if epay_config['epay_url'] else ''
        epay_pid = epay_config['epay_pid']
        epay_key = epay_config['epay_key']
        epay_notify = epay_config['epay_notify_url']
        epay_return = epay_config['epay_return_url']
        
        # æ£€æŸ¥æ˜“æ”¯ä»˜é…ç½®
        if not epay_url or not epay_pid or not epay_key:
            # å¦‚æœæœªé…ç½®æ˜“æ”¯ä»˜ï¼Œè¿”å›æµ‹è¯•æ¨¡å¼æç¤º
            return jsonify({
                'success': False,
                'error': 'æ”¯ä»˜åŠŸèƒ½æœªé…ç½®ï¼Œè¯·è”ç³»ç®¡ç†å‘˜åœ¨ç³»ç»Ÿè®¾ç½®ä¸­é…ç½®æ˜“æ”¯ä»˜å‚æ•°',
                'test_mode': True
            }), 400
        
        # æ„å»ºæ˜“æ”¯ä»˜è¯·æ±‚å‚æ•°
        # è·å–å½“å‰ç«™ç‚¹åœ°å€
        site_url = request.host_url.rstrip('/')
        notify_url = epay_notify or f'{site_url}/api/payment/notify'
        return_url = epay_return or f'{site_url}/dashboard#purchase'
        
        # æ”¯ä»˜ç±»å‹æ˜ å°„
        pay_type_map = {
            'alipay': 'alipay',
            'wxpay': 'wxpay', 
            'qqpay': 'qqpay'
        }
        pay_type = pay_type_map.get(payment_method, 'alipay')
        
        params = {
            'pid': epay_pid,
            'type': pay_type,
            'out_trade_no': order_no,
            'notify_url': notify_url,
            'return_url': return_url,
            'name': order.plan_name or f'{order.plan_type}å¥—é¤',
            'money': str(order.final_price),
            'sitename': 'Embyåª’ä½“åº“'
        }
        
        # ç”Ÿæˆç­¾å
        params['sign'] = epay_sign(params, epay_key)
        params['sign_type'] = 'MD5'
        
        # æ„å»ºæ”¯ä»˜URLï¼ˆæäº¤åˆ°æ˜“æ”¯ä»˜ç½‘å…³ï¼‰
        payment_url = f'{epay_url}/submit.php'
        
        # ä½¿ç”¨ GET æ–¹å¼è·³è½¬
        query_string = '&'.join([f'{k}={requests.utils.quote(str(v))}' for k, v in params.items()])
        redirect_url = f'{epay_url}/submit.php?{query_string}'
        
        app.logger.info(f'åˆ›å»ºæ˜“æ”¯ä»˜è®¢å•: è®¢å•={order_no}, é‡‘é¢={order.final_price}, æ–¹å¼={payment_method}')
        
        return jsonify({
            'success': True,
            'payment_url': redirect_url,
            'params': params,  # ä¹Ÿè¿”å›å‚æ•°ä¾›å‰ç«¯è¡¨å•æäº¤
            'submit_url': payment_url
        }), 200
        
    except Exception as e:
        app.logger.error(f'åˆ›å»ºæ”¯ä»˜å¤±è´¥: {e}')
        return jsonify({'error': str(e)}), 500


@app.route('/api/payment/notify', methods=['POST', 'GET'])
def payment_notify():
    """æ˜“æ”¯ä»˜å¼‚æ­¥é€šçŸ¥å›è°ƒ"""
    try:
        # æ˜“æ”¯ä»˜ä¼šåŒæ—¶å‘é€ GET å’Œ POST è¯·æ±‚
        if request.method == 'GET':
            params = request.args.to_dict()
        else:
            params = request.form.to_dict() if request.form else request.json or {}
        
        app.logger.info(f'æ”¶åˆ°æ˜“æ”¯ä»˜é€šçŸ¥: {params}')
        
        # åŠ¨æ€è·å–é…ç½®éªŒè¯ç­¾å
        epay_config = get_epay_config()
        epay_key = epay_config['epay_key']
        
        # éªŒè¯ç­¾å
        if epay_key and not epay_verify_sign(params, epay_key):
            app.logger.warning(f'æ˜“æ”¯ä»˜ç­¾åéªŒè¯å¤±è´¥: {params}')
            return 'sign error', 400
        
        # è·å–å‚æ•°
        trade_status = params.get('trade_status', '')
        out_trade_no = params.get('out_trade_no', '')  # å•†æˆ·è®¢å•å·
        trade_no = params.get('trade_no', '')  # æ˜“æ”¯ä»˜è®¢å•å·
        money = params.get('money', '')
        
        # åªå¤„ç†æ”¯ä»˜æˆåŠŸçš„é€šçŸ¥
        if trade_status != 'TRADE_SUCCESS':
            app.logger.info(f'è®¢å•çŠ¶æ€éæˆåŠŸ: {trade_status}')
            return 'success'  # è¿”å›successé¿å…é‡å¤é€šçŸ¥
        
        # æŸ¥æ‰¾è®¢å•
        order = Order.query.filter_by(order_no=out_trade_no).first()
        if not order:
            app.logger.error(f'è®¢å•ä¸å­˜åœ¨: {out_trade_no}')
            return 'order not found', 404
        
        # æ£€æŸ¥æ˜¯å¦å·²å¤„ç†
        if order.payment_status == 'paid':
            app.logger.info(f'è®¢å•å·²å¤„ç†: {out_trade_no}')
            return 'success'
        
        # å·²å–æ¶ˆçš„è®¢å•ä¸èƒ½å†è¢«æ¿€æ´»
        if order.payment_status == 'cancelled':
            app.logger.warning(f'å·²å–æ¶ˆçš„è®¢å•æ”¶åˆ°æ”¯ä»˜é€šçŸ¥ï¼Œå¿½ç•¥: {out_trade_no}')
            return 'order cancelled'
        
        # éªŒè¯é‡‘é¢ï¼ˆå¯é€‰ï¼Œä½†æ¨èï¼‰
        if money and float(money) != float(order.final_price):
            app.logger.warning(f'é‡‘é¢ä¸åŒ¹é…: è®¢å•é‡‘é¢={order.final_price}, å®ä»˜={money}')
        
        # æ›´æ–°è®¢å•çŠ¶æ€
        order.payment_status = 'paid'
        order.payment_time = datetime.now()
        order.trade_no = trade_no
        
        # åˆ›å»ºè®¢é˜…è®°å½•
        user = db.session.get(User, order.user_tg)
        if user:
            # è®¡ç®—è®¢é˜…å¼€å§‹å’Œç»“æŸæ—¶é—´ - åœ¨ç°æœ‰è®¢é˜…åŸºç¡€ä¸Šå åŠ 
            now = datetime.now()
            start_date = now
            purchased_days = order.duration_days if order.duration_days else (order.duration_months * 30)
            
            # æ£€æŸ¥è¯¥å¥—é¤æ˜¯å¦æ ‡è®°ä¸ºç™½åå•å¥—é¤
            _purchase_plan_type = order.plan_type
            _purchase_plan_name = order.plan_name
            _is_wl_purchase = False
            try:
                for _pp in load_plans_config():
                    if _pp.get('id') == order.plan_type and _pp.get('is_whitelist'):
                        _is_wl_purchase = True
                        break
            except Exception:
                pass
            
            if _is_wl_purchase:
                # ç™½åå•å¥—é¤ï¼šæ°¸ä¹…æœ‰æ•ˆ
                end_date = datetime(9999, 12, 31)
                _purchase_plan_type = 'whitelist'
                _purchase_plan_name = 'ç™½åå•ç”¨æˆ·'
            else:
                # æ™®é€šå¥—é¤ï¼šåœ¨ç°æœ‰è®¢é˜…åŸºç¡€ä¸Šå åŠ 
                if user.ex and user.ex > now:
                    end_date = user.ex + timedelta(days=purchased_days)
                else:
                    end_date = now + timedelta(days=purchased_days)
            
            subscription = Subscription(
                user_tg=user.tg,
                plan_type=_purchase_plan_type,
                plan_name=_purchase_plan_name,
                duration_months=order.duration_months,
                price=order.final_price,
                start_date=start_date,
                end_date=end_date,
                status='active',
                source='purchase'
            )
            
            db.session.add(subscription)
            
            # æ›´æ–°ç”¨æˆ·ä¿¡æ¯
            user.ex = end_date
            if _is_wl_purchase:
                user.lv = 'a'  # ç™½åå•å¥—é¤è®¾ä¸ºç™½åå•ç­‰çº§
            elif user.lv not in ['a', 'b', 'c']:  # æ™®é€šç”¨æˆ·ä¸å˜ï¼Œå°ç¦ç”¨æˆ·ä¿æŒå°ç¦çŠ¶æ€
                user.lv = 'b'
            
            # æ¢å¤Embyè´¦å·ï¼ˆå°ç¦ç”¨æˆ·å’Œé»‘åå•ç¦ç”¨ç”¨æˆ·ä¸è‡ªåŠ¨æ¢å¤ï¼‰
            if user.lv != 'c' and not user.ban_reason and user.embyid and emby_client.is_enabled():
                if emby_client.enable_user(user.embyid):
                    app.logger.info(f'ç”¨æˆ· {user.name} ç»­è´¹æˆåŠŸï¼Œå·²æ¢å¤Embyè´¦å·')
            
            # é‚€è¯·è¿”åˆ©ï¼šæ£€æŸ¥æ˜¯å¦æœ‰é‚€è¯·äººï¼Œç»™é‚€è¯·äººè¿”åˆ©
            process_invite_reward(user, purchased_days, source='æ˜“æ”¯ä»˜é€šçŸ¥')
        
        db.session.commit()
        app.logger.info(f'æ˜“æ”¯ä»˜æˆåŠŸ: è®¢å•={out_trade_no}, äº¤æ˜“å·={trade_no}, å¤©æ•°={purchased_days if user else "N/A"}')
        
        # è®°å½•æ”¯ä»˜æˆåŠŸæ—¥å¿—
        if user:
            log_user_activity(UserActivityLog.ACTION_PAYMENT_SUCCESS, user=user,
                             detail={'order_no': out_trade_no, 'trade_no': trade_no, 'amount': money,
                                    'plan_name': order.plan_name, 'duration_days': purchased_days})
        
        # è¿”å›successå‘ŠçŸ¥æ˜“æ”¯ä»˜ä¸å†é‡å¤é€šçŸ¥
        return 'success'
        
    except Exception as e:
        app.logger.error(f'æ˜“æ”¯ä»˜é€šçŸ¥å¤„ç†å¤±è´¥: {e}')
        db.session.rollback()
        return 'error', 500


@app.route('/api/payment/callback', methods=['POST'])
def payment_callback():
    """æ”¯ä»˜å›è°ƒï¼ˆå…¼å®¹æ—§æ¥å£ï¼‰- éœ€è¦éªŒè¯ç­¾å"""
    try:
        data = request.json or request.form.to_dict()
        
        # éªŒè¯ç­¾å
        epay_config = get_epay_config()
        epay_key = epay_config['epay_key']
        
        if epay_key and not epay_verify_sign(data, epay_key):
            app.logger.warning(f'æ”¯ä»˜å›è°ƒç­¾åéªŒè¯å¤±è´¥: {data}')
            return jsonify({'error': 'ç­¾åéªŒè¯å¤±è´¥'}), 403
        
        order_no = data.get('order_no') or data.get('out_trade_no')
        trade_no = data.get('trade_no')
        status = data.get('status') or data.get('trade_status')
        
        order = Order.query.filter_by(order_no=order_no).first()
        if not order:
            return jsonify({'error': 'è®¢å•ä¸å­˜åœ¨'}), 404
        
        # æ£€æŸ¥æ˜¯å¦å·²å¤„ç†
        if order.payment_status == 'paid':
            return jsonify({'success': True, 'message': 'è®¢å•å·²å¤„ç†'}), 200
        
        # å·²å–æ¶ˆçš„è®¢å•ä¸èƒ½å†è¢«æ¿€æ´»
        if order.payment_status == 'cancelled':
            app.logger.warning(f'å·²å–æ¶ˆçš„è®¢å•æ”¶åˆ°æ”¯ä»˜å›è°ƒï¼Œå¿½ç•¥: {order_no}')
            return jsonify({'error': 'è®¢å•å·²å–æ¶ˆï¼Œæ— æ³•å¤„ç†æ”¯ä»˜'}), 400
        
        if status in ('success', 'TRADE_SUCCESS'):
            order.payment_status = 'paid'
            order.payment_time = datetime.now()
            order.trade_no = trade_no
            
            # åˆ›å»ºè®¢é˜…è®°å½•
            user = db.session.get(User, order.user_tg)
            if user:
                # è®¡ç®—è®¢é˜…å¼€å§‹å’Œç»“æŸæ—¶é—´ - åœ¨ç°æœ‰è®¢é˜…åŸºç¡€ä¸Šå åŠ 
                now = datetime.now()
                start_date = now
                purchased_days = order.duration_days if order.duration_days else (order.duration_months * 30)
                
                # æ£€æŸ¥è¯¥å¥—é¤æ˜¯å¦æ ‡è®°ä¸ºç™½åå•å¥—é¤
                _cb_plan_type = order.plan_type
                _cb_plan_name = order.plan_name
                _cb_is_wl = False
                try:
                    for _pp in load_plans_config():
                        if _pp.get('id') == order.plan_type and _pp.get('is_whitelist'):
                            _cb_is_wl = True
                            break
                except Exception:
                    pass
                
                if _cb_is_wl:
                    # ç™½åå•å¥—é¤ï¼šæ°¸ä¹…æœ‰æ•ˆ
                    end_date = datetime(9999, 12, 31)
                    _cb_plan_type = 'whitelist'
                    _cb_plan_name = 'ç™½åå•ç”¨æˆ·'
                else:
                    # æ™®é€šå¥—é¤ï¼šåœ¨ç°æœ‰è®¢é˜…åŸºç¡€ä¸Šå åŠ 
                    if user.ex and user.ex > now:
                        end_date = user.ex + timedelta(days=purchased_days)
                    else:
                        end_date = now + timedelta(days=purchased_days)
                
                subscription = Subscription(
                    user_tg=user.tg,
                    plan_type=_cb_plan_type,
                    plan_name=_cb_plan_name,
                    duration_months=order.duration_months,
                    price=order.final_price,
                    start_date=start_date,
                    end_date=end_date,
                    status='active',
                    source='purchase'
                )
                
                db.session.add(subscription)
                
                # æ›´æ–°ç”¨æˆ·ä¿¡æ¯
                user.ex = end_date
                if _cb_is_wl:
                    user.lv = 'a'  # ç™½åå•å¥—é¤è®¾ä¸ºç™½åå•ç­‰çº§
                elif user.lv not in ['a', 'b', 'c']:  # æ™®é€šç”¨æˆ·ä¸å˜ï¼Œå°ç¦ç”¨æˆ·ä¿æŒå°ç¦çŠ¶æ€
                    user.lv = 'b'
                
                # é‚€è¯·è¿”åˆ©ï¼šæ£€æŸ¥æ˜¯å¦æœ‰é‚€è¯·äººï¼Œç»™é‚€è¯·äººè¿”åˆ©
                process_invite_reward(user, purchased_days, source='æ”¯ä»˜å›è°ƒ')
                
                # æ¢å¤Embyè´¦å·ï¼ˆå°ç¦ç”¨æˆ·å’Œé»‘åå•ç¦ç”¨ç”¨æˆ·ä¸è‡ªåŠ¨æ¢å¤ï¼‰
                if user.lv != 'c' and not user.ban_reason and user.embyid and emby_client.is_enabled():
                    if emby_client.enable_user(user.embyid):
                        app.logger.info(f'ç”¨æˆ· {user.name} æ”¯ä»˜æˆåŠŸï¼Œå·²æ¢å¤Embyè´¦å·')
            
            db.session.commit()
            app.logger.info(f'æ”¯ä»˜æˆåŠŸ: è®¢å•={order_no}, äº¤æ˜“å·={trade_no}')
            
        return jsonify({'success': True}), 200
        
    except Exception as e:
        app.logger.error(f'æ”¯ä»˜å›è°ƒå¤„ç†å¤±è´¥: {e}')
        db.session.rollback()
        return jsonify({'error': str(e)}), 500


@app.route('/api/payment/query', methods=['GET'])
@login_required
def query_payment():
    """æŸ¥è¯¢è®¢å•æ”¯ä»˜çŠ¶æ€"""
    try:
        order_no = request.args.get('order_no')
        if not order_no:
            return jsonify({'error': 'ç¼ºå°‘è®¢å•å·'}), 400
        
        order = Order.query.filter_by(order_no=order_no).first()
        if not order:
            return jsonify({'error': 'è®¢å•ä¸å­˜åœ¨'}), 404
        
        # å¦‚æœæœ¬åœ°çŠ¶æ€æ˜¯å·²æ”¯ä»˜ï¼Œç›´æ¥è¿”å›
        if order.payment_status == 'paid':
            # è·å–ç”¨æˆ·ä¿¡æ¯ï¼Œåˆ¤æ–­æ˜¯å¦æœ‰ Emby è´¦å·
            user = db.session.get(User, order.user_tg)
            has_emby_account = bool(user and user.embyid) if user else False
            return jsonify({
                'success': True,
                'paid': True,
                'order_no': order_no,
                'trade_no': order.trade_no,
                'has_emby_account': has_emby_account
            }), 200
        
        # å·²å–æ¶ˆçš„è®¢å•ä¸å†æŸ¥è¯¢æ”¯ä»˜çŠ¶æ€ï¼Œç›´æ¥è¿”å›æœªæ”¯ä»˜
        if order.payment_status == 'cancelled':
            return jsonify({
                'success': True,
                'paid': False,
                'order_no': order_no,
                'status': 'cancelled'
            }), 200
        
        # åªæœ‰ pending çŠ¶æ€çš„è®¢å•æ‰å»æ˜“æ”¯ä»˜æŸ¥è¯¢
        # åŠ¨æ€è·å–æ˜“æ”¯ä»˜é…ç½®
        epay_config = get_epay_config()
        epay_url = epay_config['epay_url'].rstrip('/') if epay_config['epay_url'] else ''
        epay_pid = epay_config['epay_pid']
        epay_key = epay_config['epay_key']
        
        # å¦‚æœé…ç½®äº†æ˜“æ”¯ä»˜ï¼Œå¯ä»¥ä¸»åŠ¨æŸ¥è¯¢æ˜“æ”¯ä»˜è®¢å•çŠ¶æ€
        if epay_url and epay_pid and epay_key:
            try:
                params = {
                    'act': 'order',
                    'pid': epay_pid,
                    'out_trade_no': order_no
                }
                params['sign'] = epay_sign(params, epay_key)
                params['sign_type'] = 'MD5'
                
                response = requests.get(f'{epay_url}/api.php', params=params, timeout=10)
                result = response.json()
                
                if result.get('code') == 1 and result.get('status') == 1:
                    # æ˜“æ”¯ä»˜æ˜¾ç¤ºå·²æ”¯ä»˜ï¼Œæ›´æ–°æœ¬åœ°çŠ¶æ€
                    order.payment_status = 'paid'
                    order.payment_time = datetime.now()
                    order.trade_no = result.get('trade_no', '')
                    
                    # åˆ›å»ºè®¢é˜…ï¼ˆä¸notifyç›¸åŒé€»è¾‘ï¼‰
                    user = db.session.get(User, order.user_tg)
                    if user:
                        now = datetime.now()
                        start_date = now
                        purchased_days = order.duration_days if order.duration_days else (order.duration_months * 30)
                        
                        # åœ¨ç°æœ‰è®¢é˜…åŸºç¡€ä¸Šå åŠ 
                        if user.ex and user.ex > now:
                            end_date = user.ex + timedelta(days=purchased_days)
                        else:
                            end_date = now + timedelta(days=purchased_days)
                        
                        subscription = Subscription(
                            user_tg=user.tg,
                            plan_type=order.plan_type,
                            plan_name=order.plan_name,
                            duration_months=order.duration_months,
                            price=order.final_price,
                            start_date=start_date,
                            end_date=end_date,
                            status='active',
                            source='purchase'
                        )
                        db.session.add(subscription)
                        user.ex = end_date
                        if user.lv not in ['a', 'b', 'c']:  # ç™½åå•/æ™®é€šç”¨æˆ·ä¸å˜ï¼Œå°ç¦ç”¨æˆ·ä¿æŒå°ç¦çŠ¶æ€
                            user.lv = 'b'
                        
                        # æ¢å¤Embyè´¦å·ï¼ˆå°ç¦ç”¨æˆ·å’Œé»‘åå•ç¦ç”¨ç”¨æˆ·ä¸è‡ªåŠ¨æ¢å¤ï¼‰
                        if user.lv != 'c' and not user.ban_reason and user.embyid and emby_client.is_enabled():
                            if emby_client.enable_user(user.embyid):
                                app.logger.info(f'ç”¨æˆ· {user.name} è½®è¯¢ç¡®è®¤æ”¯ä»˜æˆåŠŸï¼Œå·²æ¢å¤Embyè´¦å·')
                        
                        # é‚€è¯·è¿”åˆ©ï¼šæ£€æŸ¥æ˜¯å¦æœ‰é‚€è¯·äººï¼Œç»™é‚€è¯·äººè¿”åˆ©
                        process_invite_reward(user, purchased_days, source='è½®è¯¢ç¡®è®¤')
                    
                    db.session.commit()
                    
                    # åˆ¤æ–­ç”¨æˆ·æ˜¯å¦æœ‰ Emby è´¦å·
                    has_emby_account = bool(user and user.embyid) if user else False
                    return jsonify({
                        'success': True,
                        'paid': True,
                        'order_no': order_no,
                        'trade_no': order.trade_no,
                        'has_emby_account': has_emby_account
                    }), 200
                    
            except Exception as e:
                app.logger.warning(f'æŸ¥è¯¢æ˜“æ”¯ä»˜çŠ¶æ€å¤±è´¥: {e}')
        
        return jsonify({
            'success': True,
            'paid': False,
            'order_no': order_no,
            'status': order.payment_status
        }), 200
        
    except Exception as e:
        app.logger.error(f'æŸ¥è¯¢æ”¯ä»˜çŠ¶æ€å¤±è´¥: {e}')
        return jsonify({'error': str(e)}), 500


@app.route('/api/admin/payment-config', methods=['GET'])
@admin_required
def get_payment_config():
    """è·å–æ”¯ä»˜é…ç½®ï¼ˆç®¡ç†å‘˜ï¼‰"""
    config = get_epay_config()
    return jsonify({
        'success': True,
        'config': {
            'epay_url': config['epay_url'],
            'epay_pid': config['epay_pid'],
            'epay_key': config['epay_key'],  # è¿”å›å¯†é’¥ä¾›ç¼–è¾‘
            'epay_notify_url': config['epay_notify_url'],
            'epay_return_url': config['epay_return_url'],
            'configured': bool(config['epay_url'] and config['epay_pid'] and config['epay_key'])
        }
    }), 200


@app.route('/api/admin/payment-config', methods=['POST'])
@admin_required
def save_payment_config_api():
    """ä¿å­˜æ”¯ä»˜é…ç½®ï¼ˆç®¡ç†å‘˜ï¼‰"""
    global EPAY_URL, EPAY_PID, EPAY_KEY, EPAY_NOTIFY_URL, EPAY_RETURN_URL
    
    try:
        data = request.json
        
        config = {
            'epay_url': data.get('epay_url', '').strip().rstrip('/'),
            'epay_pid': data.get('epay_pid', '').strip(),
            'epay_key': data.get('epay_key', '').strip(),
            'epay_notify_url': data.get('epay_notify_url', '').strip(),
            'epay_return_url': data.get('epay_return_url', '').strip()
        }
        
        # ä¿å­˜åˆ°æ–‡ä»¶
        if save_epay_config(config):
            # æ›´æ–°å…¨å±€å˜é‡
            EPAY_URL = config['epay_url']
            EPAY_PID = config['epay_pid']
            EPAY_KEY = config['epay_key']
            EPAY_NOTIFY_URL = config['epay_notify_url']
            EPAY_RETURN_URL = config['epay_return_url']
            
            app.logger.info(f'æ˜“æ”¯ä»˜é…ç½®å·²æ›´æ–°: URL={EPAY_URL}, PID={EPAY_PID}')
            
            return jsonify({
                'success': True,
                'message': 'é…ç½®ä¿å­˜æˆåŠŸ'
            }), 200
        else:
            return jsonify({
                'success': False,
                'error': 'ä¿å­˜é…ç½®æ–‡ä»¶å¤±è´¥'
            }), 500
            
    except Exception as e:
        app.logger.error(f'ä¿å­˜æ”¯ä»˜é…ç½®å¤±è´¥: {e}')
        return jsonify({'error': str(e)}), 500


# ==================== å‰ç«¯é…ç½® API ====================
@app.route('/api/admin/site-config', methods=['GET'])
@admin_required
def get_site_config_api():
    """è·å–å‰ç«¯é…ç½®ï¼ˆç®¡ç†å‘˜ï¼‰- ä¸ä½¿ç”¨ç¼“å­˜ç¡®ä¿è¯»å–æœ€æ–°å€¼"""
    # æ¸…é™¤ç¼“å­˜ç¡®ä¿è¯»åˆ°æœ€æ–°å€¼
    clear_db_config_cache(CONFIG_KEY_SITE)
    config = get_site_config()
    return jsonify({
        'success': True,
        'config': config
    }), 200


@app.route('/api/admin/site-config', methods=['POST'])
@admin_required
def save_site_config_api():
    """ä¿å­˜å‰ç«¯é…ç½®ï¼ˆç®¡ç†å‘˜ï¼‰"""
    try:
        data = request.json
        
        # è·å–å½“å‰é…ç½®ä½œä¸ºåŸºç¡€
        current_config = get_site_config()
        
        # æ›´æ–°å…è®¸çš„å­—æ®µï¼ˆå­—ç¬¦ä¸²ç±»å‹ï¼‰
        allowed_fields = [
            'site_name', 'site_subtitle', 'site_title', 'site_logo', 'shop_url',
            'panel_url', 'telegram_group', 'telegram_bot_username', 'support_email', 'register_mode',
            'footer_text', 'welcome_message', 'docs_intro',
            'custom_css', 'custom_js'
        ]
        
        for field in allowed_fields:
            if field in data:
                current_config[field] = str(data[field]).strip() if data[field] else ''
        
        # å•ç‹¬å¤„ç†å¸ƒå°”ç±»å‹å­—æ®µ
        if 'use_image_proxy' in data:
            current_config['use_image_proxy'] = bool(data['use_image_proxy'])
        
        # å•ç‹¬å¤„ç† custom_linksï¼ˆåˆ—è¡¨ç±»å‹ï¼‰
        if 'custom_links' in data:
            current_config['custom_links'] = data['custom_links']
        
        # ä¿å­˜åˆ°æ–‡ä»¶
        if save_site_config(current_config):
            app.logger.info(f'å‰ç«¯é…ç½®å·²æ›´æ–°: site_name={current_config.get("site_name")}')
            
            return jsonify({
                'success': True,
                'message': 'é…ç½®ä¿å­˜æˆåŠŸï¼Œåˆ·æ–°é¡µé¢åç”Ÿæ•ˆ'
            }), 200
        else:
            return jsonify({
                'success': False,
                'error': 'ä¿å­˜é…ç½®æ–‡ä»¶å¤±è´¥'
            }), 500
            
    except Exception as e:
        app.logger.error(f'ä¿å­˜å‰ç«¯é…ç½®å¤±è´¥: {e}')
        return jsonify({'error': str(e)}), 500


# ==================== ä¸‹è½½é…ç½® API (MoviePilot & qBittorrent) ====================
@app.route('/api/admin/download-config', methods=['GET'])
@admin_required
def get_download_config_api():
    """è·å–ä¸‹è½½å·¥å…·é…ç½®ï¼ˆç®¡ç†å‘˜ï¼‰"""
    config = get_download_config()
    return jsonify({
        'success': True,
        'config': {
            'moviepilot': {
                'url': config['moviepilot']['url'],
                'username': config['moviepilot']['username'],
                'password': config['moviepilot']['password'],
                'token': config['moviepilot']['token'],
                'enabled': config['moviepilot']['enabled']
            },
            'qbittorrent': {
                'url': config['qbittorrent']['url'],
                'username': config['qbittorrent']['username'],
                'password': config['qbittorrent']['password'],
                'category': config['qbittorrent']['category'],
                'save_path': config['qbittorrent']['save_path'],
                'enabled': config['qbittorrent']['enabled']
            }
        }
    }), 200


@app.route('/api/admin/download-config', methods=['POST'])
@admin_required
def save_download_config_api():
    """ä¿å­˜ä¸‹è½½å·¥å…·é…ç½®ï¼ˆç®¡ç†å‘˜ï¼‰"""
    try:
        data = request.json
        
        # è·å–å½“å‰é…ç½®
        current_config = load_download_config()
        
        # æ›´æ–° MoviePilot é…ç½®
        if 'moviepilot' in data:
            mp = data['moviepilot']
            current_config['moviepilot']['url'] = mp.get('url', '').strip().rstrip('/')
            current_config['moviepilot']['username'] = mp.get('username', '').strip()
            current_config['moviepilot']['password'] = mp.get('password', '').strip()
            current_config['moviepilot']['token'] = mp.get('token', '').strip()
        
        # æ›´æ–° qBittorrent é…ç½®
        if 'qbittorrent' in data:
            qb = data['qbittorrent']
            current_config['qbittorrent']['url'] = qb.get('url', '').strip().rstrip('/')
            current_config['qbittorrent']['username'] = qb.get('username', '').strip()
            current_config['qbittorrent']['password'] = qb.get('password', '').strip()
            current_config['qbittorrent']['category'] = qb.get('category', 'emby-request').strip()
            current_config['qbittorrent']['save_path'] = qb.get('save_path', '').strip()
        
        # ç§»é™¤ enabled å­—æ®µï¼ˆè¿™æ˜¯è®¡ç®—å‡ºæ¥çš„ï¼Œä¸éœ€è¦ä¿å­˜ï¼‰
        save_config = {
            'moviepilot': {k: v for k, v in current_config['moviepilot'].items() if k != 'enabled'},
            'qbittorrent': {k: v for k, v in current_config['qbittorrent'].items() if k != 'enabled'}
        }
        
        # ä¿å­˜åˆ°æ–‡ä»¶
        if save_download_config(save_config):
            # æ›´æ–°å…¨å±€å˜é‡
            update_global_download_config()
            
            mp_status = 'å·²é…ç½®' if current_config["moviepilot"]["url"] else 'æœªé…ç½®'
            qb_status = 'å·²é…ç½®' if current_config["qbittorrent"]["url"] else 'æœªé…ç½®'
            app.logger.info(f'ä¸‹è½½é…ç½®å·²æ›´æ–°: MP={mp_status}, QB={qb_status}')
            
            return jsonify({
                'success': True,
                'message': 'ä¸‹è½½é…ç½®ä¿å­˜æˆåŠŸ'
            }), 200
        else:
            return jsonify({
                'success': False,
                'error': 'ä¿å­˜é…ç½®æ–‡ä»¶å¤±è´¥'
            }), 500
            
    except Exception as e:
        app.logger.error(f'ä¿å­˜ä¸‹è½½é…ç½®å¤±è´¥: {e}')
        return jsonify({'error': str(e)}), 500


@app.route('/api/admin/test-moviepilot', methods=['POST'])
@admin_required
def test_moviepilot_connection():
    """æµ‹è¯• MoviePilot è¿æ¥"""
    try:
        data = request.json
        url = data.get('url', '').strip().rstrip('/')
        username = data.get('username', '').strip()
        password = data.get('password', '').strip()
        token = data.get('token', '').strip()
        
        if not url:
            return jsonify({'success': False, 'error': 'MoviePilot URL ä¸èƒ½ä¸ºç©º'}), 400
        
        if not token and (not username or not password):
            return jsonify({'success': False, 'error': 'è¯·æä¾›ç”¨æˆ·åå¯†ç æˆ– Token'}), 400
        
        session = requests.Session()
        session.headers.update({'User-Agent': 'EmbyRequest/1.0'})
        
        # å¦‚æœæä¾›äº† tokenï¼Œç›´æ¥æµ‹è¯•
        if token:
            session.headers.update({'Authorization': f'Bearer {token}'})
            test_url = f"{url}/api/v1/user/current"
            resp = session.get(test_url, timeout=10)
            if resp.status_code == 200:
                user_data = resp.json()
                return jsonify({
                    'success': True,
                    'message': f'è¿æ¥æˆåŠŸï¼å½“å‰ç”¨æˆ·: {user_data.get("name", "æœªçŸ¥")}'
                }), 200
            else:
                return jsonify({
                    'success': False,
                    'error': f'Token æ— æ•ˆæˆ–å·²è¿‡æœŸ (çŠ¶æ€ç : {resp.status_code})'
                }), 400
        
        # ä½¿ç”¨ç”¨æˆ·åå¯†ç ç™»å½•
        login_url = f"{url}/api/v1/login/access-token"
        login_data = {'username': username, 'password': password}
        resp = session.post(login_url, data=login_data, timeout=10)
        
        if resp.status_code == 200:
            result = resp.json()
            access_token = result.get('access_token')
            if access_token:
                return jsonify({
                    'success': True,
                    'message': f'ç™»å½•æˆåŠŸï¼Token æœ‰æ•ˆæœŸå†…å¯æ­£å¸¸ä½¿ç”¨'
                }), 200
            else:
                return jsonify({
                    'success': False,
                    'error': 'ç™»å½•æˆåŠŸä½†æœªè·å–åˆ° Token'
                }), 400
        else:
            return jsonify({
                'success': False,
                'error': f'ç™»å½•å¤±è´¥ (çŠ¶æ€ç : {resp.status_code})'
            }), 400
            
    except requests.exceptions.Timeout:
        return jsonify({'success': False, 'error': 'è¿æ¥è¶…æ—¶ï¼Œè¯·æ£€æŸ¥åœ°å€'}), 400
    except requests.exceptions.ConnectionError:
        return jsonify({'success': False, 'error': 'æ— æ³•è¿æ¥åˆ°æœåŠ¡å™¨ï¼Œè¯·æ£€æŸ¥åœ°å€å’Œç½‘ç»œ'}), 400
    except Exception as e:
        app.logger.error(f'æµ‹è¯• MoviePilot è¿æ¥å¤±è´¥: {e}')
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/admin/test-qbittorrent', methods=['POST'])
@admin_required
def test_qbittorrent_connection():
    """æµ‹è¯• qBittorrent è¿æ¥"""
    try:
        data = request.json
        url = data.get('url', '').strip().rstrip('/')
        username = data.get('username', '').strip()
        password = data.get('password', '').strip()
        
        if not url:
            return jsonify({'success': False, 'error': 'qBittorrent URL ä¸èƒ½ä¸ºç©º'}), 400
        
        if not username or not password:
            return jsonify({'success': False, 'error': 'è¯·æä¾›ç”¨æˆ·åå’Œå¯†ç '}), 400
        
        session = requests.Session()
        session.headers.update({
            'User-Agent': 'EmbyRequest/1.0',
            'Referer': url
        })
        
        # å°è¯•ç™»å½•
        login_url = f"{url}/api/v2/auth/login"
        login_data = {'username': username, 'password': password}
        resp = session.post(login_url, data=login_data, timeout=10)
        
        if resp.status_code == 200:
            if resp.text == 'Ok.' or 'ok' in resp.text.lower():
                # ç™»å½•æˆåŠŸï¼Œè·å–ç‰ˆæœ¬ä¿¡æ¯
                try:
                    version_resp = session.get(f"{url}/api/v2/app/version", timeout=5)
                    version = version_resp.text if version_resp.status_code == 200 else 'æœªçŸ¥'
                except:
                    version = 'æœªçŸ¥'
                
                return jsonify({
                    'success': True,
                    'message': f'è¿æ¥æˆåŠŸï¼qBittorrent ç‰ˆæœ¬: {version}'
                }), 200
            else:
                return jsonify({
                    'success': False,
                    'error': 'ç™»å½•å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç”¨æˆ·åå’Œå¯†ç '
                }), 400
        elif resp.status_code == 403:
            return jsonify({
                'success': False,
                'error': 'ç™»å½•è¢«æ‹’ç»ï¼Œå¯èƒ½ IP è¢«æš‚æ—¶å°ç¦æˆ–ç”¨æˆ·åå¯†ç é”™è¯¯'
            }), 400
        else:
            return jsonify({
                'success': False,
                'error': f'ç™»å½•å¤±è´¥ (çŠ¶æ€ç : {resp.status_code})'
            }), 400
            
    except requests.exceptions.Timeout:
        return jsonify({'success': False, 'error': 'è¿æ¥è¶…æ—¶ï¼Œè¯·æ£€æŸ¥åœ°å€'}), 400
    except requests.exceptions.ConnectionError:
        return jsonify({'success': False, 'error': 'æ— æ³•è¿æ¥åˆ°æœåŠ¡å™¨ï¼Œè¯·æ£€æŸ¥åœ°å€å’Œç½‘ç»œ'}), 400
    except Exception as e:
        app.logger.error(f'æµ‹è¯• qBittorrent è¿æ¥å¤±è´¥: {e}')
        return jsonify({'success': False, 'error': str(e)}), 500


# ==================== æ•°æ®åº“é…ç½®ç®¡ç† API ====================
@app.route('/api/admin/db-config', methods=['GET'])
@admin_required
def get_db_config_status():
    """è·å–æ•°æ®åº“é…ç½®å­˜å‚¨çŠ¶æ€"""
    try:
        # æ£€æŸ¥æ•°æ®åº“ä¸­çš„æ‰€æœ‰é…ç½®
        all_configs = get_all_db_configs()
        
        config_status = {
            'admin': {
                'in_db': CONFIG_KEY_ADMIN in all_configs,
                'has_data': bool(all_configs.get(CONFIG_KEY_ADMIN))
            },
            'emby': {
                'in_db': CONFIG_KEY_EMBY in all_configs,
                'has_data': bool(all_configs.get(CONFIG_KEY_EMBY))
            },
            'telegram': {
                'in_db': CONFIG_KEY_TELEGRAM in all_configs,
                'has_data': bool(all_configs.get(CONFIG_KEY_TELEGRAM))
            },
            'tmdb': {
                'in_db': CONFIG_KEY_TMDB in all_configs,
                'has_data': bool(all_configs.get(CONFIG_KEY_TMDB))
            },
            'moviepilot': {
                'in_db': CONFIG_KEY_MOVIEPILOT in all_configs,
                'has_data': bool(all_configs.get(CONFIG_KEY_MOVIEPILOT))
            },
            'qbittorrent': {
                'in_db': CONFIG_KEY_QBITTORRENT in all_configs,
                'has_data': bool(all_configs.get(CONFIG_KEY_QBITTORRENT))
            },
            'epay': {
                'in_db': CONFIG_KEY_EPAY in all_configs,
                'has_data': bool(all_configs.get(CONFIG_KEY_EPAY))
            },
            'site': {
                'in_db': CONFIG_KEY_SITE in all_configs,
                'has_data': bool(all_configs.get(CONFIG_KEY_SITE))
            },
            'plans': {
                'in_db': CONFIG_KEY_PLANS in all_configs,
                'has_data': bool(all_configs.get(CONFIG_KEY_PLANS))
            },
            'search': {
                'in_db': CONFIG_KEY_SEARCH in all_configs,
                'has_data': bool(all_configs.get(CONFIG_KEY_SEARCH))
            },
            'request_limit': {
                'in_db': CONFIG_KEY_REQUEST_LIMIT in all_configs,
                'has_data': bool(all_configs.get(CONFIG_KEY_REQUEST_LIMIT))
            },
            'category': {
                'in_db': CONFIG_KEY_CATEGORY in all_configs,
                'has_data': bool(all_configs.get(CONFIG_KEY_CATEGORY))
            }
        }
        
        # ç»Ÿè®¡
        total = len(config_status)
        in_db_count = sum(1 for v in config_status.values() if v['in_db'])
        
        return jsonify({
            'success': True,
            'status': config_status,
            'summary': {
                'total': total,
                'in_database': in_db_count,
                'pending_migration': total - in_db_count
            }
        }), 200
    except Exception as e:
        app.logger.error(f'è·å–æ•°æ®åº“é…ç½®çŠ¶æ€å¤±è´¥: {e}')
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/admin/db-config/migrate', methods=['POST'])
@admin_required
def migrate_config_to_db():
    """å°†æ–‡ä»¶é…ç½®è¿ç§»åˆ°æ•°æ®åº“"""
    try:
        migrated = []
        errors = []
        
        # 1. è¿ç§»ç³»ç»Ÿé…ç½®ï¼ˆadmin, emby, telegram, search, tmdb, request_limit, categoryï¼‰
        try:
            file_config = load_system_config_from_file()
            if file_config.get('admin'):
                set_db_config(CONFIG_KEY_ADMIN, file_config['admin'], 'ç®¡ç†å‘˜é…ç½®')
                migrated.append('admin')
            if file_config.get('emby'):
                set_db_config(CONFIG_KEY_EMBY, file_config['emby'], 'Emby æœåŠ¡å™¨é…ç½®')
                migrated.append('emby')
            if file_config.get('telegram'):
                set_db_config(CONFIG_KEY_TELEGRAM, file_config['telegram'], 'Telegram BOTé…ç½®')
                migrated.append('telegram')
            if file_config.get('search'):
                set_db_config(CONFIG_KEY_SEARCH, file_config['search'], 'æœç´¢ç­–ç•¥é…ç½®')
                migrated.append('search')
            if file_config.get('tmdb'):
                set_db_config(CONFIG_KEY_TMDB, file_config['tmdb'], 'TMDB API é…ç½®')
                migrated.append('tmdb')
            if file_config.get('request_limit'):
                set_db_config(CONFIG_KEY_REQUEST_LIMIT, file_config['request_limit'], 'æ±‚ç‰‡é™åˆ¶é…ç½®')
                migrated.append('request_limit')
            if file_config.get('category'):
                set_db_config(CONFIG_KEY_CATEGORY, file_config['category'], 'äºŒçº§åˆ†ç±»ç­–ç•¥')
                migrated.append('category')
        except Exception as e:
            errors.append(f'ç³»ç»Ÿé…ç½®è¿ç§»å¤±è´¥: {e}')
        
        # 2. è¿ç§»ä¸‹è½½é…ç½®ï¼ˆmoviepilot, qbittorrentï¼‰
        try:
            if os.path.exists(DOWNLOAD_CONFIG_FILE):
                with open(DOWNLOAD_CONFIG_FILE, 'r', encoding='utf-8') as f:
                    dl_config = json.load(f)
                    if dl_config.get('moviepilot'):
                        set_db_config(CONFIG_KEY_MOVIEPILOT, dl_config['moviepilot'], 'MoviePilot é…ç½®')
                        migrated.append('moviepilot')
                    if dl_config.get('qbittorrent'):
                        set_db_config(CONFIG_KEY_QBITTORRENT, dl_config['qbittorrent'], 'qBittorrent é…ç½®')
                        migrated.append('qbittorrent')
        except Exception as e:
            errors.append(f'ä¸‹è½½é…ç½®è¿ç§»å¤±è´¥: {e}')
        
        # 3. è¿ç§»æ˜“æ”¯ä»˜é…ç½®
        try:
            if os.path.exists(EPAY_CONFIG_FILE):
                with open(EPAY_CONFIG_FILE, 'r', encoding='utf-8') as f:
                    epay_config = json.load(f)
                    if epay_config:
                        set_db_config(CONFIG_KEY_EPAY, epay_config, 'æ˜“æ”¯ä»˜é…ç½®')
                        migrated.append('epay')
        except Exception as e:
            errors.append(f'æ˜“æ”¯ä»˜é…ç½®è¿ç§»å¤±è´¥: {e}')
        
        # 4. è¿ç§»å‰ç«¯é…ç½®
        try:
            if os.path.exists(SITE_CONFIG_FILE):
                with open(SITE_CONFIG_FILE, 'r', encoding='utf-8') as f:
                    site_config = json.load(f)
                    if site_config:
                        set_db_config(CONFIG_KEY_SITE, site_config, 'å‰ç«¯ç«™ç‚¹é…ç½®')
                        migrated.append('site')
        except Exception as e:
            errors.append(f'å‰ç«¯é…ç½®è¿ç§»å¤±è´¥: {e}')
        
        # 5. è¿ç§»å¥—é¤é…ç½®
        try:
            if os.path.exists(PLANS_CONFIG_FILE):
                with open(PLANS_CONFIG_FILE, 'r', encoding='utf-8') as f:
                    plans_config = json.load(f)
                    if plans_config:
                        set_db_config(CONFIG_KEY_PLANS, plans_config, 'å¥—é¤é…ç½®')
                        migrated.append('plans')
        except Exception as e:
            errors.append(f'å¥—é¤é…ç½®è¿ç§»å¤±è´¥: {e}')
        
        # æ¸…é™¤é…ç½®ç¼“å­˜
        clear_db_config_cache()
        
        return jsonify({
            'success': True,
            'message': f'é…ç½®è¿ç§»å®Œæˆï¼ŒæˆåŠŸè¿ç§» {len(migrated)} é¡¹',
            'migrated': migrated,
            'errors': errors
        }), 200
    except Exception as e:
        app.logger.error(f'é…ç½®è¿ç§»å¤±è´¥: {e}')
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/admin/db-config/<config_key>', methods=['GET'])
@admin_required
def get_single_db_config(config_key):
    """è·å–å•ä¸ªé…ç½®é¡¹è¯¦æƒ…"""
    try:
        config = get_db_config(config_key, use_cache=False)
        if config is None:
            return jsonify({'success': False, 'error': 'é…ç½®ä¸å­˜åœ¨'}), 404
        
        # æ•æ„Ÿä¿¡æ¯è„±æ•
        if config_key in ['admin', 'epay', 'moviepilot', 'qbittorrent']:
            if isinstance(config, dict):
                config = config.copy()
                for key in ['password', 'api_key', 'key', 'epay_key', 'token', 'secret']:
                    if key in config and config[key]:
                        config[key] = '******'
        
        return jsonify({
            'success': True,
            'key': config_key,
            'config': config
        }), 200
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/admin/db-config/<config_key>', methods=['DELETE'])
@admin_required
def delete_single_db_config(config_key):
    """åˆ é™¤å•ä¸ªé…ç½®é¡¹ï¼ˆä»æ•°æ®åº“ï¼‰"""
    try:
        if config_key == 'admin':
            return jsonify({'success': False, 'error': 'ä¸èƒ½åˆ é™¤ç®¡ç†å‘˜é…ç½®'}), 400
        
        result = delete_db_config(config_key)
        
        return jsonify({
            'success': result,
            'message': f'é…ç½® {config_key} å·²ä»æ•°æ®åº“åˆ é™¤' if result else 'åˆ é™¤å¤±è´¥'
        }), 200 if result else 500
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/admin/db-config/clear-cache', methods=['POST'])
@admin_required
def clear_config_cache():
    """æ¸…é™¤é…ç½®ç¼“å­˜"""
    try:
        clear_db_config_cache()
        return jsonify({
            'success': True,
            'message': 'é…ç½®ç¼“å­˜å·²æ¸…é™¤'
        }), 200
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500


# ==================== ç³»ç»Ÿé…ç½® API (Embyã€Telegramç­‰) ====================
@app.route('/api/admin/system-config', methods=['GET'])
@admin_required
def get_system_config_api():
    """è·å–ç³»ç»Ÿé…ç½®ï¼ˆç®¡ç†å‘˜ï¼‰- ä¸ä½¿ç”¨ç¼“å­˜ç¡®ä¿è¯»å–æœ€æ–°å€¼"""
    config = load_system_config(use_cache=False)
    templates = config['telegram'].get('templates', {'request': '', 'completion': ''})
    return jsonify({
        'success': True,
        'config': {
            'emby': {
                'url': config['emby']['url'],
                'api_key': config['emby']['api_key'],
                'webhook_secret': config['emby']['webhook_secret'],
                'configured': bool(config['emby']['url'] and config['emby']['api_key'])
            },
            'telegram': {
                'bot_token': config['telegram']['bot_token'],
                'chat_id': config['telegram']['chat_id'],
                'group_id': config['telegram']['group_id'],
                'gift_days': config['telegram'].get('gift_days', 30),
                'max_streams': config['telegram'].get('max_streams', 0),
                'bot_admins': config['telegram'].get('bot_admins', ''),
                'bot_photo': config['telegram'].get('bot_photo', ''),
                'require_bindtg': config['telegram'].get('require_bindtg', False),
                'templates': templates,
                'request_notification': config['telegram'].get('request_notification', {
                    'enabled': True,
                    'send_to': 'group',
                    'mention_admin': True,
                    'show_overview': True,
                    'show_poster': True,
                    'custom_message': ''
                }),
                'library_notification': config['telegram'].get('library_notification', {
                    'enabled': False,
                    'chat_id': '',
                    'show_poster': True,
                    'template': {
                        'title': 'ğŸ“œ {title_year}{% if season_episode %}ä¹‹{season_episode}{% endif %}å·²å…¥ç¿°æ—çè—é˜ï¼',
                        'text': ''
                    }
                }),
                'configured': bool(config['telegram']['bot_token'] and config['telegram']['chat_id'])
            },
            'search': {
                'strategy': config['search']['strategy'],
                'poll_interval': config['search']['poll_interval']
            },
            'tmdb': {
                'api_key': config['tmdb']['api_key'],
                'configured': bool(config['tmdb']['api_key'])
            },
            'request_limit': {
                'max_daily': config['request_limit']['max_daily'],
                'level_a': config['request_limit'].get('level_a', 3),
                'level_b': config['request_limit'].get('level_b', 1),
                'level_c': config['request_limit'].get('level_c', 0),
                'level_d': config['request_limit'].get('level_d', 0)
            },
            'checkin': {
                'enabled': config.get('checkin', {}).get('enabled', False),
                'bot_enabled': config.get('checkin', {}).get('bot_enabled', False),
                'checkin_permission': config.get('checkin', {}).get('checkin_permission', 'all'),
                'coin_name': config.get('checkin', {}).get('coin_name', 'ç§¯åˆ†'),
                'coin_min': config.get('checkin', {}).get('coin_min', 1),
                'coin_max': config.get('checkin', {}).get('coin_max', 10),
                'exchange_plans': config.get('checkin', {}).get('exchange_plans', [])
            },
            'subscription_expire': {
                'auto_disable': config.get('subscription_expire', {}).get('auto_disable', True),
                'delete_days': config.get('subscription_expire', {}).get('delete_days', 0),
                'delete_web_account': config.get('subscription_expire', {}).get('delete_web_account', False),
                'retention_mode': config.get('subscription_expire', {}).get('retention_mode', 'off'),
                'retention_checkin_days': config.get('subscription_expire', {}).get('retention_checkin_days', 20),
                'retention_checkin_cost': config.get('subscription_expire', {}).get('retention_checkin_cost', 10),
                'retention_watch_days': config.get('subscription_expire', {}).get('retention_watch_days', 30),
                'retention_watch_minutes': config.get('subscription_expire', {}).get('retention_watch_minutes', 30),
                'retention_renew_days': config.get('subscription_expire', {}).get('retention_renew_days', 30),
            },
            'invite_reward': {
                'enabled': config.get('invite_reward', {}).get('enabled', True),
                'reward_percent': config.get('invite_reward', {}).get('reward_percent', 10),
                'min_reward_days': config.get('invite_reward', {}).get('min_reward_days', 1),
                'reward_mode': config.get('invite_reward', {}).get('reward_mode', 'recurring')
            },
            'email': {
                'enabled': config.get('email', {}).get('enabled', False),
                'smtp_host': config.get('email', {}).get('smtp_host', ''),
                'smtp_port': config.get('email', {}).get('smtp_port', 465),
                'smtp_ssl': config.get('email', {}).get('smtp_ssl', True),
                'smtp_user': config.get('email', {}).get('smtp_user', ''),
                'smtp_password': config.get('email', {}).get('smtp_password', ''),
                'sender_name': config.get('email', {}).get('sender_name', 'Embyç®¡ç†ç³»ç»Ÿ'),
                'require_email_register': config.get('email', {}).get('require_email_register', False)
            },
            'login_notify': {
                'enabled': config.get('login_notify', {}).get('enabled', False),
                'email': config.get('login_notify', {}).get('email', True),
                'telegram': config.get('login_notify', {}).get('telegram', True),
            },
            'expire_remind': {
                'enabled': config.get('expire_remind', {}).get('enabled', False),
                'days': config.get('expire_remind', {}).get('days', [3, 7]),
                'email': config.get('expire_remind', {}).get('email', True),
                'telegram': config.get('expire_remind', {}).get('telegram', True),
            },
            'ranking': {
                'enabled': config.get('ranking', {}).get('enabled', False),
                'movie_limit': config.get('ranking', {}).get('movie_limit', 10),
                'episode_limit': config.get('ranking', {}).get('episode_limit', 10),
                'user_limit': config.get('ranking', {}).get('user_limit', 10),
                'exclude_users': config.get('ranking', {}).get('exclude_users', ''),
                'push_enabled': config.get('ranking', {}).get('push_enabled', False),
                'push_chat_id': config.get('ranking', {}).get('push_chat_id', ''),
                'push_daily_time': config.get('ranking', {}).get('push_daily_time', '21:00'),
                'push_weekly_day': config.get('ranking', {}).get('push_weekly_day', 0),
                'push_weekly_time': config.get('ranking', {}).get('push_weekly_time', '21:00'),
                'push_daily': config.get('ranking', {}).get('push_daily', True),
                'push_weekly': config.get('ranking', {}).get('push_weekly', True),
            }
        }
    }), 200


@app.route('/api/admin/system-config', methods=['POST'])
@admin_required
def save_system_config_api():
    """ä¿å­˜ç³»ç»Ÿé…ç½®ï¼ˆç®¡ç†å‘˜ï¼‰"""
    try:
        data = request.json
        _pending_stream_sync = None  # æ ‡è®°æ˜¯å¦éœ€è¦åŒæ­¥æ’­æ”¾æµæ•°é™åˆ¶
        
        # è·å–å½“å‰é…ç½®
        current_config = load_system_config()
        
        # æ›´æ–° Emby é…ç½®
        if 'emby' in data:
            emby = data['emby']
            if 'url' in emby:
                current_config['emby']['url'] = emby['url'].strip().rstrip('/')
            if 'api_key' in emby:
                current_config['emby']['api_key'] = emby['api_key'].strip()
            if 'webhook_secret' in emby:
                current_config['emby']['webhook_secret'] = emby['webhook_secret'].strip()
        
        # æ›´æ–° Telegram é…ç½®
        _old_bot_token = current_config.get('telegram', {}).get('bot_token', '')  # è®°å½•æ—§ Tokenï¼Œç”¨äºåˆ‡æ¢æ—¶æ¸…ç† Webhook
        if 'telegram' in data:
            tg = data['telegram']
            if 'bot_token' in tg:
                new_token = tg['bot_token'].strip()
                # â˜… æ£€æµ‹ Bot Token å˜æ›´ï¼šæ¸…é™¤æ—§ Bot Webhook + ä¸ºæ–° Bot è®¾ç½® Webhook
                if _old_bot_token and new_token and _old_bot_token != new_token:
                    _configured_url = current_config.get('telegram', {}).get('configured_url', '') or TELEGRAM_CONFIGURED_URL
                    def _migrate_bot_webhook(old_token, new_tkn, cfg_url):
                        # 1) åˆ é™¤æ—§ Bot çš„ Webhookï¼Œé˜²æ­¢æ—§ Bot ç»§ç»­æ”¶åˆ°æ¶ˆæ¯
                        try:
                            del_url = f"https://api.telegram.org/bot{old_token}/deleteWebhook"
                            resp = PROXY_SESSION.post(del_url, json={'drop_pending_updates': True}, timeout=10)
                            result = resp.json()
                            app.logger.info(f'[Telegram] å·²æ¸…é™¤æ—§ Bot Webhook: {result}')
                        except Exception as e:
                            app.logger.warning(f'[Telegram] æ¸…é™¤æ—§ Bot Webhook å¤±è´¥ï¼ˆå¯å¿½ç•¥ï¼‰: {e}')
                        # 2) ä¸ºæ–° Bot è®¾ç½® Webhook + secret_tokenï¼ˆä½¿ç”¨å·²ä¿å­˜çš„ configured_urlï¼‰
                        if cfg_url:
                            try:
                                import secrets as _secrets
                                new_secret = _secrets.token_hex(32)
                                webhook_url = cfg_url.rstrip('/') + '/api/webhook/telegram'
                                set_url = f"https://api.telegram.org/bot{new_tkn}/setWebhook"
                                payload = {
                                    'url': webhook_url,
                                    'allowed_updates': ['message', 'callback_query', 'chat_member'],
                                    'drop_pending_updates': True,
                                    'secret_token': new_secret
                                }
                                resp2 = PROXY_SESSION.post(set_url, json=payload, timeout=10)
                                result2 = resp2.json()
                                app.logger.info(f'[Telegram] å·²ä¸ºæ–° Bot è®¾ç½® Webhook: {result2}')
                                # ä¿å­˜æ–°çš„ secret_token
                                if result2.get('ok'):
                                    global _TELEGRAM_WEBHOOK_SECRET
                                    _TELEGRAM_WEBHOOK_SECRET = new_secret
                                    with app.app_context():
                                        try:
                                            sys_cfg = load_system_config()
                                            sys_cfg['telegram']['webhook_secret_token'] = new_secret
                                            save_system_config(sys_cfg)
                                            app.logger.info('[Telegram] æ–° Bot çš„ webhook_secret_token å·²ä¿å­˜')
                                        except Exception as se:
                                            app.logger.warning(f'[Telegram] ä¿å­˜ webhook_secret_token å¤±è´¥: {se}')
                            except Exception as e:
                                app.logger.warning(f'[Telegram] ä¸ºæ–° Bot è®¾ç½® Webhook å¤±è´¥: {e}')
                        else:
                            app.logger.info('[Telegram] æ—  configured_urlï¼Œè·³è¿‡æ–° Bot Webhook è®¾ç½®ï¼ˆéœ€æ‰‹åŠ¨è®¾ç½®ï¼‰')
                    # åå°çº¿ç¨‹æ‰§è¡Œï¼Œä¸é˜»å¡é…ç½®ä¿å­˜
                    Thread(target=_migrate_bot_webhook, args=(_old_bot_token, new_token, _configured_url), daemon=True).start()
                current_config['telegram']['bot_token'] = new_token
            if 'chat_id' in tg:
                current_config['telegram']['chat_id'] = tg['chat_id'].strip()
            if 'group_id' in tg:
                current_config['telegram']['group_id'] = tg['group_id'].strip()
            if 'gift_days' in tg:
                current_config['telegram']['gift_days'] = int(tg['gift_days'])
            if 'max_streams' in tg:
                new_max_streams = int(tg['max_streams'])
                old_max_streams = current_config['telegram'].get('max_streams', 0)
                current_config['telegram']['max_streams'] = new_max_streams
                # æ ‡è®°éœ€è¦åŒæ­¥ï¼ˆä¿å­˜æˆåŠŸåæ‰§è¡Œï¼‰
                if new_max_streams != old_max_streams:
                    _pending_stream_sync = {'old': old_max_streams, 'new': new_max_streams}
            if 'bot_admins' in tg:
                current_config['telegram']['bot_admins'] = tg['bot_admins'].strip()
            # æ›´æ–°æ¬¢è¿å›¾ç‰‡ URL
            if 'bot_photo' in tg:
                current_config['telegram']['bot_photo'] = tg['bot_photo'].strip()
            # æ›´æ–°å¼ºåˆ¶ç»‘å®š Telegram å¼€å…³
            if 'require_bindtg' in tg:
                current_config['telegram']['require_bindtg'] = bool(tg['require_bindtg'])
            # æ›´æ–°é€šçŸ¥æ¨¡æ¿é…ç½®
            if 'templates' in tg:
                if 'templates' not in current_config['telegram']:
                    current_config['telegram']['templates'] = {'request': '', 'completion': ''}
                if 'request' in tg['templates']:
                    current_config['telegram']['templates']['request'] = tg['templates']['request']
                if 'completion' in tg['templates']:
                    current_config['telegram']['templates']['completion'] = tg['templates']['completion']
            # æ›´æ–°æ±‚ç‰‡é€šçŸ¥é…ç½®
            if 'request_notification' in tg:
                if 'request_notification' not in current_config['telegram']:
                    current_config['telegram']['request_notification'] = {}
                current_config['telegram']['request_notification'].update(tg['request_notification'])
            # æ›´æ–°é€šç”¨å…¥åº“é€šçŸ¥é…ç½®
            if 'library_notification' in tg:
                if 'library_notification' not in current_config['telegram']:
                    current_config['telegram']['library_notification'] = {}
                current_config['telegram']['library_notification'].update(tg['library_notification'])
        
        # æ›´æ–°æœç´¢é…ç½®
        if 'search' in data:
            search = data['search']
            if 'strategy' in search:
                current_config['search']['strategy'] = search['strategy'].strip()
            if 'poll_interval' in search:
                current_config['search']['poll_interval'] = int(search['poll_interval'])
        
        # æ›´æ–° TMDB é…ç½®
        if 'tmdb' in data:
            tmdb = data['tmdb']
            if 'api_key' in tmdb:
                current_config['tmdb']['api_key'] = tmdb['api_key'].strip()
        
        # æ›´æ–°æ±‚ç‰‡é™åˆ¶é…ç½®
        if 'request_limit' in data:
            limit = data['request_limit']
            if 'max_daily' in limit:
                current_config['request_limit']['max_daily'] = int(limit['max_daily'])
            if 'level_a' in limit:
                current_config['request_limit']['level_a'] = int(limit['level_a'])
            if 'level_b' in limit:
                current_config['request_limit']['level_b'] = int(limit['level_b'])
            if 'level_c' in limit:
                current_config['request_limit']['level_c'] = int(limit['level_c'])
            if 'level_d' in limit:
                current_config['request_limit']['level_d'] = int(limit['level_d'])
        
        # æ›´æ–°ç­¾åˆ°é…ç½®
        if 'checkin' in data:
            checkin = data['checkin']
            if 'checkin' not in current_config:
                current_config['checkin'] = {}
            if 'enabled' in checkin:
                current_config['checkin']['enabled'] = bool(checkin['enabled'])
            if 'bot_enabled' in checkin:
                current_config['checkin']['bot_enabled'] = bool(checkin['bot_enabled'])
            if 'checkin_permission' in checkin:
                perm_val = checkin['checkin_permission']
                if perm_val in ('all', 'subscribed', 'none'):
                    current_config['checkin']['checkin_permission'] = perm_val
            if 'coin_name' in checkin:
                current_config['checkin']['coin_name'] = checkin['coin_name'].strip()
            if 'coin_min' in checkin:
                current_config['checkin']['coin_min'] = int(checkin['coin_min'])
            if 'coin_max' in checkin:
                current_config['checkin']['coin_max'] = int(checkin['coin_max'])
            if 'exchange_plans' in checkin:
                current_config['checkin']['exchange_plans'] = checkin['exchange_plans']
        
        # æ›´æ–°è®¢é˜…è¿‡æœŸé…ç½®
        if 'subscription_expire' in data:
            expire = data['subscription_expire']
            if 'subscription_expire' not in current_config:
                current_config['subscription_expire'] = {}
            if 'auto_disable' in expire:
                current_config['subscription_expire']['auto_disable'] = bool(expire['auto_disable'])
            if 'delete_days' in expire:
                current_config['subscription_expire']['delete_days'] = int(expire['delete_days'])
            if 'delete_web_account' in expire:
                current_config['subscription_expire']['delete_web_account'] = bool(expire['delete_web_account'])
            if 'retention_mode' in expire:
                mode = expire['retention_mode']
                if mode in ('off', 'checkin', 'watch', 'both'):
                    current_config['subscription_expire']['retention_mode'] = mode
            if 'retention_checkin_days' in expire:
                current_config['subscription_expire']['retention_checkin_days'] = max(1, min(31, int(expire['retention_checkin_days'])))
            if 'retention_checkin_cost' in expire:
                current_config['subscription_expire']['retention_checkin_cost'] = max(0, int(expire['retention_checkin_cost']))
            if 'retention_watch_days' in expire:
                current_config['subscription_expire']['retention_watch_days'] = max(1, min(365, int(expire['retention_watch_days'])))
            if 'retention_watch_minutes' in expire:
                current_config['subscription_expire']['retention_watch_minutes'] = max(1, int(expire['retention_watch_minutes']))
            if 'retention_renew_days' in expire:
                current_config['subscription_expire']['retention_renew_days'] = max(1, min(365, int(expire['retention_renew_days'])))
        
        # æ›´æ–°é‚€è¯·è¿”åˆ©é…ç½®
        if 'invite_reward' in data:
            invite_rw = data['invite_reward']
            if 'invite_reward' not in current_config:
                current_config['invite_reward'] = {}
            if 'enabled' in invite_rw:
                current_config['invite_reward']['enabled'] = bool(invite_rw['enabled'])
            if 'reward_percent' in invite_rw:
                pct = float(invite_rw['reward_percent'])
                current_config['invite_reward']['reward_percent'] = max(0, min(100, pct))
            if 'min_reward_days' in invite_rw:
                current_config['invite_reward']['min_reward_days'] = max(0, int(invite_rw['min_reward_days']))
            if 'reward_mode' in invite_rw:
                mode = invite_rw['reward_mode']
                if mode in ('once', 'recurring'):
                    current_config['invite_reward']['reward_mode'] = mode
        
        # æ›´æ–°é‚®ä»¶é…ç½®
        if 'email' in data:
            email_data = data['email']
            if 'email' not in current_config:
                current_config['email'] = {}
            if 'enabled' in email_data:
                current_config['email']['enabled'] = bool(email_data['enabled'])
            if 'smtp_host' in email_data:
                current_config['email']['smtp_host'] = email_data['smtp_host'].strip()
            if 'smtp_port' in email_data:
                current_config['email']['smtp_port'] = int(email_data['smtp_port'])
            if 'smtp_ssl' in email_data:
                current_config['email']['smtp_ssl'] = bool(email_data['smtp_ssl'])
            if 'smtp_user' in email_data:
                current_config['email']['smtp_user'] = email_data['smtp_user'].strip()
            if 'smtp_password' in email_data:
                current_config['email']['smtp_password'] = email_data['smtp_password'].strip()
            if 'sender_name' in email_data:
                current_config['email']['sender_name'] = email_data['sender_name'].strip()
            if 'require_email_register' in email_data:
                current_config['email']['require_email_register'] = bool(email_data['require_email_register'])
        
        # æ›´æ–°ç™»å½•é€šçŸ¥é…ç½®
        if 'login_notify' in data:
            ln = data['login_notify']
            if 'login_notify' not in current_config:
                current_config['login_notify'] = {}
            if 'enabled' in ln:
                current_config['login_notify']['enabled'] = bool(ln['enabled'])
            if 'email' in ln:
                current_config['login_notify']['email'] = bool(ln['email'])
            if 'telegram' in ln:
                current_config['login_notify']['telegram'] = bool(ln['telegram'])
            app.logger.info(f'[CONFIG] æ›´æ–° login_notify: {current_config["login_notify"]}')
        
        # æ›´æ–°åˆ°æœŸæé†’é…ç½®
        if 'expire_remind' in data:
            er = data['expire_remind']
            if 'expire_remind' not in current_config:
                current_config['expire_remind'] = {}
            if 'enabled' in er:
                current_config['expire_remind']['enabled'] = bool(er['enabled'])
            if 'days' in er:
                # æ¥æ”¶å¤©æ•°åˆ—è¡¨ï¼Œè¿‡æ»¤æ— æ•ˆå€¼
                days_list = [int(d) for d in er['days'] if isinstance(d, (int, float)) and 0 < int(d) <= 365]
                current_config['expire_remind']['days'] = sorted(set(days_list)) if days_list else [3, 7]
            if 'email' in er:
                current_config['expire_remind']['email'] = bool(er['email'])
            if 'telegram' in er:
                current_config['expire_remind']['telegram'] = bool(er['telegram'])
            app.logger.info(f'[CONFIG] æ›´æ–° expire_remind: {current_config["expire_remind"]}')
        
        # æ›´æ–°æ’­æ”¾æ’è¡Œé…ç½®
        if 'ranking' in data:
            rk = data['ranking']
            if 'ranking' not in current_config:
                current_config['ranking'] = {}
            if 'enabled' in rk:
                current_config['ranking']['enabled'] = bool(rk['enabled'])
            if 'movie_limit' in rk:
                current_config['ranking']['movie_limit'] = max(1, min(50, int(rk['movie_limit'])))
            if 'episode_limit' in rk:
                current_config['ranking']['episode_limit'] = max(1, min(50, int(rk['episode_limit'])))
            if 'user_limit' in rk:
                current_config['ranking']['user_limit'] = max(1, min(100, int(rk['user_limit'])))
            if 'exclude_users' in rk:
                current_config['ranking']['exclude_users'] = str(rk['exclude_users']).strip()
            if 'push_enabled' in rk:
                current_config['ranking']['push_enabled'] = bool(rk['push_enabled'])
            if 'push_chat_id' in rk:
                current_config['ranking']['push_chat_id'] = str(rk['push_chat_id']).strip()
            if 'push_daily_time' in rk:
                current_config['ranking']['push_daily_time'] = str(rk['push_daily_time']).strip()
            if 'push_weekly_day' in rk:
                current_config['ranking']['push_weekly_day'] = max(0, min(6, int(rk['push_weekly_day'])))
            if 'push_weekly_time' in rk:
                current_config['ranking']['push_weekly_time'] = str(rk['push_weekly_time']).strip()
            if 'push_daily' in rk:
                current_config['ranking']['push_daily'] = bool(rk['push_daily'])
            if 'push_weekly' in rk:
                current_config['ranking']['push_weekly'] = bool(rk['push_weekly'])
            app.logger.info(f'[CONFIG] æ›´æ–° ranking: {current_config["ranking"]}')
        
        # ä¿å­˜åˆ°æ–‡ä»¶ï¼ˆå¿…é¡»åœ¨é‡å¯è°ƒåº¦å™¨ä¹‹å‰ï¼Œç¡®ä¿DBä¸­æ˜¯æœ€æ–°é…ç½®ï¼‰
        if save_system_config(current_config):
            # æ›´æ–°å…¨å±€å˜é‡
            update_global_system_config()
            
            # å¦‚æœæ›´æ–°äº†æ’è¡Œé…ç½®ï¼Œä¿å­˜æˆåŠŸåå†é‡å¯è°ƒåº¦å™¨
            if 'ranking' in data:
                _restart_ranking_scheduler(current_config['ranking'])
            
            # å¦‚æœæ›´æ–°äº†Telegramé…ç½®ï¼Œé‡æ–°æ³¨å†Œå‘½ä»¤
            if 'telegram' in data and 'bot_token' in data['telegram']:
                bot_token = current_config['telegram']['bot_token']
                if bot_token:
                    try:
                        register_telegram_commands_with_token(bot_token)
                        app.logger.info('Telegramå‘½ä»¤å·²é‡æ–°æ³¨å†Œ')
                    except Exception as e:
                        app.logger.warning(f'é‡æ–°æ³¨å†ŒTelegramå‘½ä»¤å¤±è´¥: {e}')
            
            app.logger.info(f'ç³»ç»Ÿé…ç½®å·²æ›´æ–°')
            
            # å¦‚æœæœ€å¤§åŒæ—¶æ’­æ”¾æµæ•°å‘ç”Ÿå˜åŒ–ï¼ŒåŒæ­¥åˆ°æ‰€æœ‰å·²æœ‰ Emby ç”¨æˆ·
            stream_sync_msg = ''
            if _pending_stream_sync:
                try:
                    sync_result = emby_client.sync_all_users_stream_limit(_pending_stream_sync['new'])
                    stream_sync_msg = f'ï¼Œæ’­æ”¾æµæ•°é™åˆ¶å·²ä» {_pending_stream_sync["old"]} åŒæ­¥ä¸º {_pending_stream_sync["new"]}ï¼ˆæˆåŠŸ {sync_result["success"]}/{sync_result["total"]} äººï¼‰'
                    app.logger.info(f'æœ€å¤§åŒæ—¶æ’­æ”¾æµæ•°å·²ä» {_pending_stream_sync["old"]} æ”¹ä¸º {_pending_stream_sync["new"]}ï¼Œ'
                                   f'åŒæ­¥ç»“æœ: æˆåŠŸ{sync_result["success"]}/{sync_result["total"]}äºº')
                except Exception as e:
                    stream_sync_msg = f'ï¼Œä½†åŒæ­¥æ’­æ”¾é™åˆ¶åˆ°å·²æœ‰ç”¨æˆ·å¤±è´¥: {e}'
                    app.logger.error(f'åŒæ­¥æµæ•°é™åˆ¶åˆ°å·²æœ‰ç”¨æˆ·å¤±è´¥: {e}')
            
            # è®°å½•é…ç½®å˜æ›´çš„å®¡è®¡æ—¥å¿—
            changed_sections = [k for k in data.keys() if k not in ('_',)]
            log_admin_audit('config_change', detail=f'ä¿®æ”¹ç³»ç»Ÿé…ç½®: {", ".join(changed_sections)}', target_type='config')
            
            return jsonify({
                'success': True,
                'message': 'ç³»ç»Ÿé…ç½®ä¿å­˜æˆåŠŸ' + stream_sync_msg
            }), 200
        else:
            return jsonify({
                'success': False,
                'error': 'ä¿å­˜é…ç½®æ–‡ä»¶å¤±è´¥'
            }), 500
            
    except Exception as e:
        app.logger.error(f'ä¿å­˜ç³»ç»Ÿé…ç½®å¤±è´¥: {e}')
        return jsonify({'error': str(e)}), 500


# ==================== é‚®ä»¶ç®¡ç† API ====================

@app.route('/api/admin/email/test', methods=['POST'])
@admin_required
def admin_test_email():
    """æµ‹è¯• SMTP é‚®ä»¶å‘é€"""
    try:
        data = request.json
        test_to = data.get('test_email', '').strip()
        if not test_to:
            return jsonify({'success': False, 'error': 'è¯·è¾“å…¥æµ‹è¯•æ”¶ä»¶é‚®ç®±'}), 400
        
        site_name = get_site_config().get('site_name', 'Emby')
        body = f"""<p>ğŸ‰ æ­å–œï¼ŒSMTP é‚®ä»¶é…ç½®æµ‹è¯•æˆåŠŸï¼</p>
<p>è¿™æ˜¯ä¸€å°æ¥è‡ª <b>{site_name}</b> ç®¡ç†ç³»ç»Ÿçš„æµ‹è¯•é‚®ä»¶ï¼Œè¯´æ˜æ‚¨çš„é‚®ä»¶æœåŠ¡é…ç½®æ­£ç¡®ã€‚</p>
<p style="color:#999;font-size:13px;">å‘é€æ—¶é—´: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>"""
        html = build_email_html(f'{site_name} - é‚®ä»¶æµ‹è¯•', body, site_name)
        ok, msg = send_email(test_to, f'ã€{site_name}ã€‘SMTP é‚®ä»¶æµ‹è¯•', html)
        
        if ok:
            return jsonify({'success': True, 'message': f'æµ‹è¯•é‚®ä»¶å·²å‘é€åˆ° {test_to}'}), 200
        else:
            return jsonify({'success': False, 'error': msg}), 500
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/admin/email/broadcast', methods=['POST'])
@admin_required
def admin_broadcast_email():
    """ç®¡ç†å‘˜ç¾¤å‘é‚®ä»¶"""
    from threading import Thread
    try:
        data = request.json
        subject = data.get('subject', '').strip()
        content = data.get('content', '').strip()
        target = data.get('target', 'all')  # all / active / custom
        custom_emails = data.get('custom_emails', [])
        
        if not subject:
            return jsonify({'success': False, 'error': 'è¯·è¾“å…¥é‚®ä»¶æ ‡é¢˜'}), 400
        if not content:
            return jsonify({'success': False, 'error': 'è¯·è¾“å…¥é‚®ä»¶å†…å®¹'}), 400
        
        email_cfg = get_email_config()
        if not email_cfg.get('enabled'):
            return jsonify({'success': False, 'error': 'é‚®ä»¶åŠŸèƒ½æœªå¯ç”¨'}), 400
        
        # ç¡®å®šæ”¶ä»¶äººåˆ—è¡¨
        recipients = []
        if target == 'custom':
            recipients = [e.strip().lower() for e in custom_emails if e.strip()]
        else:
            query = User.query.filter(User.email.isnot(None), User.email != '')
            if target == 'active':
                # æ´»è·ƒç”¨æˆ·ï¼šæœ‰æœ‰æ•ˆè®¢é˜…ï¼ˆç™½åå•æˆ–æœªè¿‡æœŸï¼‰
                query = query.filter(
                    db.and_(User.lv.in_(['a', 'b']), User.ex > datetime.now())
                )
            users = query.all()
            recipients = [u.email for u in users if u.email]
        
        if not recipients:
            return jsonify({'success': False, 'error': 'æ²¡æœ‰ç¬¦åˆæ¡ä»¶çš„æ”¶ä»¶äºº'}), 400
        
        # æ„å»º HTMLï¼ˆcontent æ”¯æŒåŸºç¡€ HTMLï¼Œè‡ªåŠ¨å¤„ç†æ¢è¡Œï¼‰
        processed_content = content.replace('\n', '<br>')
        site_name = get_site_config().get('site_name', 'Emby')
        html = build_email_html(subject, processed_content, site_name)
        total_count = len(recipients)
        
        # åå°çº¿ç¨‹å¼‚æ­¥å‘é€ï¼Œé¿å…å¤§é‡æ”¶ä»¶äººæ—¶è¯·æ±‚è¶…æ—¶
        def _send_broadcast():
            with app.app_context():
                success_count = 0
                fail_count = 0
                for addr in recipients:
                    try:
                        ok, msg = send_email(addr, f'ã€{site_name}ã€‘{subject}', html)
                        if ok:
                            success_count += 1
                        else:
                            fail_count += 1
                            app.logger.warning(f'ç¾¤å‘é‚®ä»¶å¤±è´¥: {addr} - {msg}')
                    except Exception as e:
                        fail_count += 1
                        app.logger.warning(f'ç¾¤å‘é‚®ä»¶å¼‚å¸¸: {addr} - {e}')
                app.logger.info(f'ç¾¤å‘é‚®ä»¶å®Œæˆ: æ ‡é¢˜={subject}, æˆåŠŸ={success_count}, å¤±è´¥={fail_count}, æ€»è®¡={total_count}')
        
        thread = Thread(target=_send_broadcast)
        thread.daemon = True
        thread.start()
        
        return jsonify({
            'success': True,
            'message': f'å·²å¼€å§‹å‘ {total_count} ä¸ªåœ°å€å‘é€é‚®ä»¶ï¼Œå‘é€è¿›åº¦è¯·æŸ¥çœ‹æ—¥å¿—',
            'total': total_count
        }), 200
        
    except Exception as e:
        app.logger.error(f'ç¾¤å‘é‚®ä»¶å¤±è´¥: {e}', exc_info=True)
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/admin/email/stats', methods=['GET'])
@admin_required
def admin_email_stats():
    """è·å–é‚®ç®±ç»‘å®šç»Ÿè®¡"""
    try:
        total_users = User.query.count()
        bound_users = User.query.filter(User.email.isnot(None), User.email != '').count()
        active_bound = User.query.filter(
            User.email.isnot(None), User.email != '',
            db.and_(User.lv.in_(['a', 'b']), User.ex > datetime.now())
        ).count()
        
        return jsonify({
            'success': True,
            'total_users': total_users,
            'bound_users': bound_users,
            'active_bound': active_bound
        }), 200
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500


# ==================== äºŒçº§åˆ†ç±»ç­–ç•¥é…ç½® API ====================
@app.route('/api/admin/category-config', methods=['GET'])
@admin_required
def get_category_config_api():
    """è·å–äºŒçº§åˆ†ç±»ç­–ç•¥é…ç½®"""
    config = load_system_config()
    category_config = config.get('category', DEFAULT_CATEGORY_CONFIG)
    
    # è·å–genre_idså­—å…¸ç”¨äºå‰ç«¯æ˜¾ç¤º
    genre_dict = {
        16: 'åŠ¨ç”»',
        99: 'çºªå½•ç‰‡',
        10762: 'å„¿ç«¥',
        10764: 'çœŸäººç§€',
        10767: 'è„±å£ç§€',
        28: 'åŠ¨ä½œ',
        12: 'å†’é™©',
        35: 'å–œå‰§',
        80: 'çŠ¯ç½ª',
        18: 'å‰§æƒ…',
        10751: 'å®¶åº­',
        14: 'å¥‡å¹»',
        36: 'å†å²',
        27: 'ææ€–',
        10402: 'éŸ³ä¹',
        9648: 'æ‚¬ç–‘',
        10749: 'çˆ±æƒ…',
        878: 'ç§‘å¹»',
        10770: 'ç”µè§†ç”µå½±',
        53: 'æƒŠæ‚š',
        10752: 'æˆ˜äº‰',
        37: 'è¥¿éƒ¨'
    }
    
    # è·å–å›½å®¶/åœ°åŒºå­—å…¸
    country_dict = {
        'CN': 'ä¸­å›½å¤§é™†',
        'TW': 'ä¸­å›½å°æ¹¾',
        'HK': 'ä¸­å›½é¦™æ¸¯',
        'US': 'ç¾å›½',
        'GB': 'è‹±å›½',
        'UK': 'è‹±å›½',
        'FR': 'æ³•å›½',
        'DE': 'å¾·å›½',
        'ES': 'è¥¿ç­ç‰™',
        'IT': 'æ„å¤§åˆ©',
        'NL': 'è·å…°',
        'PT': 'è‘¡è„ç‰™',
        'RU': 'ä¿„ç½—æ–¯',
        'CA': 'åŠ æ‹¿å¤§',
        'AU': 'æ¾³å¤§åˆ©äºš',
        'NZ': 'æ–°è¥¿å…°',
        'JP': 'æ—¥æœ¬',
        'KR': 'éŸ©å›½',
        'KP': 'æœé²œ',
        'TH': 'æ³°å›½',
        'IN': 'å°åº¦',
        'SG': 'æ–°åŠ å¡',
        'VN': 'è¶Šå—',
        'PH': 'è²å¾‹å®¾',
        'MY': 'é©¬æ¥è¥¿äºš'
    }
    
    # è·å–è¯­è¨€å­—å…¸
    language_dict = {
        'zh': 'ä¸­æ–‡',
        'cn': 'ä¸­æ–‡',
        'en': 'è‹±è¯­',
        'ja': 'æ—¥è¯­',
        'ko': 'éŸ©è¯­',
        'fr': 'æ³•è¯­',
        'de': 'å¾·è¯­',
        'es': 'è¥¿ç­ç‰™è¯­',
        'it': 'æ„å¤§åˆ©è¯­',
        'ru': 'ä¿„è¯­',
        'pt': 'è‘¡è„ç‰™è¯­',
        'th': 'æ³°è¯­',
        'vi': 'è¶Šå—è¯­',
        'bo': 'è—è¯­',
        'za': 'å£®è¯­'
    }
    
    return jsonify({
        'success': True,
        'category': category_config,
        'default_category': DEFAULT_CATEGORY_CONFIG,
        'dictionaries': {
            'genre_ids': genre_dict,
            'country': country_dict,
            'language': language_dict
        }
    }), 200


@app.route('/api/admin/category-config', methods=['POST'])
@admin_required
def save_category_config_api():
    """ä¿å­˜äºŒçº§åˆ†ç±»ç­–ç•¥é…ç½®"""
    try:
        data = request.json
        
        # è·å–å½“å‰é…ç½®
        current_config = load_system_config()
        
        # æ›´æ–°åˆ†ç±»é…ç½®
        if 'category' in data:
            current_config['category'] = data['category']
        
        # ä¿å­˜åˆ°æ–‡ä»¶
        if save_system_config(current_config):
            app.logger.info('äºŒçº§åˆ†ç±»ç­–ç•¥é…ç½®å·²æ›´æ–°')
            return jsonify({
                'success': True,
                'message': 'åˆ†ç±»ç­–ç•¥ä¿å­˜æˆåŠŸ'
            }), 200
        else:
            return jsonify({
                'success': False,
                'error': 'ä¿å­˜é…ç½®æ–‡ä»¶å¤±è´¥'
            }), 500
            
    except Exception as e:
        app.logger.error(f'ä¿å­˜åˆ†ç±»ç­–ç•¥å¤±è´¥: {e}')
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/admin/category-config/reset', methods=['POST'])
@admin_required
def reset_category_config_api():
    """é‡ç½®åˆ†ç±»ç­–ç•¥ä¸ºé»˜è®¤å€¼"""
    try:
        current_config = load_system_config()
        current_config['category'] = {
            'movie': DEFAULT_CATEGORY_CONFIG['movie'].copy(),
            'tv': DEFAULT_CATEGORY_CONFIG['tv'].copy()
        }
        
        if save_system_config(current_config):
            app.logger.info('äºŒçº§åˆ†ç±»ç­–ç•¥å·²é‡ç½®ä¸ºé»˜è®¤å€¼')
            return jsonify({
                'success': True,
                'message': 'å·²æ¢å¤é»˜è®¤åˆ†ç±»ç­–ç•¥'
            }), 200
        else:
            return jsonify({
                'success': False,
                'error': 'ä¿å­˜é…ç½®æ–‡ä»¶å¤±è´¥'
            }), 500
            
    except Exception as e:
        app.logger.error(f'é‡ç½®åˆ†ç±»ç­–ç•¥å¤±è´¥: {e}')
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/admin/test-emby', methods=['POST'])
@admin_required
def test_emby_connection():
    """æµ‹è¯• Emby è¿æ¥"""
    try:
        data = request.json
        url = data.get('url', '').strip().rstrip('/')
        api_key = data.get('api_key', '').strip()
        
        if not url:
            return jsonify({'success': False, 'error': 'Emby URL ä¸èƒ½ä¸ºç©º'}), 400
        
        if not api_key:
            return jsonify({'success': False, 'error': 'API Key ä¸èƒ½ä¸ºç©º'}), 400
        
        # æµ‹è¯•è¿æ¥ - è·å–ç³»ç»Ÿä¿¡æ¯
        test_url = f"{url}/System/Info?api_key={api_key}"
        resp = requests.get(test_url, timeout=10)
        
        if resp.status_code == 200:
            info = resp.json()
            server_name = info.get('ServerName', 'æœªçŸ¥')
            version = info.get('Version', 'æœªçŸ¥')
            return jsonify({
                'success': True,
                'message': f'è¿æ¥æˆåŠŸï¼æœåŠ¡å™¨: {server_name}, ç‰ˆæœ¬: {version}'
            }), 200
        elif resp.status_code == 401:
            return jsonify({
                'success': False,
                'error': 'API Key æ— æ•ˆæˆ–æƒé™ä¸è¶³'
            }), 400
        else:
            return jsonify({
                'success': False,
                'error': f'è¿æ¥å¤±è´¥ (çŠ¶æ€ç : {resp.status_code})'
            }), 400
            
    except requests.exceptions.Timeout:
        return jsonify({'success': False, 'error': 'è¿æ¥è¶…æ—¶ï¼Œè¯·æ£€æŸ¥åœ°å€'}), 400
    except requests.exceptions.ConnectionError:
        return jsonify({'success': False, 'error': 'æ— æ³•è¿æ¥åˆ°æœåŠ¡å™¨ï¼Œè¯·æ£€æŸ¥åœ°å€å’Œç½‘ç»œ'}), 400
    except Exception as e:
        app.logger.error(f'æµ‹è¯• Emby è¿æ¥å¤±è´¥: {e}')
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/admin/test-telegram', methods=['POST'])
@admin_required
def test_telegram_connection():
    """æµ‹è¯• Telegram Bot è¿æ¥"""
    try:
        data = request.json
        bot_token = data.get('bot_token', '').strip()
        chat_id = data.get('chat_id', '').strip()
        
        app.logger.info(f'[æµ‹è¯•è¿æ¥] å¼€å§‹æµ‹è¯• Telegram è¿æ¥ - chat_id={chat_id}')
        
        if not bot_token:
            app.logger.warning('[æµ‹è¯•è¿æ¥] Bot Token ä¸ºç©º')
            return jsonify({'success': False, 'error': 'Bot Token ä¸èƒ½ä¸ºç©º'}), 400
        
        # æµ‹è¯• Bot Token - è·å–æœºå™¨äººä¿¡æ¯
        test_url = f"https://api.telegram.org/bot{bot_token}/getMe"
        app.logger.info(f'[æµ‹è¯•è¿æ¥] è¯·æ±‚ getMe - URL: {test_url[:80]}..., ä½¿ç”¨ä»£ç†: {PROXY_SESSION.proxies if hasattr(PROXY_SESSION, "proxies") else "æ— "}')
        
        resp = PROXY_SESSION.get(test_url, timeout=10)
        app.logger.info(f'[æµ‹è¯•è¿æ¥] getMe å“åº” - çŠ¶æ€ç : {resp.status_code}')
        
        if resp.status_code != 200:
            app.logger.error(f'[æµ‹è¯•è¿æ¥] Bot Token æ— æ•ˆ - çŠ¶æ€ç : {resp.status_code}')
            return jsonify({
                'success': False,
                'error': 'Bot Token æ— æ•ˆ'
            }), 400
        
        bot_info = resp.json()
        app.logger.info(f'[æµ‹è¯•è¿æ¥] Bot ä¿¡æ¯: {json.dumps(bot_info, ensure_ascii=False)[:200]}')
        
        if not bot_info.get('ok'):
            app.logger.error(f'[æµ‹è¯•è¿æ¥] Bot Token éªŒè¯å¤±è´¥: {bot_info.get("description")}')
            return jsonify({
                'success': False,
                'error': bot_info.get('description', 'Bot Token éªŒè¯å¤±è´¥')
            }), 400
        
        bot_name = bot_info.get('result', {}).get('username', 'æœªçŸ¥')
        app.logger.info(f'[æµ‹è¯•è¿æ¥] Bot éªŒè¯æˆåŠŸ: @{bot_name}')
        
        # æ£€æŸ¥ Webhook çŠ¶æ€
        webhook_url = f"https://api.telegram.org/bot{bot_token}/getWebhookInfo"
        app.logger.info(f'[æµ‹è¯•è¿æ¥] è·å– Webhook ä¿¡æ¯...')
        
        webhook_resp = PROXY_SESSION.get(webhook_url, timeout=10)
        webhook_info = {}
        if webhook_resp.status_code == 200:
            webhook_data = webhook_resp.json()
            if webhook_data.get('ok'):
                webhook_info = webhook_data.get('result', {})
                app.logger.info(f'[æµ‹è¯•è¿æ¥] Webhook ä¿¡æ¯: URL={webhook_info.get("url", "æœªè®¾ç½®")}, pending_update_count={webhook_info.get("pending_update_count", 0)}, last_error={webhook_info.get("last_error_message", "æ— ")}')
        
        # å¦‚æœæä¾›äº† chat_idï¼Œå°è¯•å‘é€æµ‹è¯•æ¶ˆæ¯
        if chat_id:
            send_url = f"https://api.telegram.org/bot{bot_token}/sendMessage"
            app.logger.info(f'[æµ‹è¯•è¿æ¥] å‘é€æµ‹è¯•æ¶ˆæ¯åˆ° chat_id={chat_id}')
            
            send_resp = PROXY_SESSION.post(send_url, json={
                'chat_id': chat_id,
                'text': 'âœ… æµ‹è¯•æ¶ˆæ¯ - Embyç®¡ç†ç³»ç»Ÿè¿æ¥æˆåŠŸï¼',
                'parse_mode': 'HTML'
            }, timeout=10)
            
            app.logger.info(f'[æµ‹è¯•è¿æ¥] å‘é€æ¶ˆæ¯å“åº” - çŠ¶æ€ç : {send_resp.status_code}')
            
            if send_resp.status_code == 200 and send_resp.json().get('ok'):
                message = f'è¿æ¥æˆåŠŸï¼Bot: @{bot_name}ï¼Œå·²å‘é€æµ‹è¯•æ¶ˆæ¯åˆ°ç¾¤ç»„'
                
                # æ³¨å†Œå‘½ä»¤èœå•
                register_telegram_commands_with_token(bot_token)
                
                # æ·»åŠ  Webhook çŠ¶æ€æç¤º
                if not webhook_info.get('url'):
                    message += '\n\nâš ï¸ æç¤ºï¼šWebhook æœªè®¾ç½®ï¼ŒBot å‘½ä»¤åŠŸèƒ½å°†æ— æ³•ä½¿ç”¨ã€‚è¯·ç‚¹å‡»"è®¾ç½® Webhook"æŒ‰é’®è¿›è¡Œé…ç½®ã€‚'
                    app.logger.warning('[æµ‹è¯•è¿æ¥] Webhook æœªè®¾ç½®ï¼ŒBot å‘½ä»¤å°†æ— æ³•å·¥ä½œ')
                else:
                    app.logger.info(f'[æµ‹è¯•è¿æ¥] Webhook å·²è®¾ç½®: {webhook_info.get("url")}')
                
                app.logger.info('[æµ‹è¯•è¿æ¥] æµ‹è¯•å®Œæˆ - æˆåŠŸ')
                return jsonify({
                    'success': True,
                    'message': message,
                    'webhook_info': webhook_info
                }), 200
            else:
                error_desc = send_resp.json().get('description', 'å‘é€å¤±è´¥')
                app.logger.error(f'[æµ‹è¯•è¿æ¥] å‘é€æ¶ˆæ¯å¤±è´¥: {error_desc}')
                return jsonify({
                    'success': False,
                    'error': f'Bot æœ‰æ•ˆä½†å‘é€æ¶ˆæ¯å¤±è´¥: {error_desc}'
                }), 400
        
        message = f'Bot Token æœ‰æ•ˆï¼Bot: @{bot_name}'
        if not webhook_info.get('url'):
            message += '\n\nâš ï¸ æç¤ºï¼šWebhook æœªè®¾ç½®ï¼ŒBot å‘½ä»¤åŠŸèƒ½å°†æ— æ³•ä½¿ç”¨'
            app.logger.warning('[æµ‹è¯•è¿æ¥] Webhook æœªè®¾ç½®')
        
        app.logger.info('[æµ‹è¯•è¿æ¥] æµ‹è¯•å®Œæˆ - æˆåŠŸï¼ˆæœªæµ‹è¯•æ¶ˆæ¯å‘é€ï¼‰')
        return jsonify({
            'success': True,
            'message': message,
            'webhook_info': webhook_info
        }), 200
            
    except requests.exceptions.Timeout:
        app.logger.error('[æµ‹è¯•è¿æ¥] è¿æ¥è¶…æ—¶')
        return jsonify({'success': False, 'error': 'è¿æ¥è¶…æ—¶ï¼Œè¯·æ£€æŸ¥ç½‘ç»œå’Œä»£ç†è®¾ç½®'}), 400
    except requests.exceptions.ConnectionError as e:
        app.logger.error(f'[æµ‹è¯•è¿æ¥] æ— æ³•è¿æ¥åˆ° Telegram æœåŠ¡å™¨: {e}')
        return jsonify({'success': False, 'error': f'æ— æ³•è¿æ¥åˆ° Telegram æœåŠ¡å™¨ï¼Œè¯·æ£€æŸ¥ç½‘ç»œå’Œä»£ç†è®¾ç½®: {str(e)}'}), 400
    except Exception as e:
        app.logger.error(f'[æµ‹è¯•è¿æ¥] æµ‹è¯•å¤±è´¥: {e}', exc_info=True)
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/admin/register-telegram-commands', methods=['POST'])
@admin_required
def api_register_telegram_commands():
    """æ‰‹åŠ¨æ³¨å†Œ Telegram Bot å‘½ä»¤èœå•"""
    try:
        data = request.json or {}
        bot_token = data.get('bot_token', '').strip() or TELEGRAM_BOT_TOKEN
        
        if not bot_token:
            return jsonify({
                'success': False,
                'error': 'æœªé…ç½® Telegram Bot Token'
            }), 400
        
        app.logger.info('[å‘½ä»¤æ³¨å†ŒAPI] å¼€å§‹æ‰‹åŠ¨æ³¨å†Œå‘½ä»¤')
        result = register_telegram_commands_with_token(bot_token)
        
        if result:
            # è·å–å½“å‰æ³¨å†Œçš„å‘½ä»¤åˆ—è¡¨
            try:
                verify_url = f"https://api.telegram.org/bot{bot_token}/getMyCommands"
                verify_resp = PROXY_SESSION.get(verify_url, timeout=10)
                verify_data = verify_resp.json()
                commands = verify_data.get('result', []) if verify_data.get('ok') else []
            except:
                commands = []
            
            return jsonify({
                'success': True,
                'message': 'å‘½ä»¤èœå•æ³¨å†ŒæˆåŠŸï¼è¯·åœ¨ Telegram ä¸­è¾“å…¥ / æŸ¥çœ‹å‘½ä»¤åˆ—è¡¨',
                'commands': commands
            })
        else:
            return jsonify({
                'success': False,
                'error': 'å‘½ä»¤æ³¨å†Œå¤±è´¥ï¼Œè¯·æŸ¥çœ‹æœåŠ¡å™¨æ—¥å¿—'
            }), 500
            
    except Exception as e:
        app.logger.error(f'[å‘½ä»¤æ³¨å†ŒAPI] å¤±è´¥: {e}', exc_info=True)
        return jsonify({'success': False, 'error': str(e)}), 500


# ==================== å¥—é¤é…ç½® API ====================
@app.route('/api/admin/plans-config', methods=['GET'])
@admin_required
def get_plans_config():
    """è·å–å¥—é¤é…ç½®ï¼ˆç®¡ç†å‘˜ï¼‰"""
    plans = load_plans_config()
    return jsonify({
        'success': True,
        'plans': plans
    }), 200


@app.route('/api/admin/plans-config', methods=['POST'])
@admin_required
def save_plans_config_api():
    """ä¿å­˜å¥—é¤é…ç½®ï¼ˆç®¡ç†å‘˜ï¼‰"""
    try:
        data = request.json
        plans = data.get('plans', [])
        
        # éªŒè¯å¥—é¤æ•°æ®
        validated_plans = []
        for plan in plans:
            # ç¡®ä¿å¿…å¡«å­—æ®µ
            if not plan.get('id') or not plan.get('name'):
                continue
                
            # è®¡ç®— duration_daysï¼šä¼˜å…ˆä½¿ç”¨å‰ç«¯ä¼ æ¥çš„å€¼ï¼Œå¦åˆ™ä» durationï¼ˆæœˆï¼‰è®¡ç®—
            duration_months = int(plan.get('duration', 1))
            duration_days = int(plan.get('duration_days', 0))
            if duration_days <= 0:
                duration_days = duration_months * 30
            
            validated_plan = {
                'id': str(plan.get('id', '')).strip(),
                'name': str(plan.get('name', '')).strip(),
                'icon': str(plan.get('icon', '')).strip() if plan.get('icon') else None,
                'description': str(plan.get('description', '')).strip() if plan.get('description') else None,
                'duration': duration_months,
                'duration_days': duration_days,
                'price': float(plan.get('price', 0)),
                'original_price': float(plan.get('original_price')) if plan.get('original_price') else None,
                'features': plan.get('features', []) if isinstance(plan.get('features'), list) else [],
                'popular': bool(plan.get('popular', False)),
                # ç™½åå•å¥—é¤æ ‡è®°ï¼ˆå‹¾é€‰åè¯¥å¥—é¤ç”¨æˆ·è§†ä¸ºç™½åå•ç”¨æˆ·ï¼‰
                'is_whitelist': bool(plan.get('is_whitelist', False)),
                # å¤šå‘¨æœŸä»·æ ¼ï¼ˆäº’æ–¥ï¼šä¸€æ¬¡æ€§å’Œæœˆä»˜/å­£ä»˜/å¹´ä»˜åªèƒ½è®¾ä¸€ç§ï¼‰
                'price_once': float(plan.get('price_once', 0)) if plan.get('price_once') else None,
                'price_1m': float(plan.get('price_1m', 0)) if plan.get('price_1m') else None,
                'price_3m': float(plan.get('price_3m', 0)) if plan.get('price_3m') else None,
                'price_6m': float(plan.get('price_6m', 0)) if plan.get('price_6m') else None,
                'price_12m': float(plan.get('price_12m', 0)) if plan.get('price_12m') else None,
                # è®¢é˜…æƒç›Š
                'benefits': plan.get('benefits', []) if isinstance(plan.get('benefits'), list) else [],
            }
            
            # äº’æ–¥æ ¡éªŒï¼šä¸€æ¬¡æ€§ä»·æ ¼å’Œå‘¨æœŸä»·æ ¼ä¸èƒ½åŒæ—¶å­˜åœ¨
            once_price = validated_plan.get('price_once') or 0
            monthly_price = validated_plan.get('price_1m') or 0
            if once_price > 0 and monthly_price > 0:
                # ä¸€æ¬¡æ€§ä»·æ ¼ä¼˜å…ˆï¼Œæ¸…ç©ºå‘¨æœŸä»·æ ¼
                validated_plan['price_1m'] = None
                validated_plan['price_3m'] = None
                validated_plan['price_6m'] = None
                validated_plan['price_12m'] = None
                validated_plan['price'] = 0
                app.logger.warning(f'å¥—é¤ {validated_plan["name"]} åŒæ—¶è®¾ç½®äº†ä¸€æ¬¡æ€§å’Œå‘¨æœŸä»·æ ¼ï¼Œå·²è‡ªåŠ¨æ¸…ç©ºå‘¨æœŸä»·æ ¼')
            
            validated_plans.append(validated_plan)
        
        if not validated_plans:
            return jsonify({
                'success': False,
                'error': 'è¯·è‡³å°‘é…ç½®ä¸€ä¸ªæœ‰æ•ˆå¥—é¤'
            }), 400
        
        # ä¿å­˜é…ç½®
        if save_plans_config(validated_plans):
            app.logger.info(f'å¥—é¤é…ç½®å·²æ›´æ–°ï¼Œå…± {len(validated_plans)} ä¸ªå¥—é¤')
            
            return jsonify({
                'success': True,
                'message': f'é…ç½®ä¿å­˜æˆåŠŸï¼Œå…± {len(validated_plans)} ä¸ªå¥—é¤'
            }), 200
        else:
            return jsonify({
                'success': False,
                'error': 'ä¿å­˜é…ç½®æ–‡ä»¶å¤±è´¥'
            }), 500
            
    except Exception as e:
        app.logger.error(f'ä¿å­˜å¥—é¤é…ç½®å¤±è´¥: {e}')
        return jsonify({'error': str(e)}), 500


# ==================== ç³»ç»Ÿå…¬å‘Š API ====================
@app.route('/api/announcements', methods=['GET'])
@login_required
def get_announcements():
    """è·å–å½“å‰æœ‰æ•ˆçš„å…¬å‘Šï¼ˆç”¨æˆ·ç«¯ï¼‰"""
    try:
        announcements = Announcement.get_active_announcements()
        return jsonify({
            'success': True,
            'announcements': [a.to_dict() for a in announcements]
        })
    except Exception as e:
        app.logger.error(f'è·å–å…¬å‘Šå¤±è´¥: {e}')
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/admin/announcements', methods=['GET'])
@admin_required
def admin_get_announcements():
    """è·å–æ‰€æœ‰å…¬å‘Šï¼ˆç®¡ç†ç«¯ï¼‰"""
    try:
        announcements = Announcement.query.order_by(Announcement.is_pinned.desc(), Announcement.created_at.desc()).all()
        return jsonify({
            'success': True,
            'announcements': [a.to_dict() for a in announcements]
        })
    except Exception as e:
        app.logger.error(f'è·å–å…¬å‘Šåˆ—è¡¨å¤±è´¥: {e}')
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/admin/announcements', methods=['POST'])
@admin_required
def admin_create_announcement():
    """åˆ›å»ºæ–°å…¬å‘Š"""
    try:
        data = request.get_json()
        
        title = data.get('title', '').strip()
        content = data.get('content', '').strip()
        
        if not title or not content:
            return jsonify({'success': False, 'error': 'æ ‡é¢˜å’Œå†…å®¹ä¸èƒ½ä¸ºç©º'}), 400
        
        announcement = Announcement(
            title=title,
            content=content,
            type=data.get('type', 'info'),
            is_active=data.get('is_active', True),
            is_pinned=data.get('is_pinned', False),
            start_time=datetime.fromisoformat(data['start_time'].replace('Z', '+00:00')).replace(tzinfo=None) if data.get('start_time') else None,
            end_time=datetime.fromisoformat(data['end_time'].replace('Z', '+00:00')).replace(tzinfo=None) if data.get('end_time') else None
        )
        
        db.session.add(announcement)
        db.session.commit()
        
        app.logger.info(f'åˆ›å»ºå…¬å‘ŠæˆåŠŸ: {title}')
        return jsonify({
            'success': True,
            'message': 'å…¬å‘Šåˆ›å»ºæˆåŠŸ',
            'announcement': announcement.to_dict()
        })
    except Exception as e:
        db.session.rollback()
        app.logger.error(f'åˆ›å»ºå…¬å‘Šå¤±è´¥: {e}')
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/admin/announcements/<int:id>', methods=['PUT'])
@admin_required
def admin_update_announcement(id):
    """æ›´æ–°å…¬å‘Š"""
    try:
        announcement = db.session.get(Announcement, id)
        if not announcement:
            return jsonify({'success': False, 'error': 'å…¬å‘Šä¸å­˜åœ¨'}), 404
        
        data = request.get_json()
        
        if 'title' in data:
            announcement.title = data['title'].strip()
        if 'content' in data:
            announcement.content = data['content'].strip()
        if 'type' in data:
            announcement.type = data['type']
        if 'is_active' in data:
            announcement.is_active = data['is_active']
        if 'is_pinned' in data:
            announcement.is_pinned = data['is_pinned']
        if 'start_time' in data:
            announcement.start_time = datetime.fromisoformat(data['start_time'].replace('Z', '+00:00')).replace(tzinfo=None) if data['start_time'] else None
        if 'end_time' in data:
            announcement.end_time = datetime.fromisoformat(data['end_time'].replace('Z', '+00:00')).replace(tzinfo=None) if data['end_time'] else None
        
        db.session.commit()
        
        app.logger.info(f'æ›´æ–°å…¬å‘ŠæˆåŠŸ: {announcement.title}')
        return jsonify({
            'success': True,
            'message': 'å…¬å‘Šæ›´æ–°æˆåŠŸ',
            'announcement': announcement.to_dict()
        })
    except Exception as e:
        db.session.rollback()
        app.logger.error(f'æ›´æ–°å…¬å‘Šå¤±è´¥: {e}')
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/admin/announcements/<int:id>', methods=['DELETE'])
@admin_required
def admin_delete_announcement(id):
    """åˆ é™¤å…¬å‘Š"""
    try:
        announcement = db.session.get(Announcement, id)
        if not announcement:
            return jsonify({'success': False, 'error': 'å…¬å‘Šä¸å­˜åœ¨'}), 404
        
        title = announcement.title
        db.session.delete(announcement)
        db.session.commit()
        
        app.logger.info(f'åˆ é™¤å…¬å‘ŠæˆåŠŸ: {title}')
        return jsonify({
            'success': True,
            'message': 'å…¬å‘Šåˆ é™¤æˆåŠŸ'
        })
    except Exception as e:
        db.session.rollback()
        app.logger.error(f'åˆ é™¤å…¬å‘Šå¤±è´¥: {e}')
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/admin/announcements/<int:id>/toggle', methods=['POST'])
@admin_required
def admin_toggle_announcement(id):
    """åˆ‡æ¢å…¬å‘Šå¯ç”¨çŠ¶æ€"""
    try:
        announcement = db.session.get(Announcement, id)
        if not announcement:
            return jsonify({'success': False, 'error': 'å…¬å‘Šä¸å­˜åœ¨'}), 404
        
        announcement.is_active = not announcement.is_active
        db.session.commit()
        
        status = 'å¯ç”¨' if announcement.is_active else 'ç¦ç”¨'
        app.logger.info(f'å…¬å‘ŠçŠ¶æ€åˆ‡æ¢: {announcement.title} -> {status}')
        return jsonify({
            'success': True,
            'message': f'å…¬å‘Šå·²{status}',
            'is_active': announcement.is_active
        })
    except Exception as e:
        db.session.rollback()
        app.logger.error(f'åˆ‡æ¢å…¬å‘ŠçŠ¶æ€å¤±è´¥: {e}')
        return jsonify({'success': False, 'error': str(e)}), 500


# ==================== çŸ¥è¯†åº“/FAQ API ====================
@app.route('/api/admin/knowledge', methods=['GET'])
@admin_required
def admin_get_knowledge():
    """è·å–çŸ¥è¯†åº“åˆ—è¡¨ï¼ˆç®¡ç†ç«¯ï¼‰"""
    try:
        knowledge_list = get_db_config('knowledge_base', [])
        return jsonify({
            'success': True,
            'items': knowledge_list
        })
    except Exception as e:
        app.logger.error(f'è·å–çŸ¥è¯†åº“å¤±è´¥: {e}')
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/admin/knowledge', methods=['POST'])
@admin_required
def admin_save_knowledge():
    """ä¿å­˜çŸ¥è¯†åº“ï¼ˆå®Œæ•´æ›¿æ¢ï¼‰"""
    try:
        data = request.get_json()
        items = data.get('items', [])
        
        # éªŒè¯æ•°æ®æ ¼å¼
        for item in items:
            if not item.get('question') or not item.get('answer'):
                return jsonify({'success': False, 'error': 'é—®é¢˜å’Œç­”æ¡ˆä¸èƒ½ä¸ºç©º'}), 400
            if not item.get('category'):
                item['category'] = 'other'
            if 'id' not in item:
                item['id'] = int(time.time() * 1000)
        
        set_db_config('knowledge_base', items, 'çŸ¥è¯†åº“/FAQé…ç½®')
        
        app.logger.info(f'ä¿å­˜çŸ¥è¯†åº“æˆåŠŸï¼Œå…± {len(items)} æ¡')
        return jsonify({
            'success': True,
            'message': f'çŸ¥è¯†åº“ä¿å­˜æˆåŠŸï¼Œå…± {len(items)} æ¡'
        })
    except Exception as e:
        app.logger.error(f'ä¿å­˜çŸ¥è¯†åº“å¤±è´¥: {e}')
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/admin/knowledge/item', methods=['POST'])
@admin_required
def admin_add_knowledge_item():
    """æ·»åŠ å•æ¡çŸ¥è¯†åº“æ¡ç›®"""
    try:
        data = request.get_json()
        
        question = data.get('question', '').strip()
        answer = data.get('answer', '').strip()
        category = data.get('category', 'other').strip()
        
        if not question or not answer:
            return jsonify({'success': False, 'error': 'é—®é¢˜å’Œç­”æ¡ˆä¸èƒ½ä¸ºç©º'}), 400
        
        knowledge_list = get_db_config('knowledge_base', [])
        
        new_item = {
            'id': int(time.time() * 1000),
            'question': question,
            'answer': answer,
            'category': category,
            'order': len(knowledge_list)
        }
        
        knowledge_list.append(new_item)
        set_db_config('knowledge_base', knowledge_list, 'çŸ¥è¯†åº“/FAQé…ç½®')
        
        app.logger.info(f'æ·»åŠ çŸ¥è¯†åº“æ¡ç›®æˆåŠŸ: {question}')
        return jsonify({
            'success': True,
            'message': 'æ·»åŠ æˆåŠŸ',
            'item': new_item
        })
    except Exception as e:
        app.logger.error(f'æ·»åŠ çŸ¥è¯†åº“æ¡ç›®å¤±è´¥: {e}')
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/admin/knowledge/item/<int:item_id>', methods=['PUT'])
@admin_required
def admin_update_knowledge_item(item_id):
    """æ›´æ–°å•æ¡çŸ¥è¯†åº“æ¡ç›®"""
    try:
        data = request.get_json()
        knowledge_list = get_db_config('knowledge_base', [])
        
        # æŸ¥æ‰¾æ¡ç›®
        item_index = None
        for i, item in enumerate(knowledge_list):
            if item.get('id') == item_id:
                item_index = i
                break
        
        if item_index is None:
            return jsonify({'success': False, 'error': 'æ¡ç›®ä¸å­˜åœ¨'}), 404
        
        # æ›´æ–°å­—æ®µ
        if 'question' in data:
            knowledge_list[item_index]['question'] = data['question'].strip()
        if 'answer' in data:
            knowledge_list[item_index]['answer'] = data['answer'].strip()
        if 'category' in data:
            knowledge_list[item_index]['category'] = data['category'].strip()
        if 'order' in data:
            knowledge_list[item_index]['order'] = data['order']
        
        set_db_config('knowledge_base', knowledge_list, 'çŸ¥è¯†åº“/FAQé…ç½®')
        
        app.logger.info(f'æ›´æ–°çŸ¥è¯†åº“æ¡ç›®æˆåŠŸ: ID={item_id}')
        return jsonify({
            'success': True,
            'message': 'æ›´æ–°æˆåŠŸ',
            'item': knowledge_list[item_index]
        })
    except Exception as e:
        app.logger.error(f'æ›´æ–°çŸ¥è¯†åº“æ¡ç›®å¤±è´¥: {e}')
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/admin/knowledge/item/<int:item_id>', methods=['DELETE'])
@admin_required
def admin_delete_knowledge_item(item_id):
    """åˆ é™¤å•æ¡çŸ¥è¯†åº“æ¡ç›®"""
    try:
        knowledge_list = get_db_config('knowledge_base', [])
        
        # æŸ¥æ‰¾å¹¶åˆ é™¤æ¡ç›®
        new_list = [item for item in knowledge_list if item.get('id') != item_id]
        
        if len(new_list) == len(knowledge_list):
            return jsonify({'success': False, 'error': 'æ¡ç›®ä¸å­˜åœ¨'}), 404
        
        set_db_config('knowledge_base', new_list, 'çŸ¥è¯†åº“/FAQé…ç½®')
        
        app.logger.info(f'åˆ é™¤çŸ¥è¯†åº“æ¡ç›®æˆåŠŸ: ID={item_id}')
        return jsonify({
            'success': True,
            'message': 'åˆ é™¤æˆåŠŸ'
        })
    except Exception as e:
        app.logger.error(f'åˆ é™¤çŸ¥è¯†åº“æ¡ç›®å¤±è´¥: {e}')
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/admin/knowledge/categories', methods=['GET'])
@admin_required  
def admin_get_knowledge_categories():
    """è·å–çŸ¥è¯†åº“åˆ†ç±»"""
    try:
        categories = get_db_config('knowledge_categories', [
            {'id': 'account', 'name': 'è´¦æˆ·ç›¸å…³'},
            {'id': 'request', 'name': 'æ±‚ç‰‡ç›¸å…³'},
            {'id': 'playback', 'name': 'æ’­æ”¾é—®é¢˜'},
            {'id': 'payment', 'name': 'æ”¯ä»˜é—®é¢˜'},
            {'id': 'other', 'name': 'å…¶ä»–'}
        ])
        return jsonify({
            'success': True,
            'categories': categories
        })
    except Exception as e:
        app.logger.error(f'è·å–çŸ¥è¯†åº“åˆ†ç±»å¤±è´¥: {e}')
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/admin/knowledge/categories', methods=['POST'])
@admin_required
def admin_save_knowledge_categories():
    """ä¿å­˜çŸ¥è¯†åº“åˆ†ç±»"""
    try:
        data = request.get_json()
        categories = data.get('categories', [])
        
        set_db_config('knowledge_categories', categories, 'çŸ¥è¯†åº“åˆ†ç±»é…ç½®')
        
        app.logger.info(f'ä¿å­˜çŸ¥è¯†åº“åˆ†ç±»æˆåŠŸï¼Œå…± {len(categories)} ä¸ªåˆ†ç±»')
        return jsonify({
            'success': True,
            'message': 'åˆ†ç±»ä¿å­˜æˆåŠŸ'
        })
    except Exception as e:
        app.logger.error(f'ä¿å­˜çŸ¥è¯†åº“åˆ†ç±»å¤±è´¥: {e}')
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/knowledge', methods=['GET'])
def get_knowledge():
    """è·å–çŸ¥è¯†åº“åˆ—è¡¨ï¼ˆå‰ç«¯ç”¨æˆ·ç«¯ï¼‰"""
    try:
        knowledge_list = get_db_config('knowledge_base', None)
        categories = get_db_config('knowledge_categories', None)
        
        # å¦‚æœåˆ†ç±»ä¸ºç©ºï¼Œåˆå§‹åŒ–é»˜è®¤åˆ†ç±»
        if categories is None:
            categories = [
                {'id': 'account', 'name': 'è´¦æˆ·ç›¸å…³'},
                {'id': 'request', 'name': 'æ±‚ç‰‡ç›¸å…³'},
                {'id': 'playback', 'name': 'æ’­æ”¾é—®é¢˜'},
                {'id': 'payment', 'name': 'æ”¯ä»˜é—®é¢˜'},
                {'id': 'other', 'name': 'å…¶ä»–'}
            ]
            set_db_config('knowledge_categories', categories, 'çŸ¥è¯†åº“åˆ†ç±»é…ç½®')
        
        # å¦‚æœçŸ¥è¯†åº“ä¸ºç©ºï¼Œåˆå§‹åŒ–é»˜è®¤FAQæ•°æ®å¹¶å†™å…¥æ•°æ®åº“
        if knowledge_list is None or len(knowledge_list) == 0:
            knowledge_list = [
                {
                    'id': 1,
                    'category': 'account',
                    'question': 'å¦‚ä½•æ³¨å†Œè´¦å·ï¼Ÿ',
                    'answer': '<p>ç›®å‰ç³»ç»Ÿé‡‡ç”¨ Telegram ç»‘å®šç™»å½•æ–¹å¼ã€‚æ‚¨éœ€è¦ï¼š</p><ol><li>æ·»åŠ æˆ‘ä»¬çš„ Telegram Bot</li><li>å‘é€ /start å‘½ä»¤å¼€å§‹ç»‘å®š</li><li>æŒ‰æç¤ºå®Œæˆè´¦å·ç»‘å®š</li></ol>',
                    'order': 1
                },
                {
                    'id': 2,
                    'category': 'account',
                    'question': 'å¿˜è®°å¯†ç æ€ä¹ˆåŠï¼Ÿ',
                    'answer': '<p>è¯·é€šè¿‡ Telegram Bot å‘é€ /resetpwd å‘½ä»¤é‡ç½®å¯†ç ï¼Œæˆ–è”ç³»ç®¡ç†å‘˜ååŠ©å¤„ç†ã€‚</p>',
                    'order': 2
                },
                {
                    'id': 3,
                    'category': 'request',
                    'question': 'æ¯å¤©å¯ä»¥æ±‚ç‰‡å‡ æ¬¡ï¼Ÿ',
                    'answer': '<p>æ±‚ç‰‡æ¬¡æ•°æ ¹æ®ä¼šå‘˜ç­‰çº§æœ‰æ‰€ä¸åŒï¼š</p><ul><li>ç™½åå•ç”¨æˆ·ï¼šæ¯æ—¥ 3 æ¬¡</li><li>æ³¨å†Œç”¨æˆ·ï¼šæ¯æ—¥ 1 æ¬¡</li></ul><p>æ¬¡æ•°æ¯å¤© 0 ç‚¹é‡ç½®ã€‚</p>',
                    'order': 3
                },
                {
                    'id': 4,
                    'category': 'request',
                    'question': 'æ±‚ç‰‡åå¤šä¹…èƒ½çœ‹åˆ°ï¼Ÿ',
                    'answer': '<p>å¤„ç†æ—¶é—´å–å†³äºå¤šä¸ªå› ç´ ï¼š</p><ul><li>èµ„æºå¯ç”¨æ€§ï¼šçƒ­é—¨èµ„æºé€šå¸¸è¾ƒå¿«</li><li>æ–‡ä»¶å¤§å°ï¼š4K èµ„æºä¸‹è½½æ—¶é—´è¾ƒé•¿</li><li>ç½‘ç»œçŠ¶å†µï¼šä¸€èˆ¬ 1-24 å°æ—¶å†…å®Œæˆ</li></ul><p>æ‚¨å¯ä»¥åœ¨"æ±‚ç‰‡ç®¡ç†"ä¸­æŸ¥çœ‹å¤„ç†è¿›åº¦ã€‚</p>',
                    'order': 4
                },
                {
                    'id': 5,
                    'category': 'request',
                    'question': 'ä¸ºä»€ä¹ˆæœä¸åˆ°æƒ³è¦çš„å½±ç‰‡ï¼Ÿ',
                    'answer': '<p>å¯èƒ½çš„åŸå› ï¼š</p><ul><li>å½±ç‰‡åç§°è¾“å…¥ä¸å‡†ç¡®ï¼Œå°è¯•ä½¿ç”¨å®˜æ–¹è¯‘å</li><li>å½±ç‰‡å°šæœªåœ¨ TMDB æ•°æ®åº“æ”¶å½•</li><li>å¯ä»¥å°è¯•æœç´¢è‹±æ–‡åŸå</li></ul><p>å¦‚ä»æ— æ³•æ‰¾åˆ°ï¼Œå¯è”ç³»ç®¡ç†å‘˜æ‰‹åŠ¨æ·»åŠ ã€‚</p>',
                    'order': 5
                },
                {
                    'id': 6,
                    'category': 'playback',
                    'question': 'æ’­æ”¾å¡é¡¿æ€ä¹ˆåŠï¼Ÿ',
                    'answer': '<p>å»ºè®®å°è¯•ï¼š</p><ul><li>æ£€æŸ¥ç½‘ç»œè¿æ¥æ˜¯å¦ç¨³å®š</li><li>é™ä½æ’­æ”¾ç”»è´¨</li><li>æ¸…é™¤å®¢æˆ·ç«¯ç¼“å­˜</li><li>æ›´æ¢å®¢æˆ·ç«¯å°è¯•</li></ul>',
                    'order': 6
                },
                {
                    'id': 7,
                    'category': 'playback',
                    'question': 'å­—å¹•ä¸æ˜¾ç¤ºæˆ–ä¹±ç ï¼Ÿ',
                    'answer': '<p>è§£å†³æ–¹æ³•ï¼š</p><ul><li>åœ¨æ’­æ”¾å™¨è®¾ç½®ä¸­æ£€æŸ¥å­—å¹•é€‰é¡¹</li><li>å°è¯•åˆ‡æ¢å­—å¹•è½¨é“</li><li>å®¢æˆ·ç«¯è®¾ç½®ä¸­è°ƒæ•´å­—å¹•ç¼–ç ä¸º UTF-8</li></ul>',
                    'order': 7
                },
                {
                    'id': 8,
                    'category': 'payment',
                    'question': 'æ”¯æŒå“ªäº›æ”¯ä»˜æ–¹å¼ï¼Ÿ',
                    'answer': '<p>ç›®å‰æ”¯æŒï¼š</p><ul><li>æ”¯ä»˜å®</li><li>å¾®ä¿¡æ”¯ä»˜</li></ul><p>æ›´å¤šæ”¯ä»˜æ–¹å¼é™†ç»­å¼€æ”¾ä¸­ã€‚</p>',
                    'order': 8
                },
                {
                    'id': 9,
                    'category': 'payment',
                    'question': 'æ”¯ä»˜æˆåŠŸä½†è®¢é˜…æœªç”Ÿæ•ˆï¼Ÿ',
                    'answer': '<p>è¯·ç¨ç­‰å‡ åˆ†é’Ÿï¼Œç³»ç»Ÿå¯èƒ½æ­£åœ¨å¤„ç†ä¸­ã€‚å¦‚è¶…è¿‡ 30 åˆ†é’Ÿä»æœªç”Ÿæ•ˆï¼Œè¯·ï¼š</p><ol><li>ä¿å­˜å¥½æ”¯ä»˜å‡­è¯æˆªå›¾</li><li>å‰å¾€"æŠ€æœ¯æ”¯æŒ"æäº¤å·¥å•</li><li>æˆ‘ä»¬ä¼šåœ¨ 24 å°æ—¶å†…å¤„ç†</li></ol>',
                    'order': 9
                }
            ]
            # å†™å…¥æ•°æ®åº“
            set_db_config('knowledge_base', knowledge_list, 'çŸ¥è¯†åº“/FAQé…ç½®')
            app.logger.info('çŸ¥è¯†åº“åˆå§‹åŒ–ï¼šå·²å†™å…¥é»˜è®¤FAQæ•°æ®')
        
        # æŒ‰ order æ’åº
        knowledge_list.sort(key=lambda x: x.get('order', 0))
        
        return jsonify({
            'success': True,
            'items': knowledge_list,
            'categories': categories
        })
    except Exception as e:
        app.logger.error(f'è·å–çŸ¥è¯†åº“å¤±è´¥: {e}')
        return jsonify({'success': False, 'error': str(e)}), 500


# ==================== é‚€è¯·è¿”åˆ© API ====================
@app.route('/api/invite/code', methods=['GET'])
@login_required
def get_invite_code():
    """è·å–æˆ‘çš„é‚€è¯·ç """
    try:
        from sqlalchemy import func
        user = db.session.get(User, session.get('user_id'))
        
        # ç”Ÿæˆå”¯ä¸€é‚€è¯·ç ï¼ˆåŸºäºç”¨æˆ· TG IDï¼‰
        invite_code = hashlib.md5(f'{user.tg}_invite'.encode()).hexdigest()[:8].upper()
        
        # ç»Ÿè®¡é‚€è¯·æ•°æ®
        total_invites = InviteRecord.query.filter_by(inviter_tg=user.tg).count()
        successful_invites = InviteRecord.query.filter_by(
            inviter_tg=user.tg,
            reward_claimed=True
        ).count()
        
        # è®¡ç®—æ€»å¥–åŠ±
        total_rewards = db.session.query(
            func.sum(InviteRecord.reward_value)
        ).filter(
            InviteRecord.inviter_tg == user.tg,
            InviteRecord.reward_claimed == True
        ).scalar() or 0
        
        # è®¡ç®—å¾…å®¡æ ¸å¥–åŠ±
        pending_rewards = db.session.query(
            func.sum(InviteRecord.pending_reward)
        ).filter(
            InviteRecord.inviter_tg == user.tg,
            InviteRecord.pending_reward > 0
        ).scalar() or 0
        
        # é‚€è¯·é“¾æ¥æŒ‡å‘æ³¨å†Œé¡µé¢
        invite_url = f'{request.host_url}register?invite={invite_code}'
        
        return jsonify({
            'success': True,
            'invite_code': invite_code,
            'invite_url': invite_url,
            'total_invites': total_invites,
            'successful_invites': successful_invites,
            'total_rewards': total_rewards,
            'pending_rewards': pending_rewards
        }), 200
        
    except Exception as e:
        app.logger.error(f'è·å–é‚€è¯·ç å¤±è´¥: {e}')
        return jsonify({'error': str(e)}), 500


@app.route('/api/invite/records', methods=['GET'])
@login_required
def get_invite_records():
    """è·å–é‚€è¯·è®°å½•"""
    try:
        user = db.session.get(User, session.get('user_id'))
        records = InviteRecord.query.filter_by(inviter_tg=user.tg).order_by(
            InviteRecord.created_at.desc()
        ).all()
        
        return jsonify({
            'success': True,
            'records': [record.to_dict() for record in records]
        }), 200
    except Exception as e:
        app.logger.error(f'è·å–é‚€è¯·è®°å½•å¤±è´¥: {e}')
        return jsonify({'error': str(e)}), 500


# ==================== Telegram ç»‘å®š API ====================
# å­˜å‚¨ä¸´æ—¶ç»‘å®šç  {bind_code: {'user_tg': xxx, 'created_at': datetime, 'expires_at': datetime}}
TELEGRAM_BIND_CODES = {}

# å­˜å‚¨ç­¾åˆ°éªŒè¯ç  {telegram_user_id: {'code': '1234', 'created_at': datetime, 'expires_at': datetime}}
TELEGRAM_CHECKIN_CODES = {}

# Telegram Webhook æ¶ˆæ¯å»é‡ç¼“å­˜ï¼ˆé˜²æ­¢é‡å¤æ¨é€å¯¼è‡´é‡å¤å›å¤ï¼‰
# ç”¨ message_id+chat_id åšå»é‡ï¼ˆåŒä¸€æ¶ˆæ¯å¯èƒ½ä»¥ä¸åŒ update_id æ¨é€å¤šæ¬¡ï¼‰
_PROCESSED_MSG_KEYS = set()
_PROCESSED_MSG_KEYS_MAX = 500
_PROCESSED_MSG_KEYS_LOCK = threading.Lock()

# å­˜å‚¨å¿˜è®°å¯†ç éªŒè¯ç  {username: {'code': '1234', 'telegram_id': xxx, 'created_at': datetime, 'expires_at': datetime}}
PASSWORD_RESET_CODES = {}

# å­˜å‚¨é‚®ç®±éªŒè¯ç  {email_or_key: {'code': '1234', 'user_tg': xxx, 'created_at': datetime, 'expires_at': datetime}}
EMAIL_VERIFY_CODES = {}


def cleanup_expired_bind_codes():
    """æ¸…ç†è¿‡æœŸçš„ç»‘å®šç ã€é‚®ç®±éªŒè¯ç å’Œå¯†ç é‡ç½®ç """
    now = datetime.now()
    expired = [code for code, data in TELEGRAM_BIND_CODES.items() 
               if data.get('expires_at') and data['expires_at'] < now]
    for code in expired:
        del TELEGRAM_BIND_CODES[code]
    
    # åŒæ—¶æ¸…ç†è¿‡æœŸçš„é‚®ç®±éªŒè¯ç 
    expired_email = [key for key, data in EMAIL_VERIFY_CODES.items()
                     if data.get('expires_at') and data['expires_at'] < now]
    for key in expired_email:
        del EMAIL_VERIFY_CODES[key]
    
    # æ¸…ç†è¿‡æœŸçš„å¯†ç é‡ç½®éªŒè¯ç 
    expired_reset = [key for key, data in PASSWORD_RESET_CODES.items()
                     if data.get('expires_at') and data['expires_at'] < now]
    for key in expired_reset:
        del PASSWORD_RESET_CODES[key]


@app.route('/api/user/telegram', methods=['GET'])
@login_required
def get_telegram_bindinfo():
    """è·å–å½“å‰ç”¨æˆ·çš„ Telegram ç»‘å®šçŠ¶æ€"""
    try:
        user = db.session.get(User, session.get('user_id'))
        if not user:
            return jsonify({'success': False, 'error': 'ç”¨æˆ·æœªæ‰¾åˆ°'}), 404
        
        return jsonify({
            'success': True,
            'telegram_id': user.telegram_id,
            'is_bound': user.telegram_id is not None
        }), 200
    except Exception as e:
        app.logger.error(f'è·å– Telegram ç»‘å®šçŠ¶æ€å¤±è´¥: {e}')
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/user/telegram/bindcode', methods=['POST'])
@login_required
def generate_telegram_bind_code():
    """ç”Ÿæˆ Telegram ç»‘å®šç ï¼ˆç”¨æˆ·åœ¨ç½‘ç«™ç‚¹å‡»ç»‘å®šæŒ‰é’®åè·å–ï¼‰"""
    try:
        user = db.session.get(User, session.get('user_id'))
        if not user:
            return jsonify({'success': False, 'error': 'ç”¨æˆ·æœªæ‰¾åˆ°'}), 404
        
        if user.telegram_id:
            return jsonify({'success': False, 'error': 'æ‚¨å·²ç»‘å®š Telegramï¼Œè¯·å…ˆè§£ç»‘'}), 400
        
        # è·å–æ˜¯å¦å¼ºåˆ¶é‡æ–°ç”Ÿæˆå‚æ•°
        force_regenerate = request.json.get('force_regenerate', False) if request.json else False
        
        # è·å– Bot ç”¨æˆ·å
        bot_username = None
        if TELEGRAM_BOT_TOKEN:
            try:
                url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/getMe"
                resp = PROXY_SESSION.get(url, timeout=10)
                if resp.status_code == 200:
                    bot_info = resp.json()
                    if bot_info.get('ok'):
                        bot_username = bot_info.get('result', {}).get('username')
            except Exception as e:
                app.logger.warning(f'è·å– Bot ä¿¡æ¯å¤±è´¥: {e}')
        
        # æ¸…ç†è¿‡æœŸçš„ç»‘å®šç 
        cleanup_expired_bind_codes()
        
        # å¦‚æœä¸æ˜¯å¼ºåˆ¶é‡æ–°ç”Ÿæˆï¼Œæ£€æŸ¥æ˜¯å¦å·²æœ‰æœªè¿‡æœŸçš„ç»‘å®šç 
        if not force_regenerate:
            for code, data in TELEGRAM_BIND_CODES.items():
                if data.get('user_tg') == user.tg:
                    # è¿”å›ç°æœ‰çš„ç»‘å®šç 
                    return jsonify({
                        'success': True,
                        'bind_code': code,
                        'expires_in': 300,  # 5åˆ†é’Ÿ
                        'bot_username': bot_username
                    }), 200
        else:
            # å¼ºåˆ¶é‡æ–°ç”Ÿæˆï¼šåˆ é™¤è¯¥ç”¨æˆ·çš„æ‰€æœ‰æ—§ç»‘å®šç 
            codes_to_remove = [code for code, data in TELEGRAM_BIND_CODES.items() if data.get('user_tg') == user.tg]
            for code in codes_to_remove:
                del TELEGRAM_BIND_CODES[code]
                app.logger.info(f'å·²åˆ é™¤ç”¨æˆ· {user.name} çš„æ—§ç»‘å®šç : {code}')
        
        # ç”Ÿæˆæ–°çš„ç»‘å®šç ï¼ˆ6ä½æ•°å­—+å­—æ¯ï¼‰
        import random
        import string
        bind_code = ''.join(random.choices(string.ascii_uppercase + string.digits, k=6))
        
        # ç¡®ä¿å”¯ä¸€
        while bind_code in TELEGRAM_BIND_CODES:
            bind_code = ''.join(random.choices(string.ascii_uppercase + string.digits, k=6))
        
        # å­˜å‚¨ç»‘å®šç ï¼Œ5åˆ†é’Ÿæœ‰æ•ˆ
        TELEGRAM_BIND_CODES[bind_code] = {
            'user_tg': user.tg,
            'user_name': user.name,
            'created_at': datetime.now(),
            'expires_at': datetime.now() + timedelta(minutes=5)
        }
        
        app.logger.info(f'ç”¨æˆ· {user.name} ç”Ÿæˆ Telegram ç»‘å®šç : {bind_code} (å¼ºåˆ¶é‡æ–°ç”Ÿæˆ: {force_regenerate})')
        
        return jsonify({
            'success': True,
            'bind_code': bind_code,
            'expires_in': 300,  # 5åˆ†é’Ÿ
            'bot_username': bot_username
        }), 200
        
    except Exception as e:
        app.logger.error(f'ç”Ÿæˆç»‘å®šç å¤±è´¥: {e}')
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/user/telegram/bind', methods=['POST'])
@login_required
def bind_telegram_id():
    """ç»‘å®š Telegram IDï¼ˆä¿ç•™æ—§æ¥å£å…¼å®¹ï¼‰"""
    try:
        user = db.session.get(User, session.get('user_id'))
        if not user:
            return jsonify({'success': False, 'error': 'ç”¨æˆ·æœªæ‰¾åˆ°'}), 404
        
        data = request.json or {}
        telegram_id = data.get('telegram_id')
        
        if not telegram_id:
            return jsonify({'success': False, 'error': 'è¯·è¾“å…¥ Telegram ID'}), 400
        
        # éªŒè¯ Telegram ID æ ¼å¼ï¼ˆå¿…é¡»æ˜¯æ•°å­—ï¼‰
        try:
            telegram_id = int(telegram_id)
        except ValueError:
            return jsonify({'success': False, 'error': 'Telegram ID å¿…é¡»æ˜¯æ•°å­—'}), 400
        
        # æ£€æŸ¥æ˜¯å¦å·²è¢«å…¶ä»–ç”¨æˆ·ç»‘å®š
        existing = User.query.filter(
            User.telegram_id == telegram_id,
            User.tg != user.tg
        ).first()
        if existing:
            return jsonify({'success': False, 'error': 'è¯¥ Telegram ID å·²è¢«å…¶ä»–ç”¨æˆ·ç»‘å®š'}), 400
        
        # ç»‘å®š Telegram ID
        user.telegram_id = telegram_id
        db.session.commit()
        
        app.logger.info(f'ç”¨æˆ· {user.name} ç»‘å®š Telegram ID: {telegram_id}')
        
        return jsonify({
            'success': True,
            'message': 'Telegram ç»‘å®šæˆåŠŸ',
            'telegram_id': telegram_id
        }), 200
        
    except Exception as e:
        db.session.rollback()
        app.logger.error(f'ç»‘å®š Telegram å¤±è´¥: {e}')
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/user/telegram/unbind', methods=['POST'])
@login_required
def unbind_telegram_id():
    """è§£ç»‘ Telegram ID"""
    try:
        user = db.session.get(User, session.get('user_id'))
        if not user:
            return jsonify({'success': False, 'error': 'ç”¨æˆ·æœªæ‰¾åˆ°'}), 404
        
        if not user.telegram_id:
            return jsonify({'success': False, 'error': 'æ‚¨è¿˜æ²¡æœ‰ç»‘å®š Telegram'}), 400
        
        old_id = user.telegram_id
        user.telegram_id = None
        db.session.commit()
        
        app.logger.info(f'ç”¨æˆ· {user.name} è§£ç»‘ Telegram ID: {old_id}')
        
        return jsonify({
            'success': True,
            'message': 'Telegram è§£ç»‘æˆåŠŸ'
        }), 200
        
    except Exception as e:
        db.session.rollback()
        app.logger.error(f'è§£ç»‘ Telegram å¤±è´¥: {e}')
        return jsonify({'success': False, 'error': str(e)}), 500


# ==================== ç”¨æˆ·æ´»åŠ¨æ—¥å¿— API ====================
@app.route('/api/user/activity-logs', methods=['GET'])
@login_required
def get_my_activity_logs():
    """è·å–å½“å‰ç”¨æˆ·çš„æ´»åŠ¨æ—¥å¿—"""
    try:
        user = db.session.get(User, session.get('user_id'))
        if not user:
            return jsonify({'success': False, 'error': 'ç”¨æˆ·æœªæ‰¾åˆ°'}), 404
        
        app.logger.info(f'è·å–ç”¨æˆ·æ´»åŠ¨æ—¥å¿—: user_id={session.get("user_id")}, user_tg={user.tg}, user_name={user.name}')
        
        page = request.args.get('page', 1, type=int)
        per_page = min(request.args.get('per_page', 20, type=int), 50)
        action_type = request.args.get('action_type', '')
        days = request.args.get('days', '', type=str)
        
        query = UserActivityLog.query.filter_by(user_tg=user.tg)
        
        # æŒ‰æ“ä½œç±»å‹ç­›é€‰ï¼ˆæ”¯æŒåˆ†ç»„ç­›é€‰ï¼‰
        if action_type:
            # åˆ†ç»„æ˜ å°„ï¼šé€‰æ‹©æŸç±»å‹æ—¶ï¼ŒåŒæ—¶åŒ…å«ç›¸å…³å­ç±»å‹
            type_groups = {
                'login': ['login', 'logout', 'register', 'bind_telegram'],
                'password_change': ['password_change', 'password_reset', 'emby_password_reset'],
                'request_movie': ['request_movie', 'cancel_request'],
                'payment_success': ['payment_success', 'payment_failed', 'create_order'],
                'subscription_change': ['subscription_change', 'subscription_gift', 'subscription_reduce', 'level_change'],
                'emby_account_create': ['emby_account_create', 'emby_password_reset', 'playback_start'],
                'redeem_code': ['redeem_code', 'coin_change'],
            }
            group = type_groups.get(action_type, [action_type])
            query = query.filter(UserActivityLog.action_type.in_(group))
        
        # æŒ‰æ—¶é—´èŒƒå›´ç­›é€‰
        if days and days.isdigit():
            days_int = int(days)
            from datetime import datetime, timedelta
            start_date = datetime.now() - timedelta(days=days_int)
            query = query.filter(UserActivityLog.created_at >= start_date)
        
        # å…ˆæŸ¥è¯¢æ€»æ•°ç”¨äºè°ƒè¯•
        total_count = query.count()
        app.logger.info(f'ç”¨æˆ·æ´»åŠ¨æ—¥å¿—æŸ¥è¯¢: user_tg={user.tg}, total_count={total_count}, days={days}, action_type={action_type}')
        
        # æ’åºå’Œåˆ†é¡µ
        query = query.order_by(UserActivityLog.created_at.desc())
        pagination = query.paginate(page=page, per_page=per_page, error_out=False)
        
        logs = []
        for log in pagination.items:
            # è§£æ action_detail JSON å­—ç¬¦ä¸²
            action_detail = {}
            if log.action_detail:
                try:
                    import json
                    action_detail = json.loads(log.action_detail)
                except (json.JSONDecodeError, TypeError):
                    action_detail = {'raw': log.action_detail}
            
            # æ˜¾ç¤ºæ—¶é—´ï¼ˆæ•°æ®åº“å­˜å‚¨çš„æ˜¯æœ¬åœ°æ—¶é—´ï¼‰
            created_at_local = None
            if log.created_at:
                created_at_local = log.created_at.strftime('%Y-%m-%d %H:%M:%S')
            
            log_dict = {
                'id': log.id,
                'action_type': log.action_type,
                'action_detail': action_detail,
                'ip_address': log.ip_address,
                'status': log.status,
                'created_at': created_at_local
            }
            logs.append(log_dict)
        
        return jsonify({
            'success': True,
            'logs': logs,
            'pagination': {
                'page': page,
                'per_page': per_page,
                'total': pagination.total,
                'pages': pagination.pages
            }
        }), 200
    except Exception as e:
        app.logger.error(f'è·å–ç”¨æˆ·æ´»åŠ¨æ—¥å¿—å¤±è´¥: {e}')
        import traceback
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)}), 500


# ==================== ç­¾åˆ°ç³»ç»Ÿ API ====================

# â€”â€” éªŒè¯ç é¢‘ç‡é™åˆ¶å™¨ï¼ˆé˜²æ­¢è„šæœ¬åˆ·éªŒè¯ç æ¥å£ï¼‰ â€”â€”
_captcha_rate = {}   # {user_id: last_request_time}
_captcha_lock = Lock()
_captcha_last_cleanup = 0

@app.route('/api/user/captcha', methods=['GET'])
@login_required
def get_captcha():
    """ç”Ÿæˆ 4 ä½æ•°å­—å›¾ç‰‡éªŒè¯ç ï¼Œç­”æ¡ˆå­˜å…¥ sessionï¼Œå‰ç«¯æ‹¿åˆ° base64 å›¾ç‰‡"""
    import time as _time
    import base64 as _b64
    uid = session.get('user_id')
    now = _time.time()
    # åŒä¸€ç”¨æˆ· 2 ç§’å†…åªèƒ½è¯·æ±‚ä¸€æ¬¡
    with _captcha_lock:
        global _captcha_last_cleanup
        if now - _captcha_last_cleanup > 300:
            _captcha_last_cleanup = now
            _captcha_rate.clear()
        last = _captcha_rate.get(uid, 0)
        if now - last < 2:
            return jsonify({'success': False, 'error': 'è¯·æ±‚å¤ªé¢‘ç¹ï¼Œè¯·ç¨åå†è¯•'}), 429
        _captcha_rate[uid] = now

    # ç”Ÿæˆ 4 ä½éšæœºæ•°å­—
    code = ''.join([str(random.randint(0, 9)) for _ in range(4)])
    # ç”ŸæˆéªŒè¯ç å›¾ç‰‡
    img_io = _generate_web_captcha_image(code)
    if not img_io:
        return jsonify({'success': False, 'error': 'éªŒè¯ç ç”Ÿæˆå¤±è´¥'}), 500
    img_b64 = _b64.b64encode(img_io.getvalue()).decode('ascii')

    # ç­”æ¡ˆ + æ—¶é—´æˆ³å­˜å…¥ session
    session['_captcha_answer'] = code
    session['_captcha_ts'] = now
    return jsonify({'success': True, 'image': f'data:image/png;base64,{img_b64}'})


def _generate_web_captcha_image(code):
    """ä¸º Web ç«¯ç”Ÿæˆå¸¦å¹²æ‰°çš„ 4 ä½æ•°å­—éªŒè¯ç å›¾ç‰‡ï¼Œè¿”å› BytesIO"""
    try:
        width, height = 200, 70
        image = Image.new('RGB', (width, height), color=(245, 245, 245))
        draw = ImageDraw.Draw(image)

        # éšæœºèƒŒæ™¯è‰²å—
        for _ in range(6):
            x0 = random.randint(0, width)
            y0 = random.randint(0, height)
            x1 = x0 + random.randint(20, 60)
            y1 = y0 + random.randint(10, 30)
            fill = (random.randint(220, 250), random.randint(220, 250), random.randint(220, 250))
            draw.rectangle([x0, y0, x1, y1], fill=fill)

        # å¹²æ‰°çº¿
        for _ in range(random.randint(4, 6)):
            x1, y1 = random.randint(0, width), random.randint(0, height)
            x2, y2 = random.randint(0, width), random.randint(0, height)
            color = (random.randint(150, 210), random.randint(150, 210), random.randint(150, 210))
            draw.line([(x1, y1), (x2, y2)], fill=color, width=random.randint(1, 2))

        # å¹²æ‰°ç‚¹
        for _ in range(80):
            x, y = random.randint(0, width - 1), random.randint(0, height - 1)
            draw.point((x, y), fill=(random.randint(120, 200), random.randint(120, 200), random.randint(120, 200)))

        # åŠ è½½å­—ä½“
        font = None
        font_size = 42
        for fp in [
            '/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf',
            '/usr/share/fonts/truetype/liberation/LiberationMono-Bold.ttf',
            'arial.ttf',
            'C:/Windows/Fonts/arial.ttf',
        ]:
            try:
                font = ImageFont.truetype(fp, font_size)
                break
            except (OSError, IOError):
                continue
        if font is None:
            font = ImageFont.load_default()

        # é€å­—ç»˜åˆ¶ï¼ˆéšæœºé¢œè‰² + éšæœºåç§» + éšæœºæ—‹è½¬ï¼‰
        char_w = width // (len(code) + 1)
        for i, ch in enumerate(code):
            # åˆ›å»ºå•å­—ç¬¦é€æ˜å›¾å±‚ç”¨äºæ—‹è½¬
            txt_img = Image.new('RGBA', (char_w + 10, height), (0, 0, 0, 0))
            txt_draw = ImageDraw.Draw(txt_img)
            color = (random.randint(20, 120), random.randint(20, 120), random.randint(20, 120))
            try:
                bbox = txt_draw.textbbox((0, 0), ch, font=font)
                tw, th = bbox[2] - bbox[0], bbox[3] - bbox[1]
            except AttributeError:
                tw, th = txt_draw.textsize(ch, font=font)
            txt_draw.text(((char_w + 10 - tw) // 2, (height - th) // 2 + random.randint(-6, 6)),
                          ch, font=font, fill=color)
            angle = random.randint(-18, 18)
            txt_img = txt_img.rotate(angle, expand=False, resample=Image.BICUBIC)
            # ç²˜è´´åˆ°ä¸»å›¾
            x_offset = char_w * i + random.randint(8, 14)
            image.paste(txt_img, (x_offset, 0), txt_img)

        bio = BytesIO()
        image.save(bio, format='PNG')
        bio.seek(0)
        return bio
    except Exception as e:
        app.logger.error(f'ç”Ÿæˆ Web éªŒè¯ç å›¾ç‰‡å¤±è´¥: {e}')
        return None


def _verify_captcha(captcha_answer):
    """æ ¡éªŒéªŒè¯ç ï¼Œè¿”å› (ok, error_msg)ï¼›éªŒè¯åç«‹å³é”€æ¯"""
    import time as _time
    stored = session.pop('_captcha_answer', None)
    ts = session.pop('_captcha_ts', None)
    if stored is None or ts is None:
        return False, 'è¯·å…ˆè·å–éªŒè¯ç '
    if _time.time() - ts > 60:           # 1 åˆ†é’Ÿè¿‡æœŸ
        return False, 'éªŒè¯ç å·²è¿‡æœŸï¼Œè¯·é‡æ–°è·å–'
    if not captcha_answer or str(captcha_answer).strip() != str(stored):
        return False, 'éªŒè¯ç é”™è¯¯'
    return True, ''


@app.route('/api/user/checkin', methods=['POST'])
@login_required
def user_checkin():
    """ç”¨æˆ·ç­¾åˆ°"""
    try:
        # â€”â€” åç«¯éªŒè¯ç æ ¡éªŒ â€”â€”
        data = request.get_json(silent=True) or {}
        captcha_answer = data.get('captcha_answer')
        ok, err = _verify_captcha(captcha_answer)
        if not ok:
            return jsonify({'success': False, 'error': err}), 400

        user = db.session.get(User, session.get('user_id'))
        if not user:
            return jsonify({'success': False, 'error': 'ç”¨æˆ·æœªæ‰¾åˆ°'}), 404
        
        # è·å–ç­¾åˆ°é…ç½®
        checkin_config = SystemConfig.get_config(SystemConfig.KEY_CHECKIN, {})
        if not checkin_config.get('enabled', False):
            return jsonify({'success': False, 'error': 'ç­¾åˆ°åŠŸèƒ½æœªå¼€å¯'}), 400
        
        # ç­¾åˆ°æƒé™æ£€æŸ¥
        checkin_perm = checkin_config.get('checkin_permission', 'all')
        if checkin_perm == 'none':
            return jsonify({'success': False, 'error': 'ç®¡ç†å‘˜å·²å…³é—­ç­¾åˆ°åŠŸèƒ½'}), 403
        if checkin_perm == 'subscribed':
            if not user.ex or user.ex < datetime.now():
                return jsonify({'success': False, 'error': 'ä»…é™æœ‰è®¢é˜…çš„ç”¨æˆ·ç­¾åˆ°ï¼Œè¯·å…ˆè®¢é˜…åå†æ¥ç­¾åˆ°'}), 403
        
        # æ£€æŸ¥ä»Šå¤©æ˜¯å¦å·²ç­¾åˆ°
        today = datetime.now().date()
        existing = CheckInRecord.query.filter_by(
            user_tg=user.tg,
            checkin_date=today
        ).first()
        
        if existing:
            return jsonify({
                'success': False,
                'error': 'ä»Šå¤©å·²ç»ç­¾åˆ°è¿‡äº†',
                'coins_earned': existing.coins_earned,
                'continuous_days': existing.continuous_days
            }), 400
        
        # è®¡ç®—è¿ç»­ç­¾åˆ°å¤©æ•°
        yesterday = today - timedelta(days=1)
        yesterday_record = CheckInRecord.query.filter_by(
            user_tg=user.tg,
            checkin_date=yesterday
        ).first()
        
        continuous_days = (yesterday_record.continuous_days + 1) if yesterday_record else 1
        
        # éšæœºç”Ÿæˆç­¾åˆ°ç§¯åˆ†
        coin_min = checkin_config.get('coin_min', 1)
        coin_max = checkin_config.get('coin_max', 10)
        coins_earned = random.randint(coin_min, coin_max)
        
        # åˆ›å»ºç­¾åˆ°è®°å½•
        checkin_record = CheckInRecord(
            user_tg=user.tg,
            checkin_date=today,
            coins_earned=coins_earned,
            continuous_days=continuous_days
        )
        db.session.add(checkin_record)
        
        # æ›´æ–°ç”¨æˆ·ç§¯åˆ†å’Œç­¾åˆ°æ—¶é—´
        user.coins = (user.coins or 0) + coins_earned
        user.ch = datetime.now()
        
        # åˆ›å»ºç§¯åˆ†äº¤æ˜“è®°å½•
        coin_trans = CoinTransaction(
            user_tg=user.tg,
            amount=coins_earned,
            balance_after=user.coins,
            trans_type='checkin',
            description=f'æ¯æ—¥ç­¾åˆ°ï¼Œè¿ç»­{continuous_days}å¤©',
            related_id=checkin_record.id
        )
        db.session.add(coin_trans)
        
        db.session.commit()
        
        app.logger.info(f'ç”¨æˆ·ç­¾åˆ°æˆåŠŸ: {user.name}, è·å¾—ç§¯åˆ†: {coins_earned}, è¿ç»­{continuous_days}å¤©')
        
        return jsonify({
            'success': True,
            'message': f'ç­¾åˆ°æˆåŠŸï¼è·å¾— {coins_earned} {checkin_config.get("coin_name", "ç§¯åˆ†")}',
            'coins_earned': coins_earned,
            'coin_name': checkin_config.get('coin_name', 'ç§¯åˆ†'),
            'continuous_days': continuous_days,
            'total_coins': user.coins
        }), 200
    except Exception as e:
        app.logger.error(f'ç­¾åˆ°å¤±è´¥: {e}')
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/user/checkin/status', methods=['GET'])
@login_required
def get_checkin_status():
    """è·å–ç”¨æˆ·ç­¾åˆ°çŠ¶æ€"""
    try:
        user = db.session.get(User, session.get('user_id'))
        if not user:
            return jsonify({'success': False, 'error': 'ç”¨æˆ·æœªæ‰¾åˆ°'}), 404
        
        # è·å–ç­¾åˆ°é…ç½®
        checkin_config = SystemConfig.get_config(SystemConfig.KEY_CHECKIN, {})
        
        # è·å–å¥—é¤é…ç½®ï¼Œç”¨äºä¿®æ­£æ—§çš„ exchange_plans æ•°æ®
        plans_config = load_plans_config()
        plans_dict = {p.get('id'): p for p in plans_config}
        
        # å¤„ç†å…‘æ¢å¥—é¤ï¼Œä¿®æ­£æ—§æ•°æ®ä¸­çš„ days å­—æ®µ
        exchange_plans = checkin_config.get('exchange_plans', [])
        fixed_exchange_plans = []
        for ep in exchange_plans:
            plan_id = ep.get('id')
            days = ep.get('days', 0)
            # å¦‚æœ days å¾ˆå°ï¼ˆå¯èƒ½æ˜¯æ—§çš„æœˆæ•°æ•°æ®ï¼‰ï¼Œå°è¯•ä»å¥—é¤é…ç½®ä¸­è·å–æ­£ç¡®çš„å¤©æ•°
            if days <= 12 and plan_id in plans_dict:
                plan = plans_dict[plan_id]
                # ä¼˜å…ˆä½¿ç”¨ duration_daysï¼Œå¦åˆ™ç”¨ durationï¼ˆæœˆï¼‰* 30
                correct_days = plan.get('duration_days') or (plan.get('duration', 1) * 30)
                days = correct_days
            fixed_exchange_plans.append({
                'id': plan_id,
                'name': ep.get('name', ''),
                'days': days,
                'coins': ep.get('coins', 0)
            })
        
        # æ„å»ºé…ç½®å“åº” - éœ€è¦åŒ…å« enabled å­—æ®µä¾›å‰ç«¯åˆ¤æ–­
        checkin_perm = checkin_config.get('checkin_permission', 'all')
        has_subscription = bool(user.ex and user.ex > datetime.now())
        can_checkin = True
        checkin_hint = ''
        if checkin_perm == 'none':
            can_checkin = False
            checkin_hint = 'ç®¡ç†å‘˜å·²å…³é—­ç­¾åˆ°åŠŸèƒ½'
        elif checkin_perm == 'subscribed' and not has_subscription:
            can_checkin = False
            checkin_hint = 'ä»…é™æœ‰è®¢é˜…çš„ç”¨æˆ·ç­¾åˆ°ï¼Œè¯·å…ˆè®¢é˜…åå†æ¥ç­¾åˆ°'
        
        config_response = {
            'enabled': checkin_config.get('enabled', False),
            'coin_name': checkin_config.get('coin_name', 'ç§¯åˆ†'),
            'coin_min': checkin_config.get('coin_min', 1),
            'coin_max': checkin_config.get('coin_max', 10),
            'exchange_plans': fixed_exchange_plans,
            'checkin_permission': checkin_perm,
            'can_checkin': can_checkin,
            'checkin_hint': checkin_hint
        }
        
        # å¦‚æœç­¾åˆ°åŠŸèƒ½æœªå¼€å¯ï¼Œè¿”å›ç©ºçŠ¶æ€
        if not checkin_config.get('enabled', False):
            return jsonify({
                'success': True,
                'config': config_response,
                'status': {
                    'coins': 0,
                    'continuous_days': 0,
                    'monthly_count': 0,
                    'checked_today': False,
                    'recent_7days': []
                }
            }), 200
        
        # æ£€æŸ¥ä»Šå¤©æ˜¯å¦å·²ç­¾åˆ°
        today = datetime.now().date()
        today_record = CheckInRecord.query.filter_by(
            user_tg=user.tg,
            checkin_date=today
        ).first()
        
        # è·å–è¿ç»­ç­¾åˆ°å¤©æ•°
        continuous_days = 0
        if today_record:
            continuous_days = today_record.continuous_days
        else:
            yesterday = today - timedelta(days=1)
            yesterday_record = CheckInRecord.query.filter_by(
                user_tg=user.tg,
                checkin_date=yesterday
            ).first()
            if yesterday_record:
                continuous_days = yesterday_record.continuous_days
        
        # è·å–æœ¬æœˆç­¾åˆ°æ¬¡æ•°
        month_start = today.replace(day=1)
        monthly_count = CheckInRecord.query.filter(
            CheckInRecord.user_tg == user.tg,
            CheckInRecord.checkin_date >= month_start
        ).count()
        
        # è·å–æœ€è¿‘7å¤©ç­¾åˆ°è®°å½•
        week_ago = today - timedelta(days=6)
        week_records = CheckInRecord.query.filter(
            CheckInRecord.user_tg == user.tg,
            CheckInRecord.checkin_date >= week_ago,
            CheckInRecord.checkin_date <= today
        ).all()
        recent_7days = [r.checkin_date.isoformat() for r in week_records]
        
        return jsonify({
            'success': True,
            'config': config_response,
            'status': {
                'coins': user.coins or 0,
                'continuous_days': continuous_days,
                'monthly_count': monthly_count,
                'checked_today': today_record is not None,
                'recent_7days': recent_7days
            }
        }), 200
    except Exception as e:
        app.logger.error(f'è·å–ç­¾åˆ°çŠ¶æ€å¤±è´¥: {e}')
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/user/coins/transactions', methods=['GET'])
@login_required
def get_coin_transactions():
    """è·å–ç§¯åˆ†äº¤æ˜“è®°å½•"""
    try:
        user = db.session.get(User, session.get('user_id'))
        if not user:
            return jsonify({'success': False, 'error': 'ç”¨æˆ·æœªæ‰¾åˆ°'}), 404
        
        page = request.args.get('page', 1, type=int)
        per_page = min(request.args.get('per_page', 20, type=int), 50)
        
        pagination = CoinTransaction.query.filter_by(user_tg=user.tg)\
            .order_by(CoinTransaction.created_at.desc())\
            .paginate(page=page, per_page=per_page, error_out=False)
        
        transactions = [{
            'id': t.id,
            'amount': t.amount,
            'balance_after': t.balance_after,
            'trans_type': t.trans_type,
            'description': t.description,
            'created_at': t.created_at.isoformat() if t.created_at else None
        } for t in pagination.items]
        
        return jsonify({
            'success': True,
            'transactions': transactions,
            'pagination': {
                'page': page,
                'per_page': per_page,
                'total': pagination.total,
                'pages': pagination.pages
            }
        }), 200
    except Exception as e:
        app.logger.error(f'è·å–ç§¯åˆ†è®°å½•å¤±è´¥: {e}')
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/user/exchange', methods=['POST'])
@login_required
def exchange_plan():
    """å…‘æ¢å¥—é¤"""
    try:
        # â€”â€” åç«¯éªŒè¯ç æ ¡éªŒ â€”â€”
        data = request.get_json(silent=True) or {}
        captcha_answer = data.get('captcha_answer')
        ok, err = _verify_captcha(captcha_answer)
        if not ok:
            return jsonify({'success': False, 'error': err}), 400

        # åŠ è¡Œé”è¯»å–ç”¨æˆ·ï¼ˆé˜²æ­¢å¹¶å‘å…‘æ¢å¯¼è‡´ç§¯åˆ†æ‰£æˆè´Ÿæ•°ï¼‰
        is_mysql = 'mysql' in app.config.get('SQLALCHEMY_DATABASE_URI', '')
        uid = session.get('user_id')
        if is_mysql:
            user = User.query.filter_by(tg=uid).with_for_update().first()
        else:
            user = db.session.get(User, uid)
        if not user:
            return jsonify({'success': False, 'error': 'ç”¨æˆ·æœªæ‰¾åˆ°'}), 404
        
        plan_id = data.get('plan_id')
        
        if not plan_id:
            return jsonify({'success': False, 'error': 'è¯·é€‰æ‹©è¦å…‘æ¢çš„å¥—é¤'}), 400
        
        # è·å–ç­¾åˆ°é…ç½®å’Œå¥—é¤é…ç½®
        checkin_config = SystemConfig.get_config(SystemConfig.KEY_CHECKIN, {})
        if not checkin_config.get('enabled', False):
            return jsonify({'success': False, 'error': 'ç­¾åˆ°åŠŸèƒ½æœªå¼€å¯'}), 400
        
        exchange_plans = checkin_config.get('exchange_plans', [])
        plan = next((p for p in exchange_plans if p.get('id') == plan_id), None)
        
        if not plan:
            return jsonify({'success': False, 'error': 'å¥—é¤ä¸å­˜åœ¨'}), 404
        
        coins_cost = plan.get('coins', 0)
        duration_days = plan.get('days', 0)
        plan_name = plan.get('name', 'æœªçŸ¥å¥—é¤')
        
        # æ£€æŸ¥ç§¯åˆ†æ˜¯å¦è¶³å¤Ÿ
        user_coins = user.coins or 0
        if user_coins < coins_cost:
            return jsonify({
                'success': False,
                'error': f'ç§¯åˆ†ä¸è¶³ï¼Œéœ€è¦ {coins_cost} {checkin_config.get("coin_name", "ç§¯åˆ†")}ï¼Œå½“å‰ä»…æœ‰ {user_coins}'
            }), 400
        
        # æ‰£é™¤ç§¯åˆ†
        user.coins -= coins_cost
        
        # å»¶é•¿è®¢é˜…æ—¶é—´
        now = datetime.now()
        if user.ex and user.ex > now:
            # æœ‰æœªè¿‡æœŸçš„è®¢é˜…ï¼Œå»¶é•¿æ—¶é—´
            user.ex = user.ex + timedelta(days=duration_days)
        else:
            # æ— è®¢é˜…æˆ–å·²è¿‡æœŸï¼Œä»ç°åœ¨å¼€å§‹è®¡ç®—
            user.ex = now + timedelta(days=duration_days)
        
        # æ— è´¦å·ç”¨æˆ·å‡çº§ä¸ºæ™®é€šç”¨æˆ·ï¼Œå°ç¦ç”¨æˆ·ä¿æŒå°ç¦çŠ¶æ€
        if user.lv not in ['a', 'b', 'c']:
            user.lv = 'b'
        
        # æ›´æ–°æˆ–åˆ›å»º Subscription è®°å½•ï¼ˆç¡®ä¿ç”¨æˆ·æœ‰æœ‰æ•ˆçš„è®¢é˜…çŠ¶æ€ï¼‰
        existing_sub = Subscription.query.filter_by(
            user_tg=user.tg, status='active'
        ).order_by(Subscription.end_date.desc()).first()
        if existing_sub:
            # æ›´æ–°ç°æœ‰è®¢é˜…çš„åˆ°æœŸæ—¶é—´
            existing_sub.end_date = user.ex
            existing_sub.updated_at = now
        else:
            # åˆ›å»ºæ–°çš„è®¢é˜…è®°å½•
            new_sub = Subscription(
                user_tg=user.tg,
                plan_type='custom',
                plan_name=f'ç§¯åˆ†å…‘æ¢: {plan_name}',
                duration_months=0,
                price=0,
                start_date=now,
                end_date=user.ex,
                status='active',
                source='manual'
            )
            db.session.add(new_sub)
        
        # åˆ›å»ºå…‘æ¢è®°å½•
        exchange_record = ExchangeRecord(
            user_tg=user.tg,
            plan_id=plan_id,
            plan_name=plan_name,
            coins_cost=coins_cost,
            duration_days=duration_days,
            status='completed'
        )
        db.session.add(exchange_record)
        
        # åˆ›å»ºç§¯åˆ†äº¤æ˜“è®°å½•
        coin_trans = CoinTransaction(
            user_tg=user.tg,
            amount=-coins_cost,
            balance_after=user.coins,
            trans_type='exchange',
            description=f'å…‘æ¢å¥—é¤: {plan_name} ({duration_days}å¤©)',
            related_id=exchange_record.id
        )
        db.session.add(coin_trans)
        
        db.session.commit()
        
        # å…ˆå–å€¼ä¾›åå°çº¿ç¨‹å’Œè¿”å›ä½¿ç”¨
        _remaining_coins = user.coins
        _new_expiry = user.ex.isoformat() if user.ex else None
        _emby_id = user.embyid
        _user_name = user.name
        _user_lv = user.lv
        _user_ban_reason = user.ban_reason
        
        app.logger.info(f'ç”¨æˆ·å…‘æ¢å¥—é¤æˆåŠŸ: {_user_name}, å¥—é¤: {plan_name}, èŠ±è´¹: {coins_cost}ç§¯åˆ†')
        
        # â€”â€” Emby API è°ƒç”¨æ”¾å…¥åå°çº¿ç¨‹ï¼Œä¸é˜»å¡ä¸»è¯·æ±‚ï¼ˆå°ç¦ç”¨æˆ·å’Œé»‘åå•ç¦ç”¨ç”¨æˆ·ä¸è‡ªåŠ¨æ¢å¤ï¼‰ â€”â€”
        if _user_lv != 'c' and not _user_ban_reason and _emby_id and emby_client.is_enabled():
            def _restore_emby():
                with app.app_context():
                    if emby_client.enable_user(_emby_id):
                        app.logger.info(f'ç”¨æˆ· {_user_name} ç§¯åˆ†å…‘æ¢æˆåŠŸï¼Œå·²æ¢å¤Embyè´¦å·')
            Thread(target=_restore_emby, daemon=True).start()
        
        return jsonify({
            'success': True,
            'message': f'å…‘æ¢æˆåŠŸï¼å·²å»¶é•¿ {duration_days} å¤©è®¢é˜…',
            'remaining_coins': _remaining_coins,
            'new_expiry': _new_expiry
        }), 200
    except Exception as e:
        app.logger.error(f'å…‘æ¢å¥—é¤å¤±è´¥: {e}')
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/user/exchange/records', methods=['GET'])
@login_required
def get_exchange_records():
    """è·å–å…‘æ¢è®°å½•"""
    try:
        user = db.session.get(User, session.get('user_id'))
        if not user:
            return jsonify({'success': False, 'error': 'ç”¨æˆ·æœªæ‰¾åˆ°'}), 404
        
        page = request.args.get('page', 1, type=int)
        per_page = min(request.args.get('per_page', 20, type=int), 50)
        
        pagination = ExchangeRecord.query.filter_by(user_tg=user.tg)\
            .order_by(ExchangeRecord.created_at.desc())\
            .paginate(page=page, per_page=per_page, error_out=False)
        
        records = [{
            'id': r.id,
            'plan_name': r.plan_name,
            'coins_cost': r.coins_cost,
            'duration_days': r.duration_days,
            'status': r.status,
            'created_at': r.created_at.isoformat() if r.created_at else None
        } for r in pagination.items]
        
        return jsonify({
            'success': True,
            'records': records,
            'pagination': {
                'page': page,
                'per_page': per_page,
                'total': pagination.total,
                'pages': pagination.pages
            }
        }), 200
    except Exception as e:
        app.logger.error(f'è·å–å…‘æ¢è®°å½•å¤±è´¥: {e}')
        return jsonify({'success': False, 'error': str(e)}), 500


# ==================== æŠ€æœ¯æ”¯æŒ API ====================
@app.route('/api/support/create', methods=['POST'])
@login_required
def create_support_ticket():
    """åˆ›å»ºæ”¯æŒå·¥å•"""
    try:
        data = request.json
        user = db.session.get(User, session.get('user_id'))
        
        # ç”Ÿæˆå·¥å•å·
        ticket_no = f'TK{int(time.time())}{user.tg % 1000}'
        
        ticket = SupportTicket(
            ticket_no=ticket_no,
            user_tg=user.tg,
            category=data.get('category', 'other'),
            subject=data.get('subject', ''),
            description=data.get('description', ''),
            priority=data.get('priority', 'normal')
        )
        
        db.session.add(ticket)
        db.session.commit()
        
        app.logger.info(f'åˆ›å»ºå·¥å•: {ticket_no}, ç”¨æˆ·: {user.name}, ä¸»é¢˜: {ticket.subject}')
        
        # å‘é€ Telegram é€šçŸ¥ç»™ç®¡ç†å‘˜
        try:
            category_names = {
                'account': 'è´¦å·é—®é¢˜',
                'payment': 'æ”¯ä»˜é—®é¢˜',
                'technical': 'æŠ€æœ¯é—®é¢˜',
                'content': 'å†…å®¹é—®é¢˜',
                'other': 'å…¶ä»–'
            }
            priority_names = {
                'low': 'ä½',
                'normal': 'æ™®é€š',
                'high': 'é«˜',
                'urgent': 'ğŸš¨ ç´§æ€¥'
            }
            category_name = category_names.get(ticket.category, ticket.category)
            priority_name = priority_names.get(ticket.priority, ticket.priority)
            
            message = f"""ğŸ« <b>æ–°å·¥å•æé†’</b>

ğŸ“‹ <b>å·¥å•å·ï¼š</b>{ticket_no}
ğŸ‘¤ <b>ç”¨æˆ·ï¼š</b>{user.name}
ğŸ“ <b>åˆ†ç±»ï¼š</b>{category_name}
âš¡ <b>ä¼˜å…ˆçº§ï¼š</b>{priority_name}
ğŸ“Œ <b>ä¸»é¢˜ï¼š</b>{ticket.subject}

ğŸ“ <b>æè¿°ï¼š</b>
{ticket.description[:200]}{'...' if len(ticket.description) > 200 else ''}

ğŸ”— è¯·ç™»å½•åå°å¤„ç†å·¥å•"""
            
            send_admin_notification(message)
        except Exception as e:
            app.logger.error(f'å‘é€å·¥å•é€šçŸ¥å¤±è´¥: {e}')
        
        return jsonify({
            'success': True,
            'ticket': ticket.to_dict()
        }), 200
        
    except Exception as e:
        app.logger.error(f'åˆ›å»ºå·¥å•å¤±è´¥: {e}')
        db.session.rollback()
        return jsonify({'error': str(e)}), 500


@app.route('/api/support/my-tickets', methods=['GET'])
@login_required
def get_my_tickets():
    """è·å–æˆ‘çš„å·¥å•"""
    try:
        user = db.session.get(User, session.get('user_id'))
        tickets = SupportTicket.query.filter_by(user_tg=user.tg).order_by(
            SupportTicket.created_at.desc()
        ).all()
        
        return jsonify({
            'success': True,
            'tickets': [ticket.to_dict() for ticket in tickets]
        }), 200
    except Exception as e:
        app.logger.error(f'è·å–å·¥å•å¤±è´¥: {e}')
        return jsonify({'error': str(e)}), 500


@app.route('/api/support/unread-count', methods=['GET'])
@login_required
def get_unread_ticket_count():
    """è·å–ç”¨æˆ·æœªè¯»çš„å·¥å•å›å¤æ•°é‡ï¼ˆç®¡ç†å‘˜å›å¤åç”¨æˆ·æœªæŸ¥çœ‹çš„ï¼‰"""
    try:
        user = db.session.get(User, session.get('user_id'))
        # æŸ¥æ‰¾ç”¨æˆ·çš„å·¥å•ä¸­ï¼Œæœ€åå›å¤æ˜¯ç®¡ç†å‘˜ä¸”çŠ¶æ€æœªå…³é—­çš„æ•°é‡
        unread_count = SupportTicket.query.filter(
            SupportTicket.user_tg == user.tg,
            SupportTicket.last_reply_by == 'admin',
            SupportTicket.status != 'closed'
        ).count()
        
        return jsonify({
            'success': True,
            'unread_count': unread_count
        }), 200
    except Exception as e:
        app.logger.error(f'è·å–æœªè¯»å·¥å•æ•°å¤±è´¥: {e}')
        return jsonify({'error': str(e), 'unread_count': 0}), 500


@app.route('/api/support/tickets/<int:ticket_id>', methods=['GET'])
@login_required
def get_ticket_detail(ticket_id):
    """è·å–å·¥å•è¯¦æƒ…ï¼ˆåŒ…å«æ‰€æœ‰å¯¹è¯æ¶ˆæ¯ï¼‰"""
    try:
        user = db.session.get(User, session.get('user_id'))
        ticket = db.session.get(SupportTicket, ticket_id)
        
        if not ticket:
            return jsonify({'success': False, 'error': 'å·¥å•ä¸å­˜åœ¨'}), 404
        
        # éªŒè¯å·¥å•å½’å±
        if ticket.user_tg != user.tg:
            return jsonify({'success': False, 'error': 'æ— æƒé™æŸ¥çœ‹æ­¤å·¥å•'}), 403
        
        # ç”¨æˆ·æŸ¥çœ‹å·¥å•åï¼Œæ ‡è®°ä¸ºå·²è¯»ï¼ˆå°†last_reply_byæ”¹ä¸ºuserè¡¨ç¤ºç”¨æˆ·å·²æŸ¥çœ‹ï¼‰
        if ticket.last_reply_by == 'admin':
            ticket.last_reply_by = 'user'
            db.session.commit()
        
        return jsonify({
            'success': True,
            'ticket': ticket.to_dict(include_messages=True)
        }), 200
    except Exception as e:
        app.logger.error(f'è·å–å·¥å•è¯¦æƒ…å¤±è´¥: {e}')
        return jsonify({'error': str(e)}), 500


@app.route('/api/support/tickets/<int:ticket_id>/reply', methods=['POST'])
@login_required
def user_reply_ticket(ticket_id):
    """ç”¨æˆ·å›å¤å·¥å•"""
    try:
        user = db.session.get(User, session.get('user_id'))
        ticket = db.session.get(SupportTicket, ticket_id)
        
        if not ticket:
            return jsonify({'success': False, 'error': 'å·¥å•ä¸å­˜åœ¨'}), 404
        
        # éªŒè¯å·¥å•å½’å±
        if ticket.user_tg != user.tg:
            return jsonify({'success': False, 'error': 'æ— æƒé™æ“ä½œæ­¤å·¥å•'}), 403
        
        # æ£€æŸ¥å·¥å•çŠ¶æ€ï¼Œå·²å…³é—­çš„å·¥å•ä¸èƒ½å›å¤
        if ticket.status == 'closed':
            return jsonify({'success': False, 'error': 'å·¥å•å·²å…³é—­ï¼Œæ— æ³•å›å¤'}), 400
        
        data = request.json
        reply_content = data.get('reply', '').strip()
        
        if not reply_content:
            return jsonify({'success': False, 'error': 'å›å¤å†…å®¹ä¸èƒ½ä¸ºç©º'}), 400
        
        # åˆ›å»ºæ–°çš„æ¶ˆæ¯è®°å½•
        message = TicketMessage(
            ticket_id=ticket.id,
            sender_type='user',
            sender_id=user.tg,
            sender_name=user.name,
            content=reply_content
        )
        db.session.add(message)
        
        # ç”¨æˆ·å›å¤åï¼ŒçŠ¶æ€å˜ä¸ºå¾…å¤„ç†ï¼ˆç­‰å¾…ç®¡ç†å‘˜å›å¤ï¼‰
        ticket.status = 'open'
        ticket.last_reply_by = 'user'
        ticket.last_reply_at = datetime.now()
        
        db.session.commit()
        
        app.logger.info(f'ç”¨æˆ· {user.name} å›å¤å·¥å•: {ticket.ticket_no}')
        
        return jsonify({
            'success': True,
            'message': 'å›å¤æˆåŠŸ',
            'ticket': ticket.to_dict()
        }), 200
    except Exception as e:
        app.logger.error(f'ç”¨æˆ·å›å¤å·¥å•å¤±è´¥: {e}')
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/admin/tickets', methods=['GET'])
@admin_required
def admin_get_tickets():
    """ç®¡ç†å‘˜è·å–æ‰€æœ‰å·¥å•"""
    try:
        status = request.args.get('status', 'all')
        
        query = SupportTicket.query
        if status and status != 'all':
            query = query.filter_by(status=status)
        
        tickets = query.order_by(SupportTicket.created_at.desc()).all()
        
        # ç»Ÿè®¡å„çŠ¶æ€å·¥å•æ•°é‡
        stats = {
            'total': SupportTicket.query.count(),
            'open': SupportTicket.query.filter_by(status='open').count(),
            'in_progress': SupportTicket.query.filter_by(status='in_progress').count(),
            'closed': SupportTicket.query.filter_by(status='closed').count()
        }
        
        return jsonify({
            'success': True,
            'tickets': [ticket.to_dict() for ticket in tickets],
            'stats': stats
        }), 200
    except Exception as e:
        app.logger.error(f'è·å–å·¥å•å¤±è´¥: {e}')
        return jsonify({'error': str(e)}), 500


@app.route('/api/admin/tickets/<int:ticket_id>', methods=['GET'])
@admin_required
def admin_get_ticket_detail(ticket_id):
    """ç®¡ç†å‘˜è·å–å·¥å•è¯¦æƒ…ï¼ˆåŒ…å«æ‰€æœ‰å¯¹è¯æ¶ˆæ¯ï¼‰"""
    try:
        ticket = db.session.get(SupportTicket, ticket_id)
        
        if not ticket:
            return jsonify({'success': False, 'error': 'å·¥å•ä¸å­˜åœ¨'}), 404
        
        return jsonify({
            'success': True,
            'ticket': ticket.to_dict(include_messages=True)
        }), 200
    except Exception as e:
        app.logger.error(f'è·å–å·¥å•è¯¦æƒ…å¤±è´¥: {e}')
        return jsonify({'error': str(e)}), 500


@app.route('/api/admin/tickets/<int:ticket_id>/reply', methods=['POST'])
@admin_required
def admin_reply_ticket(ticket_id):
    """ç®¡ç†å‘˜å›å¤å·¥å•"""
    try:
        data = request.json
        ticket = db.session.get(SupportTicket, ticket_id)
        
        if not ticket:
            return jsonify({'error': 'å·¥å•ä¸å­˜åœ¨'}), 404
        
        # æ£€æŸ¥å·¥å•çŠ¶æ€ï¼Œå·²å…³é—­çš„å·¥å•ä¸èƒ½å›å¤
        if ticket.status == 'closed':
            return jsonify({'success': False, 'error': 'å·¥å•å·²å…³é—­ï¼Œæ— æ³•å›å¤'}), 400
        
        reply_content = data.get('reply', '').strip()
        if reply_content:
            # åˆ›å»ºæ–°çš„æ¶ˆæ¯è®°å½•
            admin_name = session.get('admin_username', 'ç®¡ç†å‘˜')
            message = TicketMessage(
                ticket_id=ticket.id,
                sender_type='admin',
                sender_id=0,  # ç®¡ç†å‘˜ç»Ÿä¸€ç”¨0
                sender_name=admin_name,
                content=reply_content
            )
            db.session.add(message)
            # åŒæ—¶æ›´æ–° admin_reply å­—æ®µä»¥ä¿æŒå…¼å®¹
            ticket.admin_reply = reply_content
            # è®°å½•ç®¡ç†å‘˜å›å¤ä¿¡æ¯
            ticket.last_reply_by = 'admin'
            ticket.last_reply_at = datetime.now()
        
        # å¦‚æœæŒ‡å®šäº†çŠ¶æ€å°±ç”¨æŒ‡å®šçš„ï¼Œå¦åˆ™ç®¡ç†å‘˜å›å¤åè‡ªåŠ¨è®¾ç½®ä¸ºå¤„ç†ä¸­
        new_status = data.get('status')
        if new_status and new_status in ['open', 'in_progress', 'closed']:
            ticket.status = new_status
        elif reply_content and ticket.status == 'open':
            # ç®¡ç†å‘˜å›å¤åçŠ¶æ€å˜ä¸ºå¤„ç†ä¸­
            ticket.status = 'in_progress'
        
        if ticket.status == 'closed':
            ticket.resolved_at = datetime.now()
        
        db.session.commit()
        
        app.logger.info(f'ç®¡ç†å‘˜å›å¤å·¥å•: {ticket.ticket_no}')
        
        return jsonify({
            'success': True,
            'ticket': ticket.to_dict(include_messages=True)
        }), 200
    except Exception as e:
        app.logger.error(f'å›å¤å·¥å•å¤±è´¥: {e}')
        db.session.rollback()
        return jsonify({'error': str(e)}), 500


@app.route('/api/admin/tickets/<int:ticket_id>/close', methods=['POST'])
@admin_required
def admin_close_ticket(ticket_id):
    """ç®¡ç†å‘˜æ‰‹åŠ¨å…³é—­å·¥å•"""
    try:
        ticket = db.session.get(SupportTicket, ticket_id)
        
        if not ticket:
            return jsonify({'error': 'å·¥å•ä¸å­˜åœ¨'}), 404
        
        ticket.status = 'closed'
        ticket.resolved_at = datetime.now()
        db.session.commit()
        
        app.logger.info(f'ç®¡ç†å‘˜æ‰‹åŠ¨å…³é—­å·¥å•: {ticket.ticket_no}')
        
        return jsonify({
            'success': True,
            'message': 'å·¥å•å·²å…³é—­'
        }), 200
    except Exception as e:
        app.logger.error(f'å…³é—­å·¥å•å¤±è´¥: {e}')
        db.session.rollback()
        return jsonify({'error': str(e)}), 500


@app.route('/api/admin/tickets/<int:ticket_id>/status', methods=['PUT'])
@admin_required
def admin_update_ticket_status(ticket_id):
    """ç®¡ç†å‘˜æ›´æ–°å·¥å•çŠ¶æ€"""
    try:
        data = request.json
        ticket = db.session.get(SupportTicket, ticket_id)
        
        if not ticket:
            return jsonify({'error': 'å·¥å•ä¸å­˜åœ¨'}), 404
        
        new_status = data.get('status')
        if new_status not in ['open', 'in_progress', 'resolved', 'closed']:
            return jsonify({'error': 'æ— æ•ˆçš„çŠ¶æ€'}), 400
        
        ticket.status = new_status
        if new_status == 'resolved':
            ticket.resolved_at = datetime.now()
        
        db.session.commit()
        
        app.logger.info(f'ç®¡ç†å‘˜æ›´æ–°å·¥å•çŠ¶æ€: {ticket.ticket_no} -> {new_status}')
        
        return jsonify({
            'success': True,
            'ticket': ticket.to_dict()
        }), 200
    except Exception as e:
        app.logger.error(f'æ›´æ–°å·¥å•çŠ¶æ€å¤±è´¥: {e}')
        db.session.rollback()
        return jsonify({'error': str(e)}), 500


# ==================== å…‘æ¢ç ç®¡ç† API ====================

@app.route('/api/admin/redeem-codes', methods=['GET'])
@admin_required
def admin_get_redeem_codes():
    """ç®¡ç†å‘˜è·å–å…‘æ¢ç åˆ—è¡¨"""
    try:
        code_type = request.args.get('type', '')
        status = request.args.get('status', '')
        
        query = RedeemCode.query
        
        if code_type:
            query = query.filter_by(code_type=code_type)
        
        if status == 'used':
            query = query.filter_by(is_used=True)
        elif status == 'unused':
            query = query.filter_by(is_used=False)
        
        codes = query.order_by(RedeemCode.created_at.desc()).limit(200).all()
        
        # ç»Ÿè®¡
        total = RedeemCode.query.count()
        used = RedeemCode.query.filter_by(is_used=True).count()
        unused = total - used
        
        return jsonify({
            'success': True,
            'codes': [code.to_dict() for code in codes],
            'stats': {
                'total': total,
                'used': used,
                'unused': unused
            }
        }), 200
    except Exception as e:
        app.logger.error(f'è·å–å…‘æ¢ç åˆ—è¡¨å¤±è´¥: {e}')
        return jsonify({'error': str(e)}), 500


@app.route('/api/admin/redeem-codes/generate', methods=['POST'])
@admin_required
def admin_generate_redeem_code():
    """ç”Ÿæˆå…‘æ¢ç """
    try:
        data = request.json
        code_type = data.get('code_type', 'new')  # new: æ–°è®¢é˜…, renew: ç»­è´¹
        plan_type = data.get('plan_type', 'standard')
        duration_days = int(data.get('duration_days', 30))
        remark = data.get('remark', '')
        expires_days = data.get('expires_days')  # å…‘æ¢ç æœ‰æ•ˆæœŸï¼ˆå¤©ï¼‰
        
        # ç”Ÿæˆå”¯ä¸€å…‘æ¢ç 
        import string
        code = ''.join(random.choices(string.ascii_uppercase + string.digits, k=12))
        
        # ç¡®ä¿å”¯ä¸€æ€§
        while RedeemCode.query.filter_by(code=code).first():
            code = ''.join(random.choices(string.ascii_uppercase + string.digits, k=12))
        
        expires_at = None
        if expires_days:
            expires_at = datetime.now() + timedelta(days=int(expires_days))
        
        redeem = RedeemCode(
            code=code,
            code_type=code_type,
            plan_type=plan_type,
            duration_days=duration_days,
            expires_at=expires_at,
            remark=remark
        )
        
        db.session.add(redeem)
        db.session.commit()
        
        app.logger.info(f'ç”Ÿæˆå…‘æ¢ç : {code}, ç±»å‹: {code_type}, å¥—é¤: {plan_type}, å¤©æ•°: {duration_days}')
        log_admin_audit('redeem_create', detail=f'ç”Ÿæˆå…‘æ¢ç  {code}ï¼Œ{duration_days}å¤©', target_type='redeem', target_id=code)
        
        return jsonify({
            'success': True,
            'code': redeem.to_dict()
        }), 200
    except Exception as e:
        app.logger.error(f'ç”Ÿæˆå…‘æ¢ç å¤±è´¥: {e}')
        db.session.rollback()
        return jsonify({'error': str(e)}), 500


@app.route('/api/admin/redeem-codes/batch-generate', methods=['POST'])
@admin_required
def admin_batch_generate_redeem_codes():
    """æ‰¹é‡ç”Ÿæˆå…‘æ¢ç """
    try:
        data = request.json
        code_type = data.get('code_type', 'new')
        plan_type = data.get('plan_type', 'standard')
        duration_days = int(data.get('duration_days', 30))
        count = min(int(data.get('count', 10)), 100)  # æœ€å¤šä¸€æ¬¡ç”Ÿæˆ100ä¸ª
        remark = data.get('remark', '')
        expires_days = data.get('expires_days')
        
        expires_at = None
        if expires_days:
            expires_at = datetime.now() + timedelta(days=int(expires_days))
        
        import string
        generated_codes = []
        
        for _ in range(count):
            code = ''.join(random.choices(string.ascii_uppercase + string.digits, k=12))
            # ç¡®ä¿å”¯ä¸€æ€§
            while RedeemCode.query.filter_by(code=code).first() or code in [c['code'] for c in generated_codes]:
                code = ''.join(random.choices(string.ascii_uppercase + string.digits, k=12))
            
            redeem = RedeemCode(
                code=code,
                code_type=code_type,
                plan_type=plan_type,
                duration_days=duration_days,
                expires_at=expires_at,
                remark=remark
            )
            db.session.add(redeem)
            generated_codes.append(redeem.to_dict())
        
        db.session.commit()
        
        app.logger.info(f'æ‰¹é‡ç”Ÿæˆå…‘æ¢ç : {count}ä¸ª, ç±»å‹: {code_type}, å¥—é¤: {plan_type}, å¤©æ•°: {duration_days}')
        log_admin_audit('redeem_create', detail=f'æ‰¹é‡ç”Ÿæˆ{count}ä¸ªå…‘æ¢ç ï¼Œ{duration_days}å¤©', target_type='redeem')
        
        return jsonify({
            'success': True,
            'codes': generated_codes,
            'count': len(generated_codes)
        }), 200
    except Exception as e:
        app.logger.error(f'æ‰¹é‡ç”Ÿæˆå…‘æ¢ç å¤±è´¥: {e}')
        db.session.rollback()
        return jsonify({'error': str(e)}), 500


@app.route('/api/admin/redeem-codes/<int:code_id>', methods=['DELETE'])
@admin_required
def admin_delete_redeem_code(code_id):
    """åˆ é™¤å…‘æ¢ç """
    try:
        redeem = db.session.get(RedeemCode, code_id)
        
        if not redeem:
            return jsonify({'error': 'å…‘æ¢ç ä¸å­˜åœ¨'}), 404
        
        if redeem.is_used:
            return jsonify({'error': 'å·²ä½¿ç”¨çš„å…‘æ¢ç æ— æ³•åˆ é™¤'}), 400
        
        db.session.delete(redeem)
        db.session.commit()
        
        app.logger.info(f'åˆ é™¤å…‘æ¢ç : {redeem.code}')
        log_admin_audit('redeem_delete', detail=f'åˆ é™¤å…‘æ¢ç  {redeem.code}', target_type='redeem', target_id=redeem.code)
        
        return jsonify({
            'success': True,
            'message': 'åˆ é™¤æˆåŠŸ'
        }), 200
    except Exception as e:
        app.logger.error(f'åˆ é™¤å…‘æ¢ç å¤±è´¥: {e}')
        db.session.rollback()
        return jsonify({'error': str(e)}), 500


@app.route('/api/admin/redeem-codes/<int:code_id>/toggle', methods=['POST'])
@admin_required
def admin_toggle_redeem_code(code_id):
    """å¯ç”¨/ç¦ç”¨å…‘æ¢ç """
    try:
        redeem = db.session.get(RedeemCode, code_id)
        
        if not redeem:
            return jsonify({'error': 'å…‘æ¢ç ä¸å­˜åœ¨'}), 404
        
        if redeem.is_used:
            return jsonify({'error': 'å·²ä½¿ç”¨çš„å…‘æ¢ç æ— æ³•æ“ä½œ'}), 400
        
        redeem.is_active = not redeem.is_active
        db.session.commit()
        
        status_text = 'å¯ç”¨' if redeem.is_active else 'ç¦ç”¨'
        app.logger.info(f'{status_text}å…‘æ¢ç : {redeem.code}')
        
        return jsonify({
            'success': True,
            'message': f'å…‘æ¢ç å·²{status_text}'
        }), 200
    except Exception as e:
        app.logger.error(f'åˆ‡æ¢å…‘æ¢ç çŠ¶æ€å¤±è´¥: {e}')
        db.session.rollback()
        return jsonify({'error': str(e)}), 500


@app.route('/api/admin/orders', methods=['GET'])
@admin_required  
def admin_get_orders():
    """ç®¡ç†å‘˜è·å–æ‰€æœ‰è®¢å•"""
    try:
        status = request.args.get('status', 'all')
        app.logger.info(f'ç®¡ç†å‘˜æŸ¥è¯¢è®¢å•, status={status}')
        
        from sqlalchemy import text
        
        # ç›´æ¥ä½¿ç”¨SQLæŸ¥è¯¢ï¼Œé¿å…ORMå¤–é”®é—®é¢˜
        if status and status != 'all':
            sql = text("""
                SELECT o.*, e.name as user_name 
                FROM orders o 
                LEFT JOIN emby e ON o.user_tg = e.tg 
                WHERE o.payment_status = :status
                ORDER BY o.created_at DESC 
                LIMIT 100
            """)
            result = db.session.execute(sql, {'status': status})
        else:
            sql = text("""
                SELECT o.*, e.name as user_name 
                FROM orders o 
                LEFT JOIN emby e ON o.user_tg = e.tg 
                ORDER BY o.created_at DESC 
                LIMIT 100
            """)
            result = db.session.execute(sql)
        
        orders = []
        for row in result:
            row_dict = row._asdict() if hasattr(row, '_asdict') else dict(row._mapping)
            # æ ¼å¼åŒ–æ—¶é—´
            if row_dict.get('created_at'):
                row_dict['created_at'] = row_dict['created_at'].isoformat() if hasattr(row_dict['created_at'], 'isoformat') else str(row_dict['created_at'])
            if row_dict.get('payment_time'):
                row_dict['payment_time'] = row_dict['payment_time'].isoformat() if hasattr(row_dict['payment_time'], 'isoformat') else str(row_dict['payment_time'])
            if row_dict.get('updated_at'):
                row_dict['updated_at'] = row_dict['updated_at'].isoformat() if hasattr(row_dict['updated_at'], 'isoformat') else str(row_dict['updated_at'])
            row_dict['user_tg_id'] = row_dict.get('user_tg')
            orders.append(row_dict)
        
        app.logger.info(f'SQLæŸ¥è¯¢åˆ° {len(orders)} æ¡è®¢å•')
        
        # è®¡ç®—ç»Ÿè®¡ä¿¡æ¯
        stats_sql = text("""
            SELECT 
                COUNT(*) as total,
                SUM(CASE WHEN payment_status = 'pending' THEN 1 ELSE 0 END) as pending,
                SUM(CASE WHEN payment_status = 'paid' THEN 1 ELSE 0 END) as paid,
                COALESCE(SUM(CASE WHEN payment_status = 'paid' THEN final_price ELSE 0 END), 0) as revenue
            FROM orders
        """)
        stats_result = db.session.execute(stats_sql).fetchone()
        stats_dict = stats_result._asdict() if hasattr(stats_result, '_asdict') else dict(stats_result._mapping)
        
        return jsonify({
            'success': True,
            'orders': orders,
            'stats': {
                'total': int(stats_dict.get('total') or 0),
                'pending': int(stats_dict.get('pending') or 0),
                'paid': int(stats_dict.get('paid') or 0),
                'revenue': float(stats_dict.get('revenue') or 0)
            }
        }), 200
    except Exception as e:
        app.logger.error(f'è·å–è®¢å•å¤±è´¥: {e}', exc_info=True)
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/admin/subscriptions', methods=['GET'])
@admin_required
def admin_get_subscriptions():
    """ç®¡ç†å‘˜è·å–æ‰€æœ‰è®¢é˜…ç”¨æˆ·ï¼ˆåŒ…æ‹¬ç™½åå•å’Œæœ‰æ•ˆæœŸå†…ç”¨æˆ·ï¼‰"""
    try:
        status = request.args.get('status', '')
        now = datetime.now()
        
        # æŸ¥è¯¢æ‰€æœ‰ç”¨æˆ·ï¼Œæ ¹æ®çŠ¶æ€ç­›é€‰
        if status == 'active':
            # ç”Ÿæ•ˆä¸­ï¼šæœ‰æœ‰æ•ˆæœŸå†…çš„è®¢é˜…ç”¨æˆ·
            users = User.query.filter(
                db.and_(User.lv.in_(['a', 'b']), User.ex > now)
            ).order_by(User.cr.desc()).limit(100).all()
        elif status == 'expired':
            # å·²è¿‡æœŸï¼šA/Bçº§ç”¨æˆ·ä¸”è¿‡æœŸæ—¶é—´å·²è¿‡
            users = User.query.filter(
                User.lv.in_(['a', 'b']),
                User.ex <= now
            ).order_by(User.ex.desc()).limit(100).all()
        elif status == 'cancelled':
            # å·²å–æ¶ˆï¼šCçº§æˆ–Dçº§ç”¨æˆ·ï¼ˆå·²ç¦ç”¨æˆ–æ— è´¦å·ï¼‰
            users = User.query.filter(
                User.lv.in_(['c', 'd'])
            ).order_by(User.cr.desc()).limit(100).all()
        else:
            # å…¨éƒ¨ï¼šæ‰€æœ‰Aå’ŒBçº§ç”¨æˆ·
            users = User.query.filter(
                User.lv.in_(['a', 'b'])
            ).order_by(User.cr.desc()).limit(100).all()
        
        # é¢„åŠ è½½æ‰€æœ‰ç›¸å…³ç”¨æˆ·çš„è®¢é˜…è®°å½•
        user_tgs = [u.tg for u in users]
        active_subs = Subscription.query.filter(
            Subscription.user_tg.in_(user_tgs),
            Subscription.status == 'active'
        ).all() if user_tgs else []
        # æ„å»º user_tg -> subscription æ˜ å°„
        sub_map = {}
        for s in active_subs:
            if s.user_tg not in sub_map:
                sub_map[s.user_tg] = s
        
        # è½¬æ¢ä¸ºè®¢é˜…æ ¼å¼
        subscriptions = []
        for user in users:
            # åˆ¤æ–­çŠ¶æ€ï¼šé€šè¿‡è®¢é˜…è®°å½•åˆ¤æ–­ç™½åå•
            user_sub = sub_map.get(user.tg)
            is_wl = (user_sub and user_sub.plan_type == 'whitelist') or user.lv == 'a'
            
            if is_wl:
                user_status = 'active'
                plan_name = 'ç™½åå•ç”¨æˆ·'
                plan_type = 'whitelist'
            elif user.lv in ['a', 'b']:
                if user.ex and user.ex > now:
                    user_status = 'active'
                    plan_name = user_sub.plan_name if user_sub else 'æ³¨å†Œç”¨æˆ·'
                    plan_type = user_sub.plan_type if user_sub else 'registered'
                else:
                    user_status = 'expired'
                    plan_name = user_sub.plan_name if user_sub else 'æ³¨å†Œç”¨æˆ·'
                    plan_type = user_sub.plan_type if user_sub else 'registered'
            else:
                user_status = 'cancelled'
                plan_name = 'å·²ç¦ç”¨'
                plan_type = 'disabled'
            
            subscriptions.append({
                'id': user.tg,
                'user_tg_id': user.tg,
                'user_name': (user.emby_name or user.name) or f'ç”¨æˆ·{user.tg}',
                'plan_type': plan_type,
                'plan_name': plan_name,
                'duration_months': '-',
                'start_date': user.cr.isoformat() if user.cr else None,
                'end_date': user.ex.isoformat() if user.ex else None,
                'status': user_status,
                'days_remaining': (user.ex - now).days if user.ex and user.ex > now else ('æ°¸ä¹…' if is_wl else 0)
            })
        
        # ç»Ÿè®¡æ•°æ®
        total_ab = User.query.filter(User.lv.in_(['a', 'b'])).count()
        active_count = User.query.filter(
            db.and_(User.lv.in_(['a', 'b']), User.ex > now)
        ).count()
        expired_count = User.query.filter(
            User.lv.in_(['a', 'b']),
            User.ex <= now
        ).count()
        
        return jsonify({
            'success': True,
            'subscriptions': subscriptions,
            'stats': {
                'total': total_ab,
                'active': active_count,
                'expired': expired_count
            }
        }), 200
    except Exception as e:
        app.logger.error(f'è·å–è®¢é˜…å¤±è´¥: {e}')
        return jsonify({'error': str(e)}), 500


@app.route('/api/admin/subscriptions/sync', methods=['POST'])
@admin_required
def admin_sync_subscriptions():
    """ç®¡ç†å‘˜æ‰¹é‡åŒæ­¥è®¢é˜…è®°å½• - ä¸ºæœ‰ user.ex ä½†æ²¡æœ‰ Subscription è®°å½•çš„ç”¨æˆ·è¡¥å……åˆ›å»º"""
    try:
        now = datetime.now()
        synced_count = 0
        skipped_count = 0
        
        # æŸ¥æ‰¾æ‰€æœ‰æœ‰æœ‰æ•ˆåˆ°æœŸæ—¶é—´ä½†æ²¡æœ‰è®¢é˜…è®°å½•çš„éç™½åå•ç”¨æˆ·
        users_with_ex = User.query.filter(
            User.lv == 'b',
            User.ex > now
        ).all()
        
        for user in users_with_ex:
            # æ£€æŸ¥æ˜¯å¦å·²æœ‰è®¢é˜…è®°å½•
            existing_sub = Subscription.query.filter_by(user_tg=user.tg).first()
            if existing_sub:
                skipped_count += 1
                continue
            
            # å°è¯•ä»è®¢å•è¡¨æ‰¾åˆ°æœ€è¿‘çš„å·²æ”¯ä»˜è®¢å•æ¥ç¡®å®šå¥—é¤ä¿¡æ¯
            recent_order = Order.query.filter_by(
                user_tg=user.tg,
                payment_status='paid'
            ).order_by(Order.payment_time.desc()).first()
            
            if recent_order:
                # æ ¹æ®è®¢å•åˆ›å»ºè®¢é˜…è®°å½•
                subscription = Subscription(
                    user_tg=user.tg,
                    plan_type=recent_order.plan_type,
                    plan_name=recent_order.plan_name,
                    duration_months=recent_order.duration_months,
                    price=recent_order.final_price,
                    start_date=recent_order.payment_time or datetime.now(),
                    end_date=user.ex,
                    status='active',
                    source='purchase'
                )
            else:
                # æ²¡æœ‰è®¢å•è®°å½•ï¼Œåˆ›å»ºä¸€ä¸ªé€šç”¨è®°å½•
                subscription = Subscription(
                    user_tg=user.tg,
                    plan_type='manual',
                    plan_name='è®¢é˜…ä¼šå‘˜',
                    duration_months=max(1, (user.ex - now).days // 30),
                    price=0,
                    start_date=user.cr or datetime.now(),
                    end_date=user.ex,
                    status='active',
                    source='manual'
                )
            
            db.session.add(subscription)
            synced_count += 1
        
        db.session.commit()
        app.logger.info(f'æ‰¹é‡åŒæ­¥è®¢é˜…è®°å½•: åŒæ­¥={synced_count}, è·³è¿‡(å·²æœ‰è®°å½•)={skipped_count}')
        
        return jsonify({
            'success': True,
            'message': f'åŒæ­¥å®Œæˆï¼šæ–°å¢ {synced_count} æ¡è®¢é˜…è®°å½•ï¼Œè·³è¿‡ {skipped_count} æ¡(å·²æœ‰è®°å½•)'
        }), 200
    except Exception as e:
        app.logger.error(f'æ‰¹é‡åŒæ­¥è®¢é˜…è®°å½•å¤±è´¥: {e}')
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500


# ==================== çº¿è·¯ç®¡ç† API ====================

@app.route('/api/admin/lines', methods=['GET'])
@admin_required
def admin_get_lines():
    """ç®¡ç†å‘˜è·å–æ‰€æœ‰çº¿è·¯"""
    try:
        lines = ServerLine.query.order_by(ServerLine.sort_order.asc(), ServerLine.id.asc()).all()
        return jsonify({
            'success': True,
            'lines': [line.to_dict(include_sensitive=True) for line in lines]
        }), 200
    except Exception as e:
        app.logger.error(f'è·å–çº¿è·¯åˆ—è¡¨å¤±è´¥: {e}')
        return jsonify({'error': str(e)}), 500


@app.route('/api/admin/lines', methods=['POST'])
@admin_required
def admin_add_line():
    """ç®¡ç†å‘˜æ·»åŠ çº¿è·¯"""
    try:
        data = request.get_json()
        
        name = data.get('name', '').strip()
        server_url = data.get('server_url', '').strip()
        port = data.get('port', 8096)
        is_https = data.get('is_https', False)
        description = data.get('description', '').strip()
        sort_order = data.get('sort_order', 0)
        
        # å¤„ç†å…è®¸çš„å¥—é¤ç±»å‹ï¼ˆå¤šé€‰ï¼‰
        allowed_plan_types_raw = data.get('allowed_plan_types', [])
        if isinstance(allowed_plan_types_raw, list):
            allowed_plan_types = ','.join([t.strip() for t in allowed_plan_types_raw if t.strip()])
        else:
            allowed_plan_types = str(allowed_plan_types_raw).strip()
        
        # å…¼å®¹æ—§çš„ access_level å‚æ•°
        access_level = data.get('access_level', 'subscriber')
        
        if not name:
            return jsonify({'success': False, 'error': 'çº¿è·¯åç§°ä¸èƒ½ä¸ºç©º'}), 400
        if not server_url:
            return jsonify({'success': False, 'error': 'æœåŠ¡å™¨åœ°å€ä¸èƒ½ä¸ºç©º'}), 400
        
        line = ServerLine(
            name=name,
            server_url=server_url,
            port=port,
            is_https=is_https,
            description=description,
            access_level=access_level,
            allowed_plan_types=allowed_plan_types,
            sort_order=sort_order,
            is_active=True
        )
        
        db.session.add(line)
        db.session.commit()
        
        app.logger.info(f'ç®¡ç†å‘˜æ·»åŠ çº¿è·¯: {name}')
        
        return jsonify({
            'success': True,
            'message': 'çº¿è·¯æ·»åŠ æˆåŠŸ',
            'line': line.to_dict(include_sensitive=True)
        }), 201
    except Exception as e:
        db.session.rollback()
        app.logger.error(f'æ·»åŠ çº¿è·¯å¤±è´¥: {e}')
        return jsonify({'error': str(e)}), 500


@app.route('/api/admin/lines/<int:line_id>', methods=['PUT'])
@admin_required
def admin_update_line(line_id):
    """ç®¡ç†å‘˜æ›´æ–°çº¿è·¯"""
    try:
        line = db.session.get(ServerLine, line_id)
        if not line:
            return jsonify({'success': False, 'error': 'çº¿è·¯ä¸å­˜åœ¨'}), 404
        
        data = request.get_json()
        
        if 'name' in data:
            line.name = data['name'].strip()
        if 'server_url' in data:
            line.server_url = data['server_url'].strip()
        if 'port' in data:
            line.port = data['port']
        if 'is_https' in data:
            line.is_https = data['is_https']
        if 'description' in data:
            line.description = data['description'].strip()
        if 'access_level' in data:
            line.access_level = data.get('access_level', 'subscriber')
        if 'allowed_plan_types' in data:
            apt = data['allowed_plan_types']
            if isinstance(apt, list):
                line.allowed_plan_types = ','.join([t.strip() for t in apt if t.strip()])
            else:
                line.allowed_plan_types = str(apt).strip()
        if 'sort_order' in data:
            line.sort_order = data['sort_order']
        if 'is_active' in data:
            line.is_active = data['is_active']
        
        db.session.commit()
        
        app.logger.info(f'ç®¡ç†å‘˜æ›´æ–°çº¿è·¯: {line.name}')
        
        return jsonify({
            'success': True,
            'message': 'çº¿è·¯æ›´æ–°æˆåŠŸ',
            'line': line.to_dict(include_sensitive=True)
        }), 200
    except Exception as e:
        db.session.rollback()
        app.logger.error(f'æ›´æ–°çº¿è·¯å¤±è´¥: {e}')
        return jsonify({'error': str(e)}), 500


@app.route('/api/admin/lines/<int:line_id>', methods=['DELETE'])
@admin_required
def admin_delete_line(line_id):
    """ç®¡ç†å‘˜åˆ é™¤çº¿è·¯"""
    try:
        line = db.session.get(ServerLine, line_id)
        if not line:
            return jsonify({'success': False, 'error': 'çº¿è·¯ä¸å­˜åœ¨'}), 404
        
        line_name = line.name
        db.session.delete(line)
        db.session.commit()
        
        app.logger.info(f'ç®¡ç†å‘˜åˆ é™¤çº¿è·¯: {line_name}')
        
        return jsonify({
            'success': True,
            'message': 'çº¿è·¯åˆ é™¤æˆåŠŸ'
        }), 200
    except Exception as e:
        db.session.rollback()
        app.logger.error(f'åˆ é™¤çº¿è·¯å¤±è´¥: {e}')
        return jsonify({'error': str(e)}), 500


@app.route('/api/lines', methods=['GET'])
@login_required
def get_user_lines():
    """ç”¨æˆ·è·å–å¯è®¿é—®çš„çº¿è·¯ä¿¡æ¯ï¼ˆæ ¹æ®ç”¨æˆ·ç­‰çº§è¿”å›ä¸åŒå†…å®¹ï¼‰"""
    try:
        user = db.session.get(User, session.get('user_id'))
        app.logger.info(f'[çº¿è·¯API] è¿›å…¥ /api/lines, user_id={session.get("user_id")}, user={user.name if user else "None"}, lv={user.lv if user else "None"}, ex={user.ex if user else "None"}')
        if not user:
            return jsonify({'error': 'ç”¨æˆ·ä¸å­˜åœ¨'}), 404
        
        # è·å–ç”¨æˆ·çš„Embyè´¦å·å¯†ç ï¼ˆåªæœ‰å·²ç»‘å®šEmbyæ—¶æ‰è¿”å›ï¼‰
        has_emby = bool(user.embyid)
        emby_username = user.emby_name if has_emby else None  # åªç”¨ç»‘å®šåçš„Embyç”¨æˆ·å
        emby_password = user.pwd2 if has_emby else None  # Embyå¯†ç ï¼ˆç‹¬ç«‹äºç½‘ç«™å¯†ç ï¼‰
        
        # åˆ¤æ–­ç”¨æˆ·æƒé™çº§åˆ«
        now = datetime.now()
        is_subscriber = user.lv in ['a', 'b'] and user.ex and user.ex > now  # æœ‰æ•ˆè®¢é˜…ç”¨æˆ·ï¼ˆåŒ…å«æ—§ç™½åå•lv='a'ï¼‰
        
        # é€šè¿‡ Subscription è¡¨åˆ¤æ–­æ˜¯å¦æ˜¯ç™½åå•ç”¨æˆ·ï¼ˆplan_type='whitelist'ï¼‰
        # åŒæ—¶å…¼å®¹æ—§ç™½åå•ç”¨æˆ·ï¼ˆlv='a'ï¼‰
        is_whitelist = False
        if user.lv == 'a':
            is_whitelist = True
        elif is_subscriber:
            active_sub = Subscription.query.filter_by(
                user_tg=user.tg, status='active'
            ).order_by(Subscription.end_date.desc()).first()
            if active_sub and active_sub.plan_type == 'whitelist':
                is_whitelist = True
        
        # æ— æƒé™ç”¨æˆ·ï¼ˆæœªè®¢é˜…æˆ–å·²è¿‡æœŸï¼‰
        if not is_subscriber:
            app.logger.info(f'[çº¿è·¯API] ç”¨æˆ·æ— æƒé™: {user.name}, lv={user.lv}, ex={user.ex}, now={now}, is_whitelist={is_whitelist}, is_subscriber={is_subscriber}')
            return jsonify({
                'success': True,
                'has_access': False,
                'message': 'æ‚¨æš‚æ— æœ‰æ•ˆè®¢é˜…ï¼Œæ— æ³•æŸ¥çœ‹çº¿è·¯ä¿¡æ¯',
                'lines': [],
                'account': None
            }), 200
        
        # è·å–æ‰€æœ‰å¯ç”¨çš„çº¿è·¯
        lines = ServerLine.query.filter_by(is_active=True).order_by(
            ServerLine.sort_order.asc(), 
            ServerLine.id.asc()
        ).all()
        
        accessible_lines = []
        line_names = []  # è®°å½•çº¿è·¯åç§°ç”¨äºæ—¥å¿—
        
        # è·å–ç”¨æˆ·çš„å¥—é¤ç±»å‹ï¼ˆç°åœ¨ä½¿ç”¨å¥—é¤IDä½œä¸ºæ ‡è¯†ï¼‰
        user_plan_type = None
        if is_whitelist:
            user_plan_type = 'whitelist'
        elif is_subscriber:
            active_sub = Subscription.query.filter_by(
                user_tg=user.tg, status='active'
            ).order_by(Subscription.end_date.desc()).first()
            if active_sub and active_sub.plan_type:
                user_plan_type = active_sub.plan_type
            # å¦åˆ™ user_plan_type ä¿æŒ Noneï¼ˆæ— è®¢é˜…è®°å½•çš„æ—§ç”¨æˆ·ï¼‰
        
        app.logger.info(f'[çº¿è·¯è¿‡æ»¤] ç”¨æˆ·={user.name}(tg={user.tg}), lv={user.lv}, ex={user.ex}, is_whitelist={is_whitelist}, is_subscriber={is_subscriber}, user_plan_type={user_plan_type}, çº¿è·¯æ•°={len(lines)}')
        
        for line in lines:
            allowed = [t.strip() for t in (line.allowed_plan_types or '').split(',') if t.strip()]
            app.logger.info(f'[çº¿è·¯è¿‡æ»¤] çº¿è·¯={line.name}, allowed_plan_types={allowed}, access_level={line.access_level}')
            
            if not allowed:
                # æ²¡æœ‰è®¾ç½®å¥—é¤é™åˆ¶ â†’ å…¼å®¹æ—§æ•°æ®ï¼Œç”¨ access_level åˆ¤æ–­
                if is_whitelist:
                    accessible_lines.append(line.to_dict(include_sensitive=True))
                    line_names.append(line.name)
                elif is_subscriber and line.access_level in ['subscriber', 'all']:
                    accessible_lines.append(line.to_dict(include_sensitive=True))
                    line_names.append(line.name)
            else:
                # æœ‰ allowed_plan_types é™åˆ¶ï¼šä¸¥æ ¼æŒ‰å¥—é¤IDåŒ¹é…
                if user_plan_type and user_plan_type in allowed:
                    accessible_lines.append(line.to_dict(include_sensitive=True))
                    line_names.append(f"{line.name}({user_plan_type})")
        
        return jsonify({
            'success': True,
            'has_access': True,
            'is_whitelist': is_whitelist,
            'is_subscriber': is_subscriber,
            'lines': accessible_lines,
            'account': {
                'username': emby_username,
                'password': emby_password
            } if emby_username else None
        }), 200
    except Exception as e:
        app.logger.error(f'è·å–çº¿è·¯ä¿¡æ¯å¤±è´¥: {e}')
        return jsonify({'error': str(e)}), 500


@app.route('/api/lines/view-log', methods=['POST'])
@login_required
def log_view_lines():
    """ç”¨æˆ·ç‚¹å‡»æŸ¥çœ‹çº¿è·¯æ—¶è®°å½•æ—¥å¿—ï¼ˆå‰ç«¯å°çœ¼ç›è§¦å‘ï¼‰"""
    try:
        user = db.session.get(User, session.get('user_id'))
        if not user:
            return jsonify({'success': False}), 404
        
        data = request.get_json() or {}
        line_name = data.get('line_name', '')
        line_index = data.get('line_index', -1)
        
        # åˆ¤æ–­ç”¨æˆ·ç±»å‹
        now = datetime.now()
        is_subscriber = user.lv in ['a', 'b'] and user.ex and user.ex > now
        
        # é€šè¿‡ Subscription åˆ¤æ–­ç™½åå•
        is_whitelist = False
        user_plan_type = None
        if is_subscriber:
            active_sub = Subscription.query.filter_by(
                user_tg=user.tg, status='active'
            ).order_by(Subscription.end_date.desc()).first()
            if active_sub and active_sub.plan_type == 'whitelist':
                is_whitelist = True
                user_plan_type = 'whitelist'
            elif active_sub:
                plans = load_plans_config()
                valid_plan_types = {'whitelist'} | {p.get('id') for p in plans if p.get('id')} | {p.get('type') for p in plans if p.get('type')}
                if active_sub.plan_type in valid_plan_types:
                    user_plan_type = active_sub.plan_type
        
        user_type = 'ç™½åå•ç”¨æˆ·' if is_whitelist else 'è®¢é˜…ç”¨æˆ·'
        
        # æŸ¥è¯¢ç”¨æˆ·å¯è§çš„æ‰€æœ‰çº¿è·¯åç§°
        lines = ServerLine.query.filter_by(is_active=True).order_by(
            ServerLine.sort_order.asc(), ServerLine.id.asc()
        ).all()
        
        visible_line_names = []
        
        for line in lines:
            allowed = [t.strip() for t in (line.allowed_plan_types or '').split(',') if t.strip()]
            if not allowed:
                if is_whitelist or (is_subscriber and line.access_level in ['subscriber', 'all']):
                    visible_line_names.append(line.name)
            elif user_plan_type and user_plan_type in allowed:
                visible_line_names.append(line.name)
        
        log_user_activity(UserActivityLog.ACTION_VIEW_LINES, user=user,
                         detail={
                             'line_name': line_name,
                             'action': 'æŸ¥çœ‹çº¿è·¯',
                             'user_type': user_type,
                             'is_whitelist': is_whitelist,
                             'lines': visible_line_names,
                             'lines_count': len(visible_line_names)
                         })
        
        return jsonify({'success': True}), 200
    except Exception as e:
        app.logger.error(f'è®°å½•æŸ¥çœ‹çº¿è·¯æ—¥å¿—å¤±è´¥: {e}')
        return jsonify({'success': False}), 500


@app.route('/api/admin/invite-stats', methods=['GET'])
@admin_required
def admin_get_invite_stats():
    """ç®¡ç†å‘˜è·å–é‚€è¯·ç»Ÿè®¡"""
    try:
        from sqlalchemy import func
        
        # æ€»é‚€è¯·æ•°
        total_invites = InviteRecord.query.count()
        
        # æˆåŠŸé‚€è¯·æ•°ï¼ˆå·²é¢†å–å¥–åŠ±ï¼‰
        successful_invites = InviteRecord.query.filter_by(reward_claimed=True).count()
        
        # æ€»å¥–åŠ±é‡‘é¢
        total_rewards = db.session.query(
            func.sum(InviteRecord.reward_value)
        ).filter(InviteRecord.reward_claimed == True).scalar() or 0
        
        # é‚€è¯·è®°å½•
        records = InviteRecord.query.order_by(
            InviteRecord.created_at.desc()
        ).limit(100).all()
        
        # é‚€è¯·æ’è¡Œæ¦œ
        rankings = db.session.query(
            InviteRecord.inviter_tg,
            func.count(InviteRecord.id).label('count')
        ).group_by(InviteRecord.inviter_tg).order_by(
            func.count(InviteRecord.id).desc()
        ).limit(10).all()
        
        ranking_list = []
        for inviter_tg, count in rankings:
            user = User.query.filter_by(tg=inviter_tg).first()
            ranking_list.append({
                'tg_id': inviter_tg,
                'name': (user.emby_name or user.name) if user else f'ç”¨æˆ·{inviter_tg}',
                'count': count
            })
        
        # è¿‘30å¤©è¶‹åŠ¿
        from datetime import datetime, timedelta
        thirty_days_ago = datetime.now() - timedelta(days=30)
        daily_stats = db.session.query(
            func.date(InviteRecord.created_at).label('date'),
            func.count(InviteRecord.id).label('count')
        ).filter(
            InviteRecord.created_at >= thirty_days_ago
        ).group_by(
            func.date(InviteRecord.created_at)
        ).order_by('date').all()
        
        trend = [{'date': str(date), 'count': count} for date, count in daily_stats]
        
        return jsonify({
            'success': True,
            'stats': {
                'total': total_invites,
                'successful': successful_invites,
                'total_rewards': float(total_rewards)
            },
            'records': [record.to_dict() for record in records],
            'rankings': ranking_list,
            'trend': trend
        }), 200
    except Exception as e:
        app.logger.error(f'è·å–é‚€è¯·ç»Ÿè®¡å¤±è´¥: {e}')
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/admin/users', methods=['GET'])
@admin_required
def admin_get_users():
    """ç®¡ç†å‘˜è·å–ç”¨æˆ·åˆ—è¡¨ï¼ˆæ”¯æŒåˆ†é¡µï¼‰"""
    try:
        from sqlalchemy import func, or_, cast, String
        role = request.args.get('role', '')
        search = request.args.get('search', '').strip()
        page = request.args.get('page', 1, type=int)
        per_page = request.args.get('per_page', 20, type=int)
        
        # æ„å»ºæŸ¥è¯¢
        query = User.query
        
        # æœç´¢è¿‡æ»¤
        if search:
            query = query.filter(
                or_(
                    User.name.ilike(f'%{search}%'),
                    User.emby_name.ilike(f'%{search}%'),
                    cast(User.tg, String).ilike(f'%{search}%'),
                    cast(User.telegram_id, String).ilike(f'%{search}%'),
                    User.email.ilike(f'%{search}%')
                )
            )
        
        # ç»Ÿè®¡æ•°æ®ï¼ˆåœ¨ç­›é€‰å‰ï¼‰
        total_users = User.query.count()
        all_users_for_stats = User.query.all()
        admin_users = len([u for u in all_users_for_stats if u.is_admin])
        
        # è·å–è®¢é˜…ç”¨æˆ·æ•°
        subscribed_users = db.session.query(
            func.count(func.distinct(Subscription.user_tg))
        ).filter(Subscription.status == 'active').scalar() or 0
        
        # æ’åºï¼ˆMySQL å…¼å®¹ï¼šä½¿ç”¨ CASE WHEN å¤„ç† NULL å€¼æ’åœ¨æœ€åï¼‰
        query = query.order_by(
            db.case((User.cr.is_(None), 1), else_=0),
            User.cr.desc()
        )
        
        # è·å–æ‰€æœ‰æ•°æ®ç”¨äºè§’è‰²ç­›é€‰ï¼ˆå› ä¸º is_admin æ˜¯è®¡ç®—å±æ€§ï¼‰
        all_filtered_users = query.all()
        
        # æ ¹æ®è§’è‰²ç­›é€‰
        if role == 'admin':
            all_filtered_users = [u for u in all_filtered_users if u.is_admin]
        elif role == 'user':
            all_filtered_users = [u for u in all_filtered_users if not u.is_admin]
        
        # æ ¹æ®ç”¨æˆ·çŠ¶æ€ç­›é€‰ï¼ˆç™½åå•é€šè¿‡è®¢é˜…è®°å½•åˆ¤æ–­ï¼‰
        now = datetime.now()  # ä½¿ç”¨ä¸å¸¦æ—¶åŒºçš„æ—¶é—´ï¼Œä¸æ•°æ®åº“ä¸€è‡´
        status_filter = request.args.get('status', '').strip()
        if status_filter == 'whitelist':
            # æŸ¥è¯¢æ‰€æœ‰ç™½åå•è®¢é˜…çš„user_tg
            _wl_tgs = set(s.user_tg for s in Subscription.query.filter_by(plan_type='whitelist', status='active').all())
            all_filtered_users = [u for u in all_filtered_users if u.tg in _wl_tgs or u.lv == 'a']
        elif status_filter == 'subscribed':
            _wl_tgs2 = set(s.user_tg for s in Subscription.query.filter_by(plan_type='whitelist', status='active').all())
            all_filtered_users = [u for u in all_filtered_users if u.tg not in _wl_tgs2 and u.lv != 'a' and u.ex and u.ex > now]
        elif status_filter == 'normal':
            _wl_tgs3 = set(s.user_tg for s in Subscription.query.filter_by(plan_type='whitelist', status='active').all())
            all_filtered_users = [u for u in all_filtered_users if u.tg not in _wl_tgs3 and u.lv != 'a' and u.lv != 'c' and (not u.ex or u.ex <= now)]
        elif status_filter == 'banned':
            all_filtered_users = [u for u in all_filtered_users if u.lv == 'c' or u.ban_reason]
        elif status_filter == 'emby_banned':
            all_filtered_users = [u for u in all_filtered_users if u.ban_reason and u.lv != 'c']
        
        # æ‰‹åŠ¨åˆ†é¡µ
        total_filtered = len(all_filtered_users)
        total_pages = (total_filtered + per_page - 1) // per_page
        start_idx = (page - 1) * per_page
        end_idx = start_idx + per_page
        paginated_users = all_filtered_users[start_idx:end_idx]
        
        # è·å–è´§å¸åç§°é…ç½®
        checkin_config = get_db_config('checkin', {})
        coin_name = checkin_config.get('coin_name', 'ç§¯åˆ†')
        
        # ç”¨æˆ·æ•°æ®
        user_list = []
        # é¢„åŠ è½½åˆ†é¡µç”¨æˆ·çš„è®¢é˜…è®°å½•
        _page_tgs = [u.tg for u in paginated_users]
        _page_subs = Subscription.query.filter(
            Subscription.user_tg.in_(_page_tgs),
            Subscription.status == 'active'
        ).all() if _page_tgs else []
        _page_sub_map = {}
        for _ps in _page_subs:
            if _ps.user_tg not in _page_sub_map:
                _page_sub_map[_ps.user_tg] = _ps
        
        for user in paginated_users:
            # è®¢é˜…çŠ¶æ€é€»è¾‘ï¼š
            # 1. ç™½åå•å¥—é¤ç”¨æˆ·æ°¸è¿œè§†ä¸ºå·²è®¢é˜…
            # 2. æœ‰æœ‰æ•ˆåˆ°æœŸæ—¶é—´çš„ç”¨æˆ·è§†ä¸ºå·²è®¢é˜…
            # 3. å…¶ä»–ç”¨æˆ·ä¸ºæœªè®¢é˜…
            subscription_status = 'inactive'
            subscription_end = None
            subscription_plan_type = None
            
            _u_sub = _page_sub_map.get(user.tg)
            _u_is_wl = (_u_sub and _u_sub.plan_type == 'whitelist') or user.lv == 'a'
            
            if _u_is_wl:
                subscription_status = 'active'
                subscription_end = None  # ç™½åå•æ°¸ä¹…æœ‰æ•ˆ
                subscription_plan_type = 'whitelist'
            elif user.ex and user.ex > now:
                subscription_status = 'active'
                subscription_end = user.ex.isoformat()
                if _u_sub:
                    subscription_plan_type = _u_sub.plan_type
            elif user.ex:
                subscription_end = user.ex.isoformat()  # å·²è¿‡æœŸä¹Ÿè¿”å›åˆ°æœŸæ—¶é—´

            user_list.append({
                'id': user.tg,  # ä½¿ç”¨ tg ä½œä¸ºç”¨æˆ· ID
                'name': user.name,
                'emby_name': user.emby_name,  # Embyç”¨æˆ·åï¼ˆç‹¬ç«‹äºç½‘ç«™ç”¨æˆ·åï¼‰
                'telegram_id': user.telegram_id,  # åªæœ‰ç»‘å®šäº†æ‰æœ‰å€¼
                'email': user.email,  # ç»‘å®šé‚®ç®±
                'is_admin': user.is_admin,
                'level': user.lv,
                'subscription_status': subscription_status,
                'subscription_end': subscription_end,
                'subscription_plan_type': subscription_plan_type,
                'coins': user.coins or 0,
                'created_at': user.cr.isoformat() if user.cr else None,
                'ban_reason': user.ban_reason,  # é»‘åå•å°ç¦åŸå› ï¼ˆlvæœªæ”¹ä½†Embyè¢«ç¦ç”¨ï¼‰
                'ban_time': user.ban_time.isoformat() if user.ban_time else None
            })
        
        return jsonify({
            'success': True,
            'users': user_list,
            'pagination': {
                'page': page,
                'per_page': per_page,
                'total': total_filtered,
                'total_pages': total_pages,
                'has_prev': page > 1,
                'has_next': page < total_pages
            },
            'stats': {
                'total': total_users,
                'admins': admin_users,
                'subscribed': subscribed_users,
                'coin_name': coin_name
            }
        }), 200
    except Exception as e:
        app.logger.error(f'è·å–ç”¨æˆ·åˆ—è¡¨å¤±è´¥: {e}')
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/admin/export/<string:export_type>', methods=['GET'])
@admin_required
def admin_export_data(export_type):
    """ç®¡ç†å‘˜æ•°æ®å¯¼å‡ºAPI - æ”¯æŒç”¨æˆ·åˆ—è¡¨ã€è®¢å•ã€è®¢é˜…å†å²å¯¼å‡ºä¸ºCSV"""
    import csv
    import io
    from urllib.parse import quote
    
    try:
        output = io.StringIO()
        output.write('\ufeff')  # UTF-8 BOM
        now = datetime.now()
        
        if export_type == 'users':
            writer = csv.writer(output)
            writer.writerow(['ç”¨æˆ·ID', 'ç½‘ç«™ç”¨æˆ·å', 'Embyç”¨æˆ·å', 'é‚®ç®±', 'Telegram ID', 
                           'ç­‰çº§', 'è®¢é˜…çŠ¶æ€', 'åˆ°æœŸæ—¶é—´', 'ç§¯åˆ†', 'æ³¨å†Œæ—¶é—´'])
            
            users = User.query.order_by(User.cr.desc()).all()
            # é¢„åŠ è½½ç™½åå•è®¢é˜…
            _exp_wl_tgs = set(s.user_tg for s in Subscription.query.filter_by(plan_type='whitelist', status='active').all())
            level_names = {'a': 'ç™½åå•(æ—§)', 'b': 'æ™®é€šç”¨æˆ·', 'c': 'å·²ç¦ç”¨', 'd': 'æ— è´¦å·'}
            for u in users:
                is_wl = u.tg in _exp_wl_tgs or u.lv == 'a'
                if is_wl:
                    status = 'ç™½åå•'
                    lv_name = 'ç™½åå•'
                elif u.lv == 'c':
                    status = 'å·²ç¦ç”¨'
                    lv_name = level_names.get(u.lv, u.lv or 'd')
                elif u.ex and u.ex > now:
                    status = 'å·²è®¢é˜…'
                    lv_name = level_names.get(u.lv, u.lv or 'd')
                else:
                    status = 'æœªè®¢é˜…'
                    lv_name = level_names.get(u.lv, u.lv or 'd')
                writer.writerow([
                    u.tg, u.name or '', u.emby_name or '', u.email or '', u.telegram_id or '',
                    lv_name, status,
                    u.ex.strftime('%Y-%m-%d %H:%M') if u.ex else '',
                    u.coins or 0,
                    u.cr.strftime('%Y-%m-%d %H:%M') if u.cr else ''
                ])
            cn_filename = f'ç”¨æˆ·åˆ—è¡¨_{now.strftime("%Y%m%d_%H%M")}.csv'
            ascii_filename = f'users_{now.strftime("%Y%m%d_%H%M")}.csv'
        
        elif export_type == 'orders':
            writer = csv.writer(output)
            writer.writerow(['è®¢å•å·', 'ç”¨æˆ·å', 'å¥—é¤åç§°', 'é‡‘é¢', 'æ—¶é•¿(å¤©)', 'çŠ¶æ€', 
                           'æ”¯ä»˜æ–¹å¼', 'åˆ›å»ºæ—¶é—´', 'æ”¯ä»˜æ—¶é—´'])
            
            orders = Order.query.order_by(Order.created_at.desc()).all()
            status_names = {'pending': 'å¾…æ”¯ä»˜', 'paid': 'å·²æ”¯ä»˜', 'cancelled': 'å·²å–æ¶ˆ', 'expired': 'å·²è¿‡æœŸ', 'failed': 'å¤±è´¥', 'refunded': 'å·²é€€æ¬¾'}
            for o in orders:
                # è·å–ç”¨æˆ·å
                user = db.session.get(User, o.user_tg)
                user_name = (user.name if user else f'ç”¨æˆ·{o.user_tg}')
                days = o.duration_days if o.duration_days else (o.duration_months * 30 if o.duration_months else '')
                writer.writerow([
                    o.order_no or '', user_name,
                    o.plan_name or '', f'{o.final_price:.2f}' if o.final_price else '0.00',
                    days,
                    status_names.get(o.payment_status, o.payment_status or ''),
                    o.payment_method or '',
                    o.created_at.strftime('%Y-%m-%d %H:%M') if o.created_at else '',
                    o.payment_time.strftime('%Y-%m-%d %H:%M') if o.payment_time else ''
                ])
            cn_filename = f'è®¢å•åˆ—è¡¨_{now.strftime("%Y%m%d_%H%M")}.csv'
            ascii_filename = f'orders_{now.strftime("%Y%m%d_%H%M")}.csv'
        
        elif export_type == 'subscriptions':
            writer = csv.writer(output)
            writer.writerow(['ç”¨æˆ·å', 'å¥—é¤åç§°', 'å¼€å§‹æ—¶é—´', 'ç»“æŸæ—¶é—´', 'æ—¶é•¿(æœˆ)', 'ä»·æ ¼', 'çŠ¶æ€', 'æ¥æº'])
            
            subs = Subscription.query.order_by(Subscription.created_at.desc()).all()
            status_names = {'active': 'ç”Ÿæ•ˆä¸­', 'expired': 'å·²è¿‡æœŸ', 'cancelled': 'å·²å–æ¶ˆ'}
            source_names = {'purchase': 'è´­ä¹°', 'gift': 'ç®¡ç†å‘˜èµ é€', 'manual': 'æ‰‹åŠ¨è®¾ç½®', 'redeem': 'å…‘æ¢ç '}
            for s in subs:
                user = db.session.get(User, s.user_tg)
                user_name = (user.name if user else f'ç”¨æˆ·{s.user_tg}')
                writer.writerow([
                    user_name, s.plan_name or '',
                    s.start_date.strftime('%Y-%m-%d') if s.start_date else '',
                    s.end_date.strftime('%Y-%m-%d') if s.end_date else '',
                    s.duration_months or '',
                    f'{s.price:.2f}' if s.price else '0.00',
                    status_names.get(s.status, s.status or ''),
                    source_names.get(s.source, s.source or 'purchase')
                ])
            cn_filename = f'è®¢é˜…è®°å½•_{now.strftime("%Y%m%d_%H%M")}.csv'
            ascii_filename = f'subscriptions_{now.strftime("%Y%m%d_%H%M")}.csv'
        
        else:
            return jsonify({'success': False, 'error': 'ä¸æ”¯æŒçš„å¯¼å‡ºç±»å‹'}), 400
        
        # è®°å½•å®¡è®¡æ—¥å¿—
        log_admin_audit('export_data', detail=f'å¯¼å‡º{export_type}æ•°æ®')
        
        csv_data = output.getvalue()
        output.close()
        
        # æ–‡ä»¶åå¤„ç†ï¼šä½¿ç”¨ RFC 5987 ç¼–ç ä¸­æ–‡æ–‡ä»¶åï¼Œé¿å… Gunicorn WSGI Latin-1 ç¼–ç é”™è¯¯
        # filename= æä¾› ASCII åå¤‡åï¼Œfilename*= æä¾› UTF-8 ç¼–ç çš„ä¸­æ–‡åï¼ˆç°ä»£æµè§ˆå™¨ä¼˜å…ˆä½¿ç”¨ï¼‰
        encoded_cn_filename = quote(cn_filename)
        content_disposition = f"attachment; filename=\"{ascii_filename}\"; filename*=UTF-8''{encoded_cn_filename}"
        
        response = Response(
            csv_data,
            mimetype='text/csv; charset=utf-8',
            headers={
                'Content-Disposition': content_disposition,
                'X-Skip-Gzip': '1',  # æ ‡è®°è·³è¿‡ after_request çš„ gzip å‹ç¼©
            }
        )
        return response
        
    except Exception as e:
        app.logger.error(f'æ•°æ®å¯¼å‡ºå¤±è´¥: {e}', exc_info=True)
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/admin/audit-logs', methods=['GET'])
@admin_required
def admin_get_audit_logs():
    """è·å–ç®¡ç†å‘˜å®¡è®¡æ—¥å¿—"""
    try:
        page = request.args.get('page', 1, type=int)
        per_page = request.args.get('per_page', 20, type=int)
        action_type = request.args.get('action_type', '')
        admin_username = request.args.get('admin_username', '')
        keyword = request.args.get('keyword', '')
        
        per_page = min(per_page, 100)
        
        query = AdminAuditLog.query
        
        if action_type:
            query = query.filter(AdminAuditLog.action_type == action_type)
        if admin_username:
            query = query.filter(AdminAuditLog.admin_username == admin_username)
        if keyword:
            query = query.filter(AdminAuditLog.action_detail.like(f'%{keyword}%'))
        
        query = query.order_by(AdminAuditLog.created_at.desc())
        pagination = query.paginate(page=page, per_page=per_page, error_out=False)
        
        # è·å–æ‰€æœ‰ç®¡ç†å‘˜ç”¨æˆ·åï¼ˆç”¨äºç­›é€‰ï¼‰
        admin_names = db.session.query(AdminAuditLog.admin_username).distinct().all()
        admin_names = sorted(set(n[0] for n in admin_names if n[0]))
        
        # è·å–æ‰€æœ‰æ“ä½œç±»å‹ï¼ˆç”¨äºç­›é€‰ï¼‰
        action_types = db.session.query(AdminAuditLog.action_type).distinct().all()
        action_types = sorted(set(t[0] for t in action_types if t[0]))
        
        return jsonify({
            'success': True,
            'logs': [log.to_dict() for log in pagination.items],
            'total': pagination.total,
            'page': page,
            'per_page': per_page,
            'total_pages': pagination.pages,
            'admin_names': admin_names,
            'action_types': action_types
        })
        
    except Exception as e:
        app.logger.error(f'è·å–å®¡è®¡æ—¥å¿—å¤±è´¥: {e}', exc_info=True)
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/admin/audit-logs/cleanup', methods=['POST'])
@admin_required
def admin_cleanup_audit_logs():
    """æ¸…ç†æ—§å®¡è®¡æ—¥å¿—ï¼ˆä¿ç•™æœ€è¿‘Nå¤©ï¼‰"""
    try:
        # ä»…è¶…çº§ç®¡ç†å‘˜å¯æ‰§è¡Œ
        admin = getattr(g, 'current_admin', None)
        if admin and not admin.is_super:
            return jsonify({'success': False, 'error': 'ä»…è¶…çº§ç®¡ç†å‘˜å¯æ‰§è¡Œæ­¤æ“ä½œ'}), 403
        
        data = request.get_json() or {}
        keep_days = data.get('keep_days', 90)
        keep_days = max(7, min(keep_days, 365))  # æœ€å°‘ä¿ç•™7å¤©ï¼Œæœ€å¤š365å¤©
        
        cutoff = datetime.now() - timedelta(days=keep_days)
        deleted = AdminAuditLog.query.filter(AdminAuditLog.created_at < cutoff).delete()
        db.session.commit()
        
        log_admin_audit('config_change', detail=f'æ¸…ç†å®¡è®¡æ—¥å¿—ï¼Œä¿ç•™{keep_days}å¤©ï¼Œåˆ é™¤{deleted}æ¡')
        
        return jsonify({
            'success': True,
            'deleted': deleted,
            'message': f'å·²æ¸…ç†{deleted}æ¡å®¡è®¡æ—¥å¿—ï¼ˆä¿ç•™æœ€è¿‘{keep_days}å¤©ï¼‰'
        })
        
    except Exception as e:
        db.session.rollback()
        app.logger.error(f'æ¸…ç†å®¡è®¡æ—¥å¿—å¤±è´¥: {e}', exc_info=True)
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/admin/users/<int:user_id>/toggle-role', methods=['POST'])
@admin_required
def admin_toggle_user_role(user_id):
    """è®¾ç½®ç”¨æˆ·ç­‰çº§ï¼ˆa=ç™½åå•, b=æ™®é€š, c=ç¦ç”¨ï¼‰
    æ³¨æ„ï¼šç®¡ç†å‘˜èº«ä»½æ˜¯é€šè¿‡ç¯å¢ƒå˜é‡ ADMIN_USERNAMES é…ç½®çš„ï¼Œæ— æ³•é€šè¿‡ API ä¿®æ”¹
    æ­¤ API åªèƒ½è®¾ç½®ç”¨æˆ·ç­‰çº§
    
    å½“è®¾ç½®ä¸º cï¼ˆç¦ç”¨ï¼‰æ—¶ï¼Œä¼šè‡ªåŠ¨ï¼š
    1. å¤‡ä»½å½“å‰ç­‰çº§å’Œè¿‡æœŸæ—¶é—´
    2. ç¦ç”¨ Emby è´¦å·
    3. æš‚åœç”¨æˆ·è®¢é˜…
    """
    try:
        user = db.session.get(User, user_id)
        if not user:
            return jsonify({'success': False, 'error': 'ç”¨æˆ·ä¸å­˜åœ¨'}), 404
        
        data = request.get_json() or {}
        new_level = data.get('level')
        
        level_names = {'a': 'ç™½åå•', 'b': 'æ™®é€šç”¨æˆ·', 'c': 'å·²ç¦ç”¨', 'd': 'æ— è´¦å·'}
        
        # å¦‚æœæŒ‡å®šäº†æ–°ç­‰çº§ï¼Œç›´æ¥è®¾ç½®
        if new_level and new_level in ['a', 'b', 'c', 'd']:
            old_level = user.lv or 'd'
            
            emby_disabled = False
            subscription_suspended = False
            
            # å¦‚æœæ˜¯å°ç¦æ“ä½œï¼ˆè®¾ç½®ä¸º cï¼‰ï¼Œå¤‡ä»½åŸçŠ¶æ€å¹¶ç¦ç”¨ Emby
            if new_level == 'c' and old_level != 'c':
                # å¤‡ä»½å°ç¦å‰çš„ç­‰çº§å’Œè¿‡æœŸæ—¶é—´
                user.ban_prev_lv = old_level
                user.ban_prev_ex = user.ex
                user.ban_time = datetime.now()
                user.ban_reason = data.get('reason', 'ç®¡ç†å‘˜æ‰‹åŠ¨ç¦ç”¨')
                
                # ç¦ç”¨ Emby è´¦å·
                if user.embyid and emby_client.is_enabled():
                    emby_disabled = emby_client.disable_user(user.embyid)
                
                # æš‚åœç”¨æˆ·çš„æ´»è·ƒè®¢é˜…ï¼ˆè®¾ä¸º suspended çŠ¶æ€ï¼‰
                active_subscriptions = Subscription.query.filter_by(
                    user_tg=user.tg, 
                    status='active'
                ).all()
                for sub in active_subscriptions:
                    sub.status = 'suspended'
                    subscription_suspended = True
            
            user.lv = new_level
            db.session.commit()
            
            message = f'ç”¨æˆ·ç­‰çº§å·²æ›´æ–°ä¸º {level_names.get(user.lv, user.lv)}'
            if emby_disabled:
                message += 'ï¼ŒEmby è´¦å·å·²ç¦ç”¨'
            if subscription_suspended:
                message += 'ï¼Œè®¢é˜…å·²æš‚åœ'
            
            app.logger.info(f'è®¾ç½®ç”¨æˆ·ç­‰çº§: {user.name}, {old_level} -> {new_level}, Embyç¦ç”¨={emby_disabled}, è®¢é˜…æš‚åœ={subscription_suspended}')
            
            # è®°å½•ç­‰çº§å˜æ›´æ—¥å¿—
            if new_level == 'c':
                log_user_activity(UserActivityLog.ACTION_ACCOUNT_BANNED, user=user,
                                 detail={'reason': data.get('reason', 'ç®¡ç†å‘˜æ‰‹åŠ¨ç¦ç”¨'), 'old_level': old_level,
                                        'emby_disabled': emby_disabled, 'subscription_suspended': subscription_suspended})
                log_admin_audit('user_ban', detail=f'å°ç¦ç”¨æˆ· {user.name}', target_type='user', target_id=user.tg)
            else:
                log_user_activity(UserActivityLog.ACTION_LEVEL_CHANGE, user=user,
                                 detail={'old_level': old_level, 'new_level': new_level, 
                                        'old_level_name': level_names.get(old_level), 'new_level_name': level_names.get(new_level)})
                log_admin_audit('user_level_change', detail=f'ä¿®æ”¹ç”¨æˆ· {user.name} ç­‰çº§: {level_names.get(old_level)} â†’ {level_names.get(new_level)}', target_type='user', target_id=user.tg)
            
            return jsonify({
                'success': True,
                'message': message,
                'old_level': old_level,
                'new_level': new_level,
                'emby_disabled': emby_disabled,
                'subscription_suspended': subscription_suspended
            }), 200
        else:
            return jsonify({
                'success': False,
                'error': 'è¯·æŒ‡å®šæœ‰æ•ˆçš„ç­‰çº§ï¼ˆa=ç™½åå•, b=æ™®é€š, c=ç¦ç”¨ï¼‰'
            }), 400
    except Exception as e:
        db.session.rollback()
        app.logger.error(f'è®¾ç½®ç”¨æˆ·ç­‰çº§å¤±è´¥: {e}')
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/admin/users/<int:user_id>/ban-emby', methods=['POST'])
@admin_required
def admin_ban_emby(user_id):
    """æ‰‹åŠ¨å°ç¦ç”¨æˆ·çš„ Emby è´¦å·ï¼ˆä¸å½±å“ç½‘ç«™ç™»å½•ï¼‰
    
    ä»…ç¦ç”¨ Embyï¼Œä¸æ”¹ lvï¼Œç”¨æˆ·ä»å¯ç™»å½•é¢æ¿
    """
    try:
        user = db.session.get(User, user_id)
        if not user:
            return jsonify({'success': False, 'error': 'ç”¨æˆ·ä¸å­˜åœ¨'}), 404
        
        if user.ban_reason:
            return jsonify({'success': False, 'error': 'Emby å·²å¤„äºå°ç¦çŠ¶æ€'}), 400
        
        data = request.get_json() or {}
        reason = data.get('reason', 'ç®¡ç†å‘˜æ‰‹åŠ¨å°ç¦Emby')
        
        # ä¿å­˜å°ç¦å‰çŠ¶æ€
        user.ban_prev_lv = user.lv
        user.ban_prev_ex = user.ex
        user.ban_time = datetime.now()
        user.ban_reason = reason
        
        # æš‚åœæ´»è·ƒè®¢é˜…
        active_subs = Subscription.query.filter_by(user_tg=user.tg, status='active').all()
        for sub in active_subs:
            sub.status = 'suspended'
        
        # ç¦ç”¨ Emby è´¦å·å¹¶è¸¢å‡ºä¼šè¯
        emby_disabled = False
        if user.embyid and emby_client.is_enabled():
            emby_disabled = emby_client.disable_user(user.embyid)
            emby_client.kill_user_sessions(user.embyid)
        
        db.session.commit()
        
        app.logger.info(f'ç®¡ç†å‘˜æ‰‹åŠ¨å°ç¦Emby: ç”¨æˆ·={user.name}, åŸå› ={reason}')
        log_admin_audit('user_ban_emby', detail=f'å°ç¦ç”¨æˆ· {user.name} çš„Embyè´¦å·ï¼ŒåŸå› : {reason}', target_type='user', target_id=user.tg)
        
        return jsonify({
            'success': True,
            'message': f'å·²å°ç¦ç”¨æˆ· {user.name} çš„ Emby è´¦å·',
            'emby_disabled': emby_disabled
        }), 200
    except Exception as e:
        db.session.rollback()
        app.logger.error(f'å°ç¦Embyå¤±è´¥: {e}')
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/admin/users/<int:user_id>/unban-emby', methods=['POST'])
@admin_required
def admin_unban_emby(user_id):
    """è§£é™¤ç”¨æˆ·çš„ Emby å°ç¦ï¼ˆä»…æ¸…é™¤ ban_reason å¹¶æ¢å¤ Embyï¼Œä¸æ”¹ lvï¼‰"""
    try:
        user = db.session.get(User, user_id)
        if not user:
            return jsonify({'success': False, 'error': 'ç”¨æˆ·ä¸å­˜åœ¨'}), 404
        
        if not user.ban_reason:
            return jsonify({'success': False, 'error': 'Emby æœªå¤„äºå°ç¦çŠ¶æ€'}), 400
        
        # æ¸…é™¤å°ç¦ä¿¡æ¯
        user.ban_reason = None
        user.ban_time = None
        user.ban_prev_lv = None
        user.ban_prev_ex = None
        
        # æ¢å¤ Emby è´¦å·
        emby_restored = False
        if user.embyid and emby_client.is_enabled():
            emby_restored = emby_client.enable_user(user.embyid)
        
        # æ¢å¤æš‚åœçš„è®¢é˜…
        suspended_subs = Subscription.query.filter_by(user_tg=user.tg, status='suspended').all()
        for sub in suspended_subs:
            sub.status = 'active'
        
        # è§£é™¤è®¾å¤‡é»‘åå•
        blocked_devices = UserDevice.query.filter_by(user_tg=user.tg, is_blocked=True).all()
        unblocked_count = 0
        for device in blocked_devices:
            device.is_blocked = False
            unblocked_count += 1
        
        db.session.commit()
        
        app.logger.info(f'ç®¡ç†å‘˜è§£é™¤Embyå°ç¦: ç”¨æˆ·={user.name}')
        log_admin_audit('user_unban_emby', detail=f'è§£é™¤ç”¨æˆ· {user.name} çš„Embyå°ç¦', target_type='user', target_id=user.tg)
        
        return jsonify({
            'success': True,
            'message': f'å·²è§£é™¤ç”¨æˆ· {user.name} çš„ Emby å°ç¦',
            'emby_restored': emby_restored,
            'devices_unblocked': unblocked_count
        }), 200
    except Exception as e:
        db.session.rollback()
        app.logger.error(f'è§£é™¤Embyå°ç¦å¤±è´¥: {e}')
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/admin/users/<int:user_id>/set-type', methods=['POST'])
@admin_required
def admin_set_user_type(user_id):
    """è®¾ç½®ç”¨æˆ·ç±»å‹ï¼šç™½åå•ç”¨æˆ· / è®¢é˜…ç”¨æˆ· / éè®¢é˜…ç”¨æˆ·
    
    - whitelist: è®¾ä¸ºç™½åå•ç”¨æˆ· (lv='a')
    - subscribed: è®¾ä¸ºè®¢é˜…ç”¨æˆ· (lv='b' + èµ é€æŒ‡å®šå¤©æ•°è®¢é˜…)
    - normal: è®¾ä¸ºéè®¢é˜…ç”¨æˆ· (lv='b' + æ¸…é™¤è®¢é˜…æ—¶é—´)
    """
    try:
        user = db.session.get(User, user_id)
        if not user:
            return jsonify({'success': False, 'error': 'ç”¨æˆ·ä¸å­˜åœ¨'}), 404
        
        data = request.get_json() or {}
        user_type = data.get('user_type')
        subscription_days = data.get('subscription_days', 30)  # é»˜è®¤30å¤©
        
        # æ”¯æŒ sub_basic, sub_standard ç­‰æ ¼å¼
        plan_type_value = None
        if user_type and user_type.startswith('sub_'):
            plan_type_value = user_type[4:]  # æå– basic, standard ç­‰
            # æ£€æŸ¥è¯¥å¥—é¤æ˜¯å¦æ ‡è®°ä¸ºç™½åå•å¥—é¤
            plans = load_plans_config()
            is_whitelist_plan = False
            for p in plans:
                if p.get('id') == plan_type_value and p.get('is_whitelist'):
                    is_whitelist_plan = True
                    break
            if is_whitelist_plan:
                user_type = 'whitelist'  # ç™½åå•å¥—é¤æŒ‰ç™½åå•é€»è¾‘å¤„ç†
            else:
                user_type = 'subscribed'  # æ™®é€šå¥—é¤æŒ‰è®¢é˜…ç”¨æˆ·å¤„ç†
        
        if user_type not in ['whitelist', 'subscribed', 'normal']:
            return jsonify({'success': False, 'error': 'æ— æ•ˆçš„ç”¨æˆ·ç±»å‹'}), 400
        
        # éªŒè¯è®¢é˜…å¤©æ•°
        try:
            subscription_days = int(subscription_days)
            if subscription_days <= 0:
                subscription_days = 30
        except (ValueError, TypeError):
            subscription_days = 30
        
        old_level = user.lv
        old_ex = user.ex
        message = ''
        
        if user_type == 'whitelist':
            # è®¾ä¸ºç™½åå•ç”¨æˆ·ï¼ˆlv='a' + æ°¸ä¹…åˆ°æœŸ + plan_type='whitelist'è®¢é˜…è®°å½•ï¼‰
            user.lv = 'a'
            user.ex = datetime(9999, 12, 31)  # æ°¸ä¹…æœ‰æ•ˆ
            # æ¸…é™¤å°ç¦ä¿¡æ¯
            user.ban_reason = None
            user.ban_time = None
            user.ban_prev_lv = None
            user.ban_prev_ex = None
            
            # åˆ›å»ºæˆ–æ›´æ–°ç™½åå• Subscription è®°å½•
            existing_sub = Subscription.query.filter_by(
                user_tg=user.tg, status='active'
            ).order_by(Subscription.end_date.desc()).first()
            
            if existing_sub:
                existing_sub.plan_type = 'whitelist'
                existing_sub.plan_name = 'ç™½åå•ç”¨æˆ·'
                existing_sub.end_date = datetime(9999, 12, 31)
                existing_sub.updated_at = datetime.now()
            else:
                new_sub = Subscription(
                    user_tg=user.tg,
                    plan_type='whitelist',
                    plan_name='ç™½åå•ç”¨æˆ·',
                    duration_months=-1,
                    price=0,
                    start_date=datetime.now(),
                    end_date=datetime(9999, 12, 31),
                    status='active',
                    source='manual'
                )
                db.session.add(new_sub)
            
            # å¯ç”¨ Emby è´¦å·
            if user.embyid and emby_client.is_enabled():
                emby_client.enable_user(user.embyid)
            
            message = 'å·²è®¾ä¸ºç™½åå•ç”¨æˆ·'
            
        elif user_type == 'subscribed':
            # è®¾ä¸ºè®¢é˜…ç”¨æˆ·ï¼šåªåˆ‡æ¢ç­‰çº§ï¼Œä¸è‡ªåŠ¨å»¶é•¿æ—¶é—´
            user.lv = 'b'
            # æ¸…é™¤é»‘åå•å°ç¦ä¿¡æ¯ï¼ˆç®¡ç†å‘˜æ˜ç¡®æ“ä½œï¼‰
            user.ban_reason = None
            user.ban_time = None
            user.ban_prev_lv = None
            user.ban_prev_ex = None
            
            # å¦‚æœæŒ‡å®šäº†å¥—é¤IDï¼Œæ›´æ–°æˆ–åˆ›å»º Subscription è®°å½•
            if plan_type_value:
                # åŠ¨æ€ä»å¥—é¤é…ç½®è·å–åç§°ï¼ˆæŒ‰IDåŒ¹é…ï¼Œå…¼å®¹æ—§typeåŒ¹é…ï¼‰
                plans = load_plans_config()
                plan_name = None
                for p in plans:
                    if p.get('id') == plan_type_value:
                        plan_name = p.get('name')
                        break
                if not plan_name:
                    for p in plans:
                        if p.get('type') == plan_type_value:
                            plan_name = p.get('name')
                            break
                if not plan_name:
                    plan_name = plan_type_value
                plan_name = plan_name + 'å¥—é¤'
                
                existing_sub = Subscription.query.filter_by(
                    user_tg=user.tg, status='active'
                ).order_by(Subscription.end_date.desc()).first()
                
                if existing_sub:
                    existing_sub.plan_type = plan_type_value
                    existing_sub.plan_name = plan_name
                    existing_sub.updated_at = datetime.now()
                else:
                    # åˆ›å»ºæ–°çš„è®¢é˜…è®°å½•ï¼ˆæ—¶é•¿ç”±ç®¡ç†å‘˜åç»­åœ¨è¯¦æƒ…é¡µèµ é€ï¼‰
                    new_sub = Subscription(
                        user_tg=user.tg,
                        plan_type=plan_type_value,
                        plan_name=plan_name,
                        duration_months=1,
                        price=0,
                        start_date=datetime.now(),
                        end_date=user.ex if user.ex and user.ex > datetime.now() else datetime.now(),
                        status='active',
                        source='manual'
                    )
                    db.session.add(new_sub)
                
                message = f'å·²è®¾ä¸º{plan_name}ç”¨æˆ·'
            else:
                message = 'å·²è®¾ä¸ºè®¢é˜…ç”¨æˆ·'
            
            # å¯ç”¨ Emby è´¦å·ï¼ˆå¦‚æœä¹‹å‰è¢«ç¦ç”¨ï¼‰
            if user.embyid and emby_client.is_enabled():
                emby_client.enable_user(user.embyid)
                
        elif user_type == 'normal':
            # è®¾ä¸ºéè®¢é˜…ç”¨æˆ·ï¼šæ™®é€šç­‰çº§ + æ¸…é™¤è®¢é˜…
            user.lv = 'b'
            user.ex = None
            message = 'å·²è®¾ä¸ºéè®¢é˜…ç”¨æˆ·ï¼Œè®¢é˜…å·²æ¸…é™¤'
        
        db.session.commit()
        
        # è®°å½•æ—¥å¿—
        log_user_activity(UserActivityLog.ACTION_LEVEL_CHANGE, user=user,
                         detail={'action': 'set_user_type', 'user_type': user_type,
                                'old_level': old_level, 'new_level': user.lv,
                                'old_ex': str(old_ex) if old_ex else None,
                                'new_ex': str(user.ex) if user.ex else None,
                                'subscription_days': subscription_days if user_type == 'subscribed' else None})
        
        app.logger.info(f'è®¾ç½®ç”¨æˆ·ç±»å‹: {user.name}, type={user_type}, lv={old_level}->{user.lv}, ex={old_ex}->{user.ex}')
        
        return jsonify({
            'success': True,
            'message': message
        }), 200
        
    except Exception as e:
        db.session.rollback()
        app.logger.error(f'è®¾ç½®ç”¨æˆ·ç±»å‹å¤±è´¥: {e}')
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/admin/users/<int:user_id>/unban', methods=['POST'])
@admin_required
def admin_unban_user(user_id):
    """è§£é™¤ç”¨æˆ·ç¦ç”¨ï¼ˆæ¢å¤æœ¬åœ°è´¦å·å’Œ Emby è´¦å·ï¼Œæ¢å¤åŸå…ˆçš„ç­‰çº§å’Œåˆ°æœŸæ—¶é—´ï¼‰
    
    å®æ—¶ç”Ÿæ•ˆï¼šè§£å°åç”¨æˆ·ç«‹å³å¯ä»¥ç™»å½•å’Œè§‚çœ‹
    """
    try:
        user = db.session.get(User, user_id)
        if not user:
            return jsonify({'success': False, 'error': 'ç”¨æˆ·ä¸å­˜åœ¨'}), 404
        
        data = request.get_json() or {}
        restore_original = data.get('restore_original', True)  # é»˜è®¤æ¢å¤åŸå…ˆçŠ¶æ€
        
        old_level = user.lv
        restored_info = {}
        
        if restore_original and user.ban_prev_lv:
            # æ¢å¤å°ç¦å‰çš„ç­‰çº§
            user.lv = user.ban_prev_lv
            restored_info['level'] = user.ban_prev_lv
            
            # æ¢å¤å°ç¦å‰çš„åˆ°æœŸæ—¶é—´ï¼ˆä¿æŒåŸæ ·ï¼Œä¸è‡ªåŠ¨å»¶é•¿ï¼‰
            if user.ban_prev_ex:
                user.ex = user.ban_prev_ex
                restored_info['expires_at'] = user.ban_prev_ex.isoformat()
            
            # æ¸…ç©ºå°ç¦å¤‡ä»½ä¿¡æ¯
            user.ban_prev_lv = None
            user.ban_prev_ex = None
            user.ban_time = None
            user.ban_reason = None
        else:
            # æ²¡æœ‰å¤‡ä»½ä¿¡æ¯ï¼Œæ¢å¤ä¸ºæ™®é€šç”¨æˆ·
            new_level = data.get('level', 'b')
            if new_level not in ['a', 'b']:
                new_level = 'b'
            user.lv = new_level
            restored_info['level'] = new_level
            # æ¸…ç©ºå°ç¦ä¿¡æ¯
            user.ban_prev_lv = None
            user.ban_prev_ex = None
            user.ban_time = None
            user.ban_reason = None
        
        # æ¢å¤ Emby è´¦å·
        emby_restored = False
        emby_error = None
        if user.embyid:
            if emby_client.is_enabled():
                emby_restored = emby_client.enable_user(user.embyid)
                if not emby_restored:
                    emby_error = 'Emby è´¦å·å¯ç”¨å¤±è´¥ï¼Œè¯·åœ¨ Emby åå°æ‰‹åŠ¨å¯ç”¨'
                    app.logger.warning(f'è§£å°ç”¨æˆ· {user.name}: Emby è´¦å·å¯ç”¨å¤±è´¥, embyid={user.embyid}')
            else:
                emby_error = 'Emby æœªé…ç½®ï¼Œè¯·æ‰‹åŠ¨å¯ç”¨ Emby è´¦å·'
                app.logger.warning(f'è§£å°ç”¨æˆ· {user.name}: Emby æœªé…ç½®')
        else:
            app.logger.info(f'è§£å°ç”¨æˆ· {user.name}: ç”¨æˆ·æœªç»‘å®š Emby è´¦å·')
        
        # æ¢å¤ç”¨æˆ·çš„æš‚åœè®¢é˜…ï¼ˆsuspended -> activeï¼‰
        subscription_restored = False
        suspended_subscriptions = Subscription.query.filter_by(
            user_tg=user.tg,
            status='suspended'
        ).all()
        for sub in suspended_subscriptions:
            sub.status = 'active'
            subscription_restored = True
        
        # è§£é™¤è¯¥ç”¨æˆ·æ‰€æœ‰è®¾å¤‡çš„é»‘åå•çŠ¶æ€
        blocked_devices = UserDevice.query.filter_by(user_tg=user.tg, is_blocked=True).all()
        unblocked_count = 0
        for device in blocked_devices:
            device.is_blocked = False
            unblocked_count += 1
        
        db.session.commit()
        
        level_names = {'a': 'ç™½åå•', 'b': 'æ™®é€šç”¨æˆ·', 'c': 'ç¦ç”¨', 'd': 'æ— è´¦å·'}
        new_level_name = level_names.get(user.lv, user.lv)
        
        app.logger.info(f'è§£é™¤ç”¨æˆ·ç¦ç”¨: {user.name}, ç­‰çº§ {old_level} -> {user.lv}, Embyæ¢å¤={emby_restored}, è®¢é˜…æ¢å¤={subscription_restored}, è§£é™¤è®¾å¤‡={unblocked_count}')
        
        # è®°å½•è§£å°æ—¥å¿—
        log_user_activity(UserActivityLog.ACTION_ACCOUNT_UNBANNED, user=user,
                         detail={'old_level': old_level, 'new_level': user.lv, 'emby_restored': emby_restored,
                                'subscription_restored': subscription_restored, 'devices_unblocked': unblocked_count})
        log_admin_audit('user_unban', detail=f'è§£å°ç”¨æˆ· {user.name}', target_type='user', target_id=user.tg)
        
        message = f'ç”¨æˆ·å·²è§£é™¤ç¦ç”¨ï¼Œç­‰çº§æ¢å¤ä¸º{new_level_name}'
        if 'expires_at' in restored_info:
            message += f'ï¼Œåˆ°æœŸæ—¶é—´å·²æ¢å¤'
        if subscription_restored:
            message += 'ï¼Œè®¢é˜…å·²æ¢å¤'
        if emby_error:
            message += f'\nâš ï¸ {emby_error}'
        
        return jsonify({
            'success': True,
            'message': message,
            'emby_restored': emby_restored,
            'emby_error': emby_error,
            'subscription_restored': subscription_restored,
            'devices_unblocked': unblocked_count,
            'restored': restored_info
        }), 200
    except Exception as e:
        db.session.rollback()
        app.logger.error(f'è§£é™¤ç”¨æˆ·ç¦ç”¨å¤±è´¥: {e}')
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/admin/users/<int:user_id>/reset-password', methods=['POST'])
@admin_required
def admin_reset_user_password(user_id):
    """ç®¡ç†å‘˜é‡ç½®ç”¨æˆ·å¯†ç """
    try:
        user = db.session.get(User, user_id)
        if not user:
            return jsonify({'success': False, 'error': 'ç”¨æˆ·ä¸å­˜åœ¨'}), 404
        
        data = request.get_json() or {}
        new_password = data.get('password', '')
        
        # å¦‚æœæ²¡æœ‰æä¾›å¯†ç ï¼Œç”Ÿæˆéšæœºå¯†ç 
        if not new_password:
            import random
            import string
            new_password = ''.join(random.choices(string.ascii_letters + string.digits, k=8))
        
        # éªŒè¯å¯†ç é•¿åº¦
        if len(new_password) < 6 or len(new_password) > 32:
            return jsonify({'success': False, 'error': 'å¯†ç é•¿åº¦å¿…é¡»åœ¨6-32ä¸ªå­—ç¬¦ä¹‹é—´'}), 400
        
        user.pwd = new_password
        
        # æ›´æ–°session_tokenï¼Œä½¿ç”¨æˆ·çš„æ‰€æœ‰ä¼šè¯å¤±æ•ˆ
        import secrets
        user.session_token = secrets.token_hex(32)
        
        db.session.commit()
        
        app.logger.info(f'ç®¡ç†å‘˜é‡ç½®ç”¨æˆ·å¯†ç : {user.name}ï¼Œç”¨æˆ·å·²è¢«å¼ºåˆ¶é€€å‡ºç™»å½•')
        
        # è®°å½•æ“ä½œæ—¥å¿—
        log_user_activity(UserActivityLog.ACTION_PASSWORD_CHANGE, user=user,
                         detail={'admin_reset': True, 'admin': session.get('admin_username', 'unknown')})
        log_admin_audit('user_reset_password', detail=f'é‡ç½®ç”¨æˆ· {user.name} å¯†ç ', target_type='user', target_id=user.tg)
        
        return jsonify({
            'success': True,
            'message': 'å¯†ç é‡ç½®æˆåŠŸ',
            'new_password': new_password  # è¿”å›æ–°å¯†ç ä¾›ç®¡ç†å‘˜å‘ŠçŸ¥ç”¨æˆ·
        }), 200
    except Exception as e:
        db.session.rollback()
        app.logger.error(f'é‡ç½®ç”¨æˆ·å¯†ç å¤±è´¥: {e}')
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/admin/users/<int:user_id>/delete', methods=['DELETE'])
@admin_required
def admin_delete_user(user_id):
    """ç®¡ç†å‘˜åˆ é™¤ç”¨æˆ·è´¦å·ï¼ˆå¤ç”¨ hard_delete_user_dataï¼‰"""
    try:
        user = db.session.get(User, user_id)
        if not user:
            return jsonify({'success': False, 'error': 'ç”¨æˆ·ä¸å­˜åœ¨'}), 404
        
        # é˜²æ­¢åˆ é™¤ç®¡ç†å‘˜è´¦æˆ·
        if user.is_admin:
            return jsonify({'success': False, 'error': 'ä¸èƒ½åˆ é™¤ç®¡ç†å‘˜è´¦æˆ·'}), 400
        
        user_name = user.name
        
        # è°ƒç”¨é€šç”¨ç¡¬åˆ é™¤å‡½æ•°
        result = hard_delete_user_data(user_id, reason='ç®¡ç†å‘˜æ‰‹åŠ¨åˆ é™¤')
        
        if result['db_deleted']:
            app.logger.info(f'ç®¡ç†å‘˜åˆ é™¤ç”¨æˆ·è´¦å·: {user_name} (tg={user_id}, emby_deleted={result["emby_deleted"]})')
            return jsonify({
                'success': True,
                'message': f'ç”¨æˆ· {user_name} å·²åˆ é™¤',
                'emby_deleted': result['emby_deleted']
            }), 200
        else:
            return jsonify({'success': False, 'error': 'åˆ é™¤ç”¨æˆ·æ•°æ®å¤±è´¥ï¼Œè¯·æŸ¥çœ‹æ—¥å¿—'}), 500
    except Exception as e:
        db.session.rollback()
        app.logger.error(f'åˆ é™¤ç”¨æˆ·è´¦å·å¤±è´¥: {e}')
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/admin/users/<int:user_id>/details', methods=['GET'])
@admin_required
def admin_get_user_details(user_id):
    """ç®¡ç†å‘˜è·å–ç”¨æˆ·è¯¦ç»†ä¿¡æ¯"""
    try:
        user = db.session.get(User, user_id)
        if not user:
            return jsonify({'success': False, 'error': 'ç”¨æˆ·ä¸å­˜åœ¨'}), 404
        
        # è·å–ç”¨æˆ·è®¢é˜…ä¿¡æ¯
        subscriptions = Subscription.query.filter_by(user_tg=user.tg).order_by(
            Subscription.created_at.desc()
        ).limit(10).all()
        
        # å¦‚æœæ²¡æœ‰ Subscription è®°å½•ï¼Œä½†ç”¨æˆ·æœ‰æœ‰æ•ˆçš„åˆ°æœŸæ—¶é—´(user.ex)ï¼Œè¡¥å……åˆ›å»ºä¸€æ¡è®°å½•
        if not subscriptions and user.ex and user.ex > datetime.now():
            # å°è¯•ä»è®¢å•è¡¨æ‰¾åˆ°æœ€è¿‘çš„å·²æ”¯ä»˜è®¢å•æ¥ç¡®å®šå¥—é¤ä¿¡æ¯
            recent_order = Order.query.filter_by(
                user_tg=user.tg,
                payment_status='paid'
            ).order_by(Order.payment_time.desc()).first()
            
            if recent_order:
                # æ ¹æ®è®¢å•åˆ›å»ºè®¢é˜…è®°å½•
                subscription = Subscription(
                    user_tg=user.tg,
                    plan_type=recent_order.plan_type,
                    plan_name=recent_order.plan_name,
                    duration_months=recent_order.duration_months,
                    price=recent_order.final_price,
                    start_date=recent_order.payment_time or datetime.now(),
                    end_date=user.ex,
                    status='active',
                    source='purchase'
                )
                db.session.add(subscription)
                db.session.commit()
                app.logger.info(f'[ç®¡ç†åå°] è‡ªåŠ¨è¡¥å……åˆ›å»ºè®¢é˜…è®°å½•: ç”¨æˆ·={user.name}, å¥—é¤={recent_order.plan_name}')
                subscriptions = [subscription]
            elif user.lv != 'a':  # æ—§ç™½åå•ç”¨æˆ·å…¼å®¹ï¼šä¸è¡¥å……åˆ›å»ºï¼ˆå·²æœ‰whitelistè®¢é˜…ï¼‰
                # æ²¡æœ‰è®¢å•è®°å½•ï¼Œå¯èƒ½æ˜¯ç®¡ç†å‘˜æ‰‹åŠ¨è®¾ç½®çš„ï¼Œåˆ›å»ºä¸€ä¸ªé€šç”¨è®°å½•
                subscription = Subscription(
                    user_tg=user.tg,
                    plan_type='manual',
                    plan_name='è®¢é˜…ä¼šå‘˜',
                    duration_months=max(1, (user.ex - datetime.now()).days // 30),
                    price=0,
                    start_date=user.cr or datetime.now(),
                    end_date=user.ex,
                    status='active',
                    source='manual'
                )
                db.session.add(subscription)
                db.session.commit()
                app.logger.info(f'[ç®¡ç†åå°] è‡ªåŠ¨è¡¥å……åˆ›å»ºè®¢é˜…è®°å½•(æ‰‹åŠ¨è®¾ç½®): ç”¨æˆ·={user.name}')
                subscriptions = [subscription]
        
        # è·å–ç”¨æˆ·è®¢å•ä¿¡æ¯
        orders = Order.query.filter_by(user_tg=user.tg).order_by(
            Order.created_at.desc()
        ).limit(10).all()
        
        # è·å–ç”¨æˆ·æ±‚ç‰‡è®°å½•
        requests = MovieRequest.query.filter_by(user_tg=user.tg).order_by(
            MovieRequest.created_at.desc()
        ).limit(10).all()
        
        # è·å–ç”¨æˆ·è®¾å¤‡ä¿¡æ¯
        devices = UserDevice.query.filter_by(user_tg=user.tg).order_by(
            UserDevice.last_active.desc()
        ).limit(10).all()
        
        # è·å–é‚€è¯·è®°å½•
        invite_records = InviteRecord.query.filter_by(inviter_tg=user.tg).order_by(
            InviteRecord.created_at.desc()
        ).limit(10).all()
        
        # åˆ¤æ–­ç”¨æˆ·ç­‰çº§åç§°ï¼ˆè€ƒè™‘è®¢é˜…çŠ¶æ€ï¼‰
        _detail_wl = Subscription.query.filter_by(user_tg=user.tg, plan_type='whitelist', status='active').first()
        if user.lv == 'c':
            level_name = 'å·²ç¦ç”¨'
        elif _detail_wl or user.lv == 'a':
            level_name = 'ç™½åå•'
        elif user.ex and user.ex > datetime.now():
            level_name = 'è®¢é˜…ç”¨æˆ·'
        else:
            level_name = 'æ™®é€šç”¨æˆ·'
        
        # åˆ¤æ–­æ˜¯å¦æ˜¯ BOT ç®¡ç†å‘˜
        config = load_system_config()
        bot_admins_str = config.get('telegram', {}).get('bot_admins', '')
        bot_admin_ids = [x.strip() for x in bot_admins_str.split(',') if x.strip()]
        is_bot_admin = str(user.telegram_id) in bot_admin_ids if user.telegram_id else False
        
        # è·å–ç­¾åˆ°é…ç½®å’Œç§¯åˆ†ä¿¡æ¯
        checkin_config = get_db_config('checkin', {})
        coin_name = checkin_config.get('coin_name', 'ç§¯åˆ†')
        user_coins = user.coins if hasattr(user, 'coins') else 0
        
        return jsonify({
            'success': True,
            'coin_name': coin_name,  # è´§å¸åç§°
            'user': {
                'id': user.tg,
                'name': user.name,
                'pwd': user.pwd or '',  # ç½‘ç«™å¯†ç ï¼ˆç®¡ç†å‘˜æŸ¥çœ‹ç”¨ï¼‰
                'pwd2': user.pwd2 or '',  # Emby å¯†ç ï¼ˆç®¡ç†å‘˜æŸ¥çœ‹ç”¨ï¼‰
                'telegram_id': user.telegram_id,  # åªæœ‰ç»‘å®šäº†æ‰æœ‰å€¼
                'emby_id': user.embyid,
                'emby_name': user.emby_name,  # Emby ç”¨æˆ·åï¼ˆç‹¬ç«‹å­—æ®µï¼‰
                'level': user.lv,
                'level_name': level_name,
                'subscription_plan_type': 'whitelist' if (_detail_wl or user.lv == 'a') else (subscriptions[0].plan_type if subscriptions and subscriptions[0].status == 'active' else None),
                'is_admin': user.is_admin,
                'is_bot_admin': is_bot_admin,
                'email': user.email,  # ç»‘å®šé‚®ç®±
                'coins': user_coins,  # ç”¨æˆ·ç§¯åˆ†
                'expires_at': user.ex.isoformat() if user.ex else None,
                'created_at': user.cr.isoformat() if user.cr else None,
                'invite_count': user.iv or 0,
                'invite_reward_mode': user.invite_reward_mode,
                'invite_reward_percent': user.invite_reward_percent,
                'ban_time': user.ban_time.isoformat() if user.ban_time else None,
                'ban_reason': user.ban_reason,
                'ban_prev_lv': user.ban_prev_lv,
                'ban_prev_ex': user.ban_prev_ex.isoformat() if user.ban_prev_ex else None
            },
            'subscriptions': [s.to_dict() for s in subscriptions],
            'orders': [o.to_dict() for o in orders],
            'requests': [{
                'id': r.id,
                'title': r.title,
                'year': r.year,
                'status': r.status,
                'media_type': r.media_type,
                'created_at': r.created_at.isoformat() if r.created_at else None
            } for r in requests],
            'devices': [{
                'id': d.id,
                'device_name': d.device_name,
                'client': d.client,
                'last_ip': d.last_ip,
                'is_blocked': d.is_blocked,
                'last_active': d.last_active.isoformat() if d.last_active else None
            } for d in devices],
            'invites': [{
                'id': i.id,
                'invitee_tg': i.invitee_tg,
                'invitee_name': (db.session.get(User, i.invitee_tg) or type('', (), {'name': 'æœªçŸ¥'})()).name,
                'reward_type': i.reward_type,
                'reward_value': i.reward_value,
                'reward_claimed': i.reward_claimed,
                'reward_mode': i.reward_mode,
                'custom_reward_percent': i.custom_reward_percent,
                'pending_reward': i.pending_reward or 0,
                'status': 'pending' if (i.pending_reward and i.pending_reward > 0) else ('approved' if i.reward_claimed else 'waiting'),
                'status_display': 'å¾…å®¡æ ¸' if (i.pending_reward and i.pending_reward > 0) else ('å·²å‘æ”¾' if i.reward_claimed else 'ç­‰å¾…è´­ä¹°'),
                'created_at': i.created_at.isoformat() if i.created_at else None
            } for i in invite_records],
            # è¯¥ç”¨æˆ·ä½œä¸ºè¢«é‚€è¯·äººçš„é‚€è¯·è®°å½•ï¼ˆè°é‚€è¯·äº†ä»–ï¼‰
            'invited_by': (lambda r: {
                'inviter_tg': r.inviter_tg,
                'inviter_name': (db.session.get(User, r.inviter_tg) or type('', (), {'name': 'æœªçŸ¥'})()).name,
                'reward_mode': r.reward_mode,
                'custom_reward_percent': r.custom_reward_percent,
                'reward_value': r.reward_value,
                'reward_claimed': r.reward_claimed,
                'pending_reward': r.pending_reward or 0,
                'status_display': 'å¾…å®¡æ ¸' if (r.pending_reward and r.pending_reward > 0) else ('å·²å‘æ”¾' if r.reward_claimed else 'ç­‰å¾…è´­ä¹°')
            } if r else None)(InviteRecord.query.filter_by(invitee_tg=user.tg).first())
        }), 200
    except Exception as e:
        app.logger.error(f'è·å–ç”¨æˆ·è¯¦æƒ…å¤±è´¥: {e}')
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/admin/users/<int:user_id>/activity-logs', methods=['GET'])
@admin_required
def admin_get_user_activity_logs(user_id):
    """ç®¡ç†å‘˜è·å–ç”¨æˆ·æ“ä½œæ—¥å¿—"""
    try:
        user = db.session.get(User, user_id)
        if not user:
            return jsonify({'success': False, 'error': 'ç”¨æˆ·ä¸å­˜åœ¨'}), 404
        
        # åˆ†é¡µå‚æ•°
        page = request.args.get('page', 1, type=int)
        per_page = request.args.get('per_page', 20, type=int)
        action_type = request.args.get('action_type', '')  # å¯é€‰çš„æ“ä½œç±»å‹è¿‡æ»¤
        
        # æŸ¥è¯¢æ—¥å¿—
        query = UserActivityLog.query.filter_by(user_tg=user.tg)
        
        if action_type:
            query = query.filter_by(action_type=action_type)
        
        # æŒ‰æ—¶é—´å€’åº
        query = query.order_by(UserActivityLog.created_at.desc())
        
        # åˆ†é¡µ
        total = query.count()
        logs = query.offset((page - 1) * per_page).limit(per_page).all()
        
        return jsonify({
            'success': True,
            'user_name': user.name,
            'logs': [log.to_dict() for log in logs],
            'pagination': {
                'page': page,
                'per_page': per_page,
                'total': total,
                'total_pages': (total + per_page - 1) // per_page
            }
        }), 200
    except Exception as e:
        app.logger.error(f'è·å–ç”¨æˆ·æ“ä½œæ—¥å¿—å¤±è´¥: {e}')
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/admin/users/<int:user_id>/invite-reward-config', methods=['POST'])
@admin_required
def admin_set_user_invite_reward_config(user_id):
    """ç®¡ç†å‘˜è®¾ç½®å•ä¸ªç”¨æˆ·çš„é‚€è¯·è¿”åˆ©é…ç½®ï¼ˆä¸ªæ€§åŒ–è¿”åˆ©æ¯”ä¾‹å’Œæ¨¡å¼ï¼‰"""
    try:
        user = db.session.get(User, user_id)
        if not user:
            return jsonify({'success': False, 'error': 'ç”¨æˆ·ä¸å­˜åœ¨'}), 404
        
        data = request.json
        if not data:
            return jsonify({'success': False, 'error': 'è¯·æ±‚æ•°æ®ä¸ºç©º'}), 400
        
        # è·å–é…ç½®å‚æ•°
        reward_mode = data.get('reward_mode')  # 'once', 'recurring', '' (ç©º=è·Ÿéšå…¨å±€)
        custom_percent = data.get('custom_reward_percent')  # number æˆ– null/'' (è·Ÿéšå…¨å±€)
        
        # éªŒè¯æ¨¡å¼
        if reward_mode and reward_mode not in ('once', 'recurring'):
            return jsonify({'success': False, 'error': 'è¿”åˆ©æ¨¡å¼åªèƒ½æ˜¯ once æˆ– recurring'}), 400
        
        # éªŒè¯æ¯”ä¾‹
        if custom_percent is not None and custom_percent != '':
            try:
                custom_percent = float(custom_percent)
                if custom_percent < 0 or custom_percent > 100:
                    return jsonify({'success': False, 'error': 'è¿”åˆ©æ¯”ä¾‹éœ€åœ¨ 0~100 ä¹‹é—´'}), 400
            except (ValueError, TypeError):
                return jsonify({'success': False, 'error': 'è¿”åˆ©æ¯”ä¾‹å¿…é¡»æ˜¯æ•°å­—'}), 400
        else:
            custom_percent = None  # è·Ÿéšå…¨å±€
        
        # ç©ºå­—ç¬¦ä¸²è¡¨ç¤ºè·Ÿéšå…¨å±€
        if reward_mode == '':
            reward_mode = None
        
        # ä¿å­˜åˆ° User è¡¨ï¼ˆä¸»è¦å­˜å‚¨ä½ç½®ï¼‰
        user.invite_reward_mode = reward_mode
        user.invite_reward_percent = custom_percent
        
        # åŒæ—¶åŒæ­¥åˆ°è¯¥ç”¨æˆ·ä½œä¸ºé‚€è¯·äººçš„æ‰€æœ‰é‚€è¯·è®°å½•ï¼ˆå…¼å®¹æ—§é€»è¾‘ï¼‰
        invite_records = InviteRecord.query.filter_by(inviter_tg=user.tg).all()
        updated_count = 0
        for record in invite_records:
            record.reward_mode = reward_mode
            record.custom_reward_percent = custom_percent
            updated_count += 1
        
        db.session.commit()
        
        app.logger.info(
            f'ç®¡ç†å‘˜è®¾ç½®ç”¨æˆ·é‚€è¯·è¿”åˆ©é…ç½®: ç”¨æˆ·={user.name}(tg={user.tg}), '
            f'æ¨¡å¼={reward_mode or "è·Ÿéšå…¨å±€"}, æ¯”ä¾‹={custom_percent if custom_percent is not None else "è·Ÿéšå…¨å±€"}%, '
            f'æ›´æ–°äº† {updated_count} æ¡é‚€è¯·è®°å½•'
        )
        
        return jsonify({
            'success': True,
            'message': f'å·²æ›´æ–° {updated_count} æ¡é‚€è¯·è®°å½•çš„è¿”åˆ©é…ç½®',
            'config': {
                'reward_mode': reward_mode,
                'custom_reward_percent': custom_percent
            }
        }), 200
    except Exception as e:
        app.logger.error(f'è®¾ç½®ç”¨æˆ·é‚€è¯·è¿”åˆ©é…ç½®å¤±è´¥: {e}')
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/admin/invite-reward/<int:record_id>/approve', methods=['POST'])
@admin_required
def admin_approve_invite_reward(record_id):
    """ç®¡ç†å‘˜å®¡æ ¸é€šè¿‡é‚€è¯·è¿”åˆ©ï¼Œå°†å¾…å®¡æ ¸çš„å¤©æ•°å‘æ”¾åˆ°é‚€è¯·äººè´¦æˆ·"""
    try:
        record = db.session.get(InviteRecord, record_id)
        if not record:
            return jsonify({'success': False, 'error': 'è®°å½•ä¸å­˜åœ¨'}), 404
        
        pending = record.pending_reward or 0
        if pending <= 0:
            return jsonify({'success': False, 'error': 'æ²¡æœ‰å¾…å®¡æ ¸çš„è¿”åˆ©'}), 400
        
        inviter = db.session.get(User, record.inviter_tg)
        if not inviter:
            return jsonify({'success': False, 'error': 'é‚€è¯·äººä¸å­˜åœ¨'}), 404
        
        # å‘æ”¾å¤©æ•°åˆ°é‚€è¯·äººè´¦æˆ·
        reward_days = int(pending)
        if inviter.ex and inviter.ex > datetime.now():
            inviter.ex = inviter.ex + timedelta(days=reward_days)
        else:
            inviter.ex = datetime.now() + timedelta(days=reward_days)
        
        # æ— è´¦å·ç”¨æˆ·å‡çº§ä¸ºæ™®é€šç”¨æˆ·ï¼Œå°ç¦ç”¨æˆ·ä¿æŒå°ç¦çŠ¶æ€
        if inviter.lv not in ['a', 'b', 'c']:
            inviter.lv = 'b'
        
        # æ›´æ–°è®°å½•
        record.reward_value = (record.reward_value or 0) + reward_days
        record.pending_reward = 0
        record.reward_claimed = True
        record.claimed_at = datetime.now()
        
        db.session.commit()
        
        app.logger.info(f'ç®¡ç†å‘˜å®¡æ ¸é€šè¿‡é‚€è¯·è¿”åˆ©: é‚€è¯·äºº={inviter.name}, å‘æ”¾å¤©æ•°={reward_days}, è®°å½•ID={record_id}')
        
        return jsonify({
            'success': True,
            'message': f'å·²å‘æ”¾ {reward_days} å¤©åˆ° {inviter.name} çš„è´¦æˆ·'
        }), 200
    except Exception as e:
        app.logger.error(f'å®¡æ ¸é‚€è¯·è¿”åˆ©å¤±è´¥: {e}')
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/admin/invite-reward/<int:record_id>/reject', methods=['POST'])
@admin_required
def admin_reject_invite_reward(record_id):
    """ç®¡ç†å‘˜é©³å›é‚€è¯·è¿”åˆ©ï¼Œæ¸…é™¤å¾…å®¡æ ¸çš„å¤©æ•°"""
    try:
        record = db.session.get(InviteRecord, record_id)
        if not record:
            return jsonify({'success': False, 'error': 'è®°å½•ä¸å­˜åœ¨'}), 404
        
        pending = record.pending_reward or 0
        if pending <= 0:
            return jsonify({'success': False, 'error': 'æ²¡æœ‰å¾…å®¡æ ¸çš„è¿”åˆ©'}), 400
        
        # æ¸…é™¤å¾…å®¡æ ¸å¤©æ•°
        record.pending_reward = 0
        
        db.session.commit()
        
        inviter = db.session.get(User, record.inviter_tg)
        inviter_name = inviter.name if inviter else 'æœªçŸ¥'
        
        app.logger.info(f'ç®¡ç†å‘˜é©³å›é‚€è¯·è¿”åˆ©: é‚€è¯·äºº={inviter_name}, é©³å›å¤©æ•°={pending}, è®°å½•ID={record_id}')
        
        return jsonify({
            'success': True,
            'message': f'å·²é©³å› {int(pending)} å¤©è¿”åˆ©'
        }), 200
    except Exception as e:
        app.logger.error(f'é©³å›é‚€è¯·è¿”åˆ©å¤±è´¥: {e}')
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/admin/activity-logs', methods=['GET'])
@admin_required
def admin_get_all_activity_logs():
    """ç®¡ç†å‘˜è·å–æ‰€æœ‰æ“ä½œæ—¥å¿—ï¼ˆå¯ç­›é€‰ï¼‰"""
    try:
        # åˆ†é¡µå‚æ•°
        page = request.args.get('page', 1, type=int)
        per_page = request.args.get('per_page', 50, type=int)
        action_type = request.args.get('action_type', '')
        user_name = request.args.get('user_name', '')
        status = request.args.get('status', '')
        
        # æ„å»ºæŸ¥è¯¢
        query = UserActivityLog.query
        
        if action_type:
            query = query.filter_by(action_type=action_type)
        if user_name:
            query = query.filter(UserActivityLog.user_name.ilike(f'%{user_name}%'))
        if status:
            query = query.filter_by(status=status)
        
        # æŒ‰æ—¶é—´å€’åº
        query = query.order_by(UserActivityLog.created_at.desc())
        
        # åˆ†é¡µ
        total = query.count()
        logs = query.offset((page - 1) * per_page).limit(per_page).all()
        
        # å¯ç”¨çš„æ“ä½œç±»å‹åˆ—è¡¨
        action_types = [
            {'value': 'login', 'label': 'ç™»å½•'},
            {'value': 'logout', 'label': 'ç™»å‡º'},
            {'value': 'register', 'label': 'æ³¨å†Œ'},
            {'value': 'password_change', 'label': 'ä¿®æ”¹å¯†ç '},
            {'value': 'request_movie', 'label': 'æäº¤æ±‚ç‰‡'},
            {'value': 'redeem_code', 'label': 'å…‘æ¢ç '},
            {'value': 'create_order', 'label': 'åˆ›å»ºè®¢å•'},
            {'value': 'payment_success', 'label': 'æ”¯ä»˜æˆåŠŸ'},
            {'value': 'account_banned', 'label': 'è´¦å·å°ç¦'},
            {'value': 'account_unbanned', 'label': 'è´¦å·è§£å°'},
            {'value': 'level_change', 'label': 'ç­‰çº§å˜æ›´'},
            {'value': 'view_lines', 'label': 'æŸ¥çœ‹çº¿è·¯'},
        ]
        
        return jsonify({
            'success': True,
            'logs': [log.to_dict() for log in logs],
            'action_types': action_types,
            'pagination': {
                'page': page,
                'per_page': per_page,
                'total': total,
                'total_pages': (total + per_page - 1) // per_page
            }
        }), 200
    except Exception as e:
        app.logger.error(f'è·å–æ“ä½œæ—¥å¿—å¤±è´¥: {e}')
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/admin/orders/<order_no>/mark-paid', methods=['POST'])
@admin_required
def admin_mark_order_paid(order_no):
    """ç®¡ç†å‘˜æ ‡è®°è®¢å•ä¸ºå·²æ”¯ä»˜"""
    try:
        order = Order.query.filter_by(order_no=order_no).first()
        if not order:
            return jsonify({'success': False, 'error': 'è®¢å•ä¸å­˜åœ¨'}), 404
        
        if order.payment_status == 'paid':
            return jsonify({'success': False, 'error': 'è®¢å•å·²ç»æ˜¯å·²æ”¯ä»˜çŠ¶æ€'}), 400
        
        # æ›´æ–°è®¢å•çŠ¶æ€
        order.payment_status = 'paid'
        order.paid_at = datetime.now()
        order.payment_method = 'manual'  # æ ‡è®°ä¸ºäººå·¥å¤„ç†
        
        # åˆ›å»ºæˆ–å»¶é•¿è®¢é˜…
        from datetime import timedelta
        user_tg = order.user_tg
        duration_months = order.duration_months or 1
        # ä¼˜å…ˆä½¿ç”¨ duration_daysï¼ˆæ”¯æŒçŸ­æœŸå¥—é¤ï¼‰ï¼Œå›é€€åˆ° duration_months * 30
        purchased_days = order.duration_days if order.duration_days else (duration_months * 30)
        
        # è·å–ç”¨æˆ·
        user = db.session.get(User, user_tg)
        if not user:
            return jsonify({'success': False, 'error': 'ç”¨æˆ·ä¸å­˜åœ¨'}), 404
        
        # è®¡ç®—è®¢é˜…ç»“æŸæ—¶é—´
        start_date = datetime.now()
        end_date = start_date + timedelta(days=purchased_days)
        
        # æŸ¥æ‰¾ç°æœ‰æœ‰æ•ˆè®¢é˜…
        existing_sub = Subscription.query.filter_by(
            user_tg=user_tg,
            status='active'
        ).first()
        
        if existing_sub:
            # å»¶é•¿ç°æœ‰è®¢é˜…
            existing_sub.end_date = existing_sub.end_date + timedelta(days=purchased_days)
            existing_sub.duration_months = (existing_sub.duration_months or 0) + duration_months
            end_date = existing_sub.end_date
        else:
            # åˆ›å»ºæ–°è®¢é˜…
            new_sub = Subscription(
                user_tg=user_tg,
                plan_type=order.plan_type,
                plan_name=order.plan_name,
                duration_months=duration_months,
                price=order.final_price,
                start_date=start_date,
                end_date=end_date,
                status='active',
                source='purchase'
            )
            db.session.add(new_sub)
        
        # æ›´æ–°ç”¨æˆ·åˆ°æœŸæ—¶é—´å’Œç­‰çº§ - ä½¿ç”¨ä¸å¸¦æ—¶åŒºçš„æ—¶é—´ï¼Œä¸æ•°æ®åº“ä¸€è‡´
        now = datetime.now()
        if user.ex and user.ex > now:
            # å¦‚æœç”¨æˆ·è¿˜æœ‰æœ‰æ•ˆæœŸï¼Œåœ¨åŸæœ‰åŸºç¡€ä¸Šå»¶é•¿
            user.ex = user.ex + timedelta(days=purchased_days)
        else:
            # å¦åˆ™ä»ç°åœ¨å¼€å§‹è®¡ç®—
            user.ex = now + timedelta(days=purchased_days)
        
        # ç™½åå•ä¸å˜ï¼Œå°ç¦ç”¨æˆ·ä¿æŒå°ç¦çŠ¶æ€ï¼ˆéœ€ç®¡ç†å‘˜æ‰‹åŠ¨è§£å°ï¼‰
        if user.lv not in ['a', 'b', 'c']:
            user.lv = 'b'
        
        # é‚€è¯·è¿”åˆ©ï¼šæ£€æŸ¥æ˜¯å¦æœ‰é‚€è¯·äººï¼Œç»™é‚€è¯·äººè¿”åˆ©
        process_invite_reward(user, purchased_days, source='æ‰‹å·¥æ ‡è®°ä»˜æ¬¾')
        
        db.session.commit()
        
        # æ¢å¤Embyè´¦å·ï¼ˆå°ç¦ç”¨æˆ·å’Œé»‘åå•ç¦ç”¨ç”¨æˆ·ä¸è‡ªåŠ¨æ¢å¤ï¼‰
        if user.lv != 'c' and not user.ban_reason and user.embyid and emby_client.is_enabled():
            if emby_client.enable_user(user.embyid):
                app.logger.info(f'ç®¡ç†å‘˜æ‰‹åŠ¨æ ‡è®°ä»˜æ¬¾ï¼Œå·²æ¢å¤ç”¨æˆ· {user.name} çš„Embyè´¦å·')
        
        app.logger.info(f'ç®¡ç†å‘˜æ‰‹åŠ¨æ ‡è®°è®¢å• {order_no} ä¸ºå·²æ”¯ä»˜ï¼Œç”¨æˆ· {user.name} è®¢é˜…å·²ç”Ÿæ•ˆï¼Œåˆ°æœŸæ—¶é—´: {user.ex}')
        log_admin_audit('order_mark_paid', detail=f'æ‰‹åŠ¨æ ‡è®°è®¢å• {order_no} ä¸ºå·²æ”¯ä»˜ï¼Œç”¨æˆ· {user.name}', target_type='order', target_id=order_no)
        
        return jsonify({
            'success': True,
            'message': 'è®¢å•å·²æ ‡è®°ä¸ºå·²æ”¯ä»˜ï¼Œè®¢é˜…å·²ç”Ÿæ•ˆ'
        }), 200
    except Exception as e:
        db.session.rollback()
        app.logger.error(f'æ ‡è®°è®¢å•å·²æ”¯ä»˜å¤±è´¥: {e}')
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/admin/orders/<order_no>/cancel', methods=['POST'])
@admin_required
def admin_cancel_order(order_no):
    """ç®¡ç†å‘˜å–æ¶ˆè®¢å•"""
    try:
        from sqlalchemy import text
        
        # ä½¿ç”¨SQLæŸ¥è¯¢è®¢å•
        result = db.session.execute(
            text("SELECT * FROM orders WHERE order_no = :order_no"),
            {'order_no': order_no}
        ).fetchone()
        
        if not result:
            return jsonify({'success': False, 'error': 'è®¢å•ä¸å­˜åœ¨'}), 404
        
        row = result._asdict() if hasattr(result, '_asdict') else dict(result._mapping)
        
        if row.get('payment_status') == 'paid':
            return jsonify({'success': False, 'error': 'å·²æ”¯ä»˜è®¢å•æ— æ³•å–æ¶ˆ'}), 400
        
        if row.get('payment_status') == 'cancelled':
            return jsonify({'success': False, 'error': 'è®¢å•å·²ç»æ˜¯å–æ¶ˆçŠ¶æ€'}), 400
        
        # æ›´æ–°è®¢å•çŠ¶æ€ä¸ºå–æ¶ˆ
        db.session.execute(
            text("UPDATE orders SET payment_status = 'cancelled', updated_at = :now WHERE order_no = :order_no"),
            {'order_no': order_no, 'now': datetime.now()}
        )
        db.session.commit()
        
        app.logger.info(f'ç®¡ç†å‘˜å–æ¶ˆè®¢å• {order_no}')
        log_admin_audit('order_cancel', detail=f'å–æ¶ˆè®¢å• {order_no}', target_type='order', target_id=order_no)
        
        return jsonify({
            'success': True,
            'message': 'è®¢å•å·²å–æ¶ˆ'
        }), 200
    except Exception as e:
        db.session.rollback()
        app.logger.error(f'å–æ¶ˆè®¢å•å¤±è´¥: {e}')
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/admin/users/<int:user_id>/gift-subscription', methods=['POST'])
@admin_required
def admin_gift_subscription(user_id):
    """ç®¡ç†å‘˜èµ é€è®¢é˜…"""
    try:
        data = request.get_json()
        plan_type = data.get('plan_type', 'basic')
        duration_days = data.get('duration_days')  # ä¼˜å…ˆä½¿ç”¨å¤©æ•°
        duration_months = data.get('duration_months', 1)
        
        user = db.session.get(User, user_id)
        if not user:
            return jsonify({'success': False, 'error': 'ç”¨æˆ·ä¸å­˜åœ¨'}), 404
        
        from datetime import timedelta
        
        # è®¡ç®—èµ é€å¤©æ•°ï¼ˆä¼˜å…ˆä½¿ç”¨ä¼ å…¥çš„å¤©æ•°ï¼Œå¦åˆ™æŒ‰æœˆè®¡ç®—ï¼‰
        if duration_days and int(duration_days) > 0:
            gift_days = int(duration_days)
        else:
            gift_days = 30 * duration_months
        now = datetime.now()  # ä½¿ç”¨ timezone-naive datetime ä»¥ä¿æŒä¸€è‡´
        
        plan_names = {
            'basic': 'åŸºç¡€ç‰ˆ',
            'standard': 'æ ‡å‡†ç‰ˆ',
            'premium': 'é«˜çº§ç‰ˆ'
        }
        
        # ç«‹å³ç”Ÿæ•ˆï¼Œåœ¨ç°æœ‰åˆ°æœŸæ—¶é—´åŸºç¡€ä¸Šå åŠ 
        start_date = now
        if user.ex and user.ex > now:
            # ç”¨æˆ·æœ‰æœªè¿‡æœŸçš„åˆ°æœŸæ—¶é—´ï¼Œåœ¨æ­¤åŸºç¡€ä¸Šå åŠ 
            end_date = user.ex + timedelta(days=gift_days)
        else:
            # ç”¨æˆ·æ²¡æœ‰æœ‰æ•ˆæœŸæˆ–å·²è¿‡æœŸï¼Œä»ä»Šå¤©å¼€å§‹
            end_date = now + timedelta(days=gift_days)
        
        # åˆ›å»ºè®¢é˜…è®°å½•
        gift_record = Subscription(
            user_tg=user.tg,
            plan_type=plan_type,
            plan_name=plan_names.get(plan_type, 'åŸºç¡€ç‰ˆ'),
            duration_months=duration_months,
            price=0,  # èµ é€çš„å…è´¹
            start_date=start_date,
            end_date=end_date,
            status='active',
            source='gift'  # æ ‡è®°ä¸ºç®¡ç†å‘˜èµ é€
        )
        db.session.add(gift_record)
        
        # æ›´æ–°ç”¨æˆ·çš„åˆ°æœŸæ—¶é—´
        user.ex = end_date
        
        # ç¡®ä¿ç”¨æˆ·ç­‰çº§ä¸ºBï¼ˆæ™®é€šç”¨æˆ·ï¼‰ï¼Œä½†ä¸é™çº§ç™½åå•ç”¨æˆ·ï¼Œå°ç¦ç”¨æˆ·ä¿æŒå°ç¦çŠ¶æ€
        if user.lv not in ['a', 'c']:
            user.lv = 'b'
        
        db.session.commit()
        
        # æ¢å¤Embyè´¦å·ï¼ˆå°ç¦ç”¨æˆ·å’Œé»‘åå•ç¦ç”¨ç”¨æˆ·ä¸è‡ªåŠ¨æ¢å¤ï¼‰
        if user.lv != 'c' and not user.ban_reason and user.embyid and emby_client.is_enabled():
            if emby_client.enable_user(user.embyid):
                app.logger.info(f'ç”¨æˆ· {user.name} è·èµ è®¢é˜…ï¼Œå·²æ¢å¤Embyè´¦å·')
        
        app.logger.info(f'ç®¡ç†å‘˜èµ é€è®¢é˜…: ç”¨æˆ·={user.name}, å¥—é¤={plan_type}, å¤©æ•°={gift_days}, æ–°åˆ°æœŸæ—¶é—´={user.ex}')
        
        # è®°å½•æ“ä½œæ—¥å¿—
        log_user_activity(UserActivityLog.ACTION_SUBSCRIPTION_GIFT, user=user,
                         detail={'action': 'gift_subscription', 'plan_type': plan_type,
                                'gift_days': gift_days, 'new_ex': str(user.ex)})
        log_admin_audit('user_gift_subscription', detail=f'èµ é€ç”¨æˆ· {user.name} {gift_days}å¤©è®¢é˜…', target_type='user', target_id=user.tg)
        
        return jsonify({
            'success': True,
            'message': f'å·²ä¸ºç”¨æˆ·èµ é€ {gift_days} å¤©è®¢é˜…ï¼Œåˆ°æœŸæ—¶é—´ï¼š{user.ex.strftime("%Y-%m-%d %H:%M")}'
        }), 200
    except Exception as e:
        db.session.rollback()
        app.logger.error(f'èµ é€è®¢é˜…å¤±è´¥: {e}')
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/admin/users/<int:user_id>/reduce-subscription', methods=['POST'])
@admin_required
def admin_reduce_subscription(user_id):
    """ç®¡ç†å‘˜å‡å°‘è®¢é˜…æ—¶é—´"""
    try:
        data = request.get_json()
        duration_days = data.get('duration_days', 0)
        
        if not duration_days or int(duration_days) <= 0:
            return jsonify({'success': False, 'error': 'è¯·è¾“å…¥æœ‰æ•ˆçš„å¤©æ•°'}), 400
        
        reduce_days = int(duration_days)
        
        user = db.session.get(User, user_id)
        if not user:
            return jsonify({'success': False, 'error': 'ç”¨æˆ·ä¸å­˜åœ¨'}), 404
        
        from datetime import timedelta
        now = datetime.now()
        
        # æ£€æŸ¥ç”¨æˆ·æ˜¯å¦æœ‰æœ‰æ•ˆè®¢é˜…
        if not user.ex or user.ex <= now:
            return jsonify({'success': False, 'error': 'ç”¨æˆ·å½“å‰æ²¡æœ‰æœ‰æ•ˆè®¢é˜…'}), 400
        
        # è®¡ç®—å‡å°‘åçš„åˆ°æœŸæ—¶é—´
        new_ex = user.ex - timedelta(days=reduce_days)
        
        # å¦‚æœå‡å°‘åçš„æ—¶é—´æ—©äºå½“å‰æ—¶é—´ï¼Œåˆ™è®¾ä¸ºå½“å‰æ—¶é—´ï¼ˆç«‹å³è¿‡æœŸï¼‰
        if new_ex <= now:
            new_ex = now
            message = f'å·²å‡å°‘ {reduce_days} å¤©è®¢é˜…ï¼Œç”¨æˆ·è®¢é˜…å·²è¿‡æœŸ'
        else:
            remaining_days = (new_ex - now).days
            message = f'å·²å‡å°‘ {reduce_days} å¤©è®¢é˜…ï¼Œå‰©ä½™ {remaining_days} å¤©ï¼Œåˆ°æœŸæ—¶é—´ï¼š{new_ex.strftime("%Y-%m-%d %H:%M")}'
        
        user.ex = new_ex
        db.session.commit()
        
        # å¦‚æœè®¢é˜…å·²è¿‡æœŸï¼Œç¦ç”¨Embyè´¦å·
        if new_ex <= now and user.embyid and emby_client.is_enabled():
            emby_client.disable_user(user.embyid)
            emby_client.kill_user_sessions(user.embyid)
            app.logger.info(f'ç”¨æˆ· {user.name} è®¢é˜…è¿‡æœŸï¼Œå·²ç¦ç”¨Embyè´¦å·')
        
        app.logger.info(f'ç®¡ç†å‘˜å‡å°‘è®¢é˜…: ç”¨æˆ·={user.name}, å‡å°‘å¤©æ•°={reduce_days}, æ–°åˆ°æœŸæ—¶é—´={user.ex}')
        
        # è®°å½•æ“ä½œæ—¥å¿—
        log_user_activity(UserActivityLog.ACTION_SUBSCRIPTION_REDUCE, user=user,
                         detail={'action': 'reduce_subscription', 'reduce_days': reduce_days,
                                'new_ex': str(user.ex), 'expired': new_ex <= now})
        log_admin_audit('user_reduce_subscription', detail=f'å‡å°‘ç”¨æˆ· {user.name} {reduce_days}å¤©è®¢é˜…', target_type='user', target_id=user.tg)
        
        return jsonify({
            'success': True,
            'message': message
        }), 200
    except Exception as e:
        db.session.rollback()
        app.logger.error(f'å‡å°‘è®¢é˜…å¤±è´¥: {e}')
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/admin/users/<int:user_id>/adjust-coins', methods=['POST'])
@admin_required
def admin_adjust_coins(user_id):
    """ç®¡ç†å‘˜è°ƒæ•´ç”¨æˆ·ç§¯åˆ†"""
    try:
        data = request.get_json()
        adjust_type = data.get('action')  # 'add' or 'reduce'
        amount = data.get('amount', 0)
        reason = data.get('reason', '')
        
        if adjust_type not in ['add', 'reduce']:
            return jsonify({'success': False, 'error': 'æ— æ•ˆçš„æ“ä½œç±»å‹'}), 400
        
        if not amount or int(amount) <= 0:
            return jsonify({'success': False, 'error': 'è¯·è¾“å…¥æœ‰æ•ˆçš„æ•°é‡'}), 400
        
        amount = int(amount)
        
        user = db.session.get(User, user_id)
        if not user:
            return jsonify({'success': False, 'error': 'ç”¨æˆ·ä¸å­˜åœ¨'}), 404
        
        # è·å–ç§¯åˆ†åç§°
        config = load_system_config()
        checkin_config = config.get('checkin', {})
        coin_name = checkin_config.get('coin_name', 'ç§¯åˆ†')
        
        old_coins = user.coins or 0
        
        if adjust_type == 'add':
            user.coins = old_coins + amount
            action_name = 'å¢åŠ '
        else:
            if old_coins < amount:
                return jsonify({'success': False, 'error': f'ç”¨æˆ·{coin_name}ä¸è¶³ï¼Œå½“å‰ä»…æœ‰ {old_coins}'}), 400
            user.coins = old_coins - amount
            action_name = 'å‡å°‘'
        
        # æ„å»ºæè¿°ä¿¡æ¯
        description = f'ç®¡ç†å‘˜{action_name}{amount}{coin_name}'
        if reason:
            description += f' - {reason}'
        
        # è®°å½•ç§¯åˆ†äº¤æ˜“
        transaction = CoinTransaction(
            user_tg=user.tg,
            amount=amount if adjust_type == 'add' else -amount,
            trans_type='admin_adjust',
            description=description,
            balance_after=user.coins
        )
        db.session.add(transaction)
        db.session.commit()
        
        app.logger.info(f'ç®¡ç†å‘˜è°ƒæ•´{coin_name}: ç”¨æˆ·={user.name}, æ“ä½œ={action_name}, æ•°é‡={amount}, åŸä½™é¢={old_coins}, æ–°ä½™é¢={user.coins}')
        
        # è®°å½•æ“ä½œæ—¥å¿—
        log_user_activity(UserActivityLog.ACTION_COIN_CHANGE, user=user,
                         detail={'action': 'admin_adjust', 'type': adjust_type,
                                'amount': amount, 'old_coins': old_coins,
                                'new_coins': user.coins, 'reason': reason,
                                'coin_name': coin_name})
        
        return jsonify({
            'success': True,
            'message': f'å·²{action_name} {amount} {coin_name}ï¼Œå½“å‰ä½™é¢ï¼š{user.coins}',
            'new_balance': user.coins
        }), 200
    except Exception as e:
        db.session.rollback()
        app.logger.error(f'è°ƒæ•´ç§¯åˆ†å¤±è´¥: {e}')
        return jsonify({'success': False, 'error': str(e)}), 500


# é…ç½®æ£€æŸ¥
def check_config():
    """æ£€æŸ¥å…³é”®é…ç½®é¡¹"""
    issues = []
    
    # ä»æ•°æ®åº“åŠ è½½é…ç½®æ£€æŸ¥
    config = load_system_config()
    admin_config = config.get('admin', {})
    telegram_config = config.get('telegram', {})
    tmdb_config = config.get('tmdb', {})
    
    if not tmdb_config.get('api_key') and not TMDB_API_KEY:
        issues.append('TMDB_API_KEY æœªé…ç½®ï¼Œå½±ç‰‡æœç´¢åŠŸèƒ½å°†ä¸å¯ç”¨')
    
    if not admin_config.get('username') or not admin_config.get('password'):
        issues.append('ç®¡ç†å‘˜è´¦å·å¯†ç æœªé…ç½®ï¼Œè¯·åœ¨åå°è®¾ç½®æˆ– .env æ–‡ä»¶ä¸­é…ç½®')
    
    if not admin_config.get('secret_path') or admin_config.get('secret_path') == 'admin-secret-path':
        issues.append('ç®¡ç†åå°å®‰å…¨å…¥å£æœªé…ç½®ï¼Œè¯·åœ¨åå°è®¾ç½®æˆ– .env æ–‡ä»¶ä¸­é…ç½®')
    
    if not telegram_config.get('bot_token') and not TELEGRAM_BOT_TOKEN:
        issues.append('Telegram é€šçŸ¥æœªé…ç½®ï¼Œæ±‚ç‰‡é€šçŸ¥å°†ä¸ä¼šå‘é€')
    
    if issues:
        app.logger.warning('é…ç½®æ£€æŸ¥å‘ç°ä»¥ä¸‹é—®é¢˜:')
        for issue in issues:
            app.logger.warning(f'  - {issue}')
    else:
        app.logger.info('æ‰€æœ‰å…³é”®é…ç½®é¡¹æ£€æŸ¥é€šè¿‡ âœ“')


# æ•°æ®åº“è¿ç§»ï¼šæ·»åŠ ç¼ºå¤±çš„åˆ—
def migrate_database():
    """æ£€æŸ¥å¹¶æ·»åŠ æ•°æ®åº“ä¸­ç¼ºå¤±çš„åˆ—"""
    
    # æ£€æµ‹æ•°æ®åº“ç±»å‹
    is_mysql = 'mysql' in str(db.engine.url).lower()
    
    # è¾…åŠ©å‡½æ•°ï¼šæ£€æŸ¥è¡¨æ˜¯å¦å­˜åœ¨
    def table_exists(table_name):
        try:
            if is_mysql:
                result = db.session.execute(db.text(f"""
                    SELECT COUNT(*) FROM information_schema.tables 
                    WHERE table_schema = DATABASE() AND table_name = '{table_name}'
                """)).fetchone()
                return result[0] > 0
            else:
                result = db.session.execute(db.text(f"""
                    SELECT COUNT(*) FROM sqlite_master 
                    WHERE type='table' AND name='{table_name}'
                """)).fetchone()
                return result[0] > 0
        except:
            return False
    
    # è¾…åŠ©å‡½æ•°ï¼šæ£€æŸ¥åˆ—æ˜¯å¦å­˜åœ¨ï¼ˆä½¿ç”¨ç›´æ¥æŸ¥è¯¢æ–¹å¼ï¼‰
    def column_exists(table_name, column_name):
        try:
            if is_mysql:
                # æ–¹æ³•1ï¼šä½¿ç”¨ information_schema
                result = db.session.execute(db.text(f"""
                    SELECT COUNT(*) FROM information_schema.columns 
                    WHERE table_schema = DATABASE() 
                    AND table_name = '{table_name}' 
                    AND column_name = '{column_name}'
                """)).fetchone()
                if result[0] > 0:
                    return True
                # æ–¹æ³•2ï¼šå°è¯•ç›´æ¥ SELECT è¯¥åˆ—ï¼ˆä½œä¸ºå¤‡ç”¨æ£€æµ‹ï¼‰
                try:
                    db.session.execute(db.text(f"SELECT `{column_name}` FROM `{table_name}` LIMIT 0"))
                    return True
                except:
                    return False
            else:
                result = db.session.execute(db.text(f"PRAGMA table_info({table_name})")).fetchall()
                return any(row[1] == column_name for row in result)
        except Exception as e:
            app.logger.warning(f'æ£€æŸ¥åˆ—å­˜åœ¨æ€§å¤±è´¥ ({table_name}.{column_name}): {e}')
            return False
    
    migrations = [
        # (è¡¨å, åˆ—å, åˆ—å®šä¹‰ for MySQL, åˆ—å®šä¹‰ for SQLite)
        ('emby', 'telegram_id', 'BIGINT NULL UNIQUE'),
        ('emby', 'is_banned', 'INTEGER DEFAULT 0'),
        ('emby', 'ban_reason', 'VARCHAR(500) NULL'),
        ('emby', 'invited_by', 'INTEGER NULL'),
        ('emby', 'invite_count', 'INTEGER DEFAULT 0'),
        ('emby', 'invite_reward_days', 'INTEGER DEFAULT 0'),
        ('emby', 'session_token', 'VARCHAR(64) NULL'),  # ç”¨äºå¼ºåˆ¶ç”¨æˆ·é€€å‡ºç™»å½•
        # å·¥å•è¡¨æ–°å­—æ®µ
        ('support_tickets', 'last_reply_by', "VARCHAR(20) DEFAULT 'user'"),
        ('support_tickets', 'last_reply_at', 'DATETIME NULL'),
        # è®¢é˜…è¡¨æ¥æºå­—æ®µ
        ('subscriptions', 'source', "VARCHAR(20) DEFAULT 'purchase'"),
        # Embyç”¨æˆ·åç‹¬ç«‹å­—æ®µï¼ˆä¸ç½‘ç«™ç”¨æˆ·ååˆ†ç¦»ï¼‰
        ('emby', 'emby_name', 'VARCHAR(255) NULL'),
        # é‚€è¯·è®°å½•è¡¨ï¼šè¿”åˆ©æ¨¡å¼å’Œä¸ªæ€§åŒ–è¿”åˆ©æ¯”ä¾‹
        ('invite_records', 'reward_mode', 'VARCHAR(20) NULL'),
        ('invite_records', 'custom_reward_percent', 'FLOAT NULL'),
        ('invite_records', 'pending_reward', 'FLOAT DEFAULT 0'),
        # Userè¡¨ä¸ªæ€§åŒ–è¿”åˆ©é…ç½®
        ('emby', 'invite_reward_mode', 'VARCHAR(20) NULL'),
        ('emby', 'invite_reward_percent', 'FLOAT NULL'),
        # Userè¡¨é‚®ç®±å­—æ®µ
        ('emby', 'email', 'VARCHAR(255) NULL'),
        # çº¿è·¯è¡¨å¥—é¤å¯è§æ€§å­—æ®µ
        ('server_lines', 'allowed_plan_types', "VARCHAR(500) DEFAULT ''"),
        # è®¢å•è¡¨å¤©æ•°å­—æ®µï¼ˆæ”¯æŒè‡ªå®šä¹‰å¤©æ•°å¥—é¤ï¼‰
        ('orders', 'duration_days', 'INTEGER NULL'),
        # ç®¡ç†å‘˜è¡¨æ˜æ–‡å¯†ç å­—æ®µï¼ˆå­ç®¡ç†å‘˜å¯†ç ä¾›è¶…çº§ç®¡ç†å‘˜æŸ¥çœ‹ï¼‰
        ('admin_users', 'password_plain', 'VARCHAR(255) NULL'),
    ]
    
    app.logger.info('å¼€å§‹æ£€æŸ¥æ•°æ®åº“è¿ç§»...')
    app.logger.info(f'æ•°æ®åº“ç±»å‹: {"MySQL" if is_mysql else "SQLite"}')
    
    for table, column, definition in migrations:
        try:
            # å…ˆæ£€æŸ¥è¡¨æ˜¯å¦å­˜åœ¨
            if not table_exists(table):
                app.logger.info(f'æ•°æ®åº“è¿ç§»: è¡¨ {table} ä¸å­˜åœ¨ï¼Œè·³è¿‡åˆ— {column}')
                continue
            
            # æ£€æŸ¥åˆ—æ˜¯å¦å·²å­˜åœ¨
            exists = column_exists(table, column)
            app.logger.info(f'æ•°æ®åº“è¿ç§»: æ£€æŸ¥åˆ— {table}.{column} æ˜¯å¦å­˜åœ¨: {exists}')
            if exists:
                continue
            
            # æ·»åŠ åˆ—
            try:
                sql = f"ALTER TABLE {table} ADD COLUMN {column} {definition}"
                app.logger.info(f'æ•°æ®åº“è¿ç§»: æ‰§è¡ŒSQL: {sql}')
                db.session.execute(db.text(sql))
                db.session.commit()
                app.logger.info(f'æ•°æ®åº“è¿ç§»: æˆåŠŸæ·»åŠ åˆ— {table}.{column}')
            except Exception as add_err:
                db.session.rollback()
                err_str = str(add_err).lower()
                # å¦‚æœæ˜¯å› ä¸ºåˆ—å·²å­˜åœ¨ï¼Œå¿½ç•¥é”™è¯¯
                if 'duplicate' in err_str or 'already exists' in err_str or 'duplicate column' in err_str:
                    app.logger.info(f'æ•°æ®åº“è¿ç§»: åˆ— {table}.{column} å·²å­˜åœ¨ï¼ˆé€šè¿‡å¼‚å¸¸æ£€æµ‹ï¼‰')
                else:
                    app.logger.error(f'æ•°æ®åº“è¿ç§»å¤±è´¥ ({table}.{column}): {add_err}')
        except Exception as e:
            db.session.rollback()
            app.logger.error(f'æ•°æ®åº“è¿ç§»å¼‚å¸¸ ({table}.{column}): {e}')
    
    # æ•°æ®è¿ç§»ï¼šå°†å·²æœ‰ embyid ç”¨æˆ·çš„ name å¤åˆ¶åˆ° emby_nameï¼ˆä»…é¦–æ¬¡è¿ç§»æ—¶æ‰§è¡Œï¼‰
    try:
        if column_exists('emby', 'emby_name'):
            # æ£€æŸ¥æ˜¯å¦æœ‰ embyid éç©ºä½† emby_name ä¸ºç©ºçš„è®°å½•ï¼ˆéœ€è¦è¿ç§»ï¼‰
            result = db.session.execute(db.text(
                "SELECT COUNT(*) FROM emby WHERE embyid IS NOT NULL AND emby_name IS NULL AND name IS NOT NULL"
            )).fetchone()
            if result[0] > 0:
                db.session.execute(db.text(
                    "UPDATE emby SET emby_name = name WHERE embyid IS NOT NULL AND emby_name IS NULL AND name IS NOT NULL"
                ))
                db.session.commit()
                app.logger.info(f'æ•°æ®è¿ç§»: å·²å°† {result[0]} ä¸ªç”¨æˆ·çš„ name å¤åˆ¶åˆ° emby_name')
    except Exception as e:
        db.session.rollback()
        app.logger.warning(f'æ•°æ®è¿ç§»(emby_name)å¤±è´¥: {e}')
    
    # ç­¾åˆ°ç³»ç»Ÿè¡¨è¿ç§»
    _migrate_checkin_system()
    
    app.logger.info('æ•°æ®åº“è¿ç§»æ£€æŸ¥å®Œæˆ')


def _migrate_checkin_system():
    """ç­¾åˆ°ç³»ç»Ÿæ•°æ®åº“è¿ç§»"""
    try:
        app.logger.info('å¼€å§‹ç­¾åˆ°ç³»ç»Ÿè¿ç§»...')
        
        # æ£€æµ‹æ•°æ®åº“ç±»å‹
        is_mysql = 'mysql' in str(db.engine.url).lower()
        auto_increment = 'AUTO_INCREMENT' if is_mysql else 'AUTOINCREMENT'
        
        # è¾…åŠ©å‡½æ•°ï¼šæ£€æŸ¥è¡¨æ˜¯å¦å­˜åœ¨
        def table_exists(table_name):
            try:
                if is_mysql:
                    result = db.session.execute(db.text(f"""
                        SELECT COUNT(*) FROM information_schema.tables 
                        WHERE table_schema = DATABASE() AND table_name = '{table_name}'
                    """)).fetchone()
                    return result[0] > 0
                else:
                    result = db.session.execute(db.text(f"""
                        SELECT COUNT(*) FROM sqlite_master 
                        WHERE type='table' AND name='{table_name}'
                    """)).fetchone()
                    return result[0] > 0
            except:
                return False
        
        # è¾…åŠ©å‡½æ•°ï¼šæ£€æŸ¥åˆ—æ˜¯å¦å­˜åœ¨
        def column_exists(table_name, column_name):
            try:
                if is_mysql:
                    result = db.session.execute(db.text(f"""
                        SELECT COUNT(*) FROM information_schema.columns 
                        WHERE table_schema = DATABASE() 
                        AND table_name = '{table_name}' 
                        AND column_name = '{column_name}'
                    """)).fetchone()
                    return result[0] > 0
                else:
                    result = db.session.execute(db.text(f"PRAGMA table_info({table_name})")).fetchall()
                    return any(row[1] == column_name for row in result)
            except:
                return False
        
        # 1. ç»™ emby è¡¨æ·»åŠ  coins å­—æ®µ
        if not column_exists('emby', 'coins'):
            try:
                db.session.execute(
                    db.text("ALTER TABLE emby ADD COLUMN coins INTEGER DEFAULT 0")
                )
                db.session.commit()
                app.logger.info('ç­¾åˆ°ç³»ç»Ÿè¿ç§»: æˆåŠŸæ·»åŠ  emby.coins å­—æ®µ')
            except Exception as e:
                db.session.rollback()
                if 'duplicate' not in str(e).lower() and 'already exists' not in str(e).lower():
                    app.logger.warning(f'æ·»åŠ  coins å­—æ®µè­¦å‘Š: {e}')
        
        # 2. åˆ›å»ºç­¾åˆ°è®°å½•è¡¨
        if not table_exists('checkin_records'):
            try:
                db.session.execute(db.text(f"""
                    CREATE TABLE IF NOT EXISTS checkin_records (
                        id INTEGER PRIMARY KEY {auto_increment},
                        user_tg BIGINT NOT NULL,
                        checkin_date DATE NOT NULL,
                        coins_earned INTEGER NOT NULL,
                        continuous_days INTEGER DEFAULT 1,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        UNIQUE(user_tg, checkin_date),
                        FOREIGN KEY (user_tg) REFERENCES emby (tg) ON DELETE CASCADE
                    )
                """))
                db.session.commit()
                app.logger.info('ç­¾åˆ°ç³»ç»Ÿè¿ç§»: æˆåŠŸåˆ›å»º checkin_records è¡¨')
            except Exception as e:
                db.session.rollback()
                if 'already exists' not in str(e).lower():
                    app.logger.warning(f'åˆ›å»º checkin_records è¡¨è­¦å‘Š: {e}')
        
        # 3. åˆ›å»ºç§¯åˆ†äº¤æ˜“è®°å½•è¡¨
        if not table_exists('coin_transactions'):
            try:
                db.session.execute(db.text(f"""
                    CREATE TABLE IF NOT EXISTS coin_transactions (
                        id INTEGER PRIMARY KEY {auto_increment},
                        user_tg BIGINT NOT NULL,
                        amount INTEGER NOT NULL,
                        balance_after INTEGER NOT NULL,
                        trans_type VARCHAR(50) NOT NULL,
                        description TEXT,
                        related_id INTEGER,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        FOREIGN KEY (user_tg) REFERENCES emby (tg) ON DELETE CASCADE
                    )
                """))
                db.session.commit()
                app.logger.info('ç­¾åˆ°ç³»ç»Ÿè¿ç§»: æˆåŠŸåˆ›å»º coin_transactions è¡¨')
            except Exception as e:
                db.session.rollback()
                if 'already exists' not in str(e).lower():
                    app.logger.warning(f'åˆ›å»º coin_transactions è¡¨è­¦å‘Š: {e}')
        
        # 4. åˆ›å»ºå…‘æ¢è®°å½•è¡¨
        if not table_exists('exchange_records'):
            try:
                db.session.execute(db.text(f"""
                    CREATE TABLE IF NOT EXISTS exchange_records (
                        id INTEGER PRIMARY KEY {auto_increment},
                        user_tg BIGINT NOT NULL,
                        plan_id VARCHAR(50) NOT NULL,
                        plan_name VARCHAR(100) NOT NULL,
                        coins_cost INTEGER NOT NULL,
                        duration_days INTEGER NOT NULL,
                        status VARCHAR(20) DEFAULT 'completed',
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        FOREIGN KEY (user_tg) REFERENCES emby (tg) ON DELETE CASCADE
                    )
                """))
                db.session.commit()
                app.logger.info('ç­¾åˆ°ç³»ç»Ÿè¿ç§»: æˆåŠŸåˆ›å»º exchange_records è¡¨')
            except Exception as e:
                db.session.rollback()
                if 'already exists' not in str(e).lower():
                    app.logger.warning(f'åˆ›å»º exchange_records è¡¨è­¦å‘Š: {e}')
        
        # 5. åˆ›å»ºç´¢å¼•
        # MySQL ä¸æ”¯æŒ IF NOT EXISTSï¼Œéœ€è¦åˆ†åˆ«å¤„ç†
        if is_mysql:
            indexes = [
                ("idx_checkin_user_date", "checkin_records", "(user_tg, checkin_date)"),
                ("idx_checkin_date", "checkin_records", "(checkin_date)"),
                ("idx_transaction_user", "coin_transactions", "(user_tg, created_at)"),
                ("idx_transaction_type", "coin_transactions", "(trans_type)"),
                ("idx_exchange_user", "exchange_records", "(user_tg, created_at)")
            ]
            
            for index_name, table_name, columns in indexes:
                try:
                    # MySQL: å…ˆæ£€æŸ¥ç´¢å¼•æ˜¯å¦å­˜åœ¨
                    result = db.session.execute(db.text(f"""
                        SELECT COUNT(*) as cnt 
                        FROM information_schema.statistics 
                        WHERE table_schema = DATABASE() 
                        AND table_name = '{table_name}' 
                        AND index_name = '{index_name}'
                    """)).fetchone()
                    
                    if result[0] == 0:  # ç´¢å¼•ä¸å­˜åœ¨
                        db.session.execute(db.text(f"CREATE INDEX {index_name} ON {table_name}{columns}"))
                        db.session.commit()
                except Exception as e:
                    db.session.rollback()
                    if 'duplicate' not in str(e).lower() and 'already exists' not in str(e).lower():
                        app.logger.warning(f'åˆ›å»ºç´¢å¼• {index_name} è­¦å‘Š: {e}')
        else:
            # SQLite æ”¯æŒ IF NOT EXISTS
            indexes = [
                "CREATE INDEX IF NOT EXISTS idx_checkin_user_date ON checkin_records(user_tg, checkin_date)",
                "CREATE INDEX IF NOT EXISTS idx_checkin_date ON checkin_records(checkin_date)",
                "CREATE INDEX IF NOT EXISTS idx_transaction_user ON coin_transactions(user_tg, created_at)",
                "CREATE INDEX IF NOT EXISTS idx_transaction_type ON coin_transactions(trans_type)",
                "CREATE INDEX IF NOT EXISTS idx_exchange_user ON exchange_records(user_tg, created_at)"
            ]
            
            for index_sql in indexes:
                try:
                    db.session.execute(db.text(index_sql))
                    db.session.commit()
                except Exception as e:
                    db.session.rollback()
                    if 'already exists' not in str(e).lower():
                        app.logger.warning(f'åˆ›å»ºç´¢å¼•è­¦å‘Š: {e}')
        
        app.logger.info('ç­¾åˆ°ç³»ç»Ÿè¿ç§»å®Œæˆ âœ“')
        
    except Exception as e:
        db.session.rollback()
        app.logger.error(f'ç­¾åˆ°ç³»ç»Ÿè¿ç§»å¤±è´¥: {e}', exc_info=True)


# åˆå§‹åŒ–æ•°æ®åº“
def init_db():
    global db_initialized
    if db_initialized:
        return
    with app.app_context():
        try:
            # åªåˆ›å»ºmovie_requestsè¡¨ï¼Œembyè¡¨å·²ç»å­˜åœ¨
            db.create_all()
            app.logger.info('æ•°æ®åº“åˆå§‹åŒ–æˆåŠŸ')
            
            # æ‰§è¡Œæ•°æ®åº“è¿ç§»ï¼ˆæ·»åŠ ç¼ºå¤±çš„åˆ—ï¼‰
            migrate_database()
            
            # ä¿®å¤æ’­æ”¾è®°å½•ä¸­å¼‚å¸¸çš„è¿›åº¦æ•°æ®ï¼ˆ>100%çš„è®°å½•ä¿®æ­£ä¸º100%ï¼‰
            try:
                fixed = PlaybackRecord.query.filter(PlaybackRecord.play_percentage > 100).update(
                    {PlaybackRecord.play_percentage: 100.0}
                )
                if fixed > 0:
                    db.session.commit()
                    app.logger.info(f'å·²ä¿®å¤ {fixed} æ¡å¼‚å¸¸æ’­æ”¾è¿›åº¦è®°å½•ï¼ˆ>100%ï¼‰')
            except Exception as e:
                db.session.rollback()
                app.logger.warning(f'ä¿®å¤å¼‚å¸¸æ’­æ”¾è¿›åº¦å¤±è´¥: {e}')
            
            # ä¿®å¤æ’­æ”¾è®°å½•ä¸­å¼‚å¸¸çš„æ’­æ”¾æ—¶é•¿ï¼ˆplay_duration > total_duration çš„ä¿®æ­£ï¼‰
            try:
                fixed_dur = PlaybackRecord.query.filter(
                    PlaybackRecord.total_duration > 0,
                    PlaybackRecord.play_duration > PlaybackRecord.total_duration
                ).update(
                    {PlaybackRecord.play_duration: PlaybackRecord.total_duration},
                    synchronize_session=False
                )
                if fixed_dur > 0:
                    db.session.commit()
                    app.logger.info(f'å·²ä¿®å¤ {fixed_dur} æ¡å¼‚å¸¸æ’­æ”¾æ—¶é•¿è®°å½•ï¼ˆduration > totalï¼‰')
            except Exception as e:
                db.session.rollback()
                app.logger.warning(f'ä¿®å¤å¼‚å¸¸æ’­æ”¾æ—¶é•¿å¤±è´¥: {e}')
            
            # åˆå§‹åŒ–ç®¡ç†å‘˜é…ç½®
            admin_config = init_admin_config()
            secret_path = admin_config.get('admin', {}).get('secret_path')
            if secret_path:
                app.logger.info(f"ç®¡ç†åå°å…¥å£: /{secret_path}")
            
            # é‡æ–°ä»æ•°æ®åº“åŠ è½½é…ç½®åˆ°å…¨å±€å˜é‡ï¼ˆç¡®ä¿æ•°æ®åº“ä¸­çš„é…ç½®ç”Ÿæ•ˆï¼‰
            update_global_system_config()
            app.logger.info('ç³»ç»Ÿé…ç½®å·²ä»æ•°æ®åº“åŠ è½½')
            
            # æ£€æŸ¥é…ç½®
            check_config()
            db_initialized = True
        except Exception as e:
            app.logger.error(f'æ•°æ®åº“åˆå§‹åŒ–å¤±è´¥: {e}', exc_info=True)
            raise


download_monitor = DownloadMonitor(app, DOWNLOAD_POLL_INTERVAL)


def auto_close_inactive_tickets():
    """è‡ªåŠ¨å…³é—­3å¤©å†…ç®¡ç†å‘˜å›å¤åç”¨æˆ·æœªå›å¤çš„å·¥å•"""
    with app.app_context():
        try:
            three_days_ago = datetime.now() - timedelta(days=3)
            
            # æŸ¥æ‰¾å¤„ç†ä¸­çŠ¶æ€ä¸”ç®¡ç†å‘˜å›å¤å3å¤©ç”¨æˆ·æœªå›å¤çš„å·¥å•
            tickets_to_close = SupportTicket.query.filter(
                SupportTicket.status == 'in_progress',
                SupportTicket.last_reply_by == 'admin',
                SupportTicket.last_reply_at < three_days_ago
            ).all()
            
            closed_count = 0
            for ticket in tickets_to_close:
                ticket.status = 'closed'
                ticket.resolved_at = datetime.now()
                closed_count += 1
                app.logger.info(f'è‡ªåŠ¨å…³é—­å·¥å•: {ticket.ticket_no} (3å¤©æœªå›å¤)')
            
            if closed_count > 0:
                db.session.commit()
                app.logger.info(f'è‡ªåŠ¨å…³é—­äº† {closed_count} ä¸ªè¶…æ—¶å·¥å•')
        except Exception as e:
            db.session.rollback()
            app.logger.error(f'è‡ªåŠ¨å…³é—­å·¥å•å¤±è´¥: {e}', exc_info=True)
        finally:
            db.session.remove()


# å·¥å•è‡ªåŠ¨å…³é—­æ£€æŸ¥çš„æ—¶é—´æˆ³
last_ticket_check_time = None


def bootstrap_background_tasks():
    """åˆå§‹åŒ–æ•°æ®åº“å¹¶å¯åŠ¨ä¸‹è½½ç›‘æ§"""
    global download_monitor_started, last_ticket_check_time
    if download_monitor_started:
        return

    try:
        init_db()
    except Exception:
        pass

    should_start = True
    if app.debug:
        should_start = os.environ.get('WERKZEUG_RUN_MAIN') == 'true'
    if should_start:
        download_monitor.start()
        download_monitor_started = True
        # å¯åŠ¨æ’è¡Œå®šæ—¶æ¨é€
        try:
            ranking_cfg = load_system_config().get('ranking', {})
            if ranking_cfg.get('push_enabled'):
                _restart_ranking_scheduler(ranking_cfg)
        except Exception as e:
            print(f'[WARNING] å¯åŠ¨æ’è¡Œå®šæ—¶æ¨é€å¤±è´¥: {e}')


download_monitor_started = False
last_subscription_check_time = None
last_expire_remind_time = None

# æ•°æ®åº“ key: å­˜å‚¨å·²å‘é€æé†’çš„è®°å½•ï¼Œæ ¼å¼ {'date': '2026-02-10', 'keys': ['tg:days', ...]}
CONFIG_KEY_EXPIRE_REMIND_SENT = '_expire_remind_sent'


def check_subscription_expiry_reminders():
    """æ£€æŸ¥å³å°†åˆ°æœŸçš„è®¢é˜…ï¼Œå‘é€åˆ°æœŸæé†’ï¼ˆé‚®ä»¶ + Telegramï¼‰"""
    with app.app_context():
        try:
            config = load_system_config()
            remind_cfg = config.get('expire_remind', {})
            
            if not remind_cfg.get('enabled', False):
                return
            
            remind_days_list = remind_cfg.get('days', [3, 7])  # æå‰å¤šå°‘å¤©æé†’
            site_name = get_site_config().get('site_name', 'Emby')
            now = datetime.now()
            today_str = now.strftime('%Y-%m-%d')
            reminded_count = 0
            
            # â˜… ä»æ•°æ®åº“è¯»å–å·²å‘é€è®°å½•ï¼ˆæŒä¹…åŒ–ï¼Œå®¹å™¨é‡å»ºä¸ä¸¢å¤±ï¼‰
            sent_data = get_db_config(CONFIG_KEY_EXPIRE_REMIND_SENT, {}) or {}
            # å¦‚æœæ—¥æœŸä¸æ˜¯ä»Šå¤©ï¼Œè¯´æ˜æ˜¯æ–°çš„ä¸€å¤©ï¼Œæ¸…ç©ºæ—§è®°å½•
            if sent_data.get('date') != today_str:
                sent_data = {'date': today_str, 'keys': []}
            sent_keys = set(sent_data.get('keys', []))
            new_keys_added = False
            
            for remind_days in remind_days_list:
                # æŸ¥æ‰¾åœ¨ remind_days å¤©åè¿‡æœŸçš„ç”¨æˆ·ï¼ˆæŒ‰æ—¥æœŸåŒ¹é…æ•´å¤©ï¼Œç¡®ä¿ä¸ä¼šé—æ¼ï¼‰
                target_date = (now + timedelta(days=remind_days)).date()
                expire_start = datetime(target_date.year, target_date.month, target_date.day, 0, 0, 0)
                expire_end = datetime(target_date.year, target_date.month, target_date.day, 23, 59, 59)
                
                users = User.query.filter(
                    User.lv.in_(['a', 'b']),
                    User.ex >= expire_start,
                    User.ex <= expire_end,
                    User.embyid.isnot(None),
                    User.embyid != ''
                ).all()
                
                for user in users:
                    # â˜… å»é‡ï¼šä»æ•°æ®åº“è¯»å–ï¼ŒåŒä¸€å¤©åŒä¸€ç”¨æˆ·åªæé†’ä¸€æ¬¡
                    remind_key = f'{user.tg}:{remind_days}'
                    if remind_key in sent_keys:
                        continue
                    sent_keys.add(remind_key)
                    new_keys_added = True
                    
                    username = user.name or 'ç”¨æˆ·'
                    expire_date = user.ex.strftime('%Y-%m-%d') if user.ex else 'æœªçŸ¥'
                    
                    # é‚®ä»¶æé†’
                    if remind_cfg.get('email', True) and user.email:
                        try:
                            body = f"""<p>æ‚¨å¥½ï¼Œ<b>{username}</b>ï¼</p>
<p>æ‚¨çš„ Emby è®¢é˜…å°†åœ¨ <b>{remind_days} å¤©å</b>ï¼ˆ{expire_date}ï¼‰åˆ°æœŸã€‚</p>
<div style="background:#fff3cd;border-left:4px solid #ffc107;padding:12px 16px;border-radius:4px;margin:16px 0;">
    <p style="margin:0;"><b>â° åˆ°æœŸæ—¶é—´ï¼š</b>{expire_date}</p>
    <p style="margin:4px 0 0;"><b>ğŸ’¡ å»ºè®®ï¼š</b>è¯·åŠæ—¶ç»­è´¹ä»¥å…å½±å“è§‚å½±ä½“éªŒ</p>
</div>
<p>æ‚¨å¯ä»¥ç™»å½•ç½‘ç«™è¿›è¡Œç»­è´¹ï¼Œæˆ–ä½¿ç”¨å…‘æ¢ç å»¶é•¿è®¢é˜…ã€‚</p>"""
                            html = build_email_html(f'{site_name} - è®¢é˜…å³å°†åˆ°æœŸ', body, site_name)
                            send_email(user.email, f'ã€{site_name}ã€‘æ‚¨çš„è®¢é˜…å°†åœ¨{remind_days}å¤©ååˆ°æœŸ', html)
                            reminded_count += 1
                        except Exception as e:
                            app.logger.debug(f'åˆ°æœŸæé†’é‚®ä»¶å‘é€å¤±è´¥({username}): {e}')
                    
                    # Telegram æé†’
                    if remind_cfg.get('telegram', True) and user.telegram_id and TELEGRAM_BOT_TOKEN:
                        try:
                            msg = f"""â° <b>è®¢é˜…åˆ°æœŸæé†’</b>

æ‚¨å¥½ <code>{username}</code>ï¼Œæ‚¨çš„ Emby è®¢é˜…å°†åœ¨ <b>{remind_days} å¤©å</b>åˆ°æœŸã€‚

ğŸ“… åˆ°æœŸæ—¶é—´ï¼š{expire_date}
ğŸ’¡ è¯·åŠæ—¶ç»­è´¹ä»¥å…å½±å“è§‚å½±ä½“éªŒï¼"""
                            send_telegram_private_message(user.telegram_id, msg)
                            reminded_count += 1
                        except Exception as e:
                            app.logger.debug(f'åˆ°æœŸæé†’TGå‘é€å¤±è´¥({username}): {e}')
            
            # â˜… æŠŠå·²å‘é€è®°å½•å†™å›æ•°æ®åº“ï¼ˆæŒä¹…åŒ–ï¼Œå®¹å™¨é‡å»ºä¹Ÿä¸ä¼šé‡å‘ï¼‰
            if new_keys_added:
                sent_data = {'date': today_str, 'keys': list(sent_keys)}
                set_db_config(CONFIG_KEY_EXPIRE_REMIND_SENT, sent_data, 'åˆ°æœŸæé†’å·²å‘é€è®°å½•')
            
            if reminded_count > 0:
                app.logger.info(f'è®¢é˜…åˆ°æœŸæé†’: å·²å‘é€ {reminded_count} æ¡æé†’')
                
        except Exception as e:
            app.logger.error(f'è®¢é˜…åˆ°æœŸæé†’æ£€æŸ¥å¤±è´¥: {e}', exc_info=True)
        finally:
            db.session.remove()


def check_expired_subscriptions():
    """æ£€æŸ¥è®¢é˜…åˆ°æœŸç”¨æˆ·å¹¶ç¦ç”¨/åˆ é™¤å…¶Embyè´¦å·ï¼ˆå«ä¿å·è‡ªåŠ¨ç»­æœŸé€»è¾‘ï¼‰"""
    with app.app_context():
        try:
            now = datetime.now()
            
            # è·å–è®¢é˜…è¿‡æœŸé…ç½®
            config = load_system_config()
            expire_config = config.get('subscription_expire', {})
            auto_disable = expire_config.get('auto_disable', True)
            delete_days = expire_config.get('delete_days', 0)
            delete_web_account = expire_config.get('delete_web_account', False)
            
            # ä¿å·é…ç½®
            retention_mode = expire_config.get('retention_mode', 'off')
            retention_checkin_days = expire_config.get('retention_checkin_days', 20)
            retention_checkin_cost = expire_config.get('retention_checkin_cost', 10)
            retention_watch_days = expire_config.get('retention_watch_days', 30)
            retention_watch_minutes = expire_config.get('retention_watch_minutes', 30)
            retention_renew_days = expire_config.get('retention_renew_days', 30)
            
            # è·å–ç­¾åˆ°è´§å¸åç§°ï¼ˆç”¨äºæ—¥å¿—å’Œäº¤æ˜“è®°å½•ï¼‰
            checkin_config = config.get('checkin', {})
            coin_name = checkin_config.get('coin_name', 'ç§¯åˆ†')
            
            # æŸ¥æ‰¾éœ€è¦å¤„ç†çš„ç”¨æˆ·ï¼š
            # 1. æ™®é€šç”¨æˆ·(lv='b') + æœ‰Embyè´¦å·
            # 2. è®¢é˜…å·²è¿‡æœŸ(ex < now) æˆ– ä»æœªè®¢é˜…(ex=None)
            from sqlalchemy import or_
            expired_users = User.query.filter(
                User.lv == 'b',  # æ™®é€šç”¨æˆ·
                User.embyid.isnot(None),  # æœ‰Embyè´¦å·
                or_(
                    User.ex.is_(None),  # ä»æœªè®¢é˜…
                    User.ex < now  # å·²è¿‡æœŸ
                )
            ).all()
            
            if not expired_users:
                return
            
            # ç«‹å³æäº¤/ç»“æŸæŸ¥è¯¢äº‹åŠ¡ï¼Œé‡Šæ”¾è¡Œé”ï¼Œé¿å…åç»­æ…¢æ“ä½œæŒé”
            db.session.commit()
            
            app.logger.info(f'[è®¢é˜…æ£€æŸ¥] å‘ç° {len(expired_users)} ä¸ªæ— æœ‰æ•ˆè®¢é˜…ç”¨æˆ·')
            
            disabled_count = 0
            emby_deleted_count = 0
            web_deleted_count = 0
            retention_count = 0
            
            for user in expired_users:
                try:
                    # äºŒæ¬¡ç¡®è®¤ï¼šé‡æ–°ä»æ•°æ®åº“è¯»å–æœ€æ–°çŠ¶æ€ï¼Œé˜²æ­¢ç«æ€æ¡ä»¶
                    # ï¼ˆç”¨æˆ·å¯èƒ½åœ¨æŸ¥è¯¢ååˆšç»­è´¹ï¼Œæ­¤æ—¶ä¸åº”è¢«ç¦ç”¨ï¼‰
                    db.session.refresh(user)
                    # ç™½åå•ç”¨æˆ·è·³è¿‡ï¼ˆé€šè¿‡è®¢é˜…è®°å½•åˆ¤æ–­ï¼‰
                    _expire_wl = Subscription.query.filter_by(user_tg=user.tg, plan_type='whitelist', status='active').first()
                    if _expire_wl or user.lv == 'a':
                        continue
                    if user.ex and user.ex > datetime.now():  # å·²ç»­è´¹ï¼Œè·³è¿‡
                        continue
                    if not user.embyid:  # å·²æ— Embyè´¦å·ï¼Œè·³è¿‡
                        continue
                    
                    # ==================== ä¿å·æ£€æŸ¥ ====================
                    # ä»…å¯¹åˆšè¿‡æœŸï¼ˆ3å¤©å†…ï¼‰çš„ç”¨æˆ·æ‰§è¡Œä¿å·æ£€æŸ¥ï¼Œé¿å…å¯¹é•¿æœŸè¿‡æœŸç”¨æˆ·é‡å¤ç»­æœŸ
                    days_expired = (now - user.ex).days if user.ex else 999
                    
                    if retention_mode != 'off' and user.ex and days_expired <= 3:
                        retention_ok = _check_user_retention(
                            user, now, retention_mode,
                            retention_checkin_days, retention_checkin_cost,
                            retention_watch_days, retention_watch_minutes,
                            retention_renew_days, coin_name
                        )
                        if retention_ok:
                            retention_count += 1
                            continue  # å·²è‡ªåŠ¨ç»­æœŸï¼Œè·³è¿‡ç¦ç”¨/åˆ é™¤
                    # ==================== ä¿å·æ£€æŸ¥ç»“æŸ ====================
                    
                    # å¦‚æœé…ç½®äº†åˆ é™¤å¤©æ•°ï¼Œä¸”è¿‡æœŸè¶…è¿‡è¯¥å¤©æ•°ï¼Œåˆ™åˆ é™¤ Emby è´¦å·
                    if delete_days > 0 and user.ex and days_expired >= delete_days:
                        user_name = user.emby_name or user.name
                        user_tg = user.tg
                        emby_id = user.embyid
                        
                        # åˆ é™¤ Emby è´¦å·
                        if emby_id and emby_client.is_enabled():
                            try:
                                emby_client.delete_user(emby_id)
                                emby_deleted_count += 1
                                app.logger.info(f'[è®¢é˜…æ£€æŸ¥] å·²åˆ é™¤Embyè´¦å·: {user_name}')
                            except Exception as e:
                                app.logger.warning(f'[è®¢é˜…æ£€æŸ¥] åˆ é™¤Embyè´¦å·å¤±è´¥: {e}')
                        
                        # å¦‚æœé…ç½®äº†åŒæ—¶åˆ é™¤ç½‘ç«™è´¦å·
                        if delete_web_account:
                            # åˆ é™¤ç›¸å…³è®°å½•
                            # å…ˆåˆ é™¤æ’­æ”¾è®°å½•ï¼ˆæœ‰å¤–é”®å¼•ç”¨ user_devices å’Œ embyï¼‰
                            PlaybackRecord.query.filter_by(user_tg=user_tg).delete(synchronize_session=False)
                            UserDevice.query.filter_by(user_tg=user_tg).delete()
                            Subscription.query.filter_by(user_tg=user_tg).delete()
                            Order.query.filter_by(user_tg=user_tg).delete()
                            # åˆ é™¤ä¸‹è½½ä»»åŠ¡ï¼ˆå…ˆåˆ é™¤ï¼Œå› ä¸ºæœ‰å¤–é”®å¼•ç”¨ movie_requestsï¼‰
                            request_ids = [r.id for r in MovieRequest.query.filter_by(user_tg=user_tg).all()]
                            if request_ids:
                                DownloadTask.query.filter(DownloadTask.request_id.in_(request_ids)).delete(synchronize_session=False)
                            MovieRequest.query.filter_by(user_tg=user_tg).delete()
                            # åˆ é™¤å·¥å•ï¼ˆå…ˆåˆ é™¤å·¥å•æ¶ˆæ¯ï¼‰
                            ticket_ids = [t.id for t in SupportTicket.query.filter_by(user_tg=user_tg).all()]
                            if ticket_ids:
                                TicketMessage.query.filter(TicketMessage.ticket_id.in_(ticket_ids)).delete(synchronize_session=False)
                            SupportTicket.query.filter_by(user_tg=user_tg).delete()
                            InviteRecord.query.filter((InviteRecord.inviter_tg == user_tg) | (InviteRecord.invitee_tg == user_tg)).delete(synchronize_session=False)
                            UserActivityLog.query.filter_by(user_tg=user_tg).delete()
                            # åˆ é™¤ç­¾åˆ°è®°å½•
                            CheckInRecord.query.filter_by(user_tg=user_tg).delete()
                            # åˆ é™¤ç§¯åˆ†äº¤æ˜“è®°å½•
                            CoinTransaction.query.filter_by(user_tg=user_tg).delete()
                            # åˆ é™¤å…‘æ¢è®°å½•
                            ExchangeRecord.query.filter_by(user_tg=user_tg).delete()
                            # æ¸…é™¤å…‘æ¢ç ä½¿ç”¨è€…å¼•ç”¨
                            RedeemCode.query.filter_by(used_by=user_tg).update({'used_by': None}, synchronize_session=False)
                            
                            # åˆ é™¤ç”¨æˆ·
                            db.session.delete(user)
                            web_deleted_count += 1
                            app.logger.info(f'[è®¢é˜…æ£€æŸ¥] å·²åˆ é™¤ç½‘ç«™è´¦å·: {user_name} (è¿‡æœŸ{days_expired}å¤©)')
                        else:
                            # åªæ¸…é™¤ Emby ç»‘å®šä¿¡æ¯ï¼Œä¿ç•™ç½‘ç«™è´¦å·ï¼ˆç½‘ç«™ç”¨æˆ·å name ä¿æŒä¸å˜ï¼‰
                            user.embyid = None
                            user.emby_name = None
                            user.pwd2 = None
                            app.logger.info(f'[è®¢é˜…æ£€æŸ¥] å·²è§£ç»‘Embyè´¦å·: {user_name} (è¿‡æœŸ{days_expired}å¤©)ï¼Œç½‘ç«™è´¦å·ä¿ç•™')
                        
                        db.session.commit()
                    
                    # å¦åˆ™åªç¦ç”¨è´¦å·ï¼ˆå¦‚æœå¯ç”¨äº†è‡ªåŠ¨ç¦ç”¨ï¼‰
                    elif auto_disable:
                        if emby_client.is_enabled() and emby_client.disable_user(user.embyid):
                            # åŒæ—¶è¸¢å‡ºè¯¥ç”¨æˆ·çš„æ‰€æœ‰æ’­æ”¾ä¼šè¯
                            emby_client.kill_user_sessions(user.embyid)
                            disabled_count += 1
                            app.logger.info(f'[è®¢é˜…æ£€æŸ¥] å·²ç¦ç”¨è¿‡æœŸç”¨æˆ·Embyè´¦å·: {user.emby_name or user.name} (è¿‡æœŸæ—¶é—´: {user.ex})')
                            
                except Exception as e:
                    db.session.rollback()
                    app.logger.error(f'[è®¢é˜…æ£€æŸ¥] å¤„ç†ç”¨æˆ· {user.emby_name or user.name} å¤±è´¥: {e}')
            
            if disabled_count > 0:
                app.logger.info(f'[è®¢é˜…æ£€æŸ¥] æœ¬æ¬¡å…±ç¦ç”¨ {disabled_count} ä¸ªè¿‡æœŸç”¨æˆ·çš„Embyè´¦å·')
            if emby_deleted_count > 0:
                app.logger.info(f'[è®¢é˜…æ£€æŸ¥] æœ¬æ¬¡å…±åˆ é™¤ {emby_deleted_count} ä¸ªEmbyè´¦å·')
            if web_deleted_count > 0:
                app.logger.info(f'[è®¢é˜…æ£€æŸ¥] æœ¬æ¬¡å…±åˆ é™¤ {web_deleted_count} ä¸ªç½‘ç«™è´¦å·')
            if retention_count > 0:
                app.logger.info(f'[è®¢é˜…æ£€æŸ¥] æœ¬æ¬¡ä¿å·è‡ªåŠ¨ç»­æœŸ {retention_count} ä¸ªç”¨æˆ·')
                
        except Exception as e:
            db.session.rollback()
            app.logger.error(f'[è®¢é˜…æ£€æŸ¥] æ£€æŸ¥è¿‡æœŸè®¢é˜…å¤±è´¥: {e}')
        finally:
            db.session.remove()


def _check_user_retention(user, now, mode, checkin_days, checkin_cost,
                          watch_days, watch_minutes, renew_days, coin_name):
    """æ£€æŸ¥ç”¨æˆ·æ˜¯å¦æ»¡è¶³ä¿å·æ¡ä»¶ï¼Œæ»¡è¶³åˆ™è‡ªåŠ¨ç»­æœŸå¹¶æ‰£è´¹
    
    Args:
        user: User å¯¹è±¡
        now: å½“å‰æ—¶é—´
        mode: 'checkin' / 'watch' / 'both'
        checkin_days: ï¼ˆå·²å¼ƒç”¨ï¼Œä¿ç•™å…¼å®¹ï¼‰
        checkin_cost: ç§¯åˆ†ä¿å·è‡ªåŠ¨æ‰£é™¤çš„ç§¯åˆ†ï¼ˆç§¯åˆ†è¶³å¤Ÿå³å¯ç»­æœŸï¼‰
        watch_days: è§‚çœ‹ä¿å·æ£€æŸ¥çš„å¤©æ•°èŒƒå›´
        watch_minutes: è§‚çœ‹ä¿å·è¦æ±‚çš„ç´¯è®¡è§‚çœ‹åˆ†é’Ÿæ•°
        renew_days: ç»­æœŸå¤©æ•°
        coin_name: è´§å¸åç§°
    
    Returns:
        True å¦‚æœä¿å·æˆåŠŸï¼ˆå·²ç»­æœŸï¼‰ï¼ŒFalse å¦‚æœä¸æ»¡è¶³æ¡ä»¶
    """
    user_name = user.emby_name or user.name
    
    try:
        # ===== ç­¾åˆ°ä¿å·æ£€æŸ¥ =====
        checkin_ok = False
        if mode in ('checkin', 'both'):
            # åªæ£€æŸ¥ç§¯åˆ†æ˜¯å¦è¶³å¤Ÿï¼Œä¸å†è¦æ±‚ç­¾åˆ°å¤©æ•°
            if (user.coins or 0) >= checkin_cost:
                checkin_ok = True
            else:
                app.logger.info(f'[ä¿å·] {user_name}: {coin_name}ä¸è¶³({user.coins or 0}<{checkin_cost})ï¼Œä¸ç»­æœŸ')
                if mode == 'checkin':
                    return False
        
        # ===== è§‚çœ‹ä¿å·æ£€æŸ¥ =====
        watch_ok = False
        if mode in ('watch', 'both'):
            from datetime import timedelta
            watch_since = now - timedelta(days=watch_days)
            
            # æŸ¥è¯¢è§‚çœ‹æ—¶é•¿ï¼ˆç§’ï¼‰
            # play_duration å­˜çš„æ˜¯æ’­æ”¾ä½ç½®ï¼ŒåŒä¸€åª’ä½“å¤šæ¡è®°å½•ä¼šé‡å¤ç´¯åŠ 
            # å¯¹æ¯ä¸ª emby_item_id å– MAX(play_duration)ï¼Œå†æ±‚å’Œ
            from sqlalchemy import func
            duration_rows = db.session.query(
                func.max(PlaybackRecord.play_duration)
            ).filter(
                PlaybackRecord.user_tg == user.tg,
                PlaybackRecord.started_at >= watch_since
            ).group_by(
                PlaybackRecord.emby_item_id
            ).all()
            total_seconds = sum(r[0] or 0 for r in duration_rows)
            
            total_minutes = total_seconds / 60
            
            if total_minutes >= watch_minutes:
                watch_ok = True
            else:
                app.logger.info(f'[ä¿å·] {user_name}: è§‚çœ‹{total_minutes:.0f}åˆ†é’Ÿ < è¦æ±‚{watch_minutes}åˆ†é’Ÿï¼Œä¸ç»­æœŸ')
                if mode == 'watch':
                    return False
        
        # ===== åˆ¤æ–­æœ€ç»ˆç»“æœ =====
        if mode == 'checkin' and checkin_ok:
            pass  # æ»¡è¶³ç­¾åˆ°ä¿å·
        elif mode == 'watch' and watch_ok:
            pass  # æ»¡è¶³è§‚çœ‹ä¿å·
        elif mode == 'both' and checkin_ok and watch_ok:
            pass  # æ»¡è¶³åŒä¿
        else:
            if mode == 'both':
                app.logger.info(f'[ä¿å·] {user_name}: åŒä¿æ¡ä»¶ä¸åŒæ—¶æ»¡è¶³ï¼ˆç­¾åˆ°:{checkin_ok}, è§‚çœ‹:{watch_ok}ï¼‰ï¼Œä¸ç»­æœŸ')
            return False
        
        # ===== æ‰§è¡Œç»­æœŸ =====
        from datetime import timedelta
        # ä»è¿‡æœŸæ—¶é—´èµ·ç»­æœŸï¼ˆè€Œä¸æ˜¯ä»å½“å‰æ—¶é—´ï¼‰ï¼Œä¿è¯ä¸ä¸¢å¤©æ•°
        new_ex = (user.ex or now) + timedelta(days=renew_days)
        user.ex = new_ex
        
        # åŒæ­¥æ›´æ–° Subscription è¡¨ä¸­çš„ end_dateï¼ˆä¿®å¤ç½‘é¡µæ˜¾ç¤ºè´Ÿæ•°å¤©æ•°çš„é—®é¢˜ï¼‰
        active_sub = Subscription.query.filter_by(
            user_tg=user.tg, status='active'
        ).order_by(Subscription.end_date.desc()).first()
        if active_sub:
            active_sub.end_date = new_ex
            active_sub.updated_at = now
        
        # ç­¾åˆ°ä¿å·éœ€è¦æ‰£ç§¯åˆ†
        if mode in ('checkin', 'both') and checkin_cost > 0:
            user.coins = (user.coins or 0) - checkin_cost
            # è®°å½•ç§¯åˆ†äº¤æ˜“
            try:
                coin_tx = CoinTransaction(
                    user_tg=user.tg,
                    amount=-checkin_cost,
                    balance_after=user.coins,
                    trans_type='retention',
                    description=f'ä¿å·è‡ªåŠ¨ç»­æœŸ{renew_days}å¤©ï¼Œæ‰£é™¤{checkin_cost}{coin_name}',
                    created_at=now
                )
                db.session.add(coin_tx)
            except Exception:
                pass  # ç§¯åˆ†è®°å½•å¤±è´¥ä¸å½±å“ç»­æœŸ
        
        db.session.commit()
        
        # ä¿å·ç»­æœŸæˆåŠŸåï¼Œé‡æ–°å¯ç”¨ Emby è´¦å·ï¼ˆå¯èƒ½åœ¨ä¹‹å‰çš„æ£€æŸ¥å‘¨æœŸä¸­è¢«ç¦ç”¨ï¼‰
        if user.embyid and emby_client.is_enabled():
            try:
                if emby_client.enable_user(user.embyid):
                    app.logger.info(f'[ä¿å·] {user_name}: å·²é‡æ–°å¯ç”¨Embyè´¦å·')
            except Exception as e:
                app.logger.warning(f'[ä¿å·] {user_name}: é‡æ–°å¯ç”¨Embyè´¦å·å¤±è´¥: {e}')
        
        cost_info = f'ï¼Œæ‰£é™¤{checkin_cost}{coin_name}' if mode in ('checkin', 'both') and checkin_cost > 0 else ''
        app.logger.info(f'[ä¿å·] âœ… {user_name}: ä¿å·æˆåŠŸï¼Œç»­æœŸ{renew_days}å¤©è‡³{new_ex.strftime("%Y-%m-%d")}{cost_info}')
        return True
        
    except Exception as e:
        db.session.rollback()
        app.logger.error(f'[ä¿å·] {user_name}: ä¿å·æ£€æŸ¥å¼‚å¸¸: {e}')
        return False


@app.before_request
def ensure_background_tasks():
    global last_ticket_check_time, last_subscription_check_time, last_expire_remind_time
    bootstrap_background_tasks()
    
    # è½»é‡çº§æˆæƒçŠ¶æ€æ£€æŸ¥ï¼ˆä¸å‘èµ·ç½‘ç»œè¯·æ±‚ï¼Œä»…æ£€æŸ¥ç¼“å­˜çŠ¶æ€ï¼‰
    if not is_license_valid():
        # ä»…å¯¹ API å’Œé¡µé¢è¯·æ±‚è¿”å›é”™è¯¯ï¼Œé™æ€èµ„æºæ”¾è¡Œ
        if not request.path.startswith('/static/'):
            _v, _r = check_license()
            if not _v:
                if request.path.startswith('/api/'):
                    return jsonify({'success': False, 'error': 'ç³»ç»Ÿæˆæƒå¼‚å¸¸'}), 503
    
    now = datetime.now()
    
    # æ¯å°æ—¶æ£€æŸ¥ä¸€æ¬¡å·¥å•è‡ªåŠ¨å…³é—­ï¼ˆé¿å…é¢‘ç¹æ£€æŸ¥ï¼‰
    if last_ticket_check_time is None or (now - last_ticket_check_time).total_seconds() > 3600:
        last_ticket_check_time = now
        # åœ¨åå°çº¿ç¨‹ä¸­æ‰§è¡Œï¼Œé¿å…é˜»å¡è¯·æ±‚
        from threading import Thread
        Thread(target=auto_close_inactive_tickets, daemon=True).start()
    
    # æ¯1å°æ—¶æ£€æŸ¥ä¸€æ¬¡è®¢é˜…è¿‡æœŸï¼ˆç¦ç”¨Embyè´¦å·ï¼‰
    if last_subscription_check_time is None or (now - last_subscription_check_time).total_seconds() > 3600:
        last_subscription_check_time = now
        from threading import Thread
        Thread(target=check_expired_subscriptions, daemon=True).start()
    
    # æ¯6å°æ—¶æ£€æŸ¥ä¸€æ¬¡è®¢é˜…åˆ°æœŸæé†’
    if last_expire_remind_time is None or (now - last_expire_remind_time).total_seconds() > 21600:
        last_expire_remind_time = now
        from threading import Thread
        Thread(target=check_subscription_expiry_reminders, daemon=True).start()


# ==================== æ’­æ”¾é™åˆ¶è°ƒè¯• API ====================
@app.route('/api/admin/debug/stream-limit', methods=['GET'])
@admin_required
def debug_stream_limit():
    """è°ƒè¯•ï¼šæŸ¥çœ‹æ’­æ”¾é™åˆ¶é…ç½®å’Œæ‰€æœ‰ç”¨æˆ·çš„å®é™… Emby Policy"""
    try:
        config = load_system_config()
        max_streams = config.get('telegram', {}).get('max_streams', 0)
        
        result = {
            'config_max_streams': max_streams,
            'emby_enabled': emby_client.is_enabled(),
            'users': []
        }
        
        if not emby_client.is_enabled():
            return jsonify({'success': True, **result}), 200
        
        # è·å–æ‰€æœ‰æœ‰ embyid çš„ç”¨æˆ·
        users = User.query.filter(User.embyid.isnot(None), User.embyid != '').limit(50).all()
        params = {'api_key': emby_client.api_key}
        
        for user in users:
            user_data = {
                'name': user.name,
                'embyid': user.embyid,
                'lv': user.lv,
                'policy': None,
                'error': None
            }
            try:
                url = f"{emby_client.base_url}/Users/{user.embyid}"
                response = emby_client.session.get(url, params=params, timeout=10)
                if response.status_code == 200:
                    user_info = response.json()
                    policy = user_info.get('Policy', {})
                    user_data['policy'] = {
                        'SimultaneousStreamLimit': policy.get('SimultaneousStreamLimit', 'æœªè®¾ç½®'),
                        'MaxActiveSessions': policy.get('MaxActiveSessions', 'æœªè®¾ç½®'),
                        'IsDisabled': policy.get('IsDisabled'),
                        'IsAdministrator': policy.get('IsAdministrator'),
                    }
                    # åˆ—å‡º Policy ä¸­æ‰€æœ‰åŒ…å« Stream/Session/Limit çš„é”®
                    user_data['policy']['_all_stream_keys'] = {
                        k: v for k, v in policy.items() 
                        if any(word in k.lower() for word in ['stream', 'session', 'limit', 'simultaneous', 'max'])
                    }
                else:
                    user_data['error'] = f'HTTP {response.status_code}'
            except Exception as e:
                user_data['error'] = str(e)
            
            result['users'].append(user_data)
        
        return jsonify({'success': True, **result}), 200
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/admin/debug/stream-limit/sync', methods=['GET', 'POST'])
@admin_required
def debug_stream_limit_sync():
    """è°ƒè¯•ï¼šæ‰‹åŠ¨è§¦å‘åŒæ­¥æ’­æ”¾é™åˆ¶åˆ°æ‰€æœ‰ Emby ç”¨æˆ·ï¼ˆæ”¯æŒ GET/POSTï¼‰"""
    try:
        config = load_system_config()
        max_streams = config.get('telegram', {}).get('max_streams', 0)
        
        if not max_streams or max_streams <= 0:
            return jsonify({'success': False, 'error': f'å½“å‰ max_streams={max_streams}ï¼Œæœªè®¾ç½®é™åˆ¶'}), 400
        
        sync_result = emby_client.sync_all_users_stream_limit(max_streams)
        
        return jsonify({
            'success': True,
            'max_streams': max_streams,
            'sync_result': sync_result,
            'message': f'å·²åŒæ­¥ max_streams={max_streams} åˆ° {sync_result["success"]}/{sync_result["total"]} ä¸ªç”¨æˆ·'
        }), 200
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/admin/debug/stream-limit/sessions', methods=['GET'])
@admin_required
def debug_stream_limit_sessions():
    """è°ƒè¯•ï¼šæŸ¥çœ‹å½“å‰æ‰€æœ‰æ­£åœ¨æ’­æ”¾çš„ Emby ä¼šè¯
    
    ç”¨äºç¡®è®¤ Webhook é™æµé€»è¾‘æ˜¯å¦æ­£å¸¸å·¥ä½œï¼š
    - å¦‚æœæœ‰4ä¸ªä¼šè¯åœ¨æ’­æ”¾è€Œ max_streams=2ï¼Œè¯´æ˜ Webhook æ²¡æœ‰è§¦å‘
    - æ£€æŸ¥ Emby æ˜¯å¦æ­£ç¡®é…ç½®äº† playback Webhook
    """
    try:
        if not emby_client.is_enabled():
            return jsonify({'success': False, 'error': 'Emby æœªå¯ç”¨'}), 400
        
        config = load_system_config()
        max_streams = config.get('telegram', {}).get('max_streams', 0)
        
        # è·å–æ‰€æœ‰æ´»è·ƒä¼šè¯
        url = f"{emby_client.base_url}/Sessions"
        params = {'api_key': emby_client.api_key}
        response = emby_client.session.get(url, params=params, timeout=10)
        
        if response.status_code != 200:
            return jsonify({'success': False, 'error': f'Emby API è¿”å› {response.status_code}'}), 500
        
        sessions = response.json()
        playing = []
        idle = []
        
        for s in sessions:
            info = {
                'session_id': s.get('Id'),
                'user_name': s.get('UserName', 'æœªçŸ¥'),
                'user_id': s.get('UserId', ''),
                'device_name': s.get('DeviceName', 'æœªçŸ¥'),
                'client': s.get('Client', 'æœªçŸ¥'),
                'last_activity': s.get('LastActivityDate', ''),
                'remote_ip': s.get('RemoteEndPoint', ''),
            }
            now_playing = s.get('NowPlayingItem')
            if now_playing:
                info['now_playing'] = now_playing.get('Name', 'æœªçŸ¥')
                info['play_state'] = s.get('PlayState', {})
                playing.append(info)
            else:
                idle.append(info)
        
        # æŒ‰ç”¨æˆ·åˆ†ç»„ç»Ÿè®¡æ­£åœ¨æ’­æ”¾æ•°
        user_playing_count = {}
        for p in playing:
            uid = p['user_id']
            uname = p['user_name']
            if uid not in user_playing_count:
                user_playing_count[uid] = {'name': uname, 'count': 0, 'sessions': []}
            user_playing_count[uid]['count'] += 1
            user_playing_count[uid]['sessions'].append(f"{p['device_name']}({p['client']})")
        
        # æ‰¾å‡ºè¶…é™ç”¨æˆ·
        over_limit = []
        if max_streams > 0:
            for uid, info in user_playing_count.items():
                if info['count'] > max_streams:
                    over_limit.append({
                        'user': info['name'],
                        'playing': info['count'],
                        'limit': max_streams,
                        'devices': info['sessions']
                    })
        
        return jsonify({
            'success': True,
            'config_max_streams': max_streams,
            'total_sessions': len(sessions),
            'playing_count': len(playing),
            'idle_count': len(idle),
            'playing_sessions': playing,
            'user_summary': user_playing_count,
            'over_limit_users': over_limit,
            'webhook_hint': 'å¦‚æœæœ‰ç”¨æˆ·è¶…é™ä½†æ²¡æœ‰è¢«é™æµï¼Œè¯´æ˜ Emby çš„ playback Webhook æ²¡æœ‰æ­£ç¡®é…ç½®ã€‚'
                           'è¯·ç¡®ä¿ Emby é€šçŸ¥ä¸­æ·»åŠ äº† Webhookï¼ŒURL ä¸º /api/webhook/emby/playbackï¼Œ'
                           'äº‹ä»¶ç±»å‹å‹¾é€‰äº† Playback Start å’Œ Playback Progressã€‚'
        }), 200
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500


# ==================== è®¾å¤‡é»‘åå•ç®¡ç† API ====================
@app.route('/api/admin/device-blacklist', methods=['GET'])
@admin_required
def get_device_blacklist():
    """è·å–æ‰€æœ‰é»‘åå•è§„åˆ™"""
    try:
        rules = DeviceBlacklist.query.order_by(DeviceBlacklist.created_at.desc()).all()
        return jsonify({
            'success': True,
            'rules': [rule.to_dict() for rule in rules]
        }), 200
    except Exception as e:
        app.logger.error(f'è·å–é»‘åå•è§„åˆ™å¤±è´¥: {e}')
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/admin/device-blacklist', methods=['POST'])
@admin_required
def create_blacklist_rule():
    """åˆ›å»ºé»‘åå•è§„åˆ™"""
    try:
        data = request.json
        
        rule = DeviceBlacklist(
            rule_name=data.get('rule_name', ''),
            client_pattern=data.get('client_pattern', ''),
            device_name_pattern=data.get('device_name_pattern', ''),
            action=data.get('action', 'stop_only'),
            is_enabled=data.get('is_enabled', True),
            description=data.get('description', '')
        )
        
        db.session.add(rule)
        db.session.commit()
        
        app.logger.info(f'åˆ›å»ºé»‘åå•è§„åˆ™: {rule.rule_name}')
        
        return jsonify({
            'success': True,
            'rule': rule.to_dict()
        }), 200
    except Exception as e:
        app.logger.error(f'åˆ›å»ºé»‘åå•è§„åˆ™å¤±è´¥: {e}')
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/admin/device-blacklist/<int:rule_id>', methods=['PUT'])
@admin_required
def update_blacklist_rule(rule_id):
    """æ›´æ–°é»‘åå•è§„åˆ™"""
    try:
        rule = db.session.get(DeviceBlacklist, rule_id)
        if not rule:
            return jsonify({'success': False, 'error': 'è§„åˆ™ä¸å­˜åœ¨'}), 404
        
        data = request.json
        rule.rule_name = data.get('rule_name', rule.rule_name)
        rule.client_pattern = data.get('client_pattern', rule.client_pattern)
        rule.device_name_pattern = data.get('device_name_pattern', rule.device_name_pattern)
        rule.action = data.get('action', rule.action)
        rule.is_enabled = data.get('is_enabled', rule.is_enabled)
        rule.description = data.get('description', rule.description)
        
        db.session.commit()
        
        app.logger.info(f'æ›´æ–°é»‘åå•è§„åˆ™: {rule.rule_name}')
        
        return jsonify({
            'success': True,
            'rule': rule.to_dict()
        }), 200
    except Exception as e:
        app.logger.error(f'æ›´æ–°é»‘åå•è§„åˆ™å¤±è´¥: {e}')
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/admin/device-blacklist/<int:rule_id>', methods=['DELETE'])
@admin_required
def delete_blacklist_rule(rule_id):
    """åˆ é™¤é»‘åå•è§„åˆ™"""
    try:
        rule = db.session.get(DeviceBlacklist, rule_id)
        if not rule:
            return jsonify({'success': False, 'error': 'è§„åˆ™ä¸å­˜åœ¨'}), 404
        
        rule_name = rule.rule_name
        db.session.delete(rule)
        db.session.commit()
        
        app.logger.info(f'åˆ é™¤é»‘åå•è§„åˆ™: {rule_name}')
        
        return jsonify({'success': True}), 200
    except Exception as e:
        app.logger.error(f'åˆ é™¤é»‘åå•è§„åˆ™å¤±è´¥: {e}')
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500


if __name__ == '__main__':
    init_db()
    
    # åˆå§‹åŒ–ç®¡ç†å‘˜é…ç½®ï¼ˆé¦–æ¬¡å¯åŠ¨ä¼šç”Ÿæˆé»˜è®¤é…ç½®ï¼‰
    admin_config = init_admin_config()
    secret_path = admin_config.get('admin', {}).get('secret_path')
    if secret_path:
        print(f"[INFO] ç®¡ç†åå°å…¥å£: /{secret_path}")
    
    bootstrap_background_tasks()
    # ä»ç¯å¢ƒå˜é‡è¯»å–è¿è¡Œé…ç½®
    debug_mode = os.getenv('FLASK_DEBUG', 'False').lower() == 'true'
    host = os.getenv('FLASK_HOST', '0.0.0.0')
    port = int(os.getenv('FLASK_PORT', 5000))
    
    app.logger.info(f'Emby Request v{APP_VERSION} å¯åŠ¨å¼€å‘æœåŠ¡å™¨: {host}:{port} (Debug={debug_mode})')
    print(f'\n  ğŸ¬ Emby Request v{APP_VERSION}')
    print(f'  ğŸŒ http://{host}:{port}\n')
    app.run(debug=debug_mode, host=host, port=port)
else:
    # Gunicorn ç­‰ WSGI æœåŠ¡å™¨å¯åŠ¨æ—¶çš„åˆå§‹åŒ–
    print(f'\n  ğŸ¬ Emby Request v{APP_VERSION}')
    init_db()
    admin_config = init_admin_config()
    secret_path = admin_config.get('admin', {}).get('secret_path')
    if secret_path:
        print(f"[INFO] ç®¡ç†åå°å…¥å£: /{secret_path}")
    bootstrap_background_tasks()
    app.logger.info(f'Emby Request v{APP_VERSION} (Gunicorn) å¯åŠ¨å®Œæˆ')
